You can optimize your list queries based on secondary indexes. For example, if you have a Customer model, you can query based on the customer's id identifier field by default, but you can add a secondary index based on the accountRepresentativeId to get a list of customers for a given account representative.

A secondary index consists of a hash key and, optionally, a sort key. Use the hash key to perform strict equality and the sort key for greater than, greater than or equal to, less than, less than or equal to, equals, begins with, and between operations.

To define a secondary index, you can use the secondaryIndexes modifier in your schema. For instance:
```javascript
const schema = {
  Customer: {
    name: 'string',
    phoneNumber: 'string',
    accountRepresentativeId: 'string',
  },
  secondaryIndexes: [
    {
      hashKey: 'accountRepresentativeId',
    },
  ],
};
```
The example client query below allows you to query for Customer records based on their accountRepresentativeId:
```javascript
import { API } from 'aws-amplify';

const queriedCustomers = await API.graphql({
  query: 'listCustomerByAccountRepresentativeId',
  variables: {
    accountRepresentativeId: 'YOUR_REP_ID',
  },
});
```
You can define sort keys to add a set of flexible filters to your query, such as greater than, greater than or equal to, less than, less than or equal to, equals, begins with, and between operations. To define a sort key, you can add a sortKeys property to your secondary index definition:
```javascript
const schema = {
  Customer: {
    name: 'string',
    phoneNumber: 'string',
    accountRepresentativeId: 'string',
  },
  secondaryIndexes: [
    {
      hashKey: 'accountRepresentativeId',
      sortKey: 'name',
    },
  ],
};
```
On the client side, you should find a new list query that's named after the hash key and sort keys. For example, in this case: listCustomerByAccountRepresentativeIdAndName. You can supply the filter as part of this new list query:
```javascript
import { API } from 'aws-amplify';

const queriedCustomers = await API.graphql({
  query: 'listCustomerByAccountRepresentativeIdAndName',
  variables: {
    accountRepresentativeId: 'YOUR_REP_ID',
    name: {
      beginsWith: 'Rene',
    },
  },
});
```
You can also customize the auto-generated query name under client.models.ModelName.listBy... by setting the queryField modifier.
```javascript
const schema = {
  Customer: {
    name: 'string',
    phoneNumber: 'string',
    accountRepresentativeId: 'string',
  },
  secondaryIndexes: [
    {
      hashKey: 'accountRepresentativeId',
      queryField: 'listByRep',
    },
  ],
};
```
In your client app code, you'll see the query updated under the Data client:
```javascript
import { API } from 'aws-amplify';

const queriedCustomers = await API.graphql({
  query: 'listByRep',
  variables: {
    accountRepresentativeId: 'YOUR_REP_ID',
  },
});
```
To customize the underlying DynamoDB's index name, you can optionally provide the name modifier.
```javascript
const schema = {
  Customer: {
    name: 'string',
    phoneNumber: 'string',
    accountRepresentativeId: 'string',
  },
  secondaryIndexes: [
    {
      hashKey: 'accountRepresentativeId',
      name: 'MyCustomIndexName',
    },
  ],
};
```
Amplify uses Amazon DynamoDB tables as the default data source for your models. For key-value databases, it is critical to model your access patterns with secondary indexes. Use the secondaryIndexes modifier to configure a secondary index. Amazon DynamoDB is a key-value and document database that delivers single-digit millisecond performance at any scale, but making it work for your access patterns requires a bit of forethought. DynamoDB query operations may use at most two attributes to efficiently query data. The first query argument passed to a query (the hash key) must use strict equality and the second attribute (the sort key) may use gt, ge, lt, le, eq, beginsWith, and between. DynamoDB can effectively implement a wide variety of access patterns that are powerful enough for the majority of applications.
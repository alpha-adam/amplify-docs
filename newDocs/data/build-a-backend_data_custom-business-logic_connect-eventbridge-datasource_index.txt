Amazon EventBridge is a serverless event bus that simplifies how applications communicate with each other. It acts as a central hub for events generated by various sources, including AWS services, custom applications, and third-party SaaS providers. EventBridge delivers event data in real-time, allowing you to build applications that react swiftly to changes. You define rules to filter and route these events to specific destinations, known as targets.

By adopting an event-driven architecture with EventBridge, you can achieve loose coupling, increased resilience, and simplified integration. Loose coupling means applications become independent and communicate through events, improving scalability and maintainability. Increased resilience means system failures are isolated as events are delivered asynchronously, ensuring overall application availability. Simplified integration means EventBridge provides a unified interface for integrating diverse event sources, streamlining development.

To connect to Amazon EventBridge, you need to set up your API, add your Amazon EventBridge event bus as a data source, define custom queries and mutations, configure custom business logic handler code, invoke custom mutations to send events to EventBridge, subscribe to mutations invoked by EventBridge, and invoke mutations and trigger subscriptions from EventBridge.

First, set up your API by defining a custom type that represents an order status change event. This type includes fields for the order ID, status, and message. 

```typescript
const schema = a.schema({
  OrderStatus: a.enum(["OrderPending", "OrderShipped", "OrderDelivered"]),
  OrderStatusChange: a.customType({
    orderId: a.id().required(),
    status: a.ref("OrderStatus").required(),
    message: a.string().required(),
  }),
});
```

Next, add your Amazon EventBridge event bus as a data source for your API. You can do this by using the `addEventBridgeDataSource` method.

```typescript
backend.data.addEventBridgeDataSource("MyEventBridgeDataSource", eventBus);
```

Then, define custom queries and mutations. For example, you can add `publishOrderToEventBridge` and `publishOrderFromEventBridge` custom mutations, and an `onOrderStatusChange` custom subscription to your schema.

```typescript
const schema = a.schema({
  publishOrderToEventBridge: a
   .mutation()
   .arguments({
      orderId: a.id().required(),
      status: a.string().required(),
      message: a.string().required(),
    })
   .returns(a.ref("OrderStatusChange"))
   .authorization((allow) => [allow.publicApiKey()])
   .handler(
      a.handler.custom({
        dataSource: "EventBridgeDataSource",
        entry: "./publishOrderToEventBridge.js",
      })
    ),
  publishOrderFromEventBridge: a
   .mutation()
   .arguments({
      orderId: a.id().required(),
      status: a.string().required(),
      message: a.string().required(),
    })
   .returns(a.ref("OrderStatusChange"))
   .authorization((allow) => [allow.publicApiKey(), allow.guest()])
   .handler(
      a.handler.custom({
        entry: "./publishOrderFromEventBridge.js",
      })
    ),
  onOrderFromEventBridge: a
   .subscription()
   .for(a.ref("publishOrderFromEventBridge"))
   .authorization((allow) => [allow.publicApiKey()])
   .handler(
      a.handler.custom({
        entry: "./onOrderFromEventBridge.js",
      })
    ),
});
```

After that, configure custom business logic handler code. For example, you can create a file called `publishOrderToEventBridge.js` with the following code:

```javascript
export function request(ctx) {
  return {
    operation: "PutEvents",
    events: [
      {
        source: "amplify.orders",
        ["detail-type"]: "OrderStatusChange",
        detail: {...ctx.args },
      },
    ],
  };
}

export function response(ctx) {
  return ctx.args;
}
```

You can then invoke custom mutations to send events to EventBridge. For example:

```typescript
await client.mutations.publishOrderToEventBridge({
  orderId: "12345",
  status: "SHIPPED",
  message: "Order has been shipped",
});
```

You can also subscribe to mutations invoked by EventBridge. For example:

```typescript
const sub = client.subscriptions.onOrderStatusChange().subscribe({
  next: (data) => {
    console.log(data);
  },
});
```

Finally, you can invoke a mutation and trigger a subscription from EventBridge. You can test your custom mutation and subscriptions by using the EventBridge console to send an event which will invoke the custom mutation. You can then observe the results from the subscription being triggered. 

To send an event, navigate to the Amazon EventBridge console and choose "Send Events". Fill out the form, specifying the event source to be `amplify.orders` and the `detail-type` to be `OrderStatusChange`. Choose "Send" and observe the subscription output in the AppSync Queries console.
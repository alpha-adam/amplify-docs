To generate React code directly from Figma, you can use the Amplify UI Figma file and the Amplify UI Builder plugin. 

First, you need to duplicate the Amplify UI Figma file. This file contains several pages, including a README page that explains how to use the Figma file to create new components, theme primitives, and customize layout and styling. 

The Theme page displays the theme values and design tokens used to style the primitives. If you want to make changes to the theme, you should use the Amplify UI Builder Figma plugin. 

The Primitives page contains building-block components such as alerts, buttons, and badges. These primitives correspond to the Amplify UI primitives and can be exported to code with all their properties. 

The My components page contains custom components built using the primitives. You can customize the provided components or build your own. 

To generate React code, you need to run the Amplify UI Builder Figma plugin. You can do this in dev mode or non-dev mode. 

In dev mode, you turn on Figma dev mode, select the AWS Amplify UI Builder plugin, and choose a layer in your file to get React code and a live preview of the generated code. 

In non-dev mode, you select the AWS Amplify UI Builder plugin and choose Download component code to download the React code for your components. 

For example, if you were to generate a button component, the React code might look like this:
```jsx
import React from 'react';

const Button = () => {
  return (
    <button>
      Click me
    </button>
  );
};

export default Button;
```
You should follow the instructions in the README page of the Figma file to learn how to create your components and optimize for code quality.

To customize the form inputs generated by Amplify, you can override properties of individual input components. The generated form provides a mechanism to override properties for each input component, such as TextField, TextAreaField, and SelectField. You can override any props to those components with the `overrides` prop on the form component.

For example, if you want to change the variation and label of the `content` field in the TodoCreateForm, you can do so like this:
```jsx
<TodoCreateForm
  overrides={{
    content: {
      variation: 'quiet',
      label: 'Todo'
    }
  }}
/>
```
It's not recommended to override properties that are already set by the generated form, as this could lead to unexpected behavior during runtime. You can verify the set properties by navigating to the component in the `src/ui-components/[your-form-component].jsx` file.

To customize the form, you can manually add a form input field connected to a data model. For example, let's say you add a `priority` field to your data model. You can make the following edits to the generated form:
```jsx
const initialValues = {
  content: "",
  priority: ""
};

const [priority, setPriority] = React.useState(initialValues.priority);

const resetStateValues = () => {
  setPriority(initialValues.priority)
  setErrors({});
};

const validations = {
  content: [],
  priority: []
};

const onSubmit = async (event) => {
  event.preventDefault();
  let modelFields = {
    content: content,
    priority: priority
  };
  // submit the form
};

// Add TextField
<TextField
  label="Priority"
  isRequired={false}
  isReadOnly={false}
  value={priority}
  onChange={(e) => {
    let { value } = e.target;
    setPriority(value);
  }}
  onBlur={() => runValidationTasks("priority", priority)}
  errorMessage={errors.priority?.errorMessage}
  hasError={errors.priority?.hasError}
  {...getOverrideProps(overrides, "priority")}
/>
```
You can also manually add option fields, such as Select Fields, Radio Group Fields, and Autocomplete Fields, by replacing the `<TextField>` with the respective component.

To configure form spacings, you can add spacing to your form and between inputs using the `overrides` prop.
```jsx
<TodoCreateForm overrides={{
  TodoCreateForm: {
    rowGap: 'xl',
    columnGap: 'xs',
    padding: 'xl'
  }
}} />
```
You can customize the label for Submit and Clear buttons using the `overrides` prop.
```jsx
<TodoCreateForm overrides={{
  ClearButton: {
    children: 'Close'
  },
  SubmitButton: {
    children: 'Save todo'
  }
}} />
```
You can also toggle the visibility of action buttons using the `overrides` prop.
```jsx
<TodoCreateForm overrides={{
  ClearButton: {
    display: 'none'
  },
  SubmitButton: {
    display: 'none'
  }
}} />
```
If you hide all form action buttons, you can still manage the form lifecycle using the `onChange` event handler.
```jsx
<TodoCreateForm
  onChange={(fields) => {
    console.log({ fields })
    return fields
  }}
/>
```

Connected forms in AWS Amplify Gen 2 are forms that are bound to a model in your app's data schema. When a connected form is submitted, it automatically creates or updates a record in the bound data model, mapping some or all of the form's input fields to fields in the data model. These forms work seamlessly with any Amplify GraphQL API and do not require `onSubmit` handling.

To generate connected forms, you need to install the Amplify UI library by running `npm add @aws-amplify/ui-react` in your terminal. Then, deploy a data model from your sandbox environment and run `npx ampx generate forms` from your project root. This command generates create and update forms for each model defined in your schema, which can be found in the `ui-components` folder.

If you update your data model and need to regenerate the forms, make sure to back up the original `ui-components` folder before running `npx ampx generate forms` again.

To render a React form in your app, start by adding the necessary imports and configuration to your application's entrypoint file. This includes importing the `@aws-amplify/ui-react` styles and `ThemeProvider`, as well as configuring Amplify with your `amplify_outputs.json` file.

Next, wrap your `<App />` component with the `ThemeProvider` component to apply the Amplify UI theme. Then, import your generated form by name, such as `TodoCreateForm`, and place it in your code where you want the form to render.

There are two types of forms: Create forms and Update forms. Create forms render a form with empty inputs and generate a new record upon submission if connected to a data model. Update forms expect an input value to pre-populate the form and can be connected to a data model using the `id` prop or the model prop.

For example, you can use the `id` prop to update a record like this: `<AuthorUpdateForm id="ac74af5c-3aab-4274-8f41-23e1e6576af5" />`. Alternatively, you can use the model prop to pass a record to the form, like this: `<AuthorUpdateForm author={authorRecord}>`.

To manage a form's lifecycle, you can hook into its lifecycle events to customize user input before submission, run validations, handle errors, or self-manage user input events. The form lifecycle consists of several stages, including initial state, onChange, onValidate, onSubmit, onSuccess, onError, and onCancel.

The initial state is when the inputs are either empty or pre-populated based on a default value. If the user clicks the Clear or Reset button, they will be brought back to this state.

The onChange event is triggered when the form data is changed by the user. This can be used to get the form data after every user input. For example, you can use the onChange event to get the form data in real-time as the user is filling the form.

```jsx
import { useState } from 'react'
import { HomeCreateForm } from './ui-components'

function App() {
  const [formData, setFormData] = useState()

  return (
    <HomeCreateForm onChange={fields => setFormData(fields)}/>
  )
}
```

The onValidate event is used to extend validation rules in code. This event triggers after onChange and can be used to validate the form input against external APIs.

The onSubmit event is triggered when the user clicks the Submit button. This can be used to customize the form data before it is saved to the cloud. For example, you can use the onSubmit event to trim all string data before saving it.

```jsx
<HomeCreateForm
    onSubmit={(fields) => {
        const updatedFields = {}
        Object.keys(fields).forEach(key => {
            if (typeof fields[key] === 'string') {
                updatedFields[key] = fields[key].trim()
            } else {
                updatedFields[key] = fields[key]
            }
        })
        return updatedFields
    }}
/>
```

The onSuccess event is triggered when the form data has been successfully submitted. This can be used to take an action after the form data has been successfully submitted, such as hiding the form.

```jsx
import { useState } from 'react'
import { HomeCreateForm } from './ui-components'

function App() {
  const [showForm, setShowForm] = useState(true)

  return (
    {showForm &&
      <HomeCreateForm onSuccess={() => {
        setShowForm(false) // Hide the form
      }}/>}
  )
}
```

The onError event is triggered when there is an error during the submit process. This can be used to log the error and present an alert to the user.

```jsx
import { HomeCreateForm } from './ui-components'

function App() {
  return (
    <HomeCreateForm onError={(error) => {
      console.log(error)
    }}/>
  )
}
```

The onCancel event is triggered when the user clicks the Cancel button. This can be used to hide the form or route the user to another page.

```jsx
import { useState } from 'react'
import { HomeCreateForm } from './ui-components'

function App() {
  const [showForm, setShowForm] = useState(true)

  return (
    {showForm &&
      <HomeCreateForm onCancel={() => {
        setShowForm(false) // Hide the form
      }}/>}
  )
}
```

The File Uploader field in Amplify form builder allows users to upload files, which are stored in an Amazon S3 bucket connected to your Amplify app. After uploading, the file's S3 key is stored in your data model, allowing for systematic retrieval.

To use the File Uploader field, your Amplify app must have Authentication and Storage enabled. The File Uploader input allows users to select files from their local device and upload them to an S3 bucket. Files are uploaded immediately upon selection, and an S3 key is generated. By default, File Uploader generates a unique S3 key based on the file uploaded.

To add the File Uploader to your form, you need a data model with an attribute that is either a string or an array of strings. After updating your data model, run `npx ampx generate forms` to generate the form JSX file. Then, replace the existing component with the FileUploader component.

For example, if your attribute is an array of strings, you can replace the ArrayField component with the FileUploader component like this:
```
<FileUploader
  accessLevel="public"
  maxFileCount={10}
  acceptedFileTypes={['image/*']}
  processFile={processFile}
  onUploadSuccess={({key}) => {
    setImages(prevImages => [...prevImages, key])
  }}
  onFileRemove={({key}) => {
    setImages(prevImages => prevImages.filter(img => img!== key))
  }}
/>
```
If your data model has only one image instead of an array of images, you can replace the TextField component with the FileUploader component like this:
```
<FileUploader
  accessLevel="public"
  maxFileCount={1}
  acceptedFileTypes={['image/*']}
  processFile={processFile}
  onUploadSuccess={({key}) => {
    setImage(key)
  }}
  onFileRemove={({key}) => {
    setImage(undefined)
  }}
/>
```
The FileUploader component has several configuration options, including accessLevel, maxFileCount, and acceptedFileTypes.

File Uploader generates a unique S3 key by hashing the file contents to prevent accidental overwriting of files. However, if a form submitter uploads two identical files to the same path, even with different file names, File Uploader will prevent file duplication in your S3 bucket. If the File level access for your File Uploader is set to private or protected, identical files uploaded by separate users will be saved separately. If the File level access is set to public, identical files will overwrite each other.

To validate form data in Amplify generated forms, you can add and customize validation rules. By default, Amplify infers a range of validation rules based on the data model. For example, if you have a field with an `AWSEmail` type, the generated form input will automatically run an email validation rule.

You can configure validation rules for different input types, such as `String`, `Int`, `Float`, `AWSDate`, `AWSTime`, and `AWSDateTime`. The available validation rules for each type include:

* `String`: Start With, End With, Contain, Does not contain, Be less than N characters long, Be at least N characters long
* `Int`, `Float`: Be greater than, Be less than, Be equal to
* `AWSDate`, `AWSTime`, `AWSDateTime`: Be before, Be after

Some types have automatically configured validation rules, such as:
* `AWSIPAddress`: must be a valid IPv4 or IPv6 address
* `AWSURL`: must consist of a schema and a path part
* `AWSEmail`: must be an email address in the format `<local-part>@<domain-part>`
* `AWSJSON`: must be a valid JSON
* `AWSPhone`: must be a phone number that can contain spaces or hyphens to separate digit groups

To add custom validation rules, you can use the `onValidate` event handler. This handler takes an object with validation functions for the fields you want to validate. The validation function must return a validation response with a shape of `{ hasError: boolean, errorMessage?: string }`.

For example, to validate that an `address` field starts with a number:
```jsx
<HomeCreateForm
  onValidate={{
    address: (value, validationResponse) => {
      const firstWord = value.split('')[0];
      if (!isNaN(firstWord)) {
        return {
          hasError: true,
          errorMessage: 'Address must start with a number'
        };
      }
      return validationResponse;
    }
  }}
/>
```

You can also add validation rules for nested JSON data by passing in validation functions in the same nested structure as the data. For example:
```js
<ProductForm
  onValidate={{
    price: {
      currency: (value, validationResponse) => {
        const allowedCurrencies = ['$', '€', '￥', '₹'];
        if (!allowedCurrencies.includes(value)) {
          return {
            hasError: true,
            errorMessage: 'Currency must be either "$", "€", "￥", or "₹".'
          };
        }
        return validationResponse;
      }
    }
  }}
  onSubmit={(fields) => {
    /* handle form data submission */
  }}
/>
```

Additionally, you can call external APIs for asynchronous form validation by returning a Promise in the `onValidate` prop. For example:
```jsx
<AgentContactForm
  onValidate={{
    licenseNumber: (value, validationResponse) => {
      return fetch(`http://localhost:3000/api/agent/${value}`).then(
        (response) => {
          if (response.status!== 200) {
            return {
              hasError: true,
              errorMessage: 'No agent was not found with that license number.'
            };
          }
          return validationResponse;
        }
      );
    }
  }}
  onSubmit={(fields) => {
    /* Handle form submission */
  }}
/>
```

Amplify offers a UI Library that makes it easy to build web app user interfaces connected to the backend. The Amplify UI Library provides connected components designed to work seamlessly with AWS Amplify backend services. These components allow you to quickly add common user experience patterns, such as authentication and storage, without having to build them from scratch.

The UI Library also includes tooling that can generate React forms from data and React components from Figma designs. This tooling is designed to work with React, JavaScript, and Next.js. 

This page is for formatting only
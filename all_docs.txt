Contents of README.txt:
READ ME

**Ways of working:** We are using `next-release/main` to commit changes for the larger site update.
- One branch per page: Create your branch from `next-release/main` to get the latest updates for the new site. Please limit branches to a page or small chapter to reduce the size of PRs for tech and editorial reviews.
- PR Reviews: When you have final copy ready for reviews, submit PRs to `next-release/main` to go through reviews and approvals.

**New IA:** The menu in this folder follows the organization for the new docs IA. Please do not change first-level folders under `gen2` (build-a-backend, build-ui, etc.). Also, every entry in the new menu can be selected and for this reason every folder will require an index.mdx file. Those without content will include a card index to the submenu when required.

**Folder structure:** Pages folders that host the root file (index.mdx) continue to drive the final URL. Use descriptive naming conventions for these folders to produce descriptive and SEO-friendly URLs. For example, src/pages/gen2/build-a-backend/auth/set-up-auth/index.mdx for https://docs.amplify.aws/gen2/build-a-backend/auth/set-up-auth/. Please use the index.mdx naming convention for your root folder files.

**Platform switcher:** There is not a platform switcher for this folder, but we are organizing the folder and file structure to work with a switcher in the future. The new platform switcher will sit at the top of the pages folder and at the start of the URL, for example, src/pages/[platform]/start/getting-started/setup/index.mdx. Please make sure your root folder files use the index.mdx naming convention.

**InlineFilter:** No InlineFilter needed on these pages atm because there is not a switcher. This folder will only be visible to JS-related platforms.

**Fragments:** Do not use any single-use fragments.

**Initial setup:** An initial IA was set up to provide a visual structure for migrating pages. Not all entries are on this page and it is expected that some of the root folder names may change. Please remember to check the notes above when making changes or adding new folders and files.

Updated 10/19
gen2
├── build-a-backend
│   ├── add-aws-services
│   │   ├── custom-resources
│   │   │   └── index.mdx
│   │   └── overriding-resources
│   │       └── index.mdx
│   ├── auth
│   │   ├── add-social-provider
│   │   │   └── index.mdx
│   │   └── set-up-auth
│   │       └── index.mdx
│   ├── data
│   │   ├── connect-existing-data
│   │   │   └── index.mdx
│   │   └── set-up-data
│   │       └── index.mdx
│   ├── functions
│   │   └── index.mdx
│   ├── index.mdx
│   └── storage
│       └── index.mdx
├── build-ui
│   └── index.mdx
├── deploy-and-host
│   ├── fullstack-branching
│   │   ├── branch-deployments
│   │   │   └── index.mdx
│   │   └── sandbox-deployments
│   │       └── index.mdx
│   ├── hosting-features
│   │   └── index.mdx
│   ├── index.mdx
│   └── local-development
│       └── index.mdx
├── how-amplify-works
│   ├── concepts
│   │   └── index.mdx
│   ├── existing-projects
│   │   └── index.mdx
│   ├── index.mdx
│   └── project-structure
│       └── index.mdx
├── README.mdx
├── reference
│   ├── amplifyconfiguration
│   │   └── index.mdx
│   ├── CLI-commands
│   │   └── index.mdx
│   └── index.mdx
└── start
    └── index.mdx


Contents of ai_concepts_architecture_index.txt:
import { getCustomStaticPath } from "@/utils/getCustomStaticPath";

export const meta = {
  title: "Architecture",
  description:
    "Amplify AI Kit fullstack architecture",
  platforms: [
    "javascript",
    "react-native",
    "angular",
    "nextjs",
    "react",
    "vue",
  ],
};

export const getStaticPaths = async () => {
  return getCustomStaticPath(meta.platforms);
};

export function getStaticProps(context) {
  return {
    props: {
      platform: context.params.platform,
      meta,
    },
  };
}



The Amplify AI kit is built around the idea of routes. An AI route is like an API endpoint for interacting with backend AI functionality. AI routes are configured in an Amplify backend where you can define the authorization rules, what type of route (generation or conversation), AI model and inference configuration like temperature, what are the inputs and outputs, and what data it has access to. There are currently 2 types of AI routes:

* **Conversation:** A conversation route is an asynchronous, multi-turn API. Conversations and messages are automatically stored in DynamoDB. Examples of this are any chat-based AI experience or conversational UI.
* **Generation:** A single synchronous request-response API. A generation route is an AppSync Query that generates structured data according to your route definition. Common uses include generating structured data from unstructured input and summarization.


## Cloud infrastructure

When you create an AI route with the Amplify AI kit, it is using these services:

### AWS AppSync
Serverless API layer to authorize and route requests from the browser to AWS services. 

### Amazon DynamoDB
Serverless database for storing conversation history.

### AWS Lambda
Serverless execution for conversations. 

### Amazon Bedrock
Serverless foundation models.


Contents of ai_concepts_index.txt:
import { getChildPageNodes } from '@/utils/getChildPageNodes';
import { getCustomStaticPath } from "@/utils/getCustomStaticPath";

export const meta = {
  title: "Concepts",
  description:
    "Learn about what Amplify AI provisions and get an overview about generative AI concepts and terminology.",
  route: '/[platform]/ai/concepts',
  platforms: [
    "javascript",
    "react-native",
    "angular",
    "nextjs",
    "react",
    "vue",
  ],
};

export const getStaticPaths = async () => {
  return getCustomStaticPath(meta.platforms);
};

export function getStaticProps(context) {
  const childPageNodes = getChildPageNodes(meta.route);
  return {
    props: {
      meta,
      childPageNodes
    }
  };
}

<Overview childPageNodes={props.childPageNodes} />


Contents of ai_concepts_inference-configuration_index.txt:
import { getCustomStaticPath } from "@/utils/getCustomStaticPath";

export const meta = {
  title: "Inference Configuration",
  description:
    "Learn about inference configuration",
  platforms: [
    "javascript",
    "react-native",
    "angular",
    "nextjs",
    "react",
    "vue",
  ],
};

export const getStaticPaths = async () => {
  return getCustomStaticPath(meta.platforms);
};

export function getStaticProps(context) {
  return {
    props: {
      platform: context.params.platform,
      meta,
    },
  };
}




LLMs have parameters that can be configured to change how the model behaves. This is called inference configuration or inference parameters. LLMs are actually *predicting* text based on the text input. This prediction is probabilistic, and can be tweaked by adjusting the inference configuration to allow for more creative or deterministic outputs. The proper configuration will depend on your use case.

[Bedrock documentation on inference configuration](https://docs.aws.amazon.com/bedrock/latest/userguide/inference-parameters.html)

<Accordion title='What is inference?'>

Inference refers to the process of using a model to generate or predict output based on input data. Inference is using a model after it has been trained on a data set. 

</Accordion>





## Setting inference configuration

All generative AI routes in Amplify accept inference configuration as optional parameters. If you do not provide any inference configuration options, Bedrock will use [default ones for that particular model](#default-values). 

```ts
a.generation({
  aiModel: a.ai.model("Claude 3.5 Haiku"),
  systemPrompt: `You are a helpful assistant`,
  inferenceConfiguration: {
    temperature: 0.2,
    topP: 0.2,
    maxTokens: 1000,
  }
})
```

## Definitions

### Temperature

Affects the shape of the probability distribution for the predicted output and influences the likelihood of the model selecting lower-probability outputs. Temperature is usually* number from 0 to 1, where a lower value will influence the model to select higher-probability options. Another way to think about temperature is to think about creativity. A low number (close to zero) would produce the least creative and most deterministic response.

-* AI21 Labs Jamba models use a temperature range of 0 &ndash; 2.0

### Top P

Top p refers to the percentage of token candidates the model can choose from for the next token in the response. A lower value will decrease the size of the pool and limit the options to more likely outputs. A higher value will increase the size of the pool and allow for lower-probability tokens.


### Max Tokens

This parameter is used to limit the maximum response a model can give. 


## Default values


| Model | Temperature | Top P | Max Tokens |
| ----- | ----------- | ----- | ---------- |
| [AI21 Labs Jamba](https://docs.aws.amazon.com/bedrock/latest/userguide/model-parameters-jamba.html#model-parameters-jamba-request-response) | 1.0* | 0.5 | 4096 |
| [Meta Llama](https://docs.aws.amazon.com/bedrock/latest/userguide/model-parameters-meta.html#model-parameters-meta-request-response) | 0.5 | 0.9 | 512 |
| [Amazon Titan](https://docs.aws.amazon.com/bedrock/latest/userguide/model-parameters-titan-text.html) | 0.7 | 0.9 | 512 |
| [Anthropic Claude](https://docs.aws.amazon.com/bedrock/latest/userguide/model-parameters-anthropic-claude-messages.html#model-parameters-anthropic-claude-messages-request-response) | 1 | 0.999 | 512 |
| [Cohere Command R](https://docs.aws.amazon.com/bedrock/latest/userguide/model-parameters-cohere-command-r-plus.html#model-parameters-cohere-command-request-response) | 0.3 | 0.75 | 512 |
| [Mistral Large](https://docs.aws.amazon.com/bedrock/latest/userguide/model-parameters-mistral-chat-completion.html#model-parameters-mistral-chat-completion-request-response) | 0.7 | 1 | 8192 |

[Bedrock documentation on model default inference configuration](https://docs.aws.amazon.com/bedrock/latest/userguide/model-parameters.html)

-* AI21 Labs Jamba models use a temperature range of 0 &ndash; 2.0


Contents of ai_concepts_models_index.txt:
import { getCustomStaticPath } from "@/utils/getCustomStaticPath";
import { Table, TableBody, TableCell, TableHead, TableRow } from '@aws-amplify/ui-react';

export const meta = {
  title: "Models",
  description:
    "Learn about foundation models provided by Amazon Bedrock used for generative AI",
  platforms: [
    "javascript",
    "react-native",
    "angular",
    "nextjs",
    "react",
    "vue",
  ],
};

export const getStaticPaths = async () => {
  return getCustomStaticPath(meta.platforms);
};

export function getStaticProps(context) {
  return {
    props: {
      platform: context.params.platform,
      meta,
    },
  };
}


A foundation model is a large, general-purpose machine learning model that has been pre-trained on a vast amount of data. These models are trained in an unsupervised or self-supervised manner, meaning they learn patterns and representations from the unlabeled training data without being given specific instructions or labels.

Foundation models are useful because they are general-purpose and you don't need to train the models yourself, but are powerful enough to take on a range of applications.

Foundation Models, which Large Language Models are a part of, are inherently stateless. They take input in the form of text or images and generate text or images. They are also inherently non-deterministic. Providing the same input can  generate different output.

## Getting model access

Before you can invoke a foundation model on Bedrock you will need to [request access to the models in the AWS console](https://console.aws.amazon.com/bedrock/home#/modelaccess).

Be sure to check the region you are building your Amplify app in!

## Pricing and Limits

Each foundation model in Amazon Bedrock has its own pricing and throughput limits for on-demand use. On-demand use is serverless, you don't need to provision any AWS resources to use and you only pay for what you use. The Amplify AI kit uses on-demand use for Bedrock.

The cost for using foundation models is calculated by token usage. A token in generative AI refers to chunks of data that were sent as input and how much data was generated. A token is roughly equal to a word, but depends on the model being used. Each foundation model in Bedrock has its own pricing based on input and output tokens used.

When you use the Amplify AI Kit, inference requests are charged to your AWS account based on Bedrock pricing. There is no Amplify markup, you are just using AWS resources in your own account.

Always refer to [Bedrock pricing](https://aws.amazon.com/bedrock/pricing/) for the most up-to-date information on running generative AI with Amplify AI Kit.

<Callout type="info">
  Your Amplify project must be deployed to a region where the foundation model you specify is available. See [Bedrock model support](https://docs.aws.amazon.com/bedrock/latest/userguide/models-supported.html) for the supported regions per model.
</Callout>

## Supported Providers and Models

The Amplify AI Kit uses Bedrock's [Converse API](https://docs.aws.amazon.com/bedrock/latest/userguide/conversation-inference.html) to leverage a unified API across models.

<Table
  caption="Table with supported models for Amplify AI kit"
  highlightOnHover={false}
  style={{ border: '1.5px solid' }}>
  <TableHead>
    <TableRow>
      <TableCell as="th">Provider</TableCell>
      <TableCell as="th">Model</TableCell>
      <TableCell as="th">Conversation</TableCell>
      <TableCell as="th">Generation</TableCell>
    </TableRow>
  </TableHead>
  <TableBody>
    <TableRow>
      <TableCell><strong><a href="https://docs.aws.amazon.com/bedrock/latest/userguide/model-parameters-ai21.html">AI21 Labs</a></strong></TableCell>
      <TableCell>Jurassic-2 Large</TableCell>
      <TableCell>✅</TableCell>
      <TableCell>❌</TableCell>
    </TableRow>
    <TableRow>
      <TableCell><strong><a href="https://docs.aws.amazon.com/bedrock/latest/userguide/model-parameters-ai21.html">AI21 Labs</a></strong></TableCell>
      <TableCell>Jurassic-2 Mini</TableCell>
      <TableCell>✅</TableCell>
      <TableCell>❌</TableCell>
    </TableRow>
    <TableRow style={{ borderTop: '1.5px solid' }}>
      <TableCell><strong><a href="https://aws.amazon.com/ai/generative-ai/nova/">Amazon</a></strong></TableCell>
      <TableCell>Amazon Nova Pro</TableCell>
      <TableCell>✅</TableCell>
      <TableCell>❌</TableCell>
    </TableRow>
    <TableRow>
      <TableCell><strong><a href="https://aws.amazon.com/ai/generative-ai/nova/">Amazon</a></strong></TableCell>
      <TableCell>Amazon Nova Lite</TableCell>
      <TableCell>✅</TableCell>
      <TableCell>❌</TableCell>
    </TableRow>
    <TableRow>
      <TableCell><strong><a href="https://aws.amazon.com/ai/generative-ai/nova/">Amazon</a></strong></TableCell>
      <TableCell>Amazon Nova Micro</TableCell>
      <TableCell>✅</TableCell>
      <TableCell>❌</TableCell>
    </TableRow>
    <TableRow style={{ borderTop: '1.5px solid' }}>
      <TableCell><strong><a href="https://docs.aws.amazon.com/bedrock/latest/userguide/model-parameters-claude.html">Anthropic</a></strong></TableCell>
      <TableCell>Claude 3 Haiku</TableCell>
      <TableCell>✅</TableCell>
      <TableCell>✅</TableCell>
    </TableRow>
    <TableRow>
      <TableCell><strong><a href="https://docs.aws.amazon.com/bedrock/latest/userguide/model-parameters-claude.html">Anthropic</a></strong></TableCell>
      <TableCell>Claude 3.5 Haiku</TableCell>
      <TableCell>✅</TableCell>
      <TableCell>✅</TableCell>
    </TableRow>
    <TableRow>
      <TableCell><strong><a href="https://docs.aws.amazon.com/bedrock/latest/userguide/model-parameters-claude.html">Anthropic</a></strong></TableCell>
      <TableCell>Claude 3 Sonnet</TableCell>
      <TableCell>✅</TableCell>
      <TableCell>✅</TableCell>
    </TableRow>
    <TableRow>
      <TableCell><strong><a href="https://docs.aws.amazon.com/bedrock/latest/userguide/model-parameters-claude.html">Anthropic</a></strong></TableCell>
      <TableCell>Claude 3.5 Sonnet</TableCell>
      <TableCell>✅</TableCell>
      <TableCell>✅</TableCell>
    </TableRow>
    <TableRow>
      <TableCell><strong><a href="https://docs.aws.amazon.com/bedrock/latest/userguide/model-parameters-claude.html">Anthropic</a></strong></TableCell>
      <TableCell>Claude 3.5 Sonnet v2</TableCell>
      <TableCell>✅</TableCell>
      <TableCell>✅</TableCell>
    </TableRow>
    <TableRow>
      <TableCell><strong><a href="https://docs.aws.amazon.com/bedrock/latest/userguide/model-parameters-claude.html">Anthropic</a></strong></TableCell>
      <TableCell>Claude 3 Opus</TableCell>
      <TableCell>✅</TableCell>
      <TableCell>✅</TableCell>
    </TableRow>
    <TableRow style={{ borderTop: '1.5px solid' }}>
      <TableCell><strong><a href="https://docs.aws.amazon.com/bedrock/latest/userguide/model-parameters-cohere.html">Cohere</a></strong></TableCell>
      <TableCell>Command R</TableCell>
      <TableCell>✅</TableCell>
      <TableCell>❌</TableCell>
    </TableRow>
    <TableRow>
      <TableCell><strong><a href="https://docs.aws.amazon.com/bedrock/latest/userguide/model-parameters-cohere.html">Cohere</a></strong></TableCell>
      <TableCell>Command R+</TableCell>
      <TableCell>✅</TableCell>
      <TableCell>❌</TableCell>
    </TableRow>
    <TableRow style={{ borderTop: '1.5px solid' }}>
      <TableCell><strong><a href="https://docs.aws.amazon.com/bedrock/latest/userguide/model-parameters-meta.html">Meta</a></strong></TableCell>
      <TableCell>Llama 3.1</TableCell>
      <TableCell>✅</TableCell>
      <TableCell>❌</TableCell>
    </TableRow>
    <TableRow style={{ borderTop: '1.5px solid' }}>
      <TableCell><strong><a href="https://docs.aws.amazon.com/bedrock/latest/userguide/model-parameters-mistral.html">Mistral AI</a></strong></TableCell>
      <TableCell>Large</TableCell>
      <TableCell>✅</TableCell>
      <TableCell>❌</TableCell>
    </TableRow>
    <TableRow>
      <TableCell><strong><a href="https://docs.aws.amazon.com/bedrock/latest/userguide/model-parameters-mistral.html">Mistral AI</a></strong></TableCell>
      <TableCell>Large 2</TableCell>
      <TableCell>✅</TableCell>
      <TableCell>❌</TableCell>
    </TableRow>
  </TableBody>
</Table>

Amplify AI Kit makes use of ["tools"](/[platform]/ai/concepts/tools) for both generation and conversation routes. [The models used must support tool use in the Converse API](https://docs.aws.amazon.com/bedrock/latest/userguide/conversation-inference-supported-models-features.html).

Most models have different structures to how they best work with input and how they format their output. Using the Converse API makes it easy to swap different models without having to drastically change how you interact with them.

## Choosing a model

Each model and model provider has their own strengths and weaknesses. We encourage you to try different models for different use-cases to find the right fit. Things to consider when choosing a model:

### Context window

Each model has its own context window size. The context window is how much information you can send to the model. FMs are stateless, but conversation routes manage message history, so the context window can continue to grow as you "chat" with a model. The context window for models is defined by the number of tokens it can receive.

### Latency

Smaller models tend to have a lower latency than larger models, but can also sometimes be less powerful.

### Cost

Each model has its own price and throughput.

### Use-case fit

Some models are trained to be better at certain tasks or with certain languages.

Choosing the right model for your use case is balancing latency, cost, and performance.


## Using different models

Using the Amplify AI Kit you can easily use different models for different functionality in your application. Each AI route definition will have an `aiModel` attribute you define in your schema. To use different foundation models in your Amplify AI backend, update the `aiModel` using `a.ai.model()`:

```ts
const schema = a.schema({
  summarizer: a.generation({
    aiModel: a.ai.model("Claude 3.5 Haiku")
  })
})
```

The `a.ai.model()` function gives you access to friendly names for the Bedrock models. We will keep this function up-to-date as new models are added to Bedrock. In case there is a new model that has not yet been added, you can always use the model ID which can be found in the Bedrock console or documentation:

```ts
const schema = a.schema({
  summarizer: a.generation({
    aiModel: {
      resourcePath: 'meta.llama3-1-405b-instruct-v1:0'
    }
  })
})
```


Contents of ai_concepts_prompting_index.txt:
import { getCustomStaticPath } from "@/utils/getCustomStaticPath";

export const meta = {
  title: "Prompting",
  description:
    "Amplify AI Concepts: Prompting",
  platforms: [
    "javascript",
    "react-native",
    "angular",
    "nextjs",
    "react",
    "vue",
  ],
};

export const getStaticPaths = async () => {
  return getCustomStaticPath(meta.platforms);
};

export function getStaticProps(context) {
  return {
    props: {
      platform: context.params.platform,
      meta,
    },
  };
}





LLM prompting refers to the process of providing a language model, such as Claude or Amazon Titan, with a specific input or "prompt" in order to generate a desired output. The prompt can be a sentence, a paragraph, or even a more complex sequence of instructions that guides the model to produce content that aligns with the user's intent.

The way the prompt is structured and worded can significantly influence the model's response. By crafting the prompt carefully, users can leverage the LLM's extensive knowledge and language understanding capabilities to generate high-quality and relevant text, code, or other types of output.

Effective prompting involves understanding the model's strengths and limitations, as well as experimenting with different prompt formats, styles, and techniques to elicit the desired responses. This can include using specific keywords, providing context, breaking down tasks into steps, and incorporating formatting elements like bullet points or code blocks.

The model APIs have improved beyond providing a single string as input and getting a string as output. Newer models have a more structured API where you define a system prompt, message history, and tool configurations. The Amplify AI kit uses Bedrock's [Converse API](https://docs.aws.amazon.com/bedrock/latest/APIReference/API_runtime_Converse.html), which has a structured input and output rather than only text in and text out. 

## Prompt structure

* **system prompt:** provides high-level instructions to the LLM about its role and how it should respond
* **messages:** The conversation history you want the model to respond to. The Amplify AI kit handles saving conversation history and providing it to the model.
* **tool configuration:** information about the tools the model can choose to invoke. The Amplify AI kit handles creating the tool configuration for you as well as invoking the tools and re-prompting the model with the results. 


## How to customize the system prompt

All AI routes in the Amplify AI kit require a system prompt. This will be used in all requests to the LLM. 

```ts
reviewSummarizer: a.generation({
  aiModel: a.ai.model("Claude 3.5 Haiku"),
  systemPrompt: `
  You are a helpful assistant that summarizes reviews
  for an ecommerce site. 
  `
})
```

## Tips

**Be as detailed as possible.** Try to give as much background and context as you can. Giving the LLM a role and scope typically helps focus the model's responses.

**Say what it should and shouldn't do.** Sometimes LLMs can be a bit verbose or go on tangents. Giving it specific parameters like "Never use placeholder data".

**Use multiple routes.** You can define as many conversation and generation routes as you like, so you don't need to try to fit all the context and functionality you need in a single route. 

**You don't need to put everything into the system prompt.** The message history or even just a single user message can contain a lot of dynamic information. 

**Prompting strategies differ based on the model.** Always read up on the model itself and what works/doesn't work well with the particular model you are using.

## Prompting resources

* [What is a prompt](https://docs.aws.amazon.com/bedrock/latest/userguide/what-is-a-prompt.html)
* [What is prompt engineering](https://docs.aws.amazon.com/bedrock/latest/userguide/what-is-prompt-engineering.html)
* [Design a prompt](https://docs.aws.amazon.com/bedrock/latest/userguide/design-a-prompt.html)
* [Anthropic prompt library](https://docs.anthropic.com/en/prompt-library/library)


Contents of ai_concepts_streaming_index.txt:
import { getCustomStaticPath } from "@/utils/getCustomStaticPath";

export const meta = {
  title: "Streaming",
  description:
    "Learn about how streaming works with LLMs and the Amplify AI kit",
  platforms: [
    "javascript",
    "react-native",
    "angular",
    "nextjs",
    "react",
    "vue",
  ],
};

export const getStaticPaths = async () => {
  return getCustomStaticPath(meta.platforms);
};

export function getStaticProps(context) {
  return {
    props: {
      platform: context.params.platform,
      meta,
    },
  };
}


When an LLM generates a large amount of text, like over 100 words, it can take a while for the entire response to be generated. Rather than waiting for the entire response to come back, we can send back text as it is generated. 

Foundation model providers like Amazon Bedrock will typically have an HTTP streaming API which can send back the response in chunks.

## How Amplify AI kit streaming works

The Amplify AI kit does not use HTTP streaming from the backend to the frontend like other AI frameworks do. Instead, streaming updates are sent to the browser via a websocket connection to AWS AppSync. 

The Lambda that the Amplify AI kit provisions will call Bedrock with a streaming API request. The Lambda will receive the chunks from the HTTP streaming response and send updates to AppSync, which the client then subscribes to. 

If you are using the provided React hook, `useAIConversation` you don't really need to worry about this because it takes care of all of that for you and provides you with conversation messages as React state that is updated as chunks are received.


Contents of ai_concepts_tools_index.txt:
import { getCustomStaticPath } from "@/utils/getCustomStaticPath";

export const meta = {
  title: "Tools",
  description:
    "Amplify AI Concepts: Tool use",
  platforms: [
    "javascript",
    "react-native",
    "angular",
    "nextjs",
    "react",
    "vue",
  ],
};

export const getStaticPaths = async () => {
  return getCustomStaticPath(meta.platforms);
};

export function getStaticProps(context) {
  return {
    props: {
      platform: context.params.platform,
      meta,
    },
  };
}



Large language models (LLMs) are stateless text generators, they have no knowledge of the real world and can't access data on their own. For example, if you asked an LLM "what is the weather in San Jose?" it would not be able to tell you because it does not know what the weather is today. Tools (sometimes referred to as function calling) are functions/APIs that LLMs can choose to invoke to get information about the world. This allows the LLM to answer questions with information not included in their training data like the weather, application-specific, and even user-specific data. 

When an LLM is prompted with tools, it can choose to respond by saying that it wants to call a tool to get some data or take an action on the user's behalf. That data is then added to the conversation history so the LLM can see what data was returned. Here is a simplified flow of what happens:

1. User: "what is the weather in san jose?"
2. Code: Call LLM with this message: "what is the weather in san jose?", and let it know it has access to a tool called `getWeather` that takes an input like `{ city: string }`
3. LLM: "I want to call the 'getWeather' tool with the input `{city: 'san jose'}`"
4. Code: Run `getWeather({city: 'san jose'})` and append the results to the conversation history so far and call the LLM again
5. LLM: "In san jose it is 72 degrees and sunny"

<Callout>

Note: the LLM itself is not actually executing any function or code. It responds with a special message saying that it wants to call that tool with specific input. That tool then needs to called and the results returned to the LLM in a message history. For more information on tools, see the [Bedrock docs on tool use](https://docs.aws.amazon.com/bedrock/latest/userguide/tool-use.html)

</Callout>





Contents of ai_conversation_ai-conversation_index.txt:
import { Card, Text } from '@aws-amplify/ui-react';
import { AIConversation } from '@aws-amplify/ui-react-ai'
import { getCustomStaticPath } from "@/utils/getCustomStaticPath";
import { UIWrapper } from '@/components/UIWrapper'
import { UserAvatar,AssistantAvatar, MESSAGES, MESSAGES_RESPONSE_COMPONENTS } from '@/components/AI'

export const meta = {
  title: "<AIConversation>",
  description:
    "The AIConversation component is a customizable chat interface built for the Amplify AI kit",
  platforms: [
    "nextjs",
    "react",
  ],
};

export const getStaticPaths = async () => {
  return getCustomStaticPath(meta.platforms);
};

export function getStaticProps(context) {
  return {
    props: {
      platform: context.params.platform,
      meta,
    },
  };
}

<UIWrapper>
<AIConversation
  allowAttachments
  messages={MESSAGES}
  handleSendMessage={() => {}}
/>
</UIWrapper>
*Note: the example is a mocked component and not hooked up to a live backend*

## Introduction

The `<AIConversation>` component is highly customizable to fit into any application. The component is built so that it works with the `useAIConversation` hook. The hook manages the state and lifecycle of the component. The component by itself is just a renderer for the conversation state, which the hook provides. The `<AIConversation>` component requires some props:
* `messages` an array of the messages in the conversation
* `handleSendMessage` a handler that is called when a user message is sent. 

The `useAIConversation` hook provides these values and manages the messages state as user messages are sent and assistant responses are streamed back. 

```tsx title="Mock conversation"
import { AIConversation } from '@aws-amplify/ui-react-ai';

export default function Chat() {
  return (
    <AIConversation
      messages={[]}
      handleSendMessage={() => {}}
    />
  )
}
```

The code above won't really do much, but if you wanted to play around with the component or visually test how it will look, you can do that passing in your own set of messages. 


## Getting started

Make sure to first follow our [getting started guide for the Amplify AI kit](/[platform]/ai/set-up-ai) to set up your Amplify AI backend.

Conversations required a logged in user, so we recommend using the [`<Authenticator>`](/[platform]/build-a-backend/auth/connect-your-frontend/using-the-authenticator/) component to easily add authentication flows to your app.

<InlineFilter filters={["react"]}>

```tsx title="src/App.tsx"
import { Amplify } from 'aws-amplify';
import { generateClient } from "aws-amplify/api";
import { Authenticator } from "@aws-amplify/ui-react";
import { AIConversation, createAIHooks } from '@aws-amplify/ui-react-ai';
import '@aws-amplify/ui-react/styles.css';
import outputs from "../amplify_outputs.json";
import { Schema } from "../amplify/data/resource";

Amplify.configure(outputs);

const client = generateClient<Schema>({ authMode: "userPool" });
const { useAIConversation } = createAIHooks(client);

export default function App() {
  const [
    {
      data: { messages },
      isLoading,
    },
    handleSendMessage,
  ] = useAIConversation('chat');
  // 'chat' is based on the key for the conversation route in your schema.

  return (
    <Authenticator>
      <AIConversation
        messages={messages}
        isLoading={isLoading}
        handleSendMessage={handleSendMessage}
      />
    </Authenticator>
  );
}
```

</InlineFilter>

## Formatting Markdown

LLMs can respond with markdown. The `<AIConversation>` component does not have built-in markdown rendering, but does allow for you to pass in your own markdown renderer.

```tsx
import ReactMarkdown from 'react-markdown';

<AIConversation
  messageRenderer={{
    text: ({ text }) => <ReactMarkdown>{text}</ReactMarkdown>
  }}
/>
```

The `messageRenderer` property lets you customize how markdown is rendered within the chat according to your application's needs. The example below demonstrates how to add code syntax highlighting by using `ReactMarkdown` with `rehypeHighlight`.

```tsx
import ReactMarkdown from 'react-markdown';
import rehypeHighlight from 'rehype-highlight';

<AIConversation
  messageRenderer={{
    text: ({ text }) => (
      <ReactMarkdown rehypePlugins={[rehypeHighlight]}>
        {text}
      </ReactMarkdown>
    )
  }}
/>
```

## Rendering images

The `<AIConversation>` component renders images in the conversation history by default. You can also customize how images are rendered with `messageRenderer`, similar to the text example above. 

```tsx
// Note: the image in a message comes in as a byte array
// you will need to convert this to base64
function convertBufferToBase64(
  buffer: ArrayBuffer,
  format: 'png' | 'jpeg' | 'gif' | 'webp'
): string {
  const base64string = Buffer.from(new Uint8Array(buffer)).toString('base64');
  return `data:image/${format};base64,${base64string}`;
}

<AIConversation
  messageRenderer={{
    image: ({ image }) => (
      <img
        className="testing"
        width={200}
        height={200}
        src={convertBufferToBase64(image.source.bytes, image.format)}
        alt=""
      />
    ),
  }}
/>
```

## Welcome message

You can have the `<AIConversation>` component display a welcome message when a user starts a new conversation. 

<UIWrapper>
<AIConversation
  messages={[]}
  handleSendMessage={() => {}}
  welcomeMessage={
    <Card variation="outlined">
      <Text>I am your virtual assistant, ask me any questions you like!</Text>
    </Card>
  }
/>
</UIWrapper>

```tsx
<AIConversation
  welcomeMessage={
    <Card variation="outlined">
      <Text>I am your virtual assistant, ask me any questions you like!</Text>
    </Card>
  }
/>
```

The welcome message will disappear once a message has been sent. 

## Customizing the timestamp

All messages have a timestamp associated with them that are displayed next to the username. To customize how the timestamp displays you can pass a custom text formatter function called `getMessageTimestampText` into the `displayText` property on the `<AIConversation>` component. This function will receive a `Date` object as its argument and should return a string. 

Browsers have a really nice built-in date/time formatter you can use called [`Intl.DateTimeFormat`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl/DateTimeFormat). 

<UIWrapper>
<AIConversation
  messages={MESSAGES}
  handleSendMessage={() => {}}
  displayText={{
    getMessageTimestampText: (date) => new Intl.DateTimeFormat('en-US', {
      timeStyle: 'short',
      hour12: true,
      timeZone: 'UTC'
    }).format(date)
  }}
/>
</UIWrapper>

```tsx
<AIConversation
  displayText={{
    getMessageTimestampText: (date) => new Intl.DateTimeFormat('en-US', {
      timeStyle: 'short',
      hour12: true,
      timeZone: 'UTC'
    }).format(date)
  }}
/>
```

You could also return an empty string if you wanted to hide the timestamps altogether. 

## Attachments

Some of the newer LLMs like the Claude 3 family of models from Anthropic support multi-modal input, so you can send images in your message to the model and it can respond based on the messages. To enable this functionality in the component, there is an `allowAttachments` prop you can enable. 

There are some limitations on the filetype and size of the images attached. The file size for each file should be below 400kb when base64 encoded. Also the currently supported file types are: png, jpg, gif, and webp. 


<UIWrapper>
<AIConversation
  messages={MESSAGES}
  handleSendMessage={() => {}}
  allowAttachments
/>
</UIWrapper>

```tsx
<AIConversation
  //...
  allowAttachments
/>
```


## Avatars

You can customize the usernames and avatars used in the `AIConversation` component by using the `avatars` prop. This lets you control what your AI assistant looks like in the chat and what your user's username and avatar are. 

There are 2 avatars, `user` and `ai`, and each have a `username` and `avatar` attribute. The `avatar` is a React Node and the `username` is a string.

<UIWrapper>
<AIConversation
  messages={MESSAGES}
  handleSendMessage={() => {}}
  allowAttachments
  avatars={{
    user: {
      avatar: <UserAvatar />,
      username: "danny"
    },
    ai: {
      avatar: <AssistantAvatar />,
      username: "Amplify assistant"
    }
  }}
/>
</UIWrapper>


```tsx
<AIConversation
  avatars={{
    user: {
      avatar: <Avatar src="/images/user.jpg" />,
      username: "danny",
    },
    ai: {
      avatar: <Avatar src="/images/ai.jpg" />,
      username: "Amplify assistant"
    }
  }}
/>
```


## Response components

Response components are a way to define custom UI components that the LLM can respond with in the conversation. This creates a richer experience than just text responses so the conversation can be more interactive and engaging. To define a response component you need any React component and give it a name, description, and define the props the LLM should know. 

<UIWrapper>
<AIConversation
  messages={MESSAGES_RESPONSE_COMPONENTS}
  handleSendMessage={() => {}}
  responseComponents={{
    WeatherCard: {
      description:
        'Used to display the weather of a given city to the user',
      component: ({ city }) => {
        return (
          <Card variation="outlined">
            {city}
          </Card>
        );
      },
      props: {
        city: {
          type: 'string',
          required: true,
        },
      },
    },
  }}
/>
</UIWrapper>


```tsx
<AIConversation
  responseComponents={{
    WeatherCard: {
      description: 'Used to display the weather of a given city to the user',
      component: ({ city }) => {
        return <Card>{city}</Card>;
      },
      props: {
        city: {
          type: 'string',
          required: true,
        },
      },
    },
  }}
/>
```

Response components are just plain React components; they can have their own interactive state, fetch data, update shared state, or really anything you can think of. You can pair response components with [data tools](/[platform]/ai/conversation/tools), so the LLM can query for some data and then use a component to display that data. Or your response component could fetch data itself. 

### Adding a fallback

Because response components are defined at runtime and conversation histories are stored in a database, there can be times when there is a response component in the message history that the current application does not have. Response components are saved in the message history as a "toolUse" block, similar to how an LLM would respond when it wants to call a tool. The toolUse block contains the name of the component, and the props the LLM wanted to pass to the component. The LLM is never directly sending UI code, but rather an abstract representation of what it wants to render. 

If the AIConversation component receives a response component message for a response component that was not given to it, by default it will just not render anything. However if you want to add a fallback component if no component is found based on the name, you can use the `FallbackResponseComponent` prop. You can think of this like a 404 page for response components. 

<UIWrapper>
<AIConversation
  messages={MESSAGES_RESPONSE_COMPONENTS}
  handleSendMessage={() => {}}
  FallbackResponseComponent={(props) => <Card variation="outlined">{JSON.stringify(props, null, 2)}</Card>}
/>
</UIWrapper>

```tsx
<AIConversation
  FallbackResponseComponent={(props) => (
    <Card variation="outlined">{JSON.stringify(props, null, 2)}</Card>
  )}
/>
```





Contents of ai_conversation_connect-your-frontend_index.txt:
import { getCustomStaticPath } from "@/utils/getCustomStaticPath";

export const meta = {
  title: "Connect your frontend",
  description: "Learn how to use AI conversations in your app",
  platforms: [
    "javascript",
    "react-native",
    "angular",
    "nextjs",
    "react",
    "vue",
  ],
};

export const getStaticPaths = async () => {
  return getCustomStaticPath(meta.platforms);
};

export function getStaticProps(context) {
  return {
    props: {
      platform: context.params.platform,
      meta,
      showBreadcrumbs: false,
    },
  };
}

In this guide, you will learn how to create, update, and delete conversations, as well as send messages and subscribe to assistant responses.

Conversations and their associated messages are persisted in Amazon DynamoDB. This means the previous messages for a conversation are automatically included in the history sent to the LLM. Access to conversations and messages are scoped to individual users through the [owner based authorization strategy](/react/build-a-backend/data/customize-authz/per-user-per-owner-data-access/).

## Conversation and Message types

### Conversation

There are two main types within the conversation flow, `Conversation` and `Message`.

A `Conversation` is an instance of a chat session between an application user and an LLM. It contains data and methods for interacting with the conversation. A conversation has a one-to-many relationship with its messages.

The `Conversation` type is accessible via `Schema['myChat']['type']` type definition, where `'myChat'` is the name of the conversation route in your data schema.

| Property/Method  | Type   | Description  |
|------------------|:-------|:-------------|
| `id`             | `string` | The unique identifier for the conversation |
| `name`           | `string \| undefined` | The name of the conversation.<br/>You can specify a name when creating or updating a conversation. |
| `metadata`       | `Record<string, string> \| undefined` | Metadata associated with the conversation.<br/>You can specify arbitrary metadata when creating or updating a conversation. |
| `createdAt`      | `string` | The date and time when the conversation was created |w
| `updatedAt`      | `string` | The date and time when the last user message was sent |
| `sendMessage()`  | `(content: MessageContent) => {`<br/>&nbsp;&nbsp;`data: Message;`<br/>&nbsp;&nbsp;`errors: Error[]`<br/>`}` | Send a message to the AI assistant |
| `listMessages()` | `() => {`<br/>&nbsp;&nbsp;`data: Message[];`<br/>&nbsp;&nbsp;`errors: Error[]`<br/>`}` | List all messages for the conversation |
| `onStreamEvent()`| `(options: {`<br/>&nbsp;&nbsp;`next: (event: StreamEvent) => void;`<br/>&nbsp;&nbsp;`error: (error: Error) => void;`<br/>`}) => void` | Subscribe to assistant responses |

### Message

A `Message` is a single chat message between an application user and an LLM. Each message has a `role` property that indicates whether the message is from the user or the assistant. User and assistant messages have a one-to-one relationship. Assistant messages contain an `associatedUserMessageId` property that points to the `id` of the user message that triggered the assistant response.

The `Message` type is accessible via `Schema['myChat']['messageType']`, where `'myChat'` is the name of the conversation route in your data schema.

| Property  | Type   | Description  |
|-----------|:-------|:-------------|
| `id` | `string` | The unique identifier for the message |
| `conversationId` | `string` | The ID of the conversation this message belongs to |
| `associatedUserMessageId` | `string \| undefined` | For assistant messages, the ID of the user message that triggered the response |
| `content` | `MessageContent[]` | The content of the message |
| `role` | `'user' \| 'assistant'` | Whether the message is from the user or assistant |
| `createdAt` | `string` | The date and time when the message was created |

## Request response flow

1. Create a new conversation with `.create()` or get an existing one with `.get()`.
2. Subscribe to assistant responses for a conversation with `.onStreamEvent()`.
3. Send messages to the conversation with `.sendMessage()`.

```ts
import { generateClient } from 'aws-amplify/data';
import { type Schema } from '../amplify/data/resource'

const client = generateClient<Schema>();

// 1. Create a conversation
const { data: chat, errors } = await client.conversations.chat.create();

// 2. Subscribe to assistant responses
const subscription = chat.onStreamEvent({
  next: (event) => {
    // handle assistant response stream events
    console.log(event);
  },
  error: (error) => {
    // handle errors
    console.error(error);
  },
});

// 3. Send a message to the conversation
const { data: message, errors } = await chat.sendMessage('Hello, world!');
```

## Managing conversations

### Create a conversation

Create a new conversation by calling the `.create()` method on your conversation route. In the examples below, we're using a conversation route named `chat`.

```ts
const { data: chat, errors } = await client.conversations.chat.create();

/**
Example conversation data
{
  id: '123e4567-e89b-12d3-a456-426614174000',
  createdAt: '2024-01-01T00:00:00.000Z',
  updatedAt: '2024-01-01T00:00:00.000Z',
}
*/
```

You can optionally attach a `name` and `metadata` to a conversation by passing them as arguments to the `.create()` method. There are no uniqueness constraints on conversation `name` or `metadata` values.

```ts
const { data: chat, errors } = await client.conversations.chat.create({
  name: 'My conversation',
  metadata: {
    value: '1234567890',
  },
});

/**
Example conversation data
{
  id: '123e4567-e89b-12d3-a456-426614174000',
  name: 'My conversation',
  metadata: {
    value: '1234567890',
  },
  createdAt: '2024-01-01T00:00:00.000Z',
  updatedAt: '2024-01-01T00:00:00.000Z',
}
*/
```

### Get an existing conversation

You can get an existing conversation by calling the `.get()` method on your conversation route with the conversation's `id`.

```ts
const id = '123e4567-e89b-12d3-a456-426614174000';
const { data: chat, errors } = await client.conversations.chat.get({ id });

/**
Example conversation data
{
  id: '123e4567-e89b-12d3-a456-426614174000',
  createdAt: '2024-01-01T00:00:00.000Z',
  updatedAt: '2024-01-01T00:00:00.000Z',
}
*/
```

### List conversations

You can list all conversations for a user with the `.list()` method. Retrieved conversations are sorted by `updatedAt` in descending order. This means the most recently used conversations are returned first.

```ts
const { data: chat, errors } = await client.conversations.chat.list();

/**
Example conversations data
{
  items: [
    {
      id: '123e4567-e89b-12d3-a456-426614174000',
      createdAt: '2024-01-01T00:00:00.000Z',
      updatedAt: '2024-01-01T00:00:00.000Z',
    },
    ...
  ],
  nextToken: '...',
}
*/
```

Use the `nextToken` value to paginate through conversations and optionally specify a `limit` to limit the number of conversations returned.

```ts
const { data: chat, errors } = await client.conversations.chat.list({
  limit: 10,
  nextToken: '...',
});
```

### Update a conversation

You can update a conversation's `name` and `metadata` with the `.update()` method.

This is useful if you want to update the conversation name based on the messages sent or attach arbitrary metadata at a later time.

```ts
const id = '123e4567-e89b-12d3-a456-426614174000';
const { data: chat, errors } = await client.conversations.chat.update({
  id,
  name: 'My updated conversation',
});

/**
Example conversation data
{
  id: '123e4567-e89b-12d3-a456-426614174000',
  name: 'My updated conversation',
  createdAt: '2024-01-01T00:00:00.000Z',
  updatedAt: '2024-01-02T00:00:00.000Z',
}
*/
```

### Delete a conversation

<Callout type="info">
  Deleting a conversation makes it unusable in the future. However it does not delete its associated messages.
</Callout>

```ts
const id = '123e4567-e89b-12d3-a456-426614174000';
const { data: chat, errors } = await client.conversations.chat.delete({ id });
```

## Using a conversation instance

Once you have a conversation instance, you can interact with it by calling methods on the instance. These methods are documented in the [Conversation and Message types](#conversation-and-message-types) section.

### Send a message

Once you have a conversation instance, you can send a message to the AI assistant by calling the `.sendMessage()` method. In its simplest form you just pass the message content as text.

<Callout type="info">
  The message returned is the user message sent. Assistant messages are streamed back to the client and can be subscribed to with the `.onStreamEvent()` method. See [Subscribe to assistant responses](#subscribe-to-assistant-responses) for more information.
</Callout>

```ts
const { data: message, errors } = await chat.sendMessage('Hello, world!');

/**
Example message data
{
  id: '98765432-dcba-4321-9876-543210987654',
  conversationId: '123e4567-e89b-12d3-a456-426614174000',
  content: 'Hello, world!',
  role: 'user',
  createdAt: '2024-01-01T00:00:00.000Z',
}
*/
```

There are other arguments you can pass to `.sendMessage()` to customize the message according to your application's needs.

#### Customizing the message content

`sendMessage()` accepts a object type with a `content` property that provides a flexible way to send different types of content to the AI assistant.

##### Image Content
Use `image` to send an image to the AI assistant.
Supported image formats are `png`, `gif`, `jpeg`, and `webp`.

```ts
const { data: message, errors } = await chat.sendMessage({
  content: [
    {
      image: {
        format: 'png',
        source: {
          bytes: new Uint8Array([1, 2, 3]),
        },
      },
    },
  ],
});
```

Mixing `text` and `image` in a single message is supported.

```ts
const { data: message, errors } = await chat.sendMessage({
  content: [
    {
      text: 'describe the image in detail',
    },
    {
      image: {
        format: 'png',
        source: {
          bytes: new Uint8Array([1, 2, 3]),
        },
      },
    },
  ],
});
```

#### AI context

The `aiContext` argument allows you to optionally attach arbitrary data to the message. This is useful for passing additional information, like user information or current state of your application, in a user message to the AI assistant.

```ts
const { data: message, errors } = await chat.sendMessage('Hello, world!', {
  aiContext: {
    user: {
      name: 'Ian',
    },
  },
});
```

#### Tool Configuration

The `toolConfiguration` argument allows you to optionally pass a client tool configuration to the AI assistant with a user message. See the [Tools concept page](/[platform]/ai/concepts/tools) and [Tools guide](/[platform]/ai/conversation/tools/) for more information on how tools works.

<Callout type="info">
  Client tools are conceptually the same as data tools and lambda executable tools. They are API definitions provided to an LLM alongside a user message. The LLM can use the provided tool configuration to decide which tool (if any) to call in order to better respond to the user. However, there's an important distinction with client tools -- you are responsible for implementing the tool execution logic and responding to the AI assistant with the tool's response.
</Callout>

The `json` property is simply a JSON Schema definition of the tool's input. The AI assistant will use this schema to provide the expected input to your tool.
```ts
const { data: message, errors } = await conversation.sendMessage({
  content: [
    {
      text: "I'd like to make a chocolate cake for my friend with a gluten intolerance. What ingredients do I need?",
    },
  ],
  toolConfiguration: {
    tools: {
      generateRecipe: {
        description: "List ingredients needed for a recipe",
        inputSchema: {
          json: {
            type: "object",
            properties: {
              ingredients: {
                type: "array",
                items: { type: "string" },
              },
            },
          },
        },
      },
    },
  },
});
```

The response from the AI assistant will be a JSON object that matches the `inputSchema` definition. See [Subscribe to assistant responses](#subscribe-to-assistant-responses) for more information on how to handle the response.

### Subscribe to assistant responses

Assistant responses are streamed back to the client as they are generated. This allows for a more natural conversation flow where the user doesn't have to wait for a complete response from the AI assistant to see progress and begin reading the response. To subscribe to assistant responses, call the `.onStreamEvent()` method on your conversation instance.

```ts
const subscription = conversation.onStreamEvent({
  next: (event) => {
    console.log(event);
  },
  error: (error) => {
    console.error(error);
  },
});

// later...
subscription.unsubscribe();
```

`onStreamEvent()` takes two callback functions as arguments: `next` and `error`. The `next` callback is invoked with each assistant response.

The `error` callback is invoked if there's an error while processing messages.

The `next` callback is invoked with a `ConversationStreamEvent` object. This type is accessible via `Schema['myChat']['streamEventType']` and is a union of the following types:

#### ConversationStreamTextEvent

As text is streamed back to the client, the `next` callback is invoked with a `ConversationStreamTextEvent` object.

| Property | Type | Description |
|----------|:-----|:------------|
| `id` | `string` | The unique identifier for the stream event |
| `conversationId` | `string` | The ID of the conversation this event belongs to |
| `associatedUserMessageId` | `string` | The ID of the user message that triggered this response |
| `contentBlockIndex` | `number` | The index of the content block being streamed |
| `contentBlockDeltaIndex` | `number` | The index of the delta within the content block |
| `text` | `string` | The text content being streamed |

#### ConversationStreamDoneAtIndexEvent

When the AI assistant completes a content block, the `next` callback is invoked with a `ConversationStreamDoneAtIndexEvent` object.

| Property | Type | Description |
|----------|:-----|:------------|
| `id` | `string` | The unique identifier for the stream event |
| `conversationId` | `string` | The ID of the conversation this event belongs to |
| `associatedUserMessageId` | `string` | The ID of the user message that triggered this response |
| `contentBlockIndex` | `number` | The index of the content block that is complete |
| `contentBlockDoneAtIndex` | `number` | The index at which the content block is complete |


#### ConversationStreamTurnDoneEvent

When the AI assistant completes a turn, the `next` callback is invoked with a `ConversationStreamTurnDoneEvent` object. This event indicates that the assistant has completed a turn and is waiting for the next user message.

| Property | Type | Description |
|----------|:-----|:------------|
| `id` | `string` | The unique identifier for the stream event |
| `conversationId` | `string` | The ID of the conversation this event belongs to |
| `associatedUserMessageId` | `string` | The ID of the user message that triggered this response |
| `contentBlockIndex` | `number` | The index of the final content block for the turn |
| `stopReason` | `string` | The reason why the assistant stopped generating the response |

#### ConversationStreamToolUseEvent

When the AI assistant uses a client tool, the `next` callback is invoked with a `ConversationStreamToolUseEvent` object. Tool use events are accumulated in your cloud resources and sent to the client as a single event.

| Property | Type | Description |
|----------|:-----|:------------|
| `id` | `string` | The unique identifier for the stream event |
| `conversationId` | `string` | The ID of the conversation this event belongs to |
| `associatedUserMessageId` | `string` | The ID of the user message that triggered this response |
| `contentBlockIndex` | `number` | The index of the content block being streamed |
| `toolUse` | `ToolUseBlock` | The tool use block containing function call information |

<Callout type="info">
  **A note on ordering**

  There are no guarantees that events will be received by the client in order. For example, a `ConversationStreamTextEvent` with `contentBlockDeltaIndex` of `1` may be received before the preceding text with `contentBlockDeltaIndex` of `0`. Assume that events may be received out of order and use the `contentBlockIndex` and `contentBlockDeltaIndex` properties to order the events as needed.
</Callout>

### List messages for a conversation

Retrieve all messages for a conversation by calling the `.listMessages()` method on your conversation instance. Recall that messages are automatically persisted, so you can retrieve them at any time to display the conversation history.

```ts
const { data: messages, errors } = await conversation.listMessages();
```

Similar to the `client.conversations.chat.list()` method, retrieved messages are paginated. Use the `nextToken` value to paginate through messages and optionally specify a `limit` to limit the number of messages returned.

```ts
const { data: messages, errors } = await conversation.listMessages({
  limit: 10,
  nextToken: '...',
});
```


Contents of ai_conversation_context_index.txt:
import { getCustomStaticPath } from "@/utils/getCustomStaticPath";

export const meta = {
  title: "Context",
  description:
    "How to pass client-side context to the LLM to help it respond.",
  platforms: [
    "javascript",
    "react-native",
    "angular",
    "nextjs",
    "react",
    "vue",
  ],
};

export const getStaticPaths = async () => {
  return getCustomStaticPath(meta.platforms);
};

export function getStaticProps(context) {
  return {
    props: {
      platform: context.params.platform,
      meta,
      showBreadcrumbs: false,
    },
  };
}



For LLMs to provide high-quality answers to users' questions, they need to have the right information. Sometimes this information is contextual, based on the user or the state of the application. To allow for this, you can send `aiContext` with any user message to the LLM, which can be any unstructured or structured data that might be useful.

<InlineFilter filters={["javascript","vue","angular"]}>

```ts
import { generateClient } from "aws-amplify/data";
import type { Schema } from "../amplify/data/resource";

const client = generateClient<Schema>({ authMode: 'userPool' });

const { data: conversation } = await client.conversations.chat.create();

conversation.sendMessage({
  content: [{ text: "hello" }],
  // aiContext can be any shape
  aiContext: {
    username: "danny"
  }
})
```

</InlineFilter>


<InlineFilter filters={["react-native"]}>

```tsx
export default function Chat() {
  const [
    {
      data: { messages },
      isLoading,
    },
    sendMessage,
  ] = useAIConversation('chat');

  function handleSendMessage(message) {
    sendMessage({
      ...message,
      // this can be any object that can be stringified
      aiContext: {
        currentTime: new Date().toLocaleTimeString()
      }
    })
  }

  return (
    //...
  )
}
```

</InlineFilter>


<InlineFilter filters={["react", "nextjs"]}>

```tsx
function Chat() {
  const [
    {
      data: { messages },
      isLoading,
    },
    sendMessage,
  ] = useAIConversation('chat');

  return (
    <AIConversation
      messages={messages}
      isLoading={isLoading}
      handleSendMessage={sendMessage}
      // This will let the LLM know about the current state of this application
      // so it can better respond to questions
      aiContext={() => {
        return {
          currentTime: new Date().toLocaleTimeString(),
        };
      }}
    />
  );
}
```


The function passed to the `aiContext` prop will be run immediately before the request is sent in order to get the most up to date information. 

You can use React context or other state management systems to update the data passed to `aiContext`. Using React context we can provide more information about the current state of the application:

```tsx
// Create a context to share state across components
const DataContext = React.createContext<{
  data: any;
  setData: (value: React.SetStateAction<any>) => void;
}>({ data: {}, setData: () => {} });

// Create a component that updates the shared state
function Counter() {
  const { data, setData } = React.useContext(AIContext);
  const count = data.count ?? 0;
  return (
    <Button onClick={() => setData({ ...data, count: count + 1 })}>
      {count}
    </Button>
  );
}

// reference shared data in aiContext
function Chat() {
  const { data } = React.useContext(DataContext);
  const [
    {
      data: { messages },
      isLoading,
    },
    sendMessage,
  ] = useAIConversation('pirateChat');

  return (
    <AIConversation
      messages={messages}
      isLoading={isLoading}
      handleSendMessage={sendMessage}
      // This will let the LLM know about the current state of this application
      // so it can better respond to questions
      aiContext={() => {
        return {
          ...data,
          currentTime: new Date().toLocaleTimeString(),
        };
      }}
    />
  );
}

export default function Example() {
  const [data, setData] = React.useState({});
  return (
    <Authenticator>
      <DataContext.Provider value={{ data, setData }}>
        <Counter />
        <Chat />
      </DataContext.Provider>
    </Authenticator>
  )
}
```


</InlineFilter>


Contents of ai_conversation_history_index.txt:
import { getCustomStaticPath } from "@/utils/getCustomStaticPath";

export const meta = {
  title: "Conversation History",
  description:
    "Learn how Amplify AI kit takes care of conversation history",
  platforms: [
    "javascript",
    "react-native",
    "angular",
    "nextjs",
    "react",
    "vue",
  ],
};

export const getStaticPaths = async () => {
  return getCustomStaticPath(meta.platforms);
};

export function getStaticProps(context) {
  return {
    props: {
      platform: context.params.platform,
      meta,
      showBreadcrumbs: false,
    },
  };
}

The Amplify AI kit automatically and securely stores conversation history per user so you can easily resume past conversations. 

<Callout>

If you are looking for a quick way to get stared with conversation history, [this example project](https://github.com/aws-samples/amplify-ai-examples/tree/main/claude-ai) has a similar interface to ChatGPT or Claude where users see past conversations in a sidebar they can manage. 

</Callout>

When you define a conversation route in your Amplify data schema, the Amplify AI kit turns that into 2 data models: `Conversation` and `Message`. The `Conversation` model functions mostly the same way as other data models defined in your schema. You can list and filter them (because they use owner-based authorization users will only see their conversations) and you can get a specific conversation by ID. Then once you have a conversation instance you can load the messages in it if there are any, send messages to it, and subscribe to the stream events being sent back. 


## Listing conversations

To list all the conversations a user has you can use the `.list()` method. It works the same way as any other Amplify data model would. You can optionally pass a `limit` or `nextToken`.

```ts
const { data: conversations } = await client.conversations.chat.list()
```

The `updatedAt` field gets updated when new messages are sent, so you can use that to see which conversation had the most recent message. Conversations retrieved via `.list()` are sorted in descending order by `updatedAt`.

### Pagination
The result of `.list()` contains a `nextToken` property. This can be used to retrieve subsequent pages of conversations.

```ts
const { data: conversations, nextToken } = await client.conversations.chat.list();

// retrieve next page
if (nextToken) { 
  const { data: nextPageConversations } = await client.conversations.chat.list({ 
    nextToken 
  });
}
```

Conversations also have `name` and `metadata` fields you can use to more easily find and resume past conversations. `name` is a string and `metadata` is a JSON object so you can store any extra information you need. 

## Resuming conversations

You can resume a conversation by calling the `.get()` method with a conversation ID. Both `.create()` and `.get()` return the a conversation instance. 

<InlineFilter filters={['javascript','vue','angular']}>

```ts
// list all conversations a user has
// make sure the user has been authenticated with Amplify Auth
const conversationList = await client.conversations.conversation.list();

// Retrieve a specific conversation
const { data: conversation } = await client.conversations.chat.get({ id: conversationList[0].id });

// list the existing messages in the conversation
const { data: messages } = await conversation.listMessages();

// You can now send a message to the conversation
conversation.sendMessage({
  content: [
    {text: "hello"}
  ]
})
```

</InlineFilter>

<InlineFilter filters={['react','nextjs','react-native']}>

```tsx
export function Chat({ id }) {
  const [
    data: { messages }
    handleSendMessage,
  ] = useAIConversation('chat', { id })
}
```

</InlineFilter>



Contents of ai_conversation_index.txt:
import { getChildPageNodes } from '@/utils/getChildPageNodes';
import { getCustomStaticPath } from "@/utils/getCustomStaticPath";

export const meta = {
  title: "Conversation",
  description:
    "Learn about conversational AI patterns and how to implement them in Amplify.",
  route: '/[platform]/ai/conversation',
  platforms: [
    "javascript",
    "react-native",
    "angular",
    "nextjs",
    "react",
    "vue",
  ],
};

export const getStaticPaths = async () => {
  return getCustomStaticPath(meta.platforms);
};

export function getStaticProps(context) {
  const childPageNodes = getChildPageNodes(meta.route);
  return {
    props: {
      meta,
      childPageNodes,
      showBreadcrumbs: false,
    }
  };
}


The conversation route simplifies the creation of AI-powered conversation interfaces in your application. It automatically sets up the necessary AppSync API components and Lambda functions to handle streaming multi-turn interactions with Amazon Bedrock foundation models.

## Key Components

1. **AppSync API**: Gateway to the conversation route.
    - Create new conversation route instance.
    - Send messages to conversation route instance.
    - Subscribe to real-time updates for assistant responses.

2. **Lambda Function**: Bridge between AppSync and Amazon Bedrock.
    - Retrieve conversation instance history.
    - Invokes Bedrock's /converse endpoint.
    - Handles tool use responses by invoking AppSync queries.

3. **DynamoDB**: Stores conversation and message data
    - Conversations are scoped to a specific application user.

## Authentication Flow

1. The user's OIDC access token is passed from the client to AppSync
2. AppSync forwards this token to the Lambda function
3. The Lambda function uses the token to authenticate requests back to AppSync

## Usage Scenarios

Each of the following scenarios have safeguards in place to mitigate risks associated with invoking tools on behalf of the user, including:

- Amazon CloudWatch log group redacting OIDC access tokens for logs from the Lambda function.
- IAM policies that limit the Lambda function's ability to access other resources.


## Data Flow

1. User sends a message via the AppSync mutation
2. AppSync triggers the Lambda function (default or custom)
3. Lambda processes the message and invokes Bedrock's /converse endpoint
  a. If response is a tool use, Lambda function invokes applicable AppSync query.
4. Lambda sends assistant response back to AppSync
5. AppSync sends the response to subscribed clients

This design allows for real-time, scalable conversations while ensuring that the Lambda function's data access matches that of the application user.

## Next Steps

<Overview childPageNodes={props.childPageNodes} />


Contents of ai_conversation_knowledge-base_index.txt:
import { getCustomStaticPath } from "@/utils/getCustomStaticPath";

export const meta = {
  title: "Knowledge Base",
  description:
    "Knowledge bases can be used for retrieval augmented generation or RAG",
  platforms: [
    "javascript",
    "react-native",
    "angular",
    "nextjs",
    "react",
    "vue",
  ],
};

export const getStaticPaths = async () => {
  return getCustomStaticPath(meta.platforms);
};

export function getStaticProps(context) {
  return {
    props: {
      platform: context.params.platform,
      meta,
      showBreadcrumbs: false,
    },
  };
}

[Amazon Bedrock knowledge bases](https://docs.aws.amazon.com/bedrock/latest/userguide/knowledge-base.html) are a great way to implement Retrieval Augmented Generation, or RAG for short. RAG is a common pattern in building generative AI applications that involves storing a lot of content, like documentation, in a vector database like Postgres with pg_vector or OpenSearch.


<Callout warning>

The default setup for an Amazon Bedrock knowledge base is OpenSearch Serverless which has a default cost whether or not you use it. You can get a large AWS bill if you are not careful. If you are just testing this out make sure to turn off the OpenSearch Serverless instance when you are done. 

</Callout>

## Create a knowledge base

To integrate Bedrock knowledge base with your conversation route, first [create an Amazon Bedrock knowledge base](https://docs.aws.amazon.com/bedrock/latest/userguide/knowledge-base-create.html) in the console, CLI, or with CDK. 

## Create a custom query and tool

```ts title="amplify/data/resource.ts"
import { type ClientSchema, a, defineData } from "@aws-amplify/backend";

const schema = a.schema({
  // highlight-start
  knowledgeBase: a
    .query()
    .arguments({ input: a.string() })
    .handler(
      a.handler.custom({
        dataSource: "KnowledgeBaseDataSource",
        entry: "./resolvers/kbResolver.js",
      }),
    )
    .returns(a.string())
    .authorization((allow) => allow.authenticated()),
  // highlight-end

  chat: a.conversation({
    aiModel: a.ai.model("Claude 3.5 Haiku"),
    systemPrompt: `You are a helpful assistant.`,
    // highlight-start
    tools: [
      a.ai.dataTool({
        name: 'searchDocumentation',
        description: 'Performs a similarity search over the documentation for ...',
        query: a.ref('knowledgeBase'),
      }),
    ]
    // highlight-end
  })
})
```

## Write an AWS AppSync resolver

Then you'll need to create a JavaScript AWS AppSync resolver to connect the query to the knowledge base. You'll need to know the ID of the knowledge base you want to use, which you can find in the Amazon Bedrock console or with the AWS CLI.

```javascript title="amplify/data/resolvers/kbResolver.js"
export function request(ctx) {
  const { input } = ctx.args;
  return {
    resourcePath: "/knowledgebases/[KNOWLEDGE_BASE_ID]/retrieve",
    method: "POST",
    params: {
      headers: {
        "Content-Type": "application/json",
      },
      body: JSON.stringify({
        retrievalQuery: {
          text: input,
        },
      }),
    },
  };
}

export function response(ctx) {
  return JSON.stringify(ctx.result.body);
}

```

## Define the data source

Then in the amplify backend file you will need to create the data source for the knowledge base query and give it permission to call the knowledge base. 

```ts title="amplify/backend.ts"
import { defineBackend } from '@aws-amplify/backend';
import { auth } from './auth/resource';
import { data } from './data/resource';
import { PolicyStatement } from 'aws-cdk-lib/aws-iam';
import * as cdk from 'aws-cdk-lib';

const backend = defineBackend({
  auth,
  data,
});

const KnowledgeBaseDataSource =
  backend.data.resources.graphqlApi.addHttpDataSource(
    "KnowledgeBaseDataSource",
    `https://bedrock-runtime.${cdk.Stack.of(backend.data).region}.amazonaws.com`,
    {
      authorizationConfig: {
        signingRegion: cdk.Stack.of(backend.data).region,
        signingServiceName: "bedrock",
      },
    },
  );

KnowledgeBaseDataSource.grantPrincipal.addToPrincipalPolicy(
  new PolicyStatement({
    resources: [
      `arn:aws:bedrock:${cdk.Stack.of(backend.data).region}:[account ID]:knowledge-base/[knowledge base ID]`
    ],
    actions: ["bedrock:Retrieve"],
  }),
);
```

That's it!




Contents of ai_conversation_response-components_index.txt:
import { getCustomStaticPath } from "@/utils/getCustomStaticPath";

export const meta = {
  title: "Response components",
  description:
    "Create rich conversational interfaces with custom UI responses",
  platforms: [
    "nextjs",
    "react",
  ],
};

export const getStaticPaths = async () => {
  return getCustomStaticPath(meta.platforms);
};

export function getStaticProps(context) {
  return {
    props: {
      platform: context.params.platform,
      meta,
      showBreadcrumbs: false,
    },
  };
}


Response components are custom UI components you can define that the AI assistant can respond with. Response components allow you to build conversational interfaces that are more than just text in and text out. 

## How it works

The `AIConversation` component takes the response components and turns them into [tool](/[platform]/ai/concepts/tools) configurations to send to the LLM. The tool configurations get sent when a user message is sent to the backend, then the backend Lambda merges the tools coming from the client and any [schema tools](/[platform]/ai/conversation/tools). The LLM sees that it can invoke UI component "tool", with certain input/props. If the LLM chooses to use a response component tool, a message gets sent to the client with the response component name and props. The `AIConversation` component will then try to render the React component provided with the props the LLM sends. 

It is important to know that the LLM is NOT writing raw code that sent to the browser and evaluated.

## Structure

The `responseComponents` prop on the `AIConversation` component takes a named object where the keys are the component names and the value is the component definition. 

A response component has:

* `description`: A description of the component. The more descriptive, the easier it is 
* `component`: The React component to render. The props of the component should match the props
* `props`: The props for the React component in [JSONSchema format](https://json-schema.org/understanding-json-schema/reference).


```tsx
<AIConversation
  // highlight-start
  responseComponents={{
    WeatherCard: {
      description: "Used to display the weather to the user",
      component: ({ city }) => {
        return (
          <div>{city}</div>
        )
      },
      props: {
        city: {
          type: "string",
          required: true,
          description: "The name of the city to display the weather for",
        },
      },
    },
  }}
  // highlight-end
/>
```

## Passing context back to the assistant

When a user sends a message to the AI assistant from the client, you can optionally send `aiContext` with the message. `aiContext` is any information about the current state of the client application that might be useful for the AI assistant to know to help it respond better. `aiContext` could be things like the user's name, or the current state of the application like what page they are currently on. AI context is a plain object that will get stringified and sent to the AI assistant with the next user message.

You can use the `aiContext` to let the AI assistant know what was rendered in the response component so it can have more context to respond with.

It can be helpful to continue the conversation to add some context to the next message in the conversation to let the AI know what was displayed to the user. Because a UI component can have state and also data not included in a prop,


```tsx
// Create a context to share state across components
// highlight-start
const DataContext = React.createContext<{
  data: any;
  setData: (value: React.SetStateAction<any>) => void;
}>({ data: {}, setData: () => {} });

function WeatherCard({ city }: { city: string }) {
  const { setData } = React.useContext(DataContext);

  React.useEffect(() => {
    // fetch some weather data
    // set the data context
    setData({ 
      city,
      // weather info
    })
  },[city])

  return (
    <div>{city}</div>
  )
}
// highlight-start


function Chat() {
  const { data } = React.useContext(DataContext);
  const [
    {
      data: { messages },
      isLoading,
    },
    sendMessage,
  ] = useAIConversation('chat');

  return (
    <AIConversation
      messages={messages}
      isLoading={isLoading}
      handleSendMessage={sendMessage}
      responseComponents={{
        WeatherCard: {
          component: WeatherCard,
          description: "Used to display the weather to the user",
          props: {
            city: {
              type: "string",
              required: true,
              description: "The name of the city to display the weather for",
            },
          },
        }
      }}
      // highlight-start
      aiContext={() => {
        return {
          ...data,
        };
      }}
      // highlight-end
    />
  );
}

export default function Example() {
  const [data, setData] = React.useState({});
  return (
    <Authenticator>
      <DataContext.Provider value={{ data, setData }}>
        <Chat />
      </DataContext.Provider>
    </Authenticator>
  )
}
```

## Fallback

Because response components are defined at runtime in your React code, but conversation history is stored in a database, there can be times when there is a message in the conversation history that has a response component you no longer have. To handle these situations there is a `FallbackResponseComponent` prop you can use.

```tsx
<AIConversation
  // highlight-start
  FallBackResponseComponent={(props) => {
    return <>{JSON.stringify(props)}</>
  }}
  // highlight-end
/>
```


Contents of ai_conversation_tools_index.txt:
import { getCustomStaticPath } from "@/utils/getCustomStaticPath";

export const meta = {
  title: "Tools",
  description:
    "Tools allow LLMs to take action or query information so it can respond with up to date information.",
  platforms: [
    "javascript",
    "react-native",
    "angular",
    "nextjs",
    "react",
    "vue",
  ],
};

export const getStaticPaths = async () => {
  return getCustomStaticPath(meta.platforms);
};

export function getStaticProps(context) {
  return {
    props: {
      platform: context.params.platform,
      meta,
      showBreadcrumbs: false,
    },
  };
}


Tools allow LLMs to query information to respond with current and relevant information. They are invoked only if the LLM requests to use one based on the user's message and the tool's description.

There are a few different ways to define LLM tools in the Amplify AI kit.

1. Model tools
2. Query tools
3. Lambda tools

The easiest way to define tools for your conversation route is with `a.ai.dataTool()` for data models and custom queries in your data schema. When you define a tool for a conversation route, Amplify takes care of the heavy lifting:

* **Describing the tools to the LLM:** Each tool definition is an Amplify model query or custom query that is defined in the schema. Amplify knows the input parameters needed for that tool and describes them to the LLM.
* **Invoking the tool with the right parameters:** After the LLM requests to use a tool with necessary input parameters, the conversation handler Lambda function invokes the tool, returns the result to the LLM, and continues the conversation.
* **Maintaining the caller identity and authorization:** Through tools, the LLM can only access data that the application user has access to. When the LLM requests to invoke a tool, we will call it with the user's identity. For example, if the LLM wanted to invoke a query to list Todos, it would only return the todos that user has access to.

## Model tools

You can give the LLM access to your data models by referencing them in an `a.ai.dataTool()` with a reference to a model in your data schema. This requires that the model uses at least one of the following authorization strategies:

**[Per user data access](https://docs.amplify.aws/react/build-a-backend/data/customize-authz/per-user-per-owner-data-access/)**
- `owner()`
- `ownerDefinedIn()`
- `ownersDefinedIn()`

**[Any signed-in user data access](https://docs.amplify.aws/react/build-a-backend/data/customize-authz/signed-in-user-data-access/)**
- `authenticated()`

**[Per user group data access](https://docs.amplify.aws/react/build-a-backend/data/customize-authz/user-group-based-data-access/)**
- `group()`
- `groupsDefinedIn()`
- `groups()`
- `groupsDefinedIn()`

```ts title="amplify/data/resource.ts"
import { type ClientSchema, a, defineData } from "@aws-amplify/backend";

const schema = a.schema({
  Post: a.model({
    title: a.string(),
    body: a.string(),
  })
  .authorization(allow => allow.owner()),

  chat: a.conversation({
    aiModel: a.ai.model('Claude 3.5 Haiku'),
    systemPrompt: 'Hello, world!',
    tools: [
      a.ai.dataTool({
        // The name of the tool as it will be referenced in the message to the LLM
        name: 'PostQuery',
        // The description of the tool provided to the LLM.
        // Use this to help the LLM understand when to use the tool.
        description: 'Searches for Post records',
        // A reference to the `a.model()` that the tool will use
        model: a.ref('Post'),
        // The operation to perform on the model
        modelOperation: 'list',
      }),
    ],
  }),
})
```

This will let the LLM list and filter `Post` records. Because the data schema has all the information about the shape of a `Post` record, the data tool will provide that information to the LLM so you don't have to. Also, the Amplify AI kit handles authorizing the tool use requests based on the caller's identity. This means if you have an owner-based model, the LLM will only be able to query the user's records.

<Callout type="info">

The only supported model operation is `'list'`.

</Callout>

## Query tools

You can also give the LLM access to custom queries defined in your data schema. To do so, define a custom query with a [function or custom handler](https://docs.amplify.aws/react/build-a-backend/data/custom-business-logic/) and then reference that custom query as a tool. This requires that the custom query uses the `allow.authenticated()` authorization strategy.

```ts title="amplify/data/resource.ts"
import { type ClientSchema, a, defineData, defineFunction } from "@aws-amplify/backend";

export const getWeather = defineFunction({
  name: 'getWeather',
  entry: './getWeather.ts',
  environment: {
    API_ENDPOINT: 'MY_API_ENDPOINT',
    API_KEY: secret('MY_API_KEY'),
  },
});

const schema = a.schema({
  getWeather: a.query()
    .arguments({ city: a.string() })
    .returns(a.customType({
      value: a.integer(),
      unit: a.string()
    }))
    .handler(a.handler.function(getWeather))
    .authorization((allow) => allow.authenticated()),

  chat: a.conversation({
    aiModel: a.ai.model('Claude 3.5 Haiku'),
    systemPrompt: 'You are a helpful assistant',
    tools: [
      a.ai.dataTool({
        // The name of the tool as it will be referenced in the LLM prompt
        name: 'get_weather',
        // The description of the tool provided to the LLM.
        // Use this to help the LLM understand when to use the tool.
        description: 'Gets the weather for a given city',
        // A reference to the `a.query()` that the tool will invoke.
        query: a.ref('getWeather'),
      }),
    ]
  })
    .authorization((allow) => allow.owner()),
});
```

The Amplify data tool takes care of specifying the necessary input parameters to the LLM based on the query definition.

Below is an illustrative example of a Lambda function handler for the `getWeather` query.

```ts title="amplify/data/getWeather.ts"
import { env } from "$amplify/env/getWeather";
import type { Schema } from "./resource";

export const handler: Schema["getWeather"]["functionHandler"] = async (
  event
) => {
  const { city } = event.arguments;
  if (!city) {
    throw new Error('City is required');
  }

  const url = `${env.API_ENDPOINT}?city=${encodeURIComponent(city)}`;
  const request = new Request(url, {
    headers: {
      Authorization: `Bearer ${env.API_KEY}`
    }
  });

  const response = await fetch(request);
  const weather = await response.json();
  return weather;
}
```

Lastly, you will need to update your **`amplify/backend.ts`** file to include the newly defined `getWeather` function.

```ts title="amplify/backend.ts"
import { defineBackend } from '@aws-amplify/backend';
import { auth } from './auth/resource';
import { data, getWeather } from './data/resource';

const backend = defineBackend({
  auth,
  data,
  getWeather
});
```


### Connect to any AWS Service

You can connect to any AWS service by defining a custom query and calling that service in the function handler. To properly authorize the custom query function to call the AWS service, you will need to provide the Lambda with the proper permissions.

```ts title="amplify/backend.ts"
import { defineBackend } from "@aws-amplify/backend";
import { auth } from "./auth/resource";
import { data } from "./data/resource";
import { storage } from "./storage/resource";
import { getWeather } from "./functions/getWeather/resource";
import { PolicyStatement } from "aws-cdk-lib/aws-iam";

const backend = defineBackend({
  auth,
  data,
  storage,
  getWeather
});

backend.getWeather.resources.lambda.addToRolePolicy(
  new PolicyStatement({
    resources: ["[resource arn]",],
    actions: ["[action]"],
  }),
)
```

## Custom Lambda Tools

You can also define a tool that executes in the conversation handler AWS Lambda function. This is useful if you want to define a tool that is not related to your data schema or that does simple tasks within the Lambda function runtime.

First install the `@aws-amplify/backend-ai` package.

```bash title="Terminal"
npm install @aws-amplify/backend-ai
```

Define a custom conversation handler function in your data schema and reference the function in the `handler` property of the `a.conversation()` definition.

```ts title="amplify/data/resource.ts"
import { type ClientSchema, a, defineData } from '@aws-amplify/backend';
import { defineConversationHandlerFunction } from '@aws-amplify/backend-ai/conversation';

export const chatHandler = defineConversationHandlerFunction({
  entry: './chatHandler.ts',
  name: 'customChatHandler',
  models: [
    { modelId: a.ai.model("Claude 3.5 Haiku") }
  ]
});

const schema = a.schema({
  chat: a.conversation({
    aiModel: a.ai.model('Claude 3.5 Haiku'),
    systemPrompt: "You are a helpful assistant",
    handler: chatHandler,
  })
    .authorization((allow) => allow.owner()),
})
```

Define the executable tool(s) and handler. Below is an illustrative example of a custom conversation handler function that defines a `calculator` tool.

```ts title="amplify/data/chatHandler.ts"
import {
  ConversationTurnEvent,
  createExecutableTool,
  handleConversationTurnEvent
} from '@aws-amplify/backend-ai/conversation/runtime';

const jsonSchema = {
  json: {
    type: 'object',
    properties: {
      'operator': {
        'type': 'string',
        'enum': ['+', '-', '*', '/'],
        'description': 'The arithmetic operator to use'
      },
      'operands': {
        'type': 'array',
        'items': {
          'type': 'number'
        },
        'minItems': 2,
        'maxItems': 2,
        'description': 'Two numbers to perform the operation on'
      }
    },
    required: ['operator', 'operands']
  }
} as const;
// declare as const to allow the input type to be derived from the JSON schema in the tool handler definition.

const calculator = createExecutableTool(
  'calculator',
  'Returns the result of a simple calculation',
  jsonSchema,
  // input type is derived from the JSON schema
  (input) => {
    const [a, b] = input.operands;
    switch (input.operator) {
      case '+': return Promise.resolve({ text: (a + b).toString() });
      case '-': return Promise.resolve({ text: (a - b).toString() });
      case '*': return Promise.resolve({ text: (a * b).toString() });
      case '/':
        if (b === 0) throw new Error('Division by zero');
        return Promise.resolve({ text: (a / b).toString() });
      default:
        throw new Error('Invalid operator');
    }
  },
);

export const handler = async (event: ConversationTurnEvent) => {
  await handleConversationTurnEvent(event, {
    tools: [calculator],
  });
};
```

Note that we throw an error in the `calculator` tool example above if the input is invalid. This error is surfaced to the LLM by the conversation handler function. Depending on the error message, the LLM may try to use the tool again with different input or completing its response with test for the user.

Lastly, update your backend definition to include the newly defined `chatHandler` function.

```ts title="amplify/backend.ts"
import { defineBackend } from '@aws-amplify/backend';
import { auth } from './auth/resource';
import { data, chatHandler } from './data/resource';

defineBackend({
  auth,
  data,
  chatHandler,
});
```

### Best Practices

- Validate and sanitize any input from the LLM before using it in your application, e.g. don't use it directly in a database query or use `eval()` to execute it.
- Handle errors gracefully and provide meaningful error messages.
- Log and monitor tool usage to detect potential misuse or issues.


Contents of ai_generation_data-extraction_index.txt:
import { getCustomStaticPath } from "@/utils/getCustomStaticPath";

export const meta = {
  title: "Data Extraction",
  description:
    "How to extract data from unstructured text.",
  platforms: [
    "javascript",
    "react-native",
    "angular",
    "nextjs",
    "react",
    "vue",
  ],
};

export const getStaticPaths = async () => {
  return getCustomStaticPath(meta.platforms);
};

export function getStaticProps(context) {
  return {
    props: {
      platform: context.params.platform,
      meta,
      showBreadcrumbs: false,
    },
  };
}

Data extraction allows you to parse unstructured text and extract structured data using AI. This is useful for converting free-form text into typed objects that can be used in your application.

The following example shows how to extract product details from an unstructured product description. The AI model will analyze the text and return a structured object containing the product name, summary, price, and category.

```typescript title="amplify/data/resource.ts"
const schema = a.schema({
  ProductDetails: a.customType({
    name: a.string().required(),
    summary: a.string().required(),
    price: a.float().required(),
    category: a.string().required(),
  }),

  extractProductDetails: a.generation({
    aiModel: a.ai.model('Claude 3.5 Haiku'),
    systemPrompt: 'Extract the property details from the text provided',
  })
    .arguments({
      productDescription: a.string()
    })
    .returns(a.ref('ProductDetails'))
    .authorization((allow) => allow.authenticated()),
});
```

<InlineFilter filters={["javascript","angular","vue"]}>
```ts title="Data Client Request"
import type { Schema } from "../amplify/data/resource";
import { generateClient } from "aws-amplify/api";

export const client = generateClient<Schema>();

const productDescription = `The NBA Official Game Basketball is a premium
regulation-size basketball crafted with genuine leather and featuring
official NBA specifications. This professional-grade ball offers superior grip
and durability, with deep channels and a moisture-wicking surface that ensures
consistent performance during intense game play. Priced at $159.99, this high-end
basketball belongs in our Professional Sports Equipment category and is the same model
used in NBA games.`

const { data, errors } = await client.generations
  .extractProductDetails({ productDescription })

/**
Example response:
{
  "name": "NBA Official Game Basketball",
  "summary": "Premium regulation-size NBA basketball made with genuine leather. Features official NBA specifications, superior grip, deep channels, and moisture-wicking surface for consistent game play performance.",
  "price": 159.99,
  "category": "Professional Sports Equipment"
}
*/
```
</InlineFilter>


<InlineFilter filters={['react','react-native','nextjs']}>

```ts title="src/components/Example.tsx"
import type { Schema } from "../amplify/data/resource";
import { generateClient } from "aws-amplify/api";
import { createAIHooks } from "@aws-amplify/ui-react-ai";

const client = generateClient<Schema>({ authMode: "userPool" });
const { useAIGeneration } = createAIHooks(client);

export default function Example() {
  const productDescription = `The NBA Official Game Basketball is a premium
  regulation-size basketball crafted with genuine leather and featuring
  official NBA specifications. This professional-grade ball offers superior grip
  and durability, with deep channels and a moisture-wicking surface that ensures
  consistent performance during intense game play. Priced at $159.99, this high-end
  basketball belongs in our Professional Sports Equipment category and is the same model
  used in NBA games.`

  // data is React state and will be populated when the generation is returned
  const [{ data, isLoading }, extractProductDetails] =
    useAIGeneration("extractProductDetails");

  const productDetails = async () => {
    extractProductDetails({
      productDescription
    });
  };
}
```
</InlineFilter>


Contents of ai_generation_index.txt:
import { getCustomStaticPath } from "@/utils/getCustomStaticPath";

export const meta = {
  title: "Generation",
  description:
    "Learn how to use AI to generate data for your application.",
  platforms: [
    "javascript",
    "react-native",
    "angular",
    "nextjs",
    "react",
    "vue",
  ],
};

export const getStaticPaths = async () => {
  return getCustomStaticPath(meta.platforms);
};

export function getStaticProps(context) {
  return {
    props: {
      platform: context.params.platform,
      meta,
    },
  };
}




AI generation routes are a request-response API used to generate structured output from AI models. Examples of generation routes include:
- generated structured data from unstructured input
- summarization

Under the hood, a generation route is an AWS AppSync query that ensures the AI model responds with the response type defined for the route.

## Generate Typed Objects

```ts title="Schema Definition"
const schema = a.schema({
  generateRecipe: a.generation({
    aiModel: a.ai.model('Claude 3.5 Haiku'),
    systemPrompt: 'You are a helpful assistant that generates recipes.',
  })
    .arguments({ description: a.string() })
    .returns(
      a.customType({
        name: a.string(),
        ingredients: a.string().array(),
        instructions: a.string(),
      })
    )
    .authorization((allow) => allow.authenticated())
});
```

<InlineFilter filters={["javascript","angular","vue"]}>

```ts title="Data Client Request"
const description = 'I would like to bake a birthday cake for my friend. She has celiac disease and loves chocolate.'
const { data, errors } = await client.generations
  .generateRecipe({ description })

/**
Example response:
{
  "name": "Gluten-Free Chocolate Birthday Cake",
  "ingredients": [
    "gluten-free all-purpose flour",
    "cocoa powder",
    "granulated sugar",
    "baking powder",
    "baking soda",
    "salt",
    "eggs",
    "milk",
    "vegetable oil",
    "vanilla extract"
  ],
  "instructions": "1. Preheat oven to 350°F. Grease and flour two 9-inch round baking pans.\n2. In a medium bowl, whisk together the gluten-free flour, cocoa powder, sugar, baking powder, baking soda and salt.\n3. In a separate bowl, beat the eggs. Then add the milk, oil and vanilla and mix well.\n4. Gradually add the wet ingredients to the dry ingredients and mix until just combined. Do not over mix.\n5. Divide the batter evenly between the prepared pans.\n6. Bake for 30-35 minutes, until a toothpick inserted in the center comes out clean.\n7. Allow cakes to cool in pans for 10 minutes, then transfer to a wire rack to cool completely.\n8. Frost with your favorite gluten-free chocolate frosting."
}
*/
```

</InlineFilter>

<InlineFilter filters={['react','react-native','next-js']}>

```tsx
import { generateClient } from "aws-amplify/api";
import { createAIHooks } from "@aws-amplify/ui-react-ai";
import { Schema } from "../amplify/data/resource";

const client = generateClient<Schema>({ authMode: "userPool" });
const { useAIGeneration } = createAIHooks(client);

export default function Example() {
  // data is React state and will be populated when the generation is returned
  const [{ data, isLoading }, generateRecipe] =
    useAIGeneration("generateRecipe");

  const generateSummary = async () => {
    generateRecipe({
      description: 'I would like to bake a birthday cake for my friend. She has celiac disease and loves chocolate.',
    });
  };
}
```

</InlineFilter>


## Generate Scalar Types

```ts title="Schema Definition"
const schema = ({
  summarize: a.generation({
    aiModel: a.ai.model('Claude 3.5 Haiku'),
    systemPrompt: 'Provide an accurate, clear, and concise summary of the input provided'
  })
  .arguments({ input: a.string() })
  .returns(a.string())
  .authorization((allow) => allow.guest()),
});
```

```ts title="Data Client Request"
const { data: summary, errors } = await client.generations
  .summarize({ input })
```

## Setting Inference Parameters

You can influence response generation by setting inference parameters for the AI model.
This ability to control the randomness and diversity of responses is useful for generating responses that are tailored to your needs.

[More information about inference parameters](/[platform]/ai/concepts/inference-configuration).

```ts title="Inference Parameters"
const schema = a.schema({
  generateHaiku: a.generation({
    aiModel: a.ai.model('Claude 3.5 Haiku'),
    systemPrompt: 'You are a helpful assistant that generates haikus.',
    // highlight-start
    inferenceConfiguration: {
      maxTokens: 1000,
      temperature: 0.5,
      topP: 0.9,
    }
    // highlight-end
  }),
});
```

## Limitations

### 1. Generation routes do not support referencing models

For example, the following schema defines a `Recipe` model, but this model cannot be used as the return type of a generation route.

```ts title="Invalid Model Reference"
const schema = a.schema({
  Recipe: a.model({
    name: a.string(),
    ingredients: a.string().array(),
    instructions: a.string(),
  }),
  generateRecipe: a.generation({
    aiModel: a.ai.model('Claude 3.5 Haiku'),
    systemPrompt: 'You are a helpful assistant that generates recipes.',
  })
    .arguments({ description: a.string() })
    .returns(a.ref('Recipe')) // ❌ Invalid
    .authorization((allow) => allow.authenticated()),
});
```

You can, however, reference custom types. Here's an example of a custom type that can be used as the return type of a generation route.

```ts title="Valid Custom Type Reference"
const schema = a.schema({
  Recipe: a.customType({
    name: a.string(),
    ingredients: a.string().array(),
    instructions: a.string(),
  }),
  generateRecipe: a.generation({
    aiModel: a.ai.model('Claude 3.5 Haiku'),
    systemPrompt: 'You are a helpful assistant that generates recipes.',
  })
    .arguments({ description: a.string() })
    .returns(a.ref('Recipe')) // ✅ Valid
    .authorization((allow) => allow.authenticated()),
});
```

### 2. Generation routes do not support some required types.

The following AppSync scalar types are not supported as **required** fields in response types:
- `AWSEmail`
- `AWSDate`
- `AWSTime`
- `AWSDateTime`
- `AWSTimestamp`
- `AWSPhone`
- `AWSURL`
- `AWSIPAddress`

```ts title="Unsupported Required Type"
const schema = a.schema({
  generateUser: a.generation({
    aiModel: a.ai.model('Claude 3.5 Haiku'),
    systemPrompt: 'You are a helpful assistant that generates users.',
  })
    .arguments({ description: a.string() })
    .returns(
      a.customType({
        name: a.string(),
        email: a.email().required(), // ❌ Required field with unsupported type
        dateOfBirth: a.date().required(), // ❌ Required field with unsupported type
      })
    )
    .authorization((allow) => allow.authenticated()),
});



Contents of ai_index.txt:
import { getChildPageNodes } from '@/utils/getChildPageNodes';
import { getCustomStaticPath } from '@/utils/getCustomStaticPath';

export const meta = {
  title: 'AI kit',
  description: 'The quickest way for fullstack developers to build web apps with AI capabilities such as chat, conversational search, and summarization',
  isNew: true,
  route: '/[platform]/ai',
  platforms: [
    'angular',
    'javascript',
    'nextjs',
    'react',
    'react-native',
    'vue'
  ]
};

export const getStaticPaths = async () => {
  return getCustomStaticPath(meta.platforms);
};

export function getStaticProps(context) {
  const childPageNodes = getChildPageNodes(meta.route);
  return {
    props: {
      meta,
      childPageNodes
    }
  };
}

<Overview childPageNodes={props.childPageNodes} />


Contents of ai_set-up-ai_index.txt:
import { getCustomStaticPath } from "@/utils/getCustomStaticPath";

export const meta = {
  title: "Set up AI",
  description:
    "Learn how to set up and connect your backend for generative AI with Amplify.",
  platforms: [
    "javascript",
    "react-native",
    "angular",
    "nextjs",
    "react",
    "vue",
  ],
};

export const getStaticPaths = async () => {
  return getCustomStaticPath(meta.platforms);
};

export function getStaticProps(context) {
  return {
    props: {
      platform: context.params.platform,
      meta,
      showBreadcrumbs: false,
    },
  };
}


In this guide, you will learn how to get stared with the Amplify AI kit. This includes defining your AI backend with Conversation and Generation routes, and securely connecting to them from your frontend application.

<Callout>

[An easy way to get started is with one of our samples](https://github.com/aws-samples/amplify-ai-examples)

</Callout>

## Prerequisites

Before you begin, you will need:

- [Node.js](https://nodejs.org/) v18.16.0 or later
- [npm](https://www.npmjs.com/) v6.14.4 or later
- [git](https://git-scm.com/) v2.14.1 or later

You will also need an AWS account that is [setup for local development](/[platform]/start/account-setup) and has access to the Bedrock Foundation Model(s) you want to use. You can request access to Bedrock models by going in to the [Bedrock console and requesting access](https://console.aws.amazon.com/bedrock/home#/modelaccess).

<Callout>

Running inference on large language models (LLMs) can be costly. Amazon Bedrock is a serverless service so you only pay for what you use, but be mindful of the costs associated with building generative AI applications. [See Bedrock pricing for more information](https://aws.amazon.com/bedrock/pricing/).

</Callout>

## Create an Amplify backend

Run the create amplify script in your project directory:

```bash title="Terminal"
npm create amplify@latest
```

Then run the [Amplify sandbox](/[platform]/deploy-and-host/sandbox-environments/setup/) to start your local cloud sandbox:

```bash title="Terminal"
npx ampx sandbox
```

This will provision the cloud resources you define in your amplify folder and watch for updates and redeploy them. 


## Build your AI backend

To build an AI backend, you define AI 'routes' in your Amplify Data schema. An AI route is like an API endpoint for interacting with backend AI functionality. There are currently 2 types of routes:

* **Conversation:** A conversation route is a streaming, multi-turn API. Conversations and messages are automatically stored in DynamoDB so users can resume conversations. Examples of this are any chat-based AI experience or conversational UI.
* **Generation:** A single synchronous request-response API. A generation route is just an AppSync Query. Examples of this are: generating alt text for an image, generating structured data from unstructured input, summarization, etc.

To define AI routes, open your **amplify/data/resource.ts** file and use `a.generation()` and `a.conversation()` in your schema.

```ts title="amplify/data/resources.ts"
import { a, defineData, type ClientSchema } from '@aws-amplify/backend';

const schema = a.schema({
  // This will add a new conversation route to your Amplify Data backend.
  // highlight-start
  chat: a.conversation({
    aiModel: a.ai.model('Claude 3.5 Haiku'),
    systemPrompt: 'You are a helpful assistant',
  })
  .authorization((allow) => allow.owner()),
  // highlight-end

  // This adds a new generation route to your Amplify Data backend.
  // highlight-start
  generateRecipe: a.generation({
    aiModel: a.ai.model('Claude 3.5 Haiku'),
    systemPrompt: 'You are a helpful assistant that generates recipes.',
  })
  .arguments({
    description: a.string(),
  })
  .returns(
    a.customType({
      name: a.string(),
      ingredients: a.string().array(),
      instructions: a.string(),
    })
  )
  .authorization((allow) => allow.authenticated()),
  // highlight-end
});
```

<Callout>

Conversation routes currently ONLY support owner-based authorization and generation routes ONLY support non-owner-based authorization (`authenticated`, `guest`, `group`, `publicApiKey`).

</Callout>

If you have the Amplify sandbox running, when you save this file it will pick up the changes and redeploy the necessary resources for you. 

## Connect your frontend

Once the cloud sandbox is up and running, it will also create an `amplify_outputs.json` file, which includes relevant connection information to your AI routes and other Amplify configuration.

To connect your frontend code to your backend, you need to:

1. Configure the Amplify library with the Amplify client configuration file (`amplify_outputs.json`).
2. Generate a new API client from the Amplify library.
3. Make an API request with end-to-end type-safety.

### Install the client libraries

Install the Amplify client library to your project:

<InlineFilter filters={["react","nextjs","react-native"]}>

```bash title="Terminal"
npm add aws-amplify @aws-amplify/ui-react @aws-amplify/ui-react-ai
```

</InlineFilter>

<InlineFilter filters={["javascript","vue","angular"]}>

```bash title="Terminal"
npm add aws-amplify
```

</InlineFilter>


### Configure the libraries

<InlineFilter filters={["vue"]}>

Call `Amplify.configure()` with the **amplify_outputs.json** file in your **main.ts** file.

```ts title="src/main.ts"
import "./assets/main.css";
import { createApp } from "vue";
import App from "./App.vue";
import { Amplify } from "aws-amplify";
import outputs from "../amplify_outputs.json";

Amplify.configure(outputs);

createApp(App).mount("#app");
```

</InlineFilter>

<InlineFilter filters={["angular"]}>

Call `Amplify.configure()` with the **amplify_outputs.json** file in your main app component:

```ts
import { Amplify } from 'aws-amplify';
import outputs from '../../amplify_outputs.json';

Amplify.configure(outputs);
```

</InlineFilter>


<InlineFilter filters={["react","react-native"]}>

Call `Amplify.configure()` with the **amplify_outputs.json** file where the React application is mounted.

```tsx title="src/main.tsx"
import { Amplify } from 'aws-amplify';
import '@aws-amplify/ui-react/styles.css';
import outputs from '../amplify_outputs.json';

Amplify.configure(outputs);
```

</InlineFilter>


<InlineFilter filters={["nextjs"]}>

<BlockSwitcher>

<Block name="Pages router">

```tsx title="pages/_app.tsx"
import "@/styles/app.css";
import type { AppProps } from "next/app";
import { Amplify } from "aws-amplify";
import outputs from "@/amplify_outputs.json";
import "@aws-amplify/ui-react/styles.css";

Amplify.configure(outputs);

export default function App({ Component, pageProps }: AppProps) {
  return <Component {...pageProps} />;
}
```

</Block>

<Block name="App router">

Create a client component that will configure Amplify:

```tsx title="app/ConfigureAmplify.tsx"
"use client";

import { Amplify } from "aws-amplify";
import config from "@/../amplify_outputs.json";
import "@aws-amplify/ui-react/styles.css";

Amplify.configure(config);

export const ConfigureAmplify = () => {
  return null;
};
```

Then render that component in the root layout:

```tsx title="app/layout.tsx"
import { ConfigureAmplify } from "./ConfigureAmplify";

export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  return (
    <html lang="en">
      <body>
        <ConfigureAmplify />
        {children}
      </body>
    </html>
  );
}

```

</Block>
</BlockSwitcher>

</InlineFilter>

### Generate the data client

Next, generate a type-safe frontend client to talk to our backend using our backend data schema and the `generateClient()` function provided by the Amplify libraries.

<InlineFilter filters={["javascript","vue","angular"]}>

```ts
import { generateClient } from "aws-amplify/api";
import { Schema } from "../amplify/data/resource";

export const client = generateClient<Schema>({ authMode: "userPool" });
```

</InlineFilter>

<InlineFilter filters={["react","nextjs","react-native"]}>

It can be helpful to create a `client.ts/js` file that exports the generated Amplify data client as well as the generated React hooks.

<BlockSwitcher>

<Block name="TypeScript">

```ts title="src/client.ts"
import { generateClient } from "aws-amplify/api";
import { Schema } from "../amplify/data/resource";
import { createAIHooks } from "@aws-amplify/ui-react-ai";

export const client = generateClient<Schema>({ authMode: "userPool" });
export const { useAIConversation, useAIGeneration } = createAIHooks(client);
```

</Block>

<Block name="JavaScript">

```ts title="src/client.js"
import { generateClient } from "aws-amplify/api";
import { Schema } from "../amplify/data/resource";
import { createAIHooks } from "@aws-amplify/ui-react-ai";

/**
 * @type {import('aws-amplify/data').Client<import('../amplify/data/resource').Schema>}
 */
export const client = generateClient({ authMode: "userPool" });
export const { useAIConversation, useAIGeneration } = createAIHooks(client);
```

</Block>
</BlockSwitcher>

</InlineFilter>



### Use a generation

<InlineFilter filters={["react"]}>

```tsx title="src/App.tsx"
import * as React from 'react';
import { Flex, TextAreaField, Loader, Text, View, Button } from "@aws-amplify/ui-react"
import { useAIGeneration } from "./client";

export default function App() {
  const [description, setDescription] = React.useState("");
  const [{ data, isLoading }, generateRecipe] =
    useAIGeneration("generateRecipe");

  const handleClick = async () => {
    generateRecipe({ description });
  };

  return (
    <Flex direction="column">
      <Flex direction="row">
        <TextAreaField
          autoResize
          value={description}
          onChange={(e) => setDescription(e.target.value)}
          label="Description"
        />
        <Button onClick={handleClick}>Generate recipe</Button>
      </Flex>
      {isLoading ? (
        <Loader variation="linear" />
      ) : (
        <>
          <Text fontWeight="bold">{data?.name}</Text>
          <View as="ul">
            {data?.ingredients?.map((ingredient) => (
              <View as="li" key={ingredient}>
                {ingredient}
              </View>
            ))}
          </View>
          <Text>{data?.instructions}</Text>
        </>
      )}
    </Flex>
  );
}
```

</InlineFilter>

<InlineFilter filters={["nextjs"]}>

<BlockSwitcher>

<Block name="Pages router">

```tsx title="pages/index.tsx"
import { useAIGeneration } from "@/client";
import {
  Button,
  Flex,
  Heading,
  Loader,
  Text,
  TextAreaField,
  View,
} from "@aws-amplify/ui-react";
import React from "react";

export default function Page() {
  const [description, setDescription] = React.useState("");
  const [{ data, isLoading, hasError }, generateRecipe] =
    useAIGeneration("generateRecipe");

  const handleClick = async () => {
    generateRecipe({ description });
  };

  return (
    <Flex direction="column">
      <Flex direction="row">
        <TextAreaField
          autoResize
          value={description}
          onChange={(e) => setDescription(e.target.value)}
          label="Description"
        />
        <Button onClick={handleClick}>Generate recipe</Button>
      </Flex>
      {isLoading ? (
        <Loader variation="linear" />
      ) : (
        <>
          <Text fontWeight="bold">{data?.name}</Text>
          <View as="ul">
            {data?.ingredients?.map((ingredient) => (
              <View as="li" key={ingredient}>
                {ingredient}
              </View>
            ))}
          </View>
          <Text>{data?.instructions}</Text>
        </>
      )}
    </Flex>
  );
}
```

</Block>

<Block name="App router">

```tsx title="app/page.tsx"
"use client";
import { useAIGeneration } from "@/client";
import {
  Button,
  Flex,
  Heading,
  Loader,
  Text,
  TextAreaField,
  View,
} from "@aws-amplify/ui-react";
import React from "react";

export default function Page() {
  const [description, setDescription] = React.useState("");
  const [{ data, isLoading, hasError }, generateRecipe] =
    useAIGeneration("generateRecipe");

  const handleClick = () => {
    generateRecipe({ description });
  };

  return (
    <Flex direction="column">
      <Flex direction="row">
        <TextAreaField
          autoResize
          value={description}
          onChange={(e) => setDescription(e.target.value)}
          label="Description"
        />
        <Button onClick={handleClick}>Generate recipe</Button>
      </Flex>
      {isLoading ? (
        <Loader variation="linear" />
      ) : (
        <>
          <Heading level={2}>{data?.name}</Heading>
          <View as="ul">
            {data?.ingredients?.map((ingredient) => (
              <Text as="li" key={ingredient}>
                {ingredient}
              </Text>
            ))}
          </View>
          <Text>{data?.instructions}</Text>
        </>
      )}
    </Flex>
  );
}
```

</Block>

</BlockSwitcher>

</InlineFilter>


<InlineFilter filters={["react-native"]}>

```tsx
import React, { useState, useEffect } from "react";
import {
  View,
  Text,
  StyleSheet,
  TextInput,
  FlatList,
  TouchableOpacity,
  ActivityIndicator,
} from "react-native";
import { useAIGeneration } from './client';

export default function Screen() {
  const [description, setDescription] = React.useState("");
  const [{ data, isLoading, hasError }, generateRecipe] =
    useAIGeneration("generateRecipe");

  const handleClick = () => {
    generateRecipe({ description });
  };

  return (
    <View>
        <TextInput
          autoResize
          value={description}
          onChange={(e) => setDescription(e.target.value)}
          label="Description"
        />
        <Button onClick={handleClick}>Generate recipe</Button>
      {isLoading ? (
        <Loader variation="linear" />
      ) : (
        <>
          <Heading level={2}>{data?.name}</Heading>
          <View as="ul">
            {data?.ingredients?.map((ingredient) => (
              <Text as="li" key={ingredient}>
                {ingredient}
              </Text>
            ))}
          </View>
          <Text>{data?.instructions}</Text>
        </>
      )}
    </Flex>
  );
}
```

</InlineFilter>


<InlineFilter filters={["javascript","vue","angular"]}>

```ts
import { client } from './client';

const { data } = await client.generations.generateRecipe({
  description: 'A gluten free chocolate cake'
});
```

</InlineFilter>



### Use a conversation

AI conversations are scoped to a user, so your users will need to be logged in with Amplify auth. The easiest way to do this is with the Authenticator component.

<InlineFilter filters={["react"]}>

```tsx title="src/App.tsx"
import { Authenticator } from "@aws-amplify/ui-react";
import { AIConversation } from '@aws-amplify/ui-react-ai';
import { useAIConversation } from './client';

export default function App() {
  const [
    {
      data: { messages },
      isLoading,
    },
    handleSendMessage,
  ] = useAIConversation('chat');
  // 'chat' is based on the key for the conversation route in your schema.

  return (
    <Authenticator>
      <AIConversation
        messages={messages}
        isLoading={isLoading}
        handleSendMessage={handleSendMessage}
      />
    </Authenticator>
  );
}
```

</InlineFilter>



<InlineFilter filters={["nextjs"]}>

<BlockSwitcher>

<Block name="Pages router">

```tsx title="pages/index.tsx"
import { Authenticator } from "@aws-amplify/ui-react";
import { AIConversation } from '@aws-amplify/ui-react-ai';
import { useAIConversation } from "@/client";

export default function Page() {
  const [
    {
      data: { messages },
      isLoading,
    },
    handleSendMessage,
  ] = useAIConversation('chat');
  // 'chat' is based on the key for the conversation route in your schema.

  return (
    <Authenticator>
      <AIConversation
        messages={messages}
        isLoading={isLoading}
        handleSendMessage={handleSendMessage}
      />
    </Authenticator>
  );
}
```
</Block>

<Block name="App router">

```tsx title="app/page.tsx"
'use client'
import { Authenticator } from "@aws-amplify/ui-react";
import { AIConversation } from '@aws-amplify/ui-react-ai';
import { useAIConversation } from "@/client";

export default function Page() {
  const [
    {
      data: { messages },
      isLoading,
    },
    handleSendMessage,
  ] = useAIConversation('chat');
  // 'chat' is based on the key for the conversation route in your schema.

  return (
    <Authenticator>
      <AIConversation
        messages={messages}
        isLoading={isLoading}
        handleSendMessage={handleSendMessage}
      />
    </Authenticator>
  );
}
```

</Block>
</BlockSwitcher>

</InlineFilter>


<InlineFilter filters={["javascript","vue","angular"]}>

```ts
const { data: conversation } = await client.conversations.chat.create();

// Assistant messages come back as websocket events
// over a subscription
conversation.onStreamEvent({
  next: (event) => {
    console.log(event);
  },
  error: (error) => {
    console.log(error);
  }
});

// When sending user messages you only need to send
// the latest message, the conversation history
// is stored in DynamoDB and retrieved in Lambda
conversation.sendMessage({
  content: [{ text: "hello" }],
})
```

</InlineFilter>




Contents of build-a-backend_[category]_reference_index.txt:
import { getApiStaticPath } from '@/utils/getApiStaticPath';

export const meta = {
  title: 'API Reference',
  description: 'API Reference'
};

export const getStaticPaths = async () => {
  return getApiStaticPath();
};

export function getStaticProps(context) {
  return {
    props: {
      platform: context.params.platform,
      category: context.params.category,
      showBreadcrumbs: false,
      meta
    }
  };
}

<ReferencePage category={props.category} />


Contents of build-a-backend_add-aws-services_[category]_reference_index.txt:
import { getApiStaticPath } from '@/utils/getApiStaticPath';

export const meta = {
  title: 'API Reference',
  description: 'API Reference'
};

export const getStaticPaths = async () => {
  return getApiStaticPath(true);
};

export function getStaticProps(context) {
  return {
    props: {
      platform: context.params.platform,
      category: context.params.category,
      showBreadcrumbs: false,
      meta
    }
  };
}

<ReferencePage category={props.category} />


Contents of build-a-backend_add-aws-services_analytics_app-uninstall_index.txt:
import { getCustomStaticPath } from '@/utils/getCustomStaticPath';

export const meta = {
  title: 'Uninstalling the app',
  description:
    'Understand how to handle persistent data on a device when a user uninstalls the app.',
  platforms: ['swift', 'android'],
};

export const getStaticPaths = async () => {
  return getCustomStaticPath(meta.platforms);
};

export function getStaticProps(context) {
  return {
    props: {
      platform: context.params.platform,
      meta
    }
  };
}

<InlineFilter filters={['android']}>
Some Amplify categories such as Analytics and Auth persist data to the local device. This application data is removed when a user uninstalls the application from the device.

If the [Android Auto Backup for Apps](https://developer.android.com/guide/topics/data/autobackup) service is enabled, this service will attempt to restore application data.

Amplify Auth uses [EncryptedSharedPreferences](https://developer.android.com/reference/androidx/security/crypto/EncryptedSharedPreferences) when persisting auth data. When an application is uninstalled, the [Android Keystore](https://developer.android.com/training/articles/keystore) keys used to create our EncryptedSharedPreferences files are deleted. Upon an application reinstall, these restored files are no longer readable due to the key removal from the Android Keystore.

Due to this limitation with EncryptedSharedPreferences, Auth information can’t be restored on an application reinstall. The user will have to re-authenticate.
</InlineFilter>

<InlineFilter filters={['swift']}>
Some Amplify categories such as Analytics, Auth, and DataStore persist data to the local device. Some of that data is automatically removed when a user uninstalls the app from the device.

Amplify stores Auth information in the local [system keychain](https://developer.apple.com/documentation/security/keychain_services), which does not guarantee any particular behavior around whether data is removed when an app is uninstalled.

Deciding on when to clear this auth information is not something that the SDK can do in a generic way, so App developers should decide when to clear the data by signing out. One strategy for accomplishing this would be to use [UserDefaults](https://developer.apple.com/documentation/foundation/userdefaults) to detect whether or not the app is launching for the first time, and invoking [`Auth.signOut()`](/[platform]/build-a-backend/auth/connect-your-frontend/sign-out) if the app has not been launched before.
</InlineFilter>


Contents of build-a-backend_add-aws-services_analytics_auto-track-sessions_index.txt:
import { getCustomStaticPath } from '@/utils/getCustomStaticPath';

export const meta = {
  title: 'Automatically track sessions',
  description: 'The Amplify analytics plugin records when an application opens and closes. This session information can be viewed either from your local computer’s terminal or the AWS Console for Pinpoint.',
  platforms: [
    'javascript',
    'react-native',
    'swift',
    'android',
    'flutter',
    'angular',
    'nextjs',
    'react',
    'vue'
  ],
};

export const getStaticPaths = async () => {
  return getCustomStaticPath(meta.platforms);
};

export function getStaticProps(context) {
  return {
    props: {
      platform: context.params.platform,
      meta
    }
  };
}


<InlineFilter filters={['javascript', "angular", "react", "vue", "react-native", "nextjs"]}>
Analytics auto tracking helps you to automatically track user behaviors like sessions' start/stop, page view change and web events like clicking or mouseover.

## Session Tracking

You can track the session both in a web app or a React Native app by using Analytics. A web session can be defined in different ways. To keep it simple, we define a web session as being active when the page is not hidden and inactive when the page is hidden. A session in a React Native app is active when the app is in the foreground and inactive when the app is in the background.

For example:

```javascript title="src/index.js"
import { configureAutoTrack } from 'aws-amplify/analytics';

configureAutoTrack({
  // REQUIRED, turn on/off the auto tracking
  enable: true,
  // REQUIRED, the event type, it's one of 'event', 'pageView' or 'session'
  type: 'session',
  // OPTIONAL, additional options for the tracked event.
  options: {
    // OPTIONAL, the attributes of the event
    attributes: {
      customizableField: 'attr'
    }
  }
});
```

By default, when the page/app transitions to the foreground, the Analytics module will send an event to the Amazon Pinpoint Service.

```json
{
  "eventType": "_session_start",
  "attributes": {
    "customizableField": "attr"
  }
}
```

This behavior can be disabled by calling `configureAutoTrack`:

```javascript title="src/index.js"
import { configureAutoTrack } from 'aws-amplify/analytics';

configureAutoTrack({
  enable: false,
  type: 'session'
});
```

## Page View Tracking

Use this feature to track the most frequently viewed page/url in your webapp. It automatically sends events containing url information when a page is visited.

This behavior can be enabled by calling `configureAutoTrack`:
```javascript title="src/index.js"
import { configureAutoTrack } from 'aws-amplify/analytics';

configureAutoTrack({
  // REQUIRED, turn on/off the auto tracking
  enable: true,
  // REQUIRED, the event type, it's one of 'event', 'pageView' or 'session'
  type: 'pageView',
  // OPTIONAL, additional options for the tracked event.
  options: {
    // OPTIONAL, the attributes of the event
    attributes: {
      customizableField: 'attr'
    },

    // OPTIONAL, the event name. By default, this is 'pageView'
    eventName: 'pageView',

    // OPTIONAL, the type of app under tracking. By default, this is 'multiPageApp'.
    // You will need to change it to 'singlePage' if your app is a single-page app like React
    appType: 'multiPageApp',

    // OPTIONAL, provide the URL for the event.
    urlProvider:  () => {
      // the default function
      return window.location.origin + window.location.pathname;
    }
  }
});
```

This behavior can be disabled by calling `configureAutoTrack`:
```javascript title="src/index.js"
import { configureAutoTrack } from 'aws-amplify/analytics';

configureAutoTrack({
  enable: false,
  type: 'pageView'
});
```

## Page Event Tracking

Use page event tracking to track user interactions with specific elements on a page. Attach the specified selectors to your DOM element and turn on the auto tracking.

This behavior can be enabled by calling `configureAutoTrack`:
```javascript title="src/index.js"
import { configureAutoTrack } from 'aws-amplify/analytics';

configureAutoTrack({
  // REQUIRED, turn on/off the auto tracking
  enable: true,
  // REQUIRED, the event type, it's one of 'event', 'pageView' or 'session'
  type: 'event',
  // OPTIONAL, additional options for the tracked event.
  options: {
    // OPTIONAL, the attributes of the event
    attributes: {
      customizableField: 'attr'
    },
    // OPTIONAL, events you want to track. By default, this is 'click'
    events: ['click'],

    // OPTIONAL, the prefix of the selectors. By default, this is 'data-amplify-analytics-'
    // Per https://www.w3schools.com/tags/att_global_data.asp, always start
    // the prefix with 'data' to avoid collisions with the user agent
    selectorPrefix: 'data-amplify-analytics-'
  }
});
```

For example:

```html
<!-- you want to track this button and send an event when it is clicked -->
<button
  data-amplify-analytics-on="click"
  data-amplify-analytics-name="click"
  data-amplify-analytics-attrs="attr1:attr1_value,attr2:attr2_value"
/>
```

When the button above is clicked, an event will be sent automatically. This is equivalent to doing:

```html
<script>
  import { record } from 'aws-amplify/analytics';
  var sendEvent = function() {
    record({
      name: 'click',
      attributes: {
        attr: 'attr', // the default ones
        attr1: attr1_value, // defined in the button component
        attr2: attr2_value // defined in the button component
      }
    });
  };
</script>
<button onclick="sendEvent()" />
```

This behavior can be disabled by calling `configureAutoTrack`:
```javascript title="src/index.js"
import { configureAutoTrack } from 'aws-amplify/analytics';

configureAutoTrack({
  enable: false,
  type: 'event'
});
```

<Callout>

**Note:** Amplify doesn't capture location automatically. Instead, you can add the location information in the default config when you [configure Analytics](/[platform]/build-a-backend/add-aws-services/analytics/set-up-analytics/#set-up-existing-analytics-backend) or while [updating the end point](/[platform]/build-a-backend/add-aws-services/analytics/existing-resources).

</Callout>
</InlineFilter>

<InlineFilter filters={["swift", "android", "flutter"]}>
The Amplify analytics plugin records when an application opens and closes. This session information can be viewed either from the AWS Console for Amazon Pinpoint.

1. In the Amazon Pinpoint Console under **Analytics**, choose **Events**. 
2. Enable filters, you can select `Session Start` and `Session Stop` events to filter on session events.
</InlineFilter>


Contents of build-a-backend_add-aws-services_analytics_data-usage-policy_index.txt:
import { getCustomStaticPath } from '@/utils/getCustomStaticPath';

export const meta = {
  title: 'Data usage policy information',
  description: "Review the data types gathered by the Amplify library that Apple requires you to disclose in your app's data usage policy when submitting the app to the App Store.",
  platforms: ['swift'],
};

export const getStaticPaths = async () => {
  return getCustomStaticPath(meta.platforms);
};

export function getStaticProps(context) {
  return {
    props: {
      platform: context.params.platform,
      meta
    }
  };
}

<InlineFilter filters={['swift']}>
Apple requires app developers to provide the data usage policy of the app when they submit their app to the App Store. See Apple's [User privacy and data use](https://developer.apple.com/app-store/user-privacy-and-data-use/) for more details. The Amplify Library is used to interact with AWS resources under the developer’s ownership and management. The library cannot predict the usage of its APIs and it is up to the developer to provide the privacy manifest that accurately reflects the data collected by the app. Below are the different categories identified by Apple and the corresponding data type used by the Amplify Library.

By utilizing the library, Amplify gathers API usage metrics from the AWS services accessed. This process involves adding a user agent to the request made to your AWS service. The user-agent header is included with information about the Amplify Library version, operating system name, and version. AWS collects this data to generate metrics related to our library usage. This information is not linked to the user’s identity and not used for tracking purposes as described in Apple's privacy and data use guidelines.

Should you have any specific concerns or require additional information for the enhancement of your privacy manifest, please don't hesitate to reach out.

## Contact info

| Data Type                        | Amplify Category   | Purpose             | Linked To Identity   | Tracking   | Provided by developer   |
| ------------------------------   | ------------------ | ------------------- | :------------------: | :--------: | :---------------------: |
| **Name**                         |                    |                     |                      |            |                         |
|                                  | Auth               | App Functionality   | ✅                   | ❌        | ✅                      |
| **Email Address**                |                    |                     |                      |            |                         |
|                                  | Auth               | App Functionality   | ✅                   | ❌        | ✅                      |
| **Phone Number**                 |                    |                     |                      |            |                         |
|                                  | Auth               | App Functionality   | ✅                   | ❌        | ✅                      |

## User Content

| Data Type                        | Amplify Category   | Purpose             | Linked To Identity   | Tracking   | Provided by developer   |
| ------------------------------   | ------------------ | ------------------- | :------------------: | :--------: | :---------------------: |
| **Photos or Videos**             |                    |                     |                      |            |                         |
|                                  | Storage            | App Functionality   | ❌                   | ❌        | ✅                      |
|                                  | Predictions        | App Functionality   | ❌                   | ❌        | ✅                      |
| **Audio Data**                   |                    |                     |                      |            |                         |
|                                  | Predictions        | App Functionality   | ❌                   | ❌        | ✅                      |

## Identifiers

| Data Type                        | Amplify Category   | Purpose             | Linked To Identity   | Tracking   | Provided by developer   |
| ------------------------------   | ------------------ | ------------------- | :------------------: | :--------: | :---------------------: |
| **User ID**                      |                    |                     |                      |            |                         |
|                                  | Auth               | App Functionality   | ✅                   | ❌        | ❌                      |
|                                  | Analytics          | Analytics           | ✅                   | ❌        | ❌                      |
| **Device ID**                    |                    |                     |                      |            |                         |
|                                  | Auth               | App Functionality   | ✅                   | ❌        | ❌                      |
|                                  | Analytics          | Analytics           | ✅                   | ❌        | ❌                      |

## Other Data

| Data Type                        | Amplify Category   | Purpose             | Linked To Identity   | Tracking   | Provided by developer   |
| ------------------------------   | ------------------ | ------------------- | :------------------: | :--------: | :---------------------: |
| **OS Version**                   |                    |                     |                      |            |                         |
|                                  | All categories     | Analytics           | ❌                   | ❌        | ❌                      |
| **OS Name**                      |                    |                     |                      |            |                         |
|                                  | All categories     | Analytics           | ❌                   | ❌        | ❌                      |
| **Locale Info**                  |                    |                     |                      |            |                         |
|                                  | All categories     | Analytics           | ❌                   | ❌        | ❌                      |
| **App Version**                  |                    |                     |                      |            |                         |
|                                  | Auth               | App Functionality   | ✅                   | ❌        | ❌                      |
| **Min OS target of the app**     |                    |                     |                      |            |                         |
|                                  | Auth               | App Functionality   | ✅                   | ❌        | ❌                      |
| **Timezone information**         |                    |                     |                      |            |                         |
|                                  | Auth               | App Functionality   | ✅                   | ❌        | ❌                      |
| **Network information**          |                    |                     |                      |            |                         |
|                                  | Auth               | App Functionality   | ✅                   | ❌        | ❌                      |
| **Has SIM card**                 |                    |                     |                      |            |                         |
|                                  | Auth               | App Functionality   | ✅                   | ❌        | ❌                      |
| **Cellular Carrier Name**        |                    |                     |                      |            |                         |
|                                  | Auth               | App Functionality   | ✅                   | ❌        | ❌                      |
| **Device Model**                 |                    |                     |                      |            |                         |
|                                  | Auth               | App Functionality   | ✅                   | ❌        | ❌                      |
| **Device Name**                  |                    |                     |                      |            |                         |
|                                  | Auth               | App Functionality   | ✅                   | ❌        | ❌                      |
| **Device OS Version**            |                    |                     |                      |            |                         |
|                                  | Auth               | App Functionality   | ✅                   | ❌        | ❌                      |
| **Device Height and Width**      |                    |                     |                      |            |                         |
|                                  | Auth               | App Functionality   | ✅                   | ❌        | ❌                      |
| **Device Language**              |                    |                     |                      |            |                         |
|                                  | Auth               | App Functionality   | ✅                   | ❌        | ❌                      |
| **identifierForVendor**          |                    |                     |                      |            |                         |
|                                  | Auth               | App Functionality   | ✅                   | ❌        | ❌                      |


## Health and Fitness	
No data is collected

## Financial Info
No data is collected

## Location							
No data is collected

## Sensitive Info							
No data is collected

## Contacts							
No data is collected

## Browsing History
No data is collected

## Search History
No data is collected

## Diagnostics
No data is collected
</InlineFilter>

Some Amplify categories such as Analytics and Auth persist data to the local device. Some of that data is automatically removed when a user uninstalls the app from the device.

Amplify stores Auth information in the local [system keychain](https://developer.apple.com/documentation/security/keychain_services), which does not guarantee any particular behavior around whether data is removed when an app is uninstalled.

Deciding on when to clear this auth information is not something that the SDK can do in a generic way, so App developers should decide when to clear the data by signing out. One strategy for accomplishing this would be to use [UserDefaults](https://developer.apple.com/documentation/foundation/userdefaults) to detect whether or not the app is launching for the first time, and invoking [`Auth.signOut()`](/[platform]/build-a-backend/auth/connect-your-frontend/sign-out) if the app has not been launched before.


Contents of build-a-backend_add-aws-services_analytics_enable-disable_index.txt:
import { getCustomStaticPath } from '@/utils/getCustomStaticPath';

export const meta = {
  title: 'Enable and disable analytics',
  description: 'Learn how to enable/disable analytics using Amplify.',
  platforms: [
    'javascript',
    'react-native',
    'swift',
    'android',
    'flutter',
    'angular',
    'nextjs',
    'react',
    'vue'
  ],
};

export const getStaticPaths = async () => {
  return getCustomStaticPath(meta.platforms);
};

export function getStaticProps(context) {
  return {
    props: {
      platform: context.params.platform,
      meta
    }
  };
}

## Disable Analytics

Analytics are enabled by default when you configure it in your app. To disable Analytics in your app use the `disable` function:

<InlineFilter filters={['javascript', 'react-native', "angular", "nextjs", "react", "vue"]}>
```javascript title="src/index.js"
import { disable } from 'aws-amplify/analytics';

disable();
```
</InlineFilter>

<InlineFilter filters={['android']}>

<BlockSwitcher>
<Block name="Java">

```java
Amplify.Analytics.disable();
```

</Block>
<Block name="Kotlin">

```kotlin
Amplify.Analytics.disable()
```

</Block>
<Block name="RxJava">

```java
RxAmplify.Analytics.disable();
```

</Block>
</BlockSwitcher>
</InlineFilter>

<InlineFilter filters={['flutter']}>
```dart
await Amplify.Analytics.disable();
```
</InlineFilter>

<InlineFilter filters={['swift']}>
```swift
Amplify.Analytics.disable()
```
</InlineFilter>

## Enable Analytics

To enable analytics you can use the `enable` function in your app:

<InlineFilter filters={['javascript', 'react-native', "angular", "nextjs", "react", "vue"]}>
```javascript title="src/index.js"
import { enable } from 'aws-amplify/analytics';

enable();
```
</InlineFilter>

<InlineFilter filters={['android']}>
<BlockSwitcher>
<Block name="Java">

```java
Amplify.Analytics.enable();
```

</Block>
<Block name="Kotlin">

```kotlin
Amplify.Analytics.enable()
```

</Block>
<Block name="RxJava">

```java
RxAmplify.Analytics.enable();
```

</Block>
</BlockSwitcher>
</InlineFilter>

<InlineFilter filters={['flutter']}>
```dart
Amplify.Analytics.enable();
```
</InlineFilter>

<InlineFilter filters={['swift']}>
```swift
Amplify.Analytics.enable()
```
</InlineFilter>


Contents of build-a-backend_add-aws-services_analytics_existing-resources_index.txt:
import { getCustomStaticPath } from '@/utils/getCustomStaticPath';

export const meta = {
  title: 'Use existing AWS resources',
  description: 'Configure the Amplify Libraries to use existing Amazon Pinpoint resources by referencing them in your configuration.',
  platforms: [
    'swift',
    'android',
    'flutter',
    'javascript',
    'react-native',
    'angular',
    'nextjs',
    'react',
    'vue'
  ],
};

export const getStaticPaths = async () => {
  return getCustomStaticPath(meta.platforms);
};

export function getStaticProps(context) {
  return {
    props: {
      platform: context.params.platform,
      meta
    }
  };
}

To use existing Amazon Pinpoint resources with your Amplify backend or frontend application, use the `addOutput` method to surface backend resource outputs to the `amplify_outputs.json` file:

```ts title="amplify/backend.ts"
import { defineBackend } from "@aws-amplify/backend"

const backend = defineBackend({})

backend.addOutput({
  analytics: {
    amazon_pinpoint: {
      aws_region: "<your-aws-region>",
      app_id: "<your-pinpoint-app-id>",
    },
  },
})
```

<InlineFilter filters={['javascript', 'react-native', "angular", "nextjs", "react", "vue"]}>
## Configuring client library directly

Alternatively, you can configure the client library directly using `Amplify.configure()`. This manual setup enables you to use your existing Amazon Pinpoint resource in your app.

```ts title="src/main.ts"
import { Amplify } from 'aws-amplify';

Amplify.configure({
  ...Amplify.getConfig(),
  Analytics: {
    ...Amplify.getConfig().Analytics,
    Pinpoint: {
      // REQUIRED -  Amazon Pinpoint App Client ID
      appId: 'XXXXXXXXXXabcdefghij1234567890ab',

      // REQUIRED -  Amazon service region
      region: 'us-east-1',

      // OPTIONAL - How many events can be buffered at once.
      bufferSize: 1000,

      // OPTIONAL - How many events will be flushed from the buffer per batch.
      flushSize: 100,

      // OPTIONAL - The interval in milliseconds to perform a buffer check and flush if necessary.
      flushInterval: 5000, // 5s

      // OPTIONAL - The limit for failed recording retries.
      resendLimit: 5
    }
  }
});
```
</InlineFilter>

## Update your IAM Policy

Amazon Pinpoint requires an AWS Identity and Access Management (IAM) policy in order to use the `record` and `identifyUser` APIs:
```json
{
  "Version": "2012-10-17",
  "Statement": [
    {
      "Effect": "Allow",
      "Action": ["mobiletargeting:UpdateEndpoint", "mobiletargeting:PutEvents"],
      "Resource": ["arn:aws:mobiletargeting:*:<your-account-id>:apps/<your-pinpoint-app-id>*"]
    }
  ]
}
```



Contents of build-a-backend_add-aws-services_analytics_identify-user_index.txt:
import { getCustomStaticPath } from '@/utils/getCustomStaticPath';

export const meta = {
  title: 'Identify user',
  description: 'Use the Amplify analytics plugin to inform Pinpoint about your users.',
  platforms: [
    'swift',
    'android',
    'flutter',
    'javascript',
    'react-native',
    'angular',
    'nextjs',
    'react',
    'vue'
  ]
};

export const getStaticPaths = async () => {
  return getCustomStaticPath(meta.platforms);
};

export function getStaticProps(context) {
  return {
    props: {
      platform: context.params.platform,
      meta
    }
  };
}

<InlineFilter filters={['android']}>
This call sends information that you have specified about the user to Amazon Pinpoint. This could be for an unauthenticated or an authenticated user.

In addition, `customProperties` and `userAttributes` can also be provided when invoking `identifyUser`. The Amazon Pinpoint console makes that data available as part of the criteria for segment creation. Attributes passed in via `customProperties` will appear under **Custom Endpoint Attributes**, while `userAttributes` will appear under **Custom User Attributes**. See the [Amazon Pinpoint documentation](https://docs.aws.amazon.com/pinpoint/latest/userguide/segments-building.html#choosecriteria) for more information on segment creation.

You can get the current user's ID from the Amplify Auth category as shown below. Be sure you have it added and setup per the [Auth category documentation](/[platform]/build-a-backend/auth/set-up-auth/).

If you have asked for location access and received permission, you can also provide that in `UserProfile.Location`.

<BlockSwitcher>
<Block name="Java">

```java
UserProfile.Location location = UserProfile.Location.builder()
    .latitude(47.606209)
    .longitude(-122.332069)
    .postalCode("98122")
    .city("Seattle")
    .region("WA")
    .country("USA")
    .build();

AnalyticsProperties customProperties = AnalyticsProperties.builder()
    .add("property1", "Property value")
    .build();

AnalyticsProperties userAttributes = AnalyticsProperties.builder()
    .add("someUserAttribute", "User attribute value")
    .build();

AWSPinpointUserProfile profile = AWSPinpointUserProfile.builder()
    .name("test-user")
    .email("user@test.com")
    .plan("test-plan")
    .location(location)
    .customProperties(customProperties)
    .userAttributes(userAttributes)
    .build();

Amplify.Auth.getCurrentUser(authUser -> {
    String userId = authUser.getUserId();
    Amplify.Analytics.identifyUser(userId, profile);
}, exception -> {
    Log.e("MyAmplifyApp", "Error getting current user", exception);
});


```

</Block>
<Block name="Kotlin">

```kotlin
val location = UserProfile.Location.builder()
    .latitude(47.606209)
    .longitude(-122.332069)
    .postalCode("98122")
    .city("Seattle")
    .region("WA")
    .country("USA")
    .build();

val customProperties = AnalyticsProperties.builder()
    .add("property1", "Property value")
    .build();

val userAttributes = AnalyticsProperties.builder()
    .add("someUserAttribute", "User attribute value")
    .build();

val profile = AWSPinpointUserProfile.builder()
    .name("test-user")
    .email("user@test.com")
    .plan("test-plan")
    .location(location)
    .customProperties(customProperties)
    .userAttributes(userAttributes)
    .build();

Amplify.Auth.getCurrentUser({ authUser ->
    Amplify.Analytics.identifyUser(authUser.userId, profile);
}, { exception ->
    Log.e("MyAmplifyApp", "Error getting current user", exception)
})
```

</Block>
<Block name="RxJava">

```java
UserProfile.Location location = UserProfile.Location.builder()
    .latitude(47.606209)
    .longitude(-122.332069)
    .postalCode("98122")
    .city("Seattle")
    .region("WA")
    .country("USA")
    .build();

AnalyticsProperties customProperties = AnalyticsProperties.builder()
    .add("property1", "Property value")
    .build();

AnalyticsProperties userAttributes = AnalyticsProperties.builder()
    .add("someUserAttribute", "User attribute value")
    .build();

AWSPinpointUserProfile profile = AWSPinpointUserProfile.builder()
    .name("test-user")
    .email("user@test.com")
    .plan("test-plan")
    .location(location)
    .customProperties(customProperties)
    .userAttributes(userAttributes)
    .build();

RxAmplify.Auth.getCurrentUser()
    .subscribe(
        result -> {
            String userId = result.getUserId();
            RxAmplify.Analytics.identifyUser(userId, profile);
        },
        error -> Log.e("AuthQuickStart", error.toString())
    );
```

</Block>
</BlockSwitcher>
</InlineFilter>

<InlineFilter filters={['swift']}>
This call sends information about the current user (which could be unauthenticated or authenticated) to Amazon Pinpoint.

You can provide `name`, `email` and `plan`, as well as location information with `AnalyticsUserProfile.Location`. You can also send additional custom attributes using `AnalyticsProperties`.

If the user is signed in through [Amplify.Auth.signIn](/[platform]/build-a-backend/auth/connect-your-frontend/sign-in/), then you can retrieve the current user's ID as shown below:

```swift

let user = try await Amplify.Auth.getCurrentUser()

let location = AnalyticsUserProfile.Location(
    latitude: 47.606209,
    longitude: -122.332069,
    postalCode: "98122",
    city: "Seattle",
    region: "WA",
    country: "USA"
)

let properties: AnalyticsProperties = [
    "phoneNumber": "+11234567890",
    "age": 25
]

let userProfile = AnalyticsUserProfile(
    name: "username",
    email: "name@example.com",
    plan: "plan",
    location: location,
    properties: properties
)

Amplify.Analytics.identifyUser(
    userId: user.userId,
    userProfile: userProfile
)
```
</InlineFilter>

<InlineFilter filters={['flutter']}>
This call sends information that you have specified about a user to Amazon Pinpoint. This could be for an unauthenticated (guest) or an authenticated user.

You can get the current user's ID from the Amplify Auth category as shown per the Auth category documentation. Be sure to have it ready before you set it as shown below (Check out the [Authentication Getting Started](/[platform]/build-a-backend/auth/set-up-auth/) guide for detailed explanation).

If you have asked for location access and received permission, you can also provide that in `UserProfileLocation`

<Callout>

Breaking changes from v0 to v1:  

The Analytics- prefix of the original `AnalyticsUserProfile` and `AnalyticsUserProfileLocation` classes is removed.  Furthermore, `AnalyticsProperties` is renamed to `CustomProperties`. 


</Callout>

```dart
Future<void> addAnalyticsWithLocation({
  required String userId,
  required String name,
  required String email,
  required String phoneNumber,
  required int age,
}) async {
  final userProfile = UserProfile(
    name: name,
    email: email,
    location: const UserProfileLocation(
      latitude: 47.606209,
      longitude: -122.332069,
      postalCode: '98122',
      city: 'Seattle',
      region: 'WA',
      country: 'USA',
    ),
    customProperties: CustomProperties()
      ..addStringProperty('phoneNumber', phoneNumber)
      ..addIntProperty('age', age),
  );

  await Amplify.Analytics.identifyUser(
    userId: userId,
    userProfile: userProfile,
  );
}
```
</InlineFilter>

<InlineFilter filters={['javascript', 'react-native', "angular", "nextjs", "react", "vue"]}>

This API sends information about the current user to Amazon Pinpoint.

Additional information such as the user's name, email, location, and device can be included by specifying the `UserProfile`. Custom attributes can also be included by setting `UserProfile.customProperties`.

If the user was signed in through [signIn](/[platform]/build-a-backend/auth/connect-your-frontend/sign-up/) you can retrieve the current user's ID as shown below:

```js title="src/index.js"
import { identifyUser } from 'aws-amplify/analytics';
import { getCurrentUser } from 'aws-amplify/auth';

const location = {
  latitude: 47.606209,
  longitude: -122.332069,
  postalCode: '98122',
  city: 'Seattle',
  region: 'WA',
  country: 'USA'
};

const customProperties = {
  plan: ['plan'],
  phoneNumber: ['+11234567890'],
  age: ['25']
};

const userProfile = {
  location,
  name: 'username',
  email: 'name@example.com',
  customProperties
};

async function sendUserData() {
  const user = await getCurrentUser();

  identifyUser({
    userId: user.userId,
    userProfile
  });
}
```

</InlineFilter>

Sending user information allows you to associate a user to their user profile and activities or actions in your app.  The user's actions and attributes can also tracked across devices and platforms by using the same `userId`.  

Some scenarios for identifying a user and their associated app activities are:
* When a user completes app sign up
* When a user completes sign in process
* When a user launches your app
* When a user modifies or updates their user profile


Contents of build-a-backend_add-aws-services_analytics_index.txt:
import { getChildPageNodes } from '@/utils/getChildPageNodes';
import { getCustomStaticPath } from '@/utils/getCustomStaticPath';

export const meta = {
  title: 'Analytics',
  description: 'Learn how to set Analytics resource powered by Pinpoint',
  route: "/[platform]/build-a-backend/add-aws-services/analytics",
  platforms: [
    'javascript',
    'react-native',
    'swift',
    'android',
    'flutter',
    'angular',
    'nextjs',
    'react',
    'vue'
  ]
};

export const getStaticPaths = async () => {
  return getCustomStaticPath(meta.platforms);
};

export function getStaticProps(context) {
  const childPageNodes = getChildPageNodes(meta.route);
  return {
    props: {
      meta,
      childPageNodes
    }
  };
}

<Overview childPageNodes={props.childPageNodes} />


Contents of build-a-backend_add-aws-services_analytics_personalize-recommendations_index.txt:
import { getCustomStaticPath } from '@/utils/getCustomStaticPath';

export const meta = {
  title: 'Personalized recommendations',
  description: 'Amazon Personalize can create recommendations by using event data, historical data, or a combination of both. The event data can then be used to create recommendations.',
  platforms: [
    'javascript',
    'angular',
    'nextjs',
    'react',
    'vue',
    "react-native",
  ]
};

export const getStaticPaths = async () => {
  return getCustomStaticPath(meta.platforms);
};

export function getStaticProps(context) {
  return {
    props: {
      platform: context.params.platform,
      meta
    }
  };
}

Amazon Personalize can create recommendations by using event data, historical data, or a combination of both. The event data can then be used to create recommendations.

To record event data, you need the following:

* [A dataset group](https://docs.aws.amazon.com/personalize/latest/dg/data-prep-ds-group.html)
* [An event tracker](https://docs.aws.amazon.com/personalize/latest/dg/event-get-tracker.html).

For more information, see [Record Events](https://docs.aws.amazon.com/personalize/latest/dg/recording-events.html).

## Installation and Configuration

After creating the Amazon Personalize dataset group, you need to add the `personalize:PutEvents` permission to your AWS Identity and Access Management (IAM) user roles.

An example IAM policy:
```json
{
  "Version": "2012-10-17",
  "Statement": [{
    "Effect": "Allow",
    "Action": "personalize:PutEvents",
    "Resource": "arn:aws:personalize:<your-aws-region>:<your-account-id>:event-tracker/<your-resource-name>"
  }]
}
```

You need the tracking ID of your event tracker. For more information, see [Get a Tracking ID](https://docs.aws.amazon.com/personalize/latest/dg/action-interaction-tracker-id.html).

Configure Amazon Personalize:

```javascript title="src/index.js"
import { Amplify } from 'aws-amplify';
Amplify.configure({
  ...Amplify.getConfig(),
  Analytics: {
    Personalize: {
      // REQUIRED - The trackingId to track the events
      trackingId: '<tracking-id>',
      // REQUIRED -  Amazon Personalize service region
      region: 'us-east-1',
      // OPTIONAL - The number of events to be deleted from the buffer when flushed.
      flushSize: 10,
      // OPTIONAL - The interval in milliseconds to perform a buffer check and flush if necessary.
      flushInterval: 5000 // 5s
    }
  }
});
```
## Working with the API

You can use the `Identify` event type to track a user identity. This lets you connect a user to their actions and record traits about them. To identify a user, specify a unique identifier for the userId property.
 Consider the following user interactions when choosing when and how often to call record with the Identify eventType:

* After a user registers.
* After a user logs in.
* When a user updates their information (For example, changing or adding a new address).
* Upon loading any pages that are accessible by a logged-in user (optional).

```javascript
import { record } from 'aws-amplify/analytics/personalize';

record({
  eventType: 'Identify',
  properties: {
    userId: '<user-id>'
  }
});
```
You can send events to Amazon Personalize by calling the `record` operation. If you already use `Identify` to track end-user data, you can skip the userId, the SDK will fetch the userId based on current browser session.
For information about the properties field, see [Put Events](https://docs.aws.amazon.com/personalize/latest/dg/API_UBS_PutEvents.html).

```javascript
import { record } from 'aws-amplify/analytics/personalize';

record({
  eventType: '<event-type>',
  userId: '<user-id>', // optional
  properties: {
    itemId: '<item-id>',
    eventValue: '<event-value>'
  }
});
```
You can track iframe and HTML5 media types by using the MediaAutoTrack event type. MediaAutoTrack tracks all media events of the media DOM element that you bind to. `MediaAutoTracker` will automatically track *Play*, *Pause*, *Ended*, *TimeWatched*, and *Resume* in `eventType`. The duration of the event compared to the total length of the media is stored as a percentage value in `eventValue`.

```javascript
import { record } from 'aws-amplify/analytics/personalize';

record({
  eventType: 'MediaAutoTrack',
  userId: '<user-id>', // (optional)
  properties: {
    domElementId: 'media-dom-element-id',
    itemId: '<item-d>'
  }
});
```

## Flush events
The recorded events are saved in a buffer and sent to the remote server periodically *(You can tune it with the `flushInterval` option)*. If needed, you have the option to manually clear all the events from the buffer by using the 'flushEvents' API.

```javascript
import { flushEvents } from 'aws-amplify/analytics/personalize';

flushEvents();
```


Contents of build-a-backend_add-aws-services_analytics_record-events_index.txt:
import { getCustomStaticPath } from '@/utils/getCustomStaticPath';

export const meta = {
  title: 'Record events',
  description: 'Learn how to record analytics events using Amplify.',
  platforms: [
    'javascript',
    'react-native',
    'swift',
    'android',
    'flutter',
    'angular',
    'nextjs',
    'react',
    'vue'
  ],
};

export const getStaticPaths = async () => {
  return getCustomStaticPath(meta.platforms);
};

export function getStaticProps(context) {
  return {
    props: {
      platform: context.params.platform,
      meta
    }
  };
}

<InlineFilter filters= {["android"]}>
## Record event

The Amplify Analytics plugin makes it easy to record custom events within an app. The plugin handles retry logic in the event that the device loses network connectivity, and it automatically batches requests to reduce network bandwidth.

<BlockSwitcher>
<Block name="Java">

```java
AnalyticsEvent event = AnalyticsEvent.builder()
    .name("PasswordReset")
    .addProperty("Channel", "SMS")
    .addProperty("Successful", true)
    .addProperty("ProcessDuration", 792)
    .addProperty("UserAge", 120.3)
    .build();

Amplify.Analytics.recordEvent(event);
```

</Block>
<Block name="Kotlin">

```kotlin
val event = AnalyticsEvent.builder()
    .name("PasswordReset")
    .addProperty("Channel", "SMS")
    .addProperty("Successful", true)
    .addProperty("ProcessDuration", 792)
    .addProperty("UserAge", 120.3)
    .build()

Amplify.Analytics.recordEvent(event)
```

</Block>
<Block name="RxJava">

```java
AnalyticsEvent event = AnalyticsEvent.builder()
    .name("PasswordReset")
    .addProperty("Channel", "SMS")
    .addProperty("Successful", true)
    .addProperty("ProcessDuration", 792)
    .addProperty("UserAge", 120.3)
    .build();

RxAmplify.Analytics.recordEvent(event);
```

</Block>
</BlockSwitcher>

<Callout>

The Amazon Pinpoint event count updates in minutes after recording your event.

However, it can take upwards of 30 minutes for the event to display in the Filter section, and for its custom attributes to appear in Pinpoint.

</Callout>

## Flush events

Events have a default configuration to flush out to the network every 30 seconds. You can change this value by passing the `autoFlushEventsInterval` option to the `AWSPinpointAnalyticsPlugin`. The option value is measured in milliseconds.

```kotlin
val options = AWSPinpointAnalyticsPlugin.Options {
    autoFlushEventsInterval = 60_000
}
Amplify.addPlugin(AWSPinpointAnalyticsPlugin(options))
Amplify.configure(AmplifyOutputs(R.raw.amplify_outputs), this)
```

To manually flush events, call:

<BlockSwitcher>
<Block name="Java">

```java
Amplify.Analytics.flushEvents();
```

</Block>
<Block name="Kotlin">

```kotlin
Amplify.Analytics.flushEvents()
```

</Block>
<Block name="RxJava">

```java
RxAmplify.Analytics.flushEvents();
```

</Block>
</BlockSwitcher>

When flushing events, a [Hub event](/[platform]/build-a-backend/auth/connect-your-frontend/listen-to-auth-events/) is sent containing the events which were successfully sent to the Pinpoint service.  To receive a list of these events, subscribe to the `HubChannel.ANALYTICS` channel and handle an event of the type `AnalyticsChannelEventName.FLUSH_EVENTS`.

## Authentication events

Authentication events indicate how frequently users authenticate with your application.

On the **Analytics** page, the **Users** tab displays charts for **Sign-ins, Sign-ups, and Authentication failures**.

To learn how frequently users authenticate with your app, update your application code so that Amazon Pinpoint receives the following standard event types for authentication:

 - `_userauth.sign_in`
 - `_userauth.sign_up`
 - `_userauth.auth_fail`

You can report authentication events by doing either of the following:

 - Managing user sign-up and sign-in with Amazon Cognito user pools.

  Cognito user pools are user directories that make it easier to add sign-up and sign-in to your app. As users authenticate with your app, Cognito reports authentication events to Pinpoint. For more information, see [Using Amazon Pinpoint Analytics with Amazon Cognito User Pools](https://docs.aws.amazon.com/cognito/latest/developerguide/cognito-user-pools-pinpoint-integration.html) in the _Amazon Cognito Developer Guide_. Also update **amplify_outputs.json** by adding the `PinpointAppId` key under `CognitoUserPool`.

  ```json
  "CognitoUserPool": {
      "Default": {
          "PoolId": "<your-user-pool-id>",
          "AppClientId": "<your-app-client-id>",
          "Region": "<your-app-region>",
          "PinpointAppId": "<your-pinpoint-app-id>"
     }
  }
  ```

- Manually recording events using the `recordEvent()` API.

  If you don't want to use Cognito user pools, you can use the Pinpoint client to record and submit authentication events, as shown in the following examples. In these examples, the event type is set to `_userauth.sign_in`, but you can substitute any authentication event type.

<BlockSwitcher>
<Block name="Java">

  ```java
  /**
  * Call this method to log an authentication event to the analytics client.
  */
  public void logAuthenticationEvent() {
    AnalyticsEvent event = AnalyticsEvent.builder()
      .name("_userauth.sign_in")
      .build();
    Amplify.Analytics.recordEvent(event);
  }
  ```

  </Block>
  <Block name="Kotlin">

  ```kotlin
  /**
  * Call this method to log an authentication event to the analytics client.
  */
  fun logAuthenticationEvent() {
    val event = AnalyticsEvent.builder()
      .name("_userauth.sign_in")
      .build()
    Amplify.Analytics.recordEvent(event)
  }
  ```
  </Block>
  <Block name="RxJava">

  ```java

  /**
  * Call this method to log an authentication event to the analytics client.
  */
  public void logAuthenticationEvent() {
    AnalyticsEvent event = AnalyticsEvent.builder()
      .name("_userauth.sign_in")
      .build();
    RxAmplify.Analytics.recordEvent(event);
  }
  ```
  </Block>
  </BlockSwitcher>

## Global Properties

You can register global properties which will be sent along with all invocations of `Amplify.Analytics.recordEvent`.

<BlockSwitcher>
<Block name="Java">

```java
Amplify.Analytics.registerGlobalProperties(
    AnalyticsProperties.builder()
        .add("AppStyle", "DarkMode")
        .build());
```

</Block>
<Block name="Kotlin">

```kotlin
Amplify.Analytics.registerGlobalProperties(
    AnalyticsProperties.builder()
        .add("AppStyle", "DarkMode")
        .build())
```

</Block>
<Block name="RxJava">

```java
RxAmplify.Analytics.registerGlobalProperties(
    AnalyticsProperties.builder()
        .add("AppStyle", "DarkMode")
        .build());
```

</Block>
</BlockSwitcher>

To unregister a global property, call `Amplify.Analytics.unregisterGlobalProperties()`:

<BlockSwitcher>
<Block name="Java">

```java
Amplify.Analytics.unregisterGlobalProperties("AppStyle", "OtherProperty");
```

</Block>
<Block name="Kotlin">

```kotlin
Amplify.Analytics.unregisterGlobalProperties("AppStyle", "OtherProperty")
```

</Block>
<Block name="RxJava">

```java
RxAmplify.Analytics.unregisterGlobalProperties("AppStyle", "OtherProperty");
```

</Block>
</BlockSwitcher>
</InlineFilter>

<InlineFilter filters={['flutter']}>
## Record event

The Amplify analytics plugin also makes it easy to record custom events within the app. The plugin handles retry logic in the event the device looses network connectivity and automatically batches requests to reduce network bandwidth.

```dart
Future<void> recordCustomEvent() async {
  final event = AnalyticsEvent('PasswordReset');

  event.customProperties
    ..addStringProperty('Channel', 'SMS')
    ..addBoolProperty('Successful', true);

  // You can also add the properties one by one like the following
  event.customProperties.addIntProperty('ProcessDuration', 792);
  event.customProperties.addDoubleProperty('doubleKey', 120.3);

  await Amplify.Analytics.recordEvent(event: event);
}
```

<Callout>

The Amazon Pinpoint event count updates in minutes after recording your event.

However, it can take upwards of 30 minutes for the event to display in the Filter section, and for its custom attributes to appear in Amazon Pinpoint.

</Callout>

## Flush events

Events have default configuration to flush out to the network every 30 seconds. If you would like to change this, update `amplify_outputs.dart` with the value in milliseconds you would like for `autoFlushEventsInterval`. This configuration will flush events every 10 seconds:

```json
{
  "Version": "1.0",
  "analytics": {
    "plugins": {
      "awsPinpointAnalyticsPlugin": {
        "pinpointAnalytics": {
          "appId": "<your-app-id>",
          "region": "<your-app-region>"
        },
        "pinpointTargeting": {
          "region": "<your-app-region>"
        },
        "autoFlushEventsInterval": 10
      }
    }
  }
}
```

> **Note**
>
> Setting `autoFlushEventsInterval` to 0 will **disable** the automatic flush of events and you will be responsible for submitting them.

To manually flush events, call:

```dart
await Amplify.Analytics.flushEvents();
```

## Global Properties

You can register global properties which will be sent along with all invocations of `Amplify.Analytics.recordEvent`.

```dart
Future<void> registerGlobalProperties() async {
  final properties = CustomProperties()
    ..addStringProperty('AppStyle', 'DarkMode');
  await Amplify.Analytics.registerGlobalProperties(
    globalProperties: properties,
  );
}
```

To unregister a global property, call `Amplify.Analytics.unregisterGlobalProperties()`:

```dart
Future<void> unregisterGlobalProperties() async {
  await Amplify.Analytics.unregisterGlobalProperties(
    propertyNames: ['AppStyle', 'OtherProperty'],
  );
}
```

Furthermore, you can remove all global properties by calling `unregisterGlobalProperties` without `propertyNames`:

```dart
Future<void> unregisterAllGlobalProperties() async {
  await Amplify.Analytics.unregisterGlobalProperties();
}
```

</InlineFilter>

<InlineFilter filters={['swift']}>

## Record Event

The Amplify Analytics plugin provides a simple interface to record custom events within your app:

```swift
let properties: AnalyticsProperties = [
    "eventPropertyStringKey": "eventPropertyStringValue",
    "eventPropertyIntKey": 123,
    "eventPropertyDoubleKey": 12.34,
    "eventPropertyBoolKey": true
]

let event = BasicAnalyticsEvent(
    name: "eventName",
    properties: properties
)

Amplify.Analytics.record(event: event)
```

<Callout>

The Amazon Pinpoint event count updates in minutes after recording your event.

However, it can take upwards of 30 minutes for the event to display in the Filter section, and for its custom attributes to appear in Pinpoint.

</Callout>

## Flush Events

By default, events are automatically flushed out to the network every 60 seconds.

You can change this through the `options` parameter when initializing the plugin, by creating a `AWSPinpointAnalyticsPlugin.Options` instance and setting its `autoFlushEventsInterval` property to the desired value, expressed in seconds:

```swift
let options = AWSPinpointAnalyticsPlugin.Options(
    autoFlushEventsInterval: 60
)
try Amplify.add(plugin: AWSPinpointAnalyticsPlugin(options: options))
```

> **Note**
>
> Setting `autoFlushEventsInterval` to 0 will **disable** the automatic flush of events and you will be responsible for submitting them.

To manually submit the recoded events to the backend, call:

```swift
Amplify.Analytics.flushEvents()
```

The plugin automatically batches requests in order to reduce network bandwidth and handles the retry logic if the device loses connectivity.

## Authentication events

Indicate how frequently users authenticate with your application.

On the **Analytics** page, the **Users** tab displays charts for **Sign-ins, Sign-ups, and Authentication failures**.

To learn how frequently users authenticate with your app, update your application code so that Pinpoint receives the following standard event types for authentication:

 - `_userauth.sign_in`
 - `_userauth.sign_up`
 - `_userauth.auth_fail`

You can report these events by doing the following:

```swift
let event = BasicAnalyticsEvent(
    name: "_userauth.sign_in" // Or any of the accepted values
)
Amplify.Analytics.record(event: event)
```

## Global Properties

You can register properties which will be included across all `Amplify.Analytics.record(event:)` calls.

```swift
let globalProperties: AnalyticsProperties = [
    "globalPropertyKey": "value"
]
Amplify.Analytics.registerGlobalProperties(globalProperties)
```

To unregister global properties, call `Amplify.Analytics.unregisterGlobalProperties()`:

```swift
// When called with no arguments, it unregisters all global properties
Amplify.Analytics.unregisterGlobalProperties()

// Or you can specify which properties to unregister
let globalProperties = ["globalPropertyKey1", "globalPropertyKey2"]
Amplify.Analytics.unregisterGlobalProperties(globalProperties)
```

</InlineFilter>

<InlineFilter filters={['javascript',  'react-native', "angular", "nextjs", "react", "vue"]}>

## Recording Custom Events

To record custom events call the `record` API:

```javascript title="src/index.js"
import { record } from 'aws-amplify/analytics';

record({
  name: 'albumVisit',
});
```

<Callout>

Analytics events are buffered in memory and periodically sent to the service and not saved locally between application sessions. If the session is ended before a buffered event is sent, it will be lost. Use the `flushEvents` API to manually send buffered events to the service.

</Callout>

## Record a Custom Event with Attributes

The `record` API lets you add additional attributes to an event. For example, to record _artist_ information with an _albumVisit_ event:

```javascript title="src/index.js"
import { record } from 'aws-amplify/analytics';

record({
  name: 'albumVisit',
  attributes: { genre: '', artist: '' },
});
```

Recorded events will be buffered and periodically sent to Amazon Pinpoint.

## Record Engagement Metrics

Metrics can also be added to an event:

```javascript title="src/index.js"
import { record } from 'aws-amplify/analytics';

record({
  name: 'albumVisit',
  metrics: { minutesListened: 30 },
});
```

Metric values must be a `Number` type such as a float or integer.

<Callout>

The Amazon Pinpoint event count updates in minutes after recording your event.

However, it can take upwards of 30 minutes for the event to display in the Filter section, and for its custom attributes to appear in Amazon Pinpoint.

</Callout>

## Flush events

The recorded events are saved in a buffer and sent to the remote server periodically. If needed, you have the option to manually clear all the events from the buffer by using the 'flushEvents' API.

```javascript title="src/index.js"
import { flushEvents } from 'aws-amplify/analytics';

flushEvents();
```

</InlineFilter>


Contents of build-a-backend_add-aws-services_analytics_sdk_index.txt:
import { getCustomStaticPath } from '@/utils/getCustomStaticPath';

export const meta = {
  title: 'Use AWS SDK',
  description: 'For advanced use cases where Amplify does not provide the functionality, you can retrieve the escape hatch to access the AWSPinpoint instance.',
  platforms: [
    'swift',
    'android'
  ],
};

export const getStaticPaths = async () => {
  return getCustomStaticPath(meta.platforms);
};

export function getStaticProps(context) {
  return {
    props: {
      platform: context.params.platform,
      meta
    }
  };
}

<InlineFilter filters={['swift']}>
For advanced use cases where Amplify does not provide the functionality, you can retrieve an escape hatch to access the underlying Amazon Pinpoint client.

Add the following import:

```swift
import AWSPinpointAnalyticsPlugin
```

Then retrieve the escape hatch with this code:

```swift
do {
    // Retrieve the reference to AWSPinpointAnalyticsPlugin
    let plugin = try Amplify.Analytics.getPlugin(for: "awsPinpointAnalyticsPlugin")
    guard let analyticsPlugin = plugin as? AWSPinpointAnalyticsPlugin else {
        return
    }

    // Retrieve the reference to PinpointClientProtocol
    let pinpointClient = analyticsPlugin.getEscapeHatch()

    // Make requests using pinpointClient...
    // ...
} catch {
    print("Get escape hatch failed with error - \(error)")
}
```
</InlineFilter>

<InlineFilter filters={['android']}>
For advanced use cases where Amplify does not provide the functionality, you can retrieve an escape hatch to access the underlying Amazon Pinpoint client.

<BlockSwitcher>

<Block name="Java">

<Callout>

Learn more about consuming Kotlin clients from Java using either a blocking interface or an equivalent async interface based on futures [here](https://github.com/awslabs/smithy-kotlin/blob/main/docs/design/kotlin-smithy-sdk.md#java-interop).

</Callout>

```java
AWSPinpointAnalyticsPlugin plugin = (AWSPinpointAnalyticsPlugin)
    Amplify.Analytics.getPlugin("awsPinpointAnalyticsPlugin");
PinpointClient pinpointClient = plugin.getEscapeHatch();
```

</Block>
<Block name="Kotlin">

```kotlin
val plugin = Amplify.Analytics.getPlugin("awsPinpointAnalyticsPlugin")
val pinpointClient = (plugin as AWSPinpointAnalyticsPlugin).escapeHatch
```

</Block>
<Block name="RxJava">

```java
AWSPinpointAnalyticsPlugin plugin = (AWSPinpointAnalyticsPlugin)
    RxAmplify.Analytics.getPlugin("awsPinpointAnalyticsPlugin");
PinpointClient pinpointClient = plugin.getEscapeHatch();
```

</Block>
</BlockSwitcher>
</InlineFilter>


Contents of build-a-backend_add-aws-services_analytics_set-up-analytics_index.txt:
import { getCustomStaticPath } from '@/utils/getCustomStaticPath';

export const meta = {
  title: 'Set up Amplify Analytics',
  description: 'The Analytics category enables you to collect analytics data for your app. The Analytics category comes with built-in support for Amazon Pinpoint and Amazon Kinesis (Kinesis support is currently only available in the Amplify JavaScript library). The Analytics category uses Amazon Cognito Identity pools to identify users in your App. Cognito allows you to receive data from authenticated, and unauthenticated users in your App.',
  platforms: [
    'javascript',
    'react-native',
    'swift',
    'android',
    'flutter',
    'angular',
    'nextjs',
    'react',
    'vue'
  ],
};

export const getStaticPaths = async () => {
  return getCustomStaticPath(meta.platforms);
};

export function getStaticProps(context) {
  return {
    props: {
      platform: context.params.platform,
      meta
    }
  };
}

Amplify enables you to collect analytics data for your app. In order to use Analytics, you will enable [Amazon Kinesis](https://aws.amazon.com/kinesis/) or [Amazon Pinpoint](https://aws.amazon.com/pinpoint/) using the AWS Cloud Development Kit (AWS CDK). The Analytics category uses [Amazon Cognito identity pools](https://docs.aws.amazon.com/cognito/latest/developerguide/identity-pools.html) to _identify_ users in your app. Cognito allows you to receive data from authenticated, and unauthenticated users in your app.

<InlineFilter filters={["swift"]}>
## Prerequisites

An application with Amplify libraries integrated and a minimum target of any of the following:
- **iOS 13.0**, using **Xcode 14.1** or later.
- **macOS 10.15**, using **Xcode 14.1** or later.
- **tvOS 13.0**, using **Xcode 14.3** or later.
- **watchOS 9.0**, using **Xcode 14.3** or later.
- **visionOS 1.0**, using **Xcode 15** or later. (Preview support - see below for more details.)

<Callout>

visionOS support is currently in **preview** and can be used by using the latest [Amplify Release](https://github.com/aws-amplify/amplify-swift/releases). 
As new Xcode and visionOS versions are released, the support will be updated with any necessary fixes on a best effort basis.

</Callout>
</InlineFilter>

<InlineFilter filters={["android"]}>
## Prerequisites

* An Android application targeting Android API level 24 (Android 7.0) or above

</InlineFilter>

<InlineFilter filters={["flutter"]}>

Amplify Flutter requires a minimum target platform for iOS (13.0), Android (API level 24), and macOS (10.15). Refer to [Flutter's supported deployment platforms](https://docs.flutter.dev/reference/supported-platforms) when targeting Web, Windows, or Linux.

</InlineFilter>
## Set up Analytics backend

Use the [AWS CDK](https://docs.aws.amazon.com/cdk/latest/guide/home.html) to create an analytics resource powered by [Amazon Pinpoint](https://aws.amazon.com/pinpoint/).

```ts title="amplify/backend.ts"
import { defineBackend } from "@aws-amplify/backend"
import { auth } from "./auth/resource";
import { data } from "./data/resource";
import { Policy, PolicyStatement } from "aws-cdk-lib/aws-iam";
import { CfnApp } from "aws-cdk-lib/aws-pinpoint";
import { Stack } from "aws-cdk-lib/core";

const backend = defineBackend({
  auth,
  data,
  // additional resources
});

const analyticsStack = backend.createStack("analytics-stack");

// create a Pinpoint app
const pinpoint = new CfnApp(analyticsStack, "Pinpoint", {
  name: "myPinpointApp",
});

// create an IAM policy to allow interacting with Pinpoint
const pinpointPolicy = new Policy(analyticsStack, "PinpointPolicy", {
  policyName: "PinpointPolicy",
  statements: [
    new PolicyStatement({
      actions: ["mobiletargeting:UpdateEndpoint", "mobiletargeting:PutEvents"],
      resources: [pinpoint.attrArn + "/*"],
    }),
  ],
});

// apply the policy to the authenticated and unauthenticated roles
backend.auth.resources.authenticatedUserIamRole.attachInlinePolicy(pinpointPolicy);
backend.auth.resources.unauthenticatedUserIamRole.attachInlinePolicy(pinpointPolicy);

// patch the custom Pinpoint resource to the expected output configuration
backend.addOutput({
  analytics: {
    amazon_pinpoint: {
      app_id: pinpoint.ref,
      aws_region: Stack.of(pinpoint).region,
    }
  },
});
```

## Install Amplify Libraries

<InlineFilter filters={['javascript', "angular", "react", "vue", "react-native", "nextjs"]}>
First, install the `aws-amplify` library:

```sh title="Terminal" showLineNumbers={false}
npm add aws-amplify
```
</InlineFilter>

<InlineFilter filters={["swift"]}>
1. To install the Amplify Libraries in your application, open your project in Xcode and select **File > Add Packages...**.

2. Enter the **Amplify Library for Swift** GitHub repo URL (`https://github.com/aws-amplify/amplify-swift`) into the search bar and click **Add Package**.

  <Callout>

  **Note:** **Up to Next Major Version** should be selected from the **Dependency Rule** dropdown.

  </Callout>
3. Lastly, add **AWSPinpointAnalyticsPlugin**, **AWSCognitoAuthPlugin**, and **Amplify** to your target. Then click **Add Package**.

</InlineFilter>

<InlineFilter filters={["android"]}>
Expand **Gradle Scripts**, open **build.gradle.kts (Module :app)**. You will already have configured Amplify by following the steps in the quickstart guide.

Add Analytics by adding these libraries into the dependencies block:
```kotlin title="app/build.gradle.kts"
android {
    compileOptions {
        // Support for Java 8 features
        isCoreLibraryDesugaringEnabled = true
        sourceCompatibility = JavaVersion.VERSION_1_8
        targetCompatibility = JavaVersion.VERSION_1_8
    }
}

dependencies {
    // Amplify API dependencies
    // highlight-start
    implementation("com.amplifyframework:aws-analytics-pinpoint:ANDROID_VERSION")
    implementation("com.amplifyframework:aws-auth-cognito:ANDROID_VERSION")    
    // highlight-end
    // ... other dependencies
    coreLibraryDesugaring("com.android.tools:desugar_jdk_libs:2.0.3")
}
```

Click **Sync Now**.
</InlineFilter>

<InlineFilter filters={["flutter"]}>
In your Flutter project directory, open **pubspec.yaml**.
Add Analytics by adding these libraries into your dependencies block:

```yaml
dependencies:
  amplify_analytics_pinpoint: ^2.0.0
  amplify_auth_cognito: ^2.0.0
  amplify_flutter: ^2.0.0
```
</InlineFilter>

## Initialize Amplify Analytics

Import and load the configuration file in your app. It's recommended you add the Amplify configuration step to your app's root entry point.

<InlineFilter filters={["javascript", "angular", "react", "vue", "react-native"]}>
```js title="src/index.js"
import { Amplify } from 'aws-amplify';
import { record } from 'aws-amplify/analytics';
import outputs from '../amplify_outputs.json';

Amplify.configure({
  ...Amplify.getConfig(),
  Analytics: amplifyconfig.Analytics,
});
```
</InlineFilter>

<InlineFilter filters={['nextjs']}>
```js title="pages/_app.tsx"
import { Amplify } from 'aws-amplify';
import { record } from 'aws-amplify/analytics';
import outputs from '@/amplify_outputs.json';

Amplify.configure({
  ...Amplify.getConfig(),
  Analytics: amplifyconfig.Analytics,
});
```
</InlineFilter>

<InlineFilter filters= {["swift"]}>
<Callout warning>
Make sure to generate the `amplify_outputs.json` file by running the following command: 

```bash title="Terminal" showLineNumbers={false}
npx ampx sandbox
```

Next, move the file to your project. You can do this by dragging and dropping the file into your Xcode project.
</Callout>

To use the Amplify Analytics and Authentication categories in your app, you need to create and configure their corresponding plugins by calling the `Amplify.add(plugin:)` and `Amplify.configure(with:)` methods.

<BlockSwitcher>

<Block name="SwiftUI">

Add the following imports to the top of your main `App` file:

```swift
import Amplify
import AWSCognitoAuthPlugin
import AWSPinpointAnalyticsPlugin
```

Add the following code to its initializer. If there is none, you can create a default `init`:

```swift
init() {
    do {
        try Amplify.add(plugin: AWSCognitoAuthPlugin())
        try Amplify.add(plugin: AWSPinpointAnalyticsPlugin())
        try Amplify.configure(with: .amplifyOutputs)
        print("Amplify configured with Auth and Analytics plugins")
    } catch {
        print("Failed to initialize Amplify with \(error)")
    }
}
```

</Block>

<Block name="UIKit">

Add the following imports to the top of your `AppDelegate.swift` file:

```swift
import Amplify
import AWSCognitoAuthPlugin
import AWSPinpointAnalyticsPlugin
```

Add the following code to the `application:didFinishLaunchingWithOptions` method:

```swift
func application(
    _ application: UIApplication,
    didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?
) -> Bool {
    do {
        try Amplify.add(plugin: AWSCognitoAuthPlugin())
        try Amplify.add(plugin: AWSPinpointAnalyticsPlugin())
        try Amplify.configure(with: .amplifyOutputs)
        print("Amplify configured with Auth and Analytics plugins")
    } catch {
        print("Failed to initialize Amplify with \(error)")
    }

    return true
}
```

</Block>

</BlockSwitcher>

Upon building and running this application you should see the following in your console window:

```console
Amplify configured with Auth and Analytics plugin
```
</InlineFilter>

<InlineFilter filters={["flutter"]}>
Add the Auth and Analytics plugin, along with any other plugins you may have added as described in the **Project Setup** section;

```dart
import 'package:amplify_analytics_pinpoint/amplify_analytics_pinpoint.dart';
import 'package:amplify_auth_cognito/amplify_auth_cognito.dart';
import 'package:amplify_flutter/amplify_flutter.dart';
import 'package:flutter/material.dart';

import 'amplify_outputs.dart';

Future<void> _configureAmplify() async {
  // Add Pinpoint and Cognito Plugins, and any other plugins you want to use
  final analyticsPlugin = AmplifyAnalyticsPinpoint();
  final authPlugin = AmplifyAuthCognito();
  await Amplify.addPlugins([analyticsPlugin, authPlugin]);
}
```

<Callout>

When running your app on macOS you will need to enable keychain sharing in Xcode, as described in the [Project setup guide](/gen1/[platform]/start/project-setup/platform-setup/#enable-keychain).

</Callout>

Make sure that the amplify_outputs.dart file generated in the project setup is included and sent to Amplify.configure:

```dart
import 'package:amplify_analytics_pinpoint/amplify_analytics_pinpoint.dart';
import 'package:amplify_auth_cognito/amplify_auth_cognito.dart';
import 'package:amplify_flutter/amplify_flutter.dart';
import 'package:flutter/material.dart';

import 'amplify_outputs.dart';

Future<void> _configureAmplify() async {
  // ...
  await Amplify.addPlugins([analyticsPlugin, authPlugin]);

  // Once Plugins are added, configure Amplify
  // Note: Amplify can only be configured once.
  try {
    await Amplify.configure(amplifyConfig);
  } on AmplifyAlreadyConfiguredException {
    safePrint(
      'Tried to reconfigure Amplify; this can occur when your app restarts on Android.',
    );
  }
}
```

Your class will look like this:

```dart
import 'package:amplify_flutter/amplify_flutter.dart';
import 'package:amplify_analytics_pinpoint/amplify_analytics_pinpoint.dart';
import 'package:amplify_auth_cognito/amplify_auth_cognito.dart';
import 'package:flutter/material.dart';

import 'amplify_outputs.dart';

Future<void> _configureAmplify() async {
  // Add any Amplify plugins you want to use
  final analyticsPlugin = AmplifyAnalyticsPinpoint();
  final authPlugin = AmplifyAuthCognito();
  await Amplify.addPlugins([analyticsPlugin, authPlugin]);

  // Once Plugins are added, configure Amplify
  // Note: Amplify can only be configured once.
  try {
    await Amplify.configure(amplifyConfig);
  } on AmplifyAlreadyConfiguredException {
    safePrint(
      'Tried to reconfigure Amplify; this can occur when your app restarts on Android.',
    );
  }
}

Future<void> main() async {
  WidgetsFlutterBinding.ensureInitialized();
  await _configureAmplify();
  runApp(const MyApp());
}

class MyApp extends StatefulWidget {
  const MyApp({Key? key}): super(key: key);

  // ...
}
```
</InlineFilter>

<InlineFilter filters={['android']}>
To initialize the Amplify Auth and Analytics categories you call `Amplify.addPlugin()` method for each category. To complete initialization call `Amplify.configure()`.

Add the following code to your `onCreate()` method in your application class:

<Callout warning>
Before calling the `Amplify.configure` function, make sure to either download the `amplify_outputs.json` file from the console, or generate it with the following command: 

```bash title="Terminal" showLineNumbers={false}
npx ampx generate outputs --app-id <app-id> --branch main --out-dir app/src/main/res/raw
```

Next, be sure the file you generated or downloaded is in the appropriate resource directory for your application (for example, `app/src/main/res/raw`) in your Android project. Otherwise, you will not be able to compile your application.
</Callout>

<BlockSwitcher>
<Block name="Java">

```java
import android.util.Log;
import com.amplifyframework.AmplifyException;
import com.amplifyframework.analytics.pinpoint.AWSPinpointAnalyticsPlugin;
import com.amplifyframework.auth.cognito.AWSCognitoAuthPlugin;
import com.amplifyframework.core.Amplify;
import com.amplifyframework.core.configuration.AmplifyOutputs;

```

```java
Amplify.addPlugin(new AWSCognitoAuthPlugin());
Amplify.addPlugin(new AWSPinpointAnalyticsPlugin());
```

Your class will look like this:

```java
public class MyAmplifyApp extends Application {
    @Override
    public void onCreate() {
        super.onCreate();

        try {
            // Add these lines to add the AWSCognitoAuthPlugin and AWSPinpointAnalyticsPlugin plugins
            Amplify.addPlugin(new AWSCognitoAuthPlugin());
            Amplify.addPlugin(new AWSPinpointAnalyticsPlugin());
            Amplify.configure(AmplifyOutputs.fromResource(R.raw.amplify_outputs), getApplicationContext());

            Log.i("MyAmplifyApp", "Initialized Amplify");
        } catch (AmplifyException error) {
            Log.e("MyAmplifyApp", "Could not initialize Amplify", error);
        }
    }
}
```

</Block>
<Block name="Kotlin">

```kotlin
import android.util.Log
import com.amplifyframework.AmplifyException
import com.amplifyframework.analytics.pinpoint.AWSPinpointAnalyticsPlugin
import com.amplifyframework.auth.cognito.AWSCognitoAuthPlugin
import com.amplifyframework.core.Amplify
import com.amplifyframework.core.configuration.AmplifyOutputs
```

```kotlin
Amplify.addPlugin(AWSCognitoAuthPlugin())
Amplify.addPlugin(AWSPinpointAnalyticsPlugin())
```

Your class will look like this:

```kotlin
class MyAmplifyApp : Application() {
    override fun onCreate() {
        super.onCreate()

        try {
            // Add these lines to add the AWSCognitoAuthPlugin and AWSPinpointAnalyticsPlugin plugins
            Amplify.addPlugin(AWSCognitoAuthPlugin())
            Amplify.addPlugin(AWSPinpointAnalyticsPlugin())
            Amplify.configure(AmplifyOutputs.fromResource(R.raw.amplify_outputs), applicationContext)

            Log.i("MyAmplifyApp", "Initialized Amplify")
        } catch (error: AmplifyException) {
            Log.e("MyAmplifyApp", "Could not initialize Amplify", error)
        }
    }
}
```

</Block>
<Block name="RxJava">

```java
import android.util.Log;
import com.amplifyframework.AmplifyException;
import com.amplifyframework.analytics.pinpoint.AWSPinpointAnalyticsPlugin;
import com.amplifyframework.auth.cognito.AWSCognitoAuthPlugin;
import com.amplifyframework.core.configuration.AmplifyOutputs;
import com.amplifyframework.rx.RxAmplify;
```

```java
RxAmplify.addPlugin(new AWSCognitoAuthPlugin());
RxAmplify.addPlugin(new AWSPinpointAnalyticsPlugin());
```

Your class will look like this:

```java
public class MyAmplifyApp extends Application {
    @Override
    public void onCreate() {
        super.onCreate();

        try {
            // Add these lines to add the AWSCognitoAuthPlugin and AWSPinpointAnalyticsPlugin plugins
            RxAmplify.addPlugin(new AWSCognitoAuthPlugin());
            RxAmplify.addPlugin(new AWSPinpointAnalyticsPlugin());
            RxAmplify.configure(AmplifyOutputs.fromResource(R.raw.amplify_outputs), getApplicationContext());

            Log.i("MyAmplifyApp", "Initialized Amplify");
        } catch (AmplifyException error) {
            Log.e("MyAmplifyApp", "Could not initialize Amplify", error);
        }
    }
}
```

</Block>
</BlockSwitcher>

</InlineFilter>

Next Steps:

Congratulations! Now that you have Analytics' backend provisioned and Analytics library installed. Check out the following links to see Amplify Analytics use cases:

- [Record Events](/[platform]/build-a-backend/add-aws-services/analytics/record-events/)
- [Track Sessions](/[platform]/build-a-backend/add-aws-services/analytics/auto-track-sessions/)
- [Identify User](/[platform]/build-a-backend/add-aws-services/analytics/identify-user/)

### References

[Amazon Pinpoint Construct Library](https://docs.aws.amazon.com/cdk/api/v2/docs/aws-cdk-lib.aws_pinpoint-readme.html)

<InlineFilter filters={['react-native']}>

## Known Issues

You may encounter the following error when starting the bundler when using Amazon Kinesis (`aws-amplify/analytics/kinesis`), Amazon Kinesis Data Firehose (`aws-amplify/analytics/kinesis-firehose`), Personalize Event (`aws-amplify/analytics/personalize`):

> Error: Unable to resolve module stream from /path/to/node_modules/@aws-sdk/... This is a [known issue](https://github.com/aws/aws-sdk-js-v3/issues/4877). Please follow [the steps](https://github.com/aws/aws-sdk-js-v3/issues/4877#issuecomment-1656007484) outlined in the issue to resolve the error.

</InlineFilter>


Contents of build-a-backend_add-aws-services_analytics_storing-data_index.txt:
import { getCustomStaticPath } from '@/utils/getCustomStaticPath';

export const meta = {
  title: 'Storing analytics data',
  description: 'The Amazon Data Firehose analytics provider allows you to send analytics data to an Amazon Data Firehose stream for reliably storing data.',
  platforms: [
    'javascript',
    'angular',
    'nextjs',
    'react',
    'vue',
    'react-native',
  ],
};

export const getStaticPaths = async () => {
  return getCustomStaticPath(meta.platforms);
};

export function getStaticProps(context) {
  return {
    props: {
      platform: context.params.platform,
      meta
    }
  };
}

The Amazon Data Firehose analytics provider allows you to send analytics data to an [Amazon Data Firehose](https://aws.amazon.com/firehose/) stream for reliably storing data.

## Setup Firehose stream

The following is an example utilizing the [AWS Cloud Development Kit (AWS CDK)](https://docs.aws.amazon.com/cdk/latest/guide/home.html) to create the Analytics resource powered by [Amazon Data Firehose](https://aws.amazon.com/firehose/).

Let's create a storage bucket to store the data from the Firehose stream.

```ts title="amplify/storage/resource.ts"
import { defineStorage } from "@aws-amplify/backend";

// Define the S3 bucket resource
export const storage = defineStorage({
  name: "FirehoseDestinationBucket",
});

```

next, let's create the Firehose resource.

```ts title="amplify/backend.ts"
import { defineBackend } from "@aws-amplify/backend";
import { auth } from "./auth/resource";
import { data } from "./data/resource";
import { storage } from "./storage/resource";
import { CfnDeliveryStream } from "aws-cdk-lib/aws-kinesisfirehose";
import { Stack } from "aws-cdk-lib/core";
import {
  Policy,
  PolicyStatement,
  Role,
  ServicePrincipal,
} from "aws-cdk-lib/aws-iam";

const backend = defineBackend({
  auth, 
  data,
  storage,
  // additional resources 
});

// Create a new stack for the Firehose resources
const firehoseStack = backend.createStack("firehose-stack");

// Access the S3 bucket resource
const s3Bucket = backend.storage.resources.bucket;

// Create a new IAM role for the Firehose
const firehoseRole = new Role(firehoseStack, "FirehoseRole", {
  assumedBy: new ServicePrincipal("firehose.amazonaws.com"),
});

// Grant the Firehose role read/write permissions to the S3 bucket
s3Bucket.grantReadWrite(firehoseRole);

// Create a new Firehose delivery stream
const myFirehose = new CfnDeliveryStream(firehoseStack, "MyFirehose", {
  deliveryStreamType: "DirectPut",
  s3DestinationConfiguration: {
    bucketArn: s3Bucket.bucketArn,
    roleArn: firehoseRole.roleArn,
  },
  deliveryStreamName: "myFirehose",
});

// Create a new IAM policy to allow users to write to the Firehose
const firehosePolicy = new Policy(firehoseStack, "FirehosePolicy", {
  statements: [
    new PolicyStatement({
      actions: ["firehose:PutRecordBatch"],
      resources: [myFirehose.attrArn],
    }),
  ],
});

// Attach the policy to the authenticated and unauthenticated IAM roles
backend.auth.resources.authenticatedUserIamRole.attachInlinePolicy(firehosePolicy);
backend.auth.resources.unauthenticatedUserIamRole.attachInlinePolicy(firehosePolicy);
```

## Installation and Configuration

Ensure you have [setup IAM permissions](https://docs.aws.amazon.com/firehose/latest/dev/controlling-access.html) for `firehose:PutRecordBatch`.

Example IAM policy for Amazon Data Firehose:

```javascript
{
  "Version": "2012-10-17",
  "Statement": [{
    "Effect": "Allow",
    "Action": "firehose:PutRecordBatch",
    // replace the template fields
    "Resource": "arn:aws:firehose:<your-aws-region>:<your-aws-account-id>:deliverystream/<your-stream-name>"
  }]
}
```

Configure Firehose:

```javascript title="src/index.js"
import { Amplify } from 'aws-amplify';

Amplify.configure({
  ...Amplify.getConfig(),
  Analytics: {
    KinesisFirehose: {
      // REQUIRED -  Amazon Kinesis Firehose service region
      region: 'us-east-1',

      // OPTIONAL - The buffer size for events in number of items.
      bufferSize: 1000,

      // OPTIONAL - The number of events to be deleted from the buffer when flushed.
      flushSize: 100,

      // OPTIONAL - The interval in milliseconds to perform a buffer check and flush if necessary.
      flushInterval: 5000, // 5s

      // OPTIONAL - The limit for failed recording retries.
      resendLimit: 5
    }
  }
});
```

## Storing data

You can send a data to a Firehose stream with the standard `record` method. Any data is acceptable and `streamName` is required:

```javascript title="src/index.js"
import { record } from 'aws-amplify/analytics/kinesis-firehose';

record({
  data: {
    // The data blob to put into the record
  },
  streamName: 'myFirehose'
});
```

## Flush events
The recorded events are saved in a buffer and sent to the remote server periodically *(You can tune it with the `flushInterval` option)*. If needed, you have the option to manually clear all the events from the buffer by using the 'flushEvents' API.

```javascript title="src/index.js"
import { flushEvents } from 'aws-amplify/analytics/kinesis-firehose';

flushEvents();
```

<InlineFilter filters={['react-native']}>

## Known Issues

When importing alternative service providers listed below, instead of the default Pinpoint provider:

- Amazon Kinesis (`aws-amplify/analytics/kinesis`)
- Amazon Data Firehose (`aws-amplify/analytics/kinesis-firehose`)
- Personalize Event (`aws-amplify/analytics/personalize`)

you may encounter the following error when starting the bundler:

> Error: Unable to resolve module stream from /path/to/node_modules/@aws-sdk/... This is a [known issue](https://github.com/aws/aws-sdk-js-v3/issues/4877). Please follow [the steps](https://github.com/aws/aws-sdk-js-v3/issues/4877#issuecomment-1656007484) outlined in the issue to resolve the error.

</InlineFilter>


Contents of build-a-backend_add-aws-services_analytics_streaming-data_index.txt:
import { getCustomStaticPath } from '@/utils/getCustomStaticPath';

export const meta = {
  title: 'Streaming analytics data',
  description: 'The Amazon Kinesis analytics provider allows you to send analytics data to an Amazon Kinesis stream for real-time processing.',
  platforms: [
    'javascript',
    'react-native',
    'angular',
    'nextjs',
    'react',
    'vue'
  ],
};

export const getStaticPaths = async () => {
  return getCustomStaticPath(meta.platforms);
};

export function getStaticProps(context) {
  return {
    props: {
      platform: context.params.platform,
      meta
    }
  };
}

The Amazon Kinesis analytics provider allows you to send analytics data to an [Kinesis](https://aws.amazon.com/kinesis) stream for real-time processing.

## Setup Kinesis stream

The following is an example utilizing the [AWS Cloud Development Kit (AWS CDK)](https://docs.aws.amazon.com/cdk/latest/guide/home.html) to create the Analytics resource powered by [Amazon Kinesis](https://aws.amazon.com/kinesis).

```ts title="amplify/backend.ts"
import { auth } from "./auth/resource";
import { data } from "./data/resource";
import { Policy, PolicyStatement } from "aws-cdk-lib/aws-iam";
import { Stream } from "aws-cdk-lib/aws-kinesis";
import { Stack } from "aws-cdk-lib/core";

const backend = defineBackend({
  auth, 
  data,
  // additional resources 
});

// create a new stack for the Kinesis stream
const kinesisStack = backend.createStack("kinesis-stack");

// create a new Kinesis stream with one shard
const kinesisStream = new Stream(kinesisStack, "KinesisStream", {
  streamName: "myKinesisStream",
  shardCount: 1,
});

// create a new policy to allow PutRecords to the Kinesis stream
const kinesisPolicy = new Policy(kinesisStack, "KinesisPolicy", {
  statements: [
    new PolicyStatement({
      actions: ["kinesis:PutRecords"],
      resources: [kinesisStream.streamArn],
    }),
  ],
});

// apply the policy to the authenticated and unauthenticated roles
backend.auth.resources.authenticatedUserIamRole.attachInlinePolicy(kinesisPolicy);
backend.auth.resources.unauthenticatedUserIamRole.attachInlinePolicy(kinesisPolicy);
```

## Installation and Configuration

If you did not use the CLI, ensure you have [setup IAM permissions](https://docs.aws.amazon.com/streams/latest/dev/learning-kinesis-module-one-iam.html) for `kinesis:PutRecords`.

Example IAM policy for Amazon Kinesis:

```javascript
{
  "Version": "2012-10-17",
  "Statement": [{
    "Effect": "Allow",
    "Action": "kinesis:PutRecords",
    "Resource": "arn:aws:kinesis:<your-aws-region>:<your-aws-account-id>:stream/<your-stream-name>" // replace the template fields
  }]
}
```

For more information visit the [Amazon Kinesis Developer Documentation](https://docs.aws.amazon.com/streams/latest/dev/learning-kinesis-module-one-iam.html).

Configure Kinesis:

```javascript title="src/index.js"
// Configure the plugin after adding it to the Analytics module
import { Amplify } from 'aws-amplify';

Amplify.configure({
  ...Amplify.getConfig(),
  Analytics: {
    Kinesis: {
      // REQUIRED -  Amazon Kinesis service region
      region: 'us-east-1',

      // OPTIONAL - The buffer size for events in number of items.
      bufferSize: 1000,

      // OPTIONAL - The number of events to be deleted from the buffer when flushed.
      flushSize: 100,

      // OPTIONAL - The interval in milliseconds to perform a buffer check and flush if necessary.
      flushInterval: 5000, // 5s

      // OPTIONAL - The limit for failed recording retries.
      resendLimit: 5
    }
  }
});
```

## Stream data

You can send a data to a Kinesis stream with the standard `record()` method:

```javascript title="src/index.js"
import { record } from 'aws-amplify/analytics/kinesis';

record({
  data: {
    // The data blob to put into the record
  },
  partitionKey: 'myPartitionKey',
  streamName: 'myKinesisStream'
});
```

## Flush events
The recorded events are saved in a buffer and sent to the remote server periodically *(You can tune it with the `flushInterval` option)*. If needed, you have the option to manually clear all the events from the buffer by using the 'flushEvents' API.

```javascript title="src/index.js"
import { flushEvents } from 'aws-amplify/analytics/kinesis';

flushEvents();
```

<InlineFilter filters={['react-native']}>

## Known Issues

When importing alternative service providers listed below, instead of the default Pinpoint provider:

- Kinesis (`aws-amplify/analytics/kinesis`)
- Kinesis Data Firehose (`aws-amplify/analytics/kinesis-firehose`)
- Personalize Event (`aws-amplify/analytics/personalize`)

you may encounter the following error when starting the bundler:

> Error: Unable to resolve module stream from /path/to/node_modules/@aws-sdk/... This is a [known issue](https://github.com/aws/aws-sdk-js-v3/issues/4877). Please follow [the steps](https://github.com/aws/aws-sdk-js-v3/issues/4877#issuecomment-1656007484) outlined in the issue to resolve the error.

</InlineFilter>


Contents of build-a-backend_add-aws-services_custom-resources_index.txt:
import { getCustomStaticPath } from '@/utils/getCustomStaticPath';

export const meta = {
  title: 'Custom resources',
  description: 'Learn how to write custom resources with the AWS CDK.',
  platforms: [
    'android',
    'angular',
    'flutter',
    'javascript',
    'nextjs',
    'react',
    'react-native',
    'swift',
    'vue'
  ]
};

export const getStaticPaths = async () => {
  return getCustomStaticPath(meta.platforms);
};

export function getStaticProps(context) {
  return {
    props: {
      meta
    }
  };

}

<Callout warning>

Custom resources allow you to integrate any AWS service into an Amplify backend. You are responsible for ensuring that your custom resources are secure, adhere to best practices, and work with the resources that Amplify creates for your app.

</Callout>

With Amplify Gen 2, you can add custom AWS resources to an Amplify app using the [AWS Cloud Development Kit (AWS CDK)](https://docs.aws.amazon.com/cdk/latest/guide/home.html), which is installed by default as part of the [`create-amplify`](https://www.npmjs.com/package/create-amplify) workflow. The AWS CDK is an open source software development framework that defines your cloud application resources using familiar programming languages, such as TypeScript.

The AWS CDK can be used within an Amplify app to add custom resources and configurations beyond what Amplify supports out of the box. For example, a developer could use CDK to hook up a Redis cache, implement custom security rules, deploy containers on AWS Fargate, or use any other AWS service.

The infrastructure defined through the AWS CDK code is deployed along with the Amplify app backend. This provides the simplicity of Amplify combined with the flexibility of CDK for situations where you need more customization.

<Callout info>

AWS CDK apps are composed of building blocks known as [constructs](https://docs.aws.amazon.com/cdk/v2/guide/constructs.html), which are composed together to form [stacks](https://docs.aws.amazon.com/cdk/api/v2/docs/aws-cdk-lib.Stack.html) and [apps](https://docs.aws.amazon.com/cdk/api/v2/docs/aws-cdk-lib.App.html). You can learn more in the [Concepts](https://docs.aws.amazon.com/cdk/v2/guide/core_concepts.html) section of the AWS Cloud Development Kit (AWS CDK) v2 Developer Guide.

</Callout>

With the Amplify code-first DX, you can add existing or custom CDK [constructs](https://docs.aws.amazon.com/cdk/v2/guide/constructs.html) to the [backend](/[platform]/how-amplify-works/concepts/#backend) of your Amplify app.

## Adding an existing CDK construct

The AWS CDK comes with [many existing constructs](https://docs.aws.amazon.com/cdk/api/v2/docs/aws-construct-library.html) that can be directly added to your Amplify backend. For example, to add an [Amazon Simple Queue Service (Amazon SQS)](https://aws.amazon.com/sqs/) queue and an [Amazon Simple Notification Service (Amazon SNS)](https://aws.amazon.com/sns/) topic to your backend, you can add the following to your `amplify/backend.ts` file.

```ts title="amplify/backend.ts"
import * as sns from 'aws-cdk-lib/aws-sns';
import * as sqs from 'aws-cdk-lib/aws-sqs';
import { defineBackend } from '@aws-amplify/backend';
import { auth } from './auth/resource';
import { data } from './data/resource';

const backend = defineBackend({
  auth,
  data
});

const customResourceStack = backend.createStack('MyCustomResources');

new sqs.Queue(customResourceStack, 'CustomQueue');
new sns.Topic(customResourceStack, 'CustomTopic');
```

Note the use of `backend.createStack()`. This method instructs the backend to create a new CloudFormation Stack for your custom resources to live in. You can create multiple custom stacks and you can place multiple resources in any given stack.

## Defining a CDK construct

<Callout>

Constructs are the basic building blocks of AWS CDK apps. A construct represents a "cloud component" and encapsulates everything AWS CloudFormation needs to create the component. [Read more](https://docs.aws.amazon.com/cdk/v2/guide/constructs.html).

</Callout>

As shown above, you can use the existing AWS CDK constructs directly in an Amplify backend. However, you may find yourself repeating some patterns of common constructs. Custom constructs allow you to encapsulate common patterns into reusable components. This helps you implement best practices, accelerate development, and maintain consistency across applications.

A common use case is creating a custom notification construct that combines a Lambda function with Amazon SNS and Amazon Simple Email Service (Amazon SES).

This AWS CDK construct implements a decoupled notification system using Amazon SNS and Lambda. It allows publishing notification messages to an SNS topic from one Lambda function, and processing those messages asynchronously using a separate Lambda subscribed to the topic.

The key components are:

- An Amazon SNS topic to receive notification messages
- A Lambda function to publish messages to the Amazon SNS topic
- A second Lambda subscribed to the topic that processes the messages and sends emails through Amazon SES

The publisher Lambda allows publishing a message containing the email subject, body text, and recipient address. The emailer Lambda retrieves messages from the SNS topic and handles sending the actual emails.

The `CustomNotifications` custom CDK construct can be defined as follows:

```ts title="amplify/custom/CustomNotifications/resource.ts"
import * as url from 'node:url';
import { Runtime } from 'aws-cdk-lib/aws-lambda';
import * as lambda from 'aws-cdk-lib/aws-lambda-nodejs';
import * as sns from 'aws-cdk-lib/aws-sns';
import * as subscriptions from 'aws-cdk-lib/aws-sns-subscriptions';
import { Construct } from 'constructs';

// message to publish
export type Message = {
  subject: string;
  body: string;
  recipient: string;
};

type CustomNotificationsProps = {
  /**
   * The source email address to use for sending emails
   */
  sourceAddress: string;
};

export class CustomNotifications extends Construct {
  public readonly topic: sns.Topic;
  constructor(scope: Construct, id: string, props: CustomNotificationsProps) {
    super(scope, id);

    const { sourceAddress } = props;

    // Create SNS topic
    this.topic = new sns.Topic(this, 'NotificationTopic');

    // Create Lambda to publish messages to SNS topic
    const publisher = new lambda.NodejsFunction(this, 'Publisher', {
      entry: url.fileURLToPath(new URL('publisher.ts', import.meta.url)),
      environment: {
        SNS_TOPIC_ARN: this.topic.topicArn
      },
      runtime: Runtime.NODEJS_18_X
    });

    // Create Lambda to process messages from SNS topic
    const emailer = new lambda.NodejsFunction(this, 'Emailer', {
      entry: url.fileURLToPath(new URL('emailer.ts', import.meta.url)),
      environment: {
        SOURCE_ADDRESS: sourceAddress
      },
      runtime: Runtime.NODEJS_18_X
    });

    // Subscribe emailer Lambda to SNS topic
    this.topic.addSubscription(new subscriptions.LambdaSubscription(emailer));

    // Allow publisher to publish to SNS topic
    this.topic.grantPublish(publisher);
  }
}
```

The Lambda function code for the `Publisher` is:

```ts title="amplify/custom/CustomNotifications/publisher.ts"
// amplify/custom/CustomNotifications/publisher.ts
import { PublishCommand, SNSClient } from '@aws-sdk/client-sns';
import type { Handler } from 'aws-lambda';
import type { Message } from './resource';

const client = new SNSClient({ region: process.env.AWS_REGION });

// define the handler that will publish messages to the SNS Topic
export const handler: Handler<Message, void> = async (event) => {
  const { subject, body, recipient } = event;
  const command = new PublishCommand({
    TopicArn: process.env.SNS_TOPIC_ARN,
    Message: JSON.stringify({
      subject,
      body,
      recipient
    })
  });
  try {
    const response = await client.send(command);
    console.log('published', response);
  } catch (error) {
    console.log('failed to publish message', error);
    throw new Error('Failed to publish message', { cause: error });
  }
};
```

The Lambda function code for the `Emailer` is:

```ts title="amplify/custom/CustomNotifications/emailer.ts"
// amplify/custom/CustomNotifications/emailer.ts
import { SESClient, SendEmailCommand } from '@aws-sdk/client-ses';
import type { SNSHandler } from 'aws-lambda';
import type { Message } from './resource';

const sesClient = new SESClient({ region: process.env.AWS_REGION });

// define the handler to process messages from the SNS topic and send via SES
export const handler: SNSHandler = async (event) => {
  for (const record of event.Records) {
    const message: Message = JSON.parse(record.Sns.Message);

    // send the message via email
    await sendEmail(message);
  }
};

const sendEmail = async (message: Message) => {
  const { recipient, subject, body } = message;

  const command = new SendEmailCommand({
    Source: process.env.SOURCE_ADDRESS,
    Destination: {
      ToAddresses: [recipient]
    },
    Message: {
      Body: {
        Text: { Data: body }
      },
      Subject: { Data: subject }
    }
  });

  try {
    const result = await sesClient.send(command);
    console.log(`Email sent to ${recipient}: ${result.MessageId}`);
  } catch (error) {
    console.error(`Error sending email to ${recipient}: ${error}`);
    throw new Error(`Failed to send email to ${recipient}`, { cause: error });
  }
};
```

The `CustomNotifications` CDK construct can then be added to the Amplify `backend` one or more times, with different properties for each instance.

```ts title="amplify/backend.ts"
// amplify/backend.ts
import { defineBackend } from '@aws-amplify/backend';
import { auth } from './auth/resource';
import { data } from './data/resource';
import { CustomNotifications } from './custom/CustomNotifications/resource';

const backend = defineBackend({
  auth,
  data
});

const customNotifications = new CustomNotifications(
  backend.createStack('CustomNotifications'),
  'CustomNotifications',
  { sourceAddress: 'sender@example.com' }
);

backend.addOutput({
  custom: {
    topicArn: customNotifications.topic.topicArn,
    topicName: customNotifications.topic.topicName,
  },
});
```

## Community CDK resources

The [Construct Hub](https://constructs.dev/) is a community-driven catalog of reusable infrastructure components. It is a place for developers to discover and share reusable patterns for AWS CDK, maintained by AWS.

In addition, the [example projects using the AWS CDK](https://github.com/aws-samples/aws-cdk-examples) repository contains a number of examples of reusable CDK constructs.

You can use these resources to create custom CDK constructs that can be used in your Amplify app.


Contents of build-a-backend_add-aws-services_deletion-backup-resources_index.txt:
import { getCustomStaticPath } from '@/utils/getCustomStaticPath';

export const meta = {
  title: 'Deletion protection and Backup resources',
  description: 'Learn how to enable deletion protection and backup on resources.',
  platforms: [
    'javascript',
    'react-native',
    'angular',
    'nextjs',
    'react',
    'vue'
  ],
};

export const getStaticPaths = async () => {
  return getCustomStaticPath(meta.platforms);
};

export function getStaticProps(context) {
  return {
    props: {
      platform: context.params.platform,
      meta
    }
  };
}


<Callout warning>

Deleting a Amplify sandbox with a resource enabled with deletion protection, the deploy process will fail and the resource will need to be manually deleted on the AWS console. 

</Callout>

Using the [AWS Cloud Development Kit (CDK)](https://docs.aws.amazon.com/cdk/latest/guide/home.html) we can configure Amplify generated resource to enable deletion protection and backups on supported resources. For example, you can use AWS CDK to enable [Point-in-time recovery for DynamoDB tables](https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/PointInTimeRecovery.html), or use [AWS Backup](https://aws.amazon.com/backup/) as a advanced backup option.

Using underlying CDK construct properties you can modify resource configurations. This allows you to customize backend resources beyond what is offered via the `define*` functions.

## Enabling deletion protection on a Auth resource

For example, if you would like to enable deletion protection on a Cognito user pool resource created by Amplify Auth.

```ts title="amplify/backend.ts"
import { defineBackend } from '@aws-amplify/backend';
import { auth } from './auth/resource';
import { data } from './data/resource';

const backend = defineBackend({
  auth,
  data
});

// highlight-start
const { cfnUserPool } = backend.auth.resources.cfnResources
cfnUserPool.deletionProtection = "ACTIVE";
// highlight-end
```

## Enabling Deletion protection on a Data resource

For example, if you would like to enable Deletion protection on all DynamoDB tables created by GraphQL API.

```ts title="amplify/backend.ts"
import { defineBackend } from '@aws-amplify/backend';
import { auth } from './auth/resource';
import { data } from './data/resource';

const backend = defineBackend({
  auth,
  data
});

// highlight-start
const { amplifyDynamoDbTables } = backend.data.resources.cfnResources;
for (const table of Object.values(amplifyDynamoDbTables)) {
  table.deletionProtectionEnabled = true;
}
// highlight-end
```

## Enabling Point-in-time recovery for DynamoDB tables

For example, enabling Point-in-time recovery for all the DynamoDB tables created by GraphQL API. By default Point-in-Time recovery retains backups for 35 days.

```ts title="amplify/backend.ts"
import { defineBackend } from '@aws-amplify/backend';
import { auth } from './auth/resource';
import { data } from './data/resource';

const backend = defineBackend({
  auth,
  data
});

// highlight-start
const { amplifyDynamoDbTables } = backend.data.resources.cfnResources;
for (const table of Object.values(amplifyDynamoDbTables)) {
  table.pointInTimeRecoveryEnabled = true;
}
// highlight-end
```

## Enabling Backups for DynamoDB tables

For example, if your DynamoDB tables requires backups that extend the default 35 days point-in-time recovery, AWS Backup service can be utilized to centralize and automate backups for DynamoDB tables. 
The example below outlines a backup plan configured to run daily at midnight, for all DynamoDB tables. 

```ts title="amplify/backend.ts"
import { defineBackend } from "@aws-amplify/backend";
// highlight-start
import {
  BackupPlan,
  BackupPlanRule,
  BackupResource,
  BackupVault,
} from "aws-cdk-lib/aws-backup";
import { Schedule } from "aws-cdk-lib/aws-events";
import { Duration } from "aws-cdk-lib/core";
// highlight-end
import { auth } from "./auth/resource";
import { data } from "./data/resource";

const backend = defineBackend({
  auth,
  data,
});

// highlight-start
const backupStack = backend.createStack("backup-stack");
const myTables = Object.values(backend.data.resources.tables);

const vault = new BackupVault(backupStack, "BackupVault", {
  backupVaultName: "backup-vault",
});

const plan = new BackupPlan(backupStack, "BackupPlan", {
  backupPlanName: "backup-plan",
  backupVault: vault,
});

plan.addRule(
  new BackupPlanRule({
    deleteAfter: Duration.days(60),
    ruleName: "backup-plan-rule",
    scheduleExpression: Schedule.cron({
      minute: "0",
      hour: "0",
      day: "*",
      month: "*",
      year: "*",
    }),
  })
);

plan.addSelection("BackupPlanSelection", {
  resources: myTables.map((table) => BackupResource.fromDynamoDbTable(table)),
  allowRestores: true,
});
// highlight-end
```

## Retaining resources on stack deletion

For example, if you would like to retain a resource on stack deletion, you can use the `applyRemovalPolicy` property on the resource to add a retention policy.

<Callout>

`ampx sandbox delete` ignores any resource removal policy and always deletes all resources.

</Callout>

```ts title="amplify/backend.ts"
import { defineBackend } from "@aws-amplify/backend";
import { auth } from "./auth/resource";
import { data } from "./data/resource";
import { RemovalPolicy } from "aws-cdk-lib";
import { storage } from "./storage/resource";

const backend = defineBackend({
  auth,
  data,
  storage,
});

// highlight-start
// Retain the S3 bucket on stack deletion
backend.storage.resources.bucket.applyRemovalPolicy(RemovalPolicy.RETAIN);

// Retain the Cognito user pool on stack deletion
backend.auth.resources.userPool.applyRemovalPolicy(RemovalPolicy.RETAIN);

// Retain the DynamoDB table on stack deletion
backend.data.resources.cfnResources.amplifyDynamoDbTables["Todo"].applyRemovalPolicy(RemovalPolicy.RETAIN);
// highlight-end
```


Contents of build-a-backend_add-aws-services_geo_amazon-location-sdk_index.txt:
import { getCustomStaticPath } from '@/utils/getCustomStaticPath';

export const meta = {
  title: 'Use Amazon Location Service SDK',
  description: 'For specialized use cases where Amplify does not provide the functionality, you can use the escape hatch to access a low-level client instance for Amazon Location Service.',
  platforms: [
    'javascript',
    'swift',
    'android',
    'angular',
    'nextjs',
    'react',
    'vue'
  ],
};

export const getStaticPaths = async () => {
  return getCustomStaticPath(meta.platforms);
};

export function getStaticProps(context) {
  return {
    props: {
      platform: context.params.platform,
      meta
    }
  };
}

<InlineFilter filters={['javascript', 'angular', 'react', 'vue', 'react-native', 'nextjs']}>

Amplify Geo provides solutions for common use cases with [Amazon Location Service](https://aws.amazon.com/location/) but for any functionality that is not currently supported by Amplify Geo you can access the [Amazon Location Service SDK](https://github.com/aws/aws-sdk-js-v3/tree/main/clients/client-location) directly.

Follow this guide to get started with the `aws-sdk` for Amazon Location Service using Amplify Auth credentials.

## Overview

In this tutorial, we’ll go over the following:

- Setting up the AWS SDK JavaScript v3 package for the Amazon Location Service SDK calls with Amplify auth.
- Code examples using the Amazon Location Service SDK.

## Installing SDK dependencies

The first step to using the SDKs in the client is to install the necessary dependencies with the following command:

```bash title="Terminal" showLineNumbers={false}
npm add @aws-sdk/client-location
```

## Connecting your app to Amazon Location Service

In the following procedure, you’ll connect your app to the Amazon Location Service APIs.

**To connect your app to the Amazon Location Service**

In your React App, open `src/App.js` file, and call the following function to initialize the Amazon Location Service client:

```javascript
import { Amplify } from 'aws-amplify';
import { fetchAuthSession } from 'aws-amplify/auth';
import {
  LocationClient,
  AssociateTrackerConsumerCommand
} from '@aws-sdk/client-location';
import outputs from '../amplify_outputs.json';
Amplify.configure(outputs);

const createClient = async () => {
  const session = await fetchAuthSession();
  const client = new LocationClient({
    credentials: session.credentials,
    region: amplifyconfig.aws_project_region
  });
  return client;
};
```

You’ve now successfully connected your app to the Amazon Location Service.

## Using the Amazon Location Service APIs

In order to access Amazon Location Service APIs, ensure you've provisioned resources and configured your app using the instructions in either [Amplify Geo Maps docs](/[platform]/build-a-backend/add-aws-services/geo/set-up-geo/) or the [Amazon Location Service console](https://console.aws.amazon.com/location/home#/create).

You can check out the [Amazon Location API Reference documentation](https://docs.aws.amazon.com/location/index.html) for a complete list of supported features.

### Example: Getting Device Position

This example requires you to have first provisioned a Tracker resource using the [Amazon Location Service console](https://console.aws.amazon.com/location/tracking/home#/create).

The following code details how to use the Amazon Location Service APIs to update a device position and get a device position using the tracker you just created:

```javascript
// UpdateDevicePosition API
const params = {
  TrackerName: 'trackerId',
  Updates: [
    {
      DeviceId: 'deviceId',
      Position: [-122.431297, 37.773972],
      SampleTime: new Date()
    }
  ]
};
const command = new BatchUpdateDevicePositionCommand(params);
client.send(command, (err, data) => {
  if (err) console.error(err);
  if (data) console.log(data);
});

// GetDevicePosition API
const client = await createClient();
const params = {
  TrackerName: 'trackerId',
  DeviceId: 'deviceId'
};
const command = new GetDevicePositionCommand(params);
client.send(command, (err, data) => {
  if (err) console.error(err);
  if (data) console.log(data);
});
```

</InlineFilter>

<InlineFilter filters={['android']}>

If you need functionality in the AWS services used by the Amplify Geo category that isn't available, we provide an escape hatch so you can get a reference to that service.

Note: If you provisioned your Geo resources via CDK, then the IAM policy will be specifically scoped to only allow actions required by the library.
Please [adjust your authorization permissions](/[platform]/build-a-backend/add-aws-services/geo/existing-resources/) accordingly for your escape hatch use-cases.

<BlockSwitcher>

<Block name="Java">

<Callout>

Learn more about consuming Kotlin clients from Java using either a blocking interface or an equivalent async interface based on futures [here](https://github.com/awslabs/smithy-kotlin/blob/main/docs/design/kotlin-smithy-sdk.md#java-interop).

</Callout>

```java
import android.util.Log;

import androidx.annotation.NonNull;

import com.amplifyframework.core.Amplify;
import com.amplifyframework.geo.location.AWSLocationGeoPlugin;

import aws.sdk.kotlin.services.location.LocationClient;
import aws.sdk.kotlin.services.location.model.ListMapsRequest;
import aws.sdk.kotlin.services.location.model.ListMapsResponse;
import kotlin.Unit;
import kotlin.coroutines.Continuation;
import kotlin.coroutines.CoroutineContext;
import kotlinx.coroutines.GlobalScope;
```

```java
// Obtain reference to the plugin
AWSLocationGeoPlugin geoPlugin = (AWSLocationGeoPlugin)
        Amplify.Geo.getPlugin("awsLocationGeoPlugin");
LocationClient locationClient = geoPlugin.getEscapeHatch();

// Send a new request to the Location Maps endpoint directly using the client
ListMapsRequest request = ListMapsRequest.Companion.invoke(requestBuilder -> Unit.INSTANCE);
locationClient.listMaps(request, new Continuation<ListMapsResponse>() {
    @NonNull
    @Override
    public CoroutineContext getContext() {
        return GlobalScope.INSTANCE.getCoroutineContext();
    }

    @Override
    public void resumeWith(@NonNull Object resultOrException) {
        Log.i("MyAmplifyApp", resultOrException.toString());
    }
});
```

</Block>
<Block name="Kotlin">

```kotlin
import android.util.Log
import aws.sdk.kotlin.services.location.LocationClient
import aws.sdk.kotlin.services.location.model.ListMapsRequest
import com.amplifyframework.core.Amplify
```

```kotlin
// Obtain reference to the Amazon Location Service client
val geoPlugin = Amplify.Geo.getPlugin("awsLocationGeoPlugin")
val locationClient = geoPlugin.escapeHatch as LocationClient

// Send a new request to the Location Maps endpoint directly using the client
val request = ListMapsRequest {  }
val response = locationClient.listMaps(request)
Log.i("MyAmplifyApp", response.entries.toString())
```

</Block>
</BlockSwitcher>

## Documentation Resources

* [How to manage Amazon Location Service resources through console](https://docs.aws.amazon.com/location/latest/developerguide/welcome.html)

**Maps**
* [Using Amazon Location Maps in your application](https://docs.aws.amazon.com/location/latest/developerguide/using-maps.html)
* [Amazon Location Maps API Reference](https://docs.aws.amazon.com/location-maps/latest/APIReference/API_Operations.html)

**Places**
* [Searching place and geolocation data using Amazon Location](https://docs.aws.amazon.com/location/latest/developerguide/searching-for-places.html)
* [Amazon Location Places API Reference](https://docs.aws.amazon.com/location-places/latest/APIReference/API_Operations.html)

**Device Tracking**
* [Managing your tracker resources](https://docs.aws.amazon.com/location/latest/developerguide/managing-trackers.html)
* [Amazon Location Trackers API Reference](https://docs.aws.amazon.com/location-trackers/latest/APIReference/API_Operations.html)

</InlineFilter>

<InlineFilter filters={['swift']}>

If you need functionality in the AWSLocation framework used by the Amplify Geo category that isn't available, we provide an escape hatch so you can reference it directly.

Note: If you provisioned your Geo resources, then the IAM policy will be specifically scoped to only allow actions required by the library. Please [adjust your authorization permissions](/[platform]/build-a-backend/add-aws-services/geo/existing-resources/) accordingly for your escape hatch use-cases.

```swift
import AWSLocation
```

Then retrieve the escape hatch and call methods on `AWSLocation` directly:

```swift
do {
    // Retrieve AWSLocationGeoPlugin
    let plugin = try Amplify.Geo.getPlugin(for: "awsLocationGeoPlugin")
    guard let locationPlugin = plugin as? AWSLocationGeoPlugin else {
        return
    }

    // Retrieve reference to AWSLocation
    let awsLocation = locationPlugin.getEscapeHatch()

    // Make Request
    var request = ListMapsInput()
    request.maxResults = 5
    let response = try await awsLocation.listMaps(input: request)
    // handle response ...
} catch {
    print("Error occurred while fetching the escape hatch \(error)")
}
```

## Documentation Resources

- [How to manage Amazon Location Service resources through console](https://docs.aws.amazon.com/location/latest/developerguide/welcome.html)

**Maps**

- [Using Amazon Location Maps in your application](https://docs.aws.amazon.com/location/latest/developerguide/using-maps.html)
- [Amazon Location Maps API Reference](https://docs.aws.amazon.com/location-maps/latest/APIReference/API_Operations.html)

**Places**

- [Searching place and geolocation data using Amazon Location](https://docs.aws.amazon.com/location/latest/developerguide/searching-for-places.html)
- [Amazon Location Places API Reference](https://docs.aws.amazon.com/location-places/latest/APIReference/API_Operations.html)

**Device Tracking**

- [Managing your tracker resources](https://docs.aws.amazon.com/location/latest/developerguide/managing-trackers.html)
- [Amazon Location Trackers API Reference](https://docs.aws.amazon.com/location-trackers/latest/APIReference/API_Operations.html)

</InlineFilter>


Contents of build-a-backend_add-aws-services_geo_configure-geofencing_index.txt:
import { getCustomStaticPath } from '@/utils/getCustomStaticPath';

export const meta = {
  title: 'Configure a geofence collection',
  description: 'Create and manage collections of Geofences',
  platforms: [
    'angular',
    'javascript',
    'nextjs',
    'react',
    'vue'
  ]
};

export const getStaticPaths = async () => {
  return getCustomStaticPath(meta.platforms);
};

export function getStaticProps(context) {
  return {
    props: {
      platform: context.params.platform,
      meta
    }
  };
}

A Geofence is a virtual perimeter for a real-world geographic area. A Geofence contains points or vertices that form a closed boundary, defining an area of interest. Geofence collections store one or multiple Geofences.

## Setup a new Geofence Collection

```ts title="amplify/backend.ts"
import { defineBackend } from "@aws-amplify/backend";
import { Policy, PolicyStatement } from "aws-cdk-lib/aws-iam";
import { CfnGeofenceCollection } from "aws-cdk-lib/aws-location";
import { auth } from "./auth/resource";
import { data } from "./data/resource";

const backend = defineBackend({
  auth,
  data,
  // additional resources
});

const geoStack = backend.createStack("geo-stack");

// create a location services geofence collection
const myGeofenceCollection = new CfnGeofenceCollection(
  geoStack,
  "GeofenceCollection",
  {
    collectionName: "myGeofenceCollection",
    pricingPlan: "RequestBasedUsage",
    tags: [
      {
        key: "name",
        value: "myGeofenceCollection",
      },
    ],
  }
);

// create an IAM policy to allow interacting with geofence collection resource
const myGeofenceCollectionPolicy = new Policy(
  geoStack,
  "GeofenceCollectionPolicy",
  {
    policyName: "myGeofenceCollectionPolicy",
    statements: [
      new PolicyStatement({
        actions: [
          "geo:GetGeofence",
          "geo:PutGeofence",
          "geo:BatchPutGeofence",
          "geo:BatchDeleteGeofence",
          "geo:ListGeofences",
        ],
        resources: [myGeofenceCollection.attrArn],
      }),
    ],
  }
);

// apply the policy to the authenticated and unauthenticated roles
backend.auth.resources.authenticatedUserIamRole.attachInlinePolicy(myGeofenceCollectionPolicy);
backend.auth.resources.unauthenticatedUserIamRole.attachInlinePolicy(myGeofenceCollectionPolicy);

// patch the geofence collection resource to the expected output configuration
backend.addOutput({
  geo: {
    geofence_collections: {
      default: myGeofenceCollection.collectionName,
      items: [myGeofenceCollection.collectionName],
    },
  },
});
```

## Geofence Collection Pricing Plan

The pricing plan for the Geofence Collection will be set to `RequestBasedUsage`. We advice you to go through the [location service pricing](https://aws.amazon.com/location/pricing/) along with the [location service terms](https://aws.amazon.com/service-terms/) (_82.5 section_) to learn more about the pricing plan.

#### Group access

To scope access permissions based on [Cognito User Groups](https://docs.aws.amazon.com/cognito/latest/developerguide/cognito-user-pools-user-groups.html)

1. Create a Cognito User Pool Group

```ts title="amplify/auth/resource.ts"
import { defineAuth } from '@aws-amplify/backend';

export const auth = defineAuth({
  loginWith: {
    email: true,
  },
  groups: ["User"],
});
```

2. Add permissions to the Cognito User Pool Group role

```ts title="amplify/backend.ts"
const myGeofenceCollectionPolicy = new Policy(
  geoStack,
  "GeofenceCollectionPolicy",
  {
    policyName: "myGeofenceCollectionPolicy",
    statements: [
      new PolicyStatement({
        actions: [
          "geo:GetGeofence",
          "geo:PutGeofence",
          "geo:BatchPutGeofence",
          "geo:BatchDeleteGeofence",
          "geo:ListGeofences",
        ],
        resources: [myGeofenceCollection.attrArn],
      }),
    ],
  }
);

backend.auth.resources.groups["User"].role.attachInlinePolicy(myGeofenceCollectionPolicy);
```

> Note: If you combine `Auth/Guest user access` and `Individual Group access`, users who are members of a group will only be granted the permissions of the group, and not the authenticated user permissions. The permissions apply to ALL Geofences in a collection. For example, If you add `Read` permission such as `ListGeofences` and `GetGeofence` to `User` Cognito group, ALL users added to that group will be able to read the properties of ALL Geofences in that Geofence collection.

#### Using the AWS SDK for Javascript

Alternatively, if you want to add users to an existing Cognito user pool group programmatically, you can use the AWS SDK for Javascript. Refer to the [API documentation](https://docs.aws.amazon.com/AWSJavaScriptSDK/latest/AWS/CognitoIdentityServiceProvider.html#adminAddUserToGroup).



<InlineFilter filters={["javascript", "react", "angular", "nextjs", "vue"]}>

<Callout>

**Note:** After you have provisioned the Geofence Collection, depending on your application's use-case, you can also add Geofences to the provisioned Geofence Collection programmatically. Refer this [API documentation](/[platform]/build-a-backend/add-aws-services/geo/geofences/#savegeofences) for more information.

</Callout>

</InlineFilter>


Contents of build-a-backend_add-aws-services_geo_configure-location-search_index.txt:
import { getCustomStaticPath } from '@/utils/getCustomStaticPath';
                  
export const meta = {
  title: 'Configure location search',
  description: 'Create and manage location search indices or place indices that are used to search for places in your application.',
  platforms: [
    'android',
    'angular',
    'javascript',
    'nextjs',
    'react',
    'swift',
    'vue'
  ],
};

export const getStaticPaths = async () => {
  return getCustomStaticPath(meta.platforms);
};

export function getStaticProps(context) {
  return {
    props: {
      platform: context.params.platform,
      meta
    }
  };
}
          

Amplify's `geo` category enables you to search by places, addresses, and coordinates in your app with "place index" resources.

## Setup a new Location Search Index

```ts title="amplify/backend.ts"
import { defineBackend } from "@aws-amplify/backend";
import { Policy, PolicyStatement } from "aws-cdk-lib/aws-iam";
// highlight-next-line
import { CfnMap, CfnPlaceIndex } from "aws-cdk-lib/aws-location";
import { auth } from "./auth/resource";
import { data } from "./data/resource";

const backend = defineBackend({
  auth,
  data,
  // additional resources
});

const geoStack = backend.createStack("geo-stack");

// create a location services map
const map = new CfnMap(geoStack, "Map", {
  mapName: "myMap",
  description: "Map",
  configuration: {
    style: "VectorEsriNavigation",
  },
  pricingPlan: "RequestBasedUsage",
  tags: [
    {
      key: "name",
      value: "myMap",
    },
  ],
});


// create an IAM policy to allow interacting with geo resource
const myGeoPolicy = new Policy(geoStack, "GeoPolicy", {
  policyName: "myGeoPolicy",
  statements: [
    new PolicyStatement({
      actions: [
        "geo:GetMapTile",
        "geo:GetMapSprites",
        "geo:GetMapGlyphs",
        "geo:GetMapStyleDescriptor",
      ],
      resources: [map.attrArn],
    }),
  ],
});

// apply the policy to the authenticated and unauthenticated roles
backend.auth.resources.authenticatedUserIamRole.attachInlinePolicy(myGeoPolicy);
backend.auth.resources.unauthenticatedUserIamRole.attachInlinePolicy(myGeoPolicy);

// highlight-start
// create a location services place index
const myIndex = new CfnPlaceIndex(geoStack, "PlaceIndex", {
  dataSource: "Here",
  dataSourceConfiguration: {
    intendedUse: "SingleUse",
  },
  indexName: "myPlaceIndex",
  pricingPlan: "RequestBasedUsage",
  tags: [
    {
      key: "name",
      value: "myPlaceIndex",
    },
  ],
});

// create a policy to allow access to the place index
const myIndexPolicy = new Policy(geoStack, "IndexPolicy", {
  policyName: "myIndexPolicy",
  statements: [
    new PolicyStatement({
      actions: [
        "geo:SearchPlaceIndexForPosition",
        "geo:SearchPlaceIndexForText",
        "geo:SearchPlaceIndexForSuggestions",
        "geo:GetPlace",
      ],
      resources: [myIndex.attrArn],
    }),
  ],
});

// attach the policy to the authenticated and unauthenticated IAM roles
backend.auth.resources.authenticatedUserIamRole.attachInlinePolicy(myIndexPolicy);
backend.auth.resources.unauthenticatedUserIamRole.attachInlinePolicy(myIndexPolicy);
// highlight-end

// patch the place index resource to the expected output configuration
backend.addOutput({
  geo: {
    aws_region: geoStack.region,
    maps: {
      items: {
        [map.mapName]: {
          style: "VectorEsriNavigation",
        },
      },
      default: map.mapName,
    },
// highlight-start
    search_indices: {
      default: myIndex.indexName,
      items: [myIndex.indexName],
    },
// highlight-end
  },
});
```


## Location Search Index Pricing Plan
The pricing plan for Search Index will be set to `RequestBasedUsage`.
We advice you to go through the [location service pricing](https://aws.amazon.com/location/pricing/) along with the [location service terms](https://aws.amazon.com/service-terms/) (_82.5 section_) to learn more about the pricing plan.


## Advanced Settings
You can optionally configure the data provider and result storage location for your location search index.

### Location Search data provider
You can select a data provider as the source for geocoding, reverse geocoding and searches.
Each provider gathers and curates their data using different means. They may also have varying expertise in different regions of the world.
The available data providers of geospatial data are shown. To learn more about data providers, please refer this [location service documentation](https://docs.aws.amazon.com/location/latest/developerguide/what-is-data-provider.html).

- Here – For additional information about HERE Technologies, see [Here guide](https://docs.aws.amazon.com/location/latest/developerguide/HERE.html).
- Esri – For additional information about Esri, see [Esri guide](https://docs.aws.amazon.com/location/latest/developerguide/esri.html).

<Callout>

**Note:** If your application is tracking or routing assets you use in your business (such as delivery vehicles or employees), you may only use `HERE` as your geolocation provider. 
See section 82 of the [AWS service terms](https://aws.amazon.com/service-terms/) for more details.

</Callout>

### Location Search result storage location
You can specify how the results of a search operation will be stored by the caller.

- SingleUse - specifies that the results won't be stored.
- Storage - specifies that the result can be cached or stored in a database.

Refer [this location service doc](https://docs.aws.amazon.com/location-places/latest/APIReference/API_DataSourceConfiguration.html#locationplaces-Type-DataSourceConfiguration-IntendedUse) for more information.


Contents of build-a-backend_add-aws-services_geo_existing-resources_index.txt:
import { getCustomStaticPath } from '@/utils/getCustomStaticPath';

export const meta = {
  title: 'Use existing Amazon Location resources',
  description: 'Configure Amplify Geo to use existing Amazon Location Service resources by referencing them in your configuration.',
  platforms: [
    'javascript',
    'swift',
    'android',
    'angular',
    'nextjs',
    'react',
    'vue'
  ],
};

export const getStaticPaths = async () => {
  return getCustomStaticPath(meta.platforms);
};

export function getStaticProps(context) {
  return {
    props: {
      platform: context.params.platform,
      meta
    }
  };
}

To use existing Amazon Location Services resources with your Amplify backend or frontend application, use the `addOutput` method to surface backend resource outputs to the `amplify_outputs.json` file:

```ts title="amplify/backend.ts"
import { defineBackend } from "@aws-amplify/backend"

const backend = defineBackend({})

backend.addOutput({
  geo: {
    aws_region: "<your-aws-region>",
    maps: {
      items: {
        "<your-friendly-map-name>": {
          name: "<your-map-name>",
          style: "<your-map-style>",
        },
      },
      default: "<your-friendly-map-name>",
    },
  },
})
```

## Authorization permissions

To use your existing Amazon Location Service resources (i.e. maps and place indices) with Amplify Geo, you need to ensure your role has the right authorization permissions through Cognito.

**Note:** Here is a guide on [Creating an Amazon Cognito identity pool for use with Amazon Location Service](https://docs.aws.amazon.com/location/latest/developerguide/authenticating-using-cognito.html)

There are two roles created by Cognito: an "authenticated role" that grants signed-in-user-level access and an "unauthenticated role" that allows unauthenticated access to resources. Attach the following policies for the appropriate resources and roles (Auth and/or Unauth). Replace `{region}`, `{account-id}`, and `{enter Map/PlaceIndex name}` with the correct items. Note that certain actions cannot be performed with unauthenticated access. The list of actions allowed for the Unauth role is in the [Granting access to Amazon Location Service guide](https://docs.aws.amazon.com/location/latest/developerguide/how-to-access.html).

```json
{
  "Version": "2012-10-17",
  "Statement": [
    {
      "Sid": "GetTiles",
      "Effect": "Allow",
      "Action": [
        "geo:GetMapTile",
        "geo:GetMapSprites",
        "geo:GetMapGlyphs",
        "geo:GetMapStyleDescriptor"
      ],
      "Resource": "arn:aws:geo:<your-geo-region>:<your-account-id>:map/<your-map-name>"
    },
    {
      "Sid": "Search",
      "Effect": "Allow",
      "Action": [
        "geo:SearchPlaceIndexForPosition",
        "geo:SearchPlaceIndexForText"
      ],
      "Resource": "arn:aws:geo:<your-geo-region>:<your-account-id>:place-index/<your-index-name>"
    },
    {
      "Sid": "Geofence",
      "Effect": "Allow",
      "Action": [
        "geo:GetGeofence",
        "geo:PutGeofence",
        "geo:BatchPutGeofence",
        "geo:BatchDeleteGeofence",
        "geo:ListGeofences",
      ],
      "Resource": "arn:aws:geo:<your-geo-region>:<your-account-id>:geofence-collection/<your-collection-name>"
    }
  ]
}
```

<InlineFilter filters={['javascript', 'angular', 'react', 'vue', 'react-native', 'nextjs']}>
## Configure client library directly

You can first import and configure the generated `amplify_outputs.json`. You can then manually configure Amplify Geo like this:

```js
import { Amplify } from 'aws-amplify';
import outputs from '../amplify_outputs.json';

Amplify.configure(outputs);
Amplify.configure({
  ...Amplify.getConfig(),
  Geo: {
    LocationService: {
      maps: {
        items: {
          <your-map-name>: {
            // REQUIRED - Amazon Location Service Map resource name
            style: 'VectorEsriStreets' // REQUIRED - String representing the style of map resource
          }
        },
        default: '<your-preferred-default-map>' // REQUIRED - Amazon Location Service Map resource name to set as default
      },
      search_indices: {
        items: ['<your-geo-index>'], // REQUIRED - Amazon Location Service Place Index name
        default: '<your-default-index>' // REQUIRED - Amazon Location Service Place Index name to set as default
      },
      geofenceCollections: {
        items: ['<your-geo-collection>'], // REQUIRED - Amazon Location Service Geofence Collection name
        default: '<your-default-collection>' // REQUIRED - Amazon Location Service Geofence Collection name to set as default
      },
      region: '<your-geo-region>' // REQUIRED - Amazon Location Service Region
    }
  }
});
```

Now you can proceed to [displaying a map](/[platform]/build-a-backend/add-aws-services/geo/maps/) or [adding location search](/[platform]/build-a-backend/add-aws-services/geo/location-search/) to your app.
</InlineFilter>


Contents of build-a-backend_add-aws-services_geo_geofences_index.txt:
import { getCustomStaticPath } from '@/utils/getCustomStaticPath';

export const meta = {
  title: 'Work with geofences',
  description: 'Provision and manage geofences in your application with Amplify Geo.',
  platforms: [
    'javascript',
    'angular',
    'nextjs',
    'react',
    'vue'
  ],
};

export const getStaticPaths = async () => {
  return getCustomStaticPath(meta.platforms);
};

export function getStaticProps(context) {
  return {
    props: {
      platform: context.params.platform,
      meta
    }
  };
}

## Provisioning geofence resources

First, make sure you've provisioned a geofence collection resource and configured your app using the instructions in either [Configure a geofence collection](/[platform]/build-a-backend/add-aws-services/geo/configure-geofencing/) or [Use existing Amazon Location Service resources](/[platform]/build-a-backend/add-aws-services/geo/existing-resources/) and you have already setup [displaying a map](/[platform]/build-a-backend/add-aws-services/geo/maps/) in your application.

## Manage Geofences in Your Application

To add a geofence management component to your map, you can use the [amplify-geofence-control](https://github.com/aws-amplify/maplibre-gl-js-amplify/blob/geo/API.md#amplifygeofencecontrol).

Install the necessary dependencies with the following command:

```bash title="Terminal" showLineNumbers={false} 
npm add aws-amplify \
  @aws-amplify/geo \
  @aws-amplify/ui-react \
  @aws-amplify/ui-react-geo
```

> **Note:** Make sure that `aws-amplify @aws-amplify/geo` version `6.0.0` or above are installed.

First, create a map onto which you want to add the geofence management component. See the guide on [creating and displaying maps](/[platform]/build-a-backend/add-aws-services/geo/maps).

Then, import [AmplifyGeofenceControl](https://github.com/aws-amplify/maplibre-gl-js-amplify/blob/geo/API.md#amplifygeofencecontrol) from "maplibre-gl-js-amplify", create a new instance of this control and add it to your MapLibre map instance.

> **Notes:** To use Geofence Controls the user will need to be authenticated with the administrative Cognito user associated with the Geofence Collection you created. Below is an example using React and the [Amplify Authenticator](https://ui.docs.amplify.aws/react/components/authenticator).

<BlockSwitcher>

  <Block name="Javascript">

**Note:** When using the existing [maps implementation](/[platform]/build-a-backend/add-aws-services/geo/maps) you can add the Geofence control to an existing map

```diff
import { useEffect, useRef } from "react";
- import { createMap } from "maplibre-gl-js-amplify";
+ import { createMap, AmplifyGeofenceControl } from "maplibre-gl-js-amplify";
+ import { withAuthenticator } from "@aws-amplify/ui-react";
+ import "@aws-amplify/ui-react/styles.css";
+ import "maplibre-gl-js-amplify/dist/public/amplify-ctrl-geofence.css";
import "maplibre-gl/dist/maplibre-gl.css";

function Map() {
  const mapRef = useRef(null); // Reference to the map DOM element

  // Wrapping your code in a useEffect allows us to run initializeMap after the div has been rendered into the DOM
  useEffect(() => {
    let map;
    async function initializeMap() {
      // You only want to initialize the underlying maplibre map after the div has been rendered
      if (mapRef.current != null) {
        map = await createMap({
          container: mapRef.current,
          center: [-122.431297, 37.773972],
          zoom: 11,
        });
      }

+     const control = new AmplifyGeofenceControl()
+     map.addControl(control);
  }
  initializeMap();

    // Cleans up and maplibre DOM elements and other resources - https://maplibre.org/maplibre-gl-js/docs/API/classes/Map/#remove
    return function cleanup() {
      if (map != null) map.remove();
    };
  }, []);

 return (
   <div className="App">
     <div ref={mapRef} id="map" />
   </div>
 );
}

export default withAuthenticator(Map);
```

  </Block>

  <Block name="React">

**Note:** When using the [Amplify React MapView component](https://ui.docs.amplify.aws/react/components/geo) you can use the [`useControl` hook from react-map-gl](https://visgl.github.io/react-map-gl/docs/api-reference/use-control) to render the Geofence control component. The [react-map-gl](https://visgl.github.io/react-map-gl) dependency is already installed through `@aws-amplify/ui-react-geo`, you do not need to install it manually.

```javascript
import React from 'react';
import { Amplify } from 'aws-amplify';
import { withAuthenticator } from '@aws-amplify/ui-react';
import { MapView } from '@aws-amplify/ui-react-geo';
import { useControl } from 'react-map-gl';
import { AmplifyGeofenceControl } from 'maplibre-gl-js-amplify';
import '@aws-amplify/ui-react/styles.css';
import '@aws-amplify/ui-react-geo/styles.css';
import 'maplibre-gl-js-amplify/dist/public/amplify-ctrl-geofence.css';
import outputs from '../amplify_outputs.json';
Amplify.configure(outputs);

function Geofence() {
  useControl(() => new AmplifyGeofenceControl());

  return null;
}

function App({ signOut }) {
  return (
    <div className="App">
      <MapView
        initialViewState={{
          latitude: 37.8,
          longitude: -122.4,
          zoom: 14
        }}
      >
        <Geofence />
      </MapView>
    </div>
  );
}

export default withAuthenticator(App);
```

  </Block>

</BlockSwitcher>

> **Note:** Ensure that your package bundler (webpack, rollup, etc) is configured to handle css files. Check out the webpack documentation [here](https://webpack.js.org/loaders/css-loader/).

!['Create Geofence' interface showing the process of selecting multiple points on a map to define the perimeter of a new geofence area](/images/geofence-create.png)

![ 'Edit Geofence' interface displaying the selection of an area on a map by adjusting multiple points around the perimeter of an existing geofence](/images/geofence-edit.png)

## Geofence API

If you are using a different mapping library or need a programmatic approach to managing geofences, the `@aws-amplify/geo` package provides methods for managing geofences, but not geofence collections.

First, you need to import Geo from the `@aws-amplify/geo` package.

```javascript
import { Geo } from '@aws-amplify/geo';
```

### saveGeofences

`saveGeofences` is used to save geofences to your collection. It can take a single geofence or an array of geofences.

#### API

```javascript
Geo.saveGeofences(geofences, options) => Promise<SaveGeofenceResults>;
```

#### Parameters

- `geofences` - can be a single geofence object, or an array of geofence objects to save to a collection.
- `options` - optional options object for saving geofences
  - `collectionName` - the name of the collection to save geofences to.
    - Defaults to the default collection listed in your `amplify_outputs.json` file after provisioning a geofence collection resource.

Geofence objects must have the following properties:

- `geofenceId` - a opaque and unique identifier for the geofence.
- `geometry` - a geometry object that defines the geofence.
  - `polygon` - an array of arrays with [Longitude, Latitude] coordinates.

<Callout>

NOTE: Polygon arrays have a few requirements:

- must have at least 4 vertices (i.e. 4 coordinate points)
- the first and last point must be the same in order to complete the polygonal loop
- vertices must be in counter-clockwise order

</Callout>

#### Return

The return from `saveGeofences` is a Promise that resolves to `SaveGeofenceResults` which contains both successes and errors for geofences that were successfully created or failed.

Each success object has the following properties:

- `geofenceId` - the geofenceId of the geofence that was saved.
- `createTime` - the time the geofence was created.
- `updateTime` - the time the geofence was last updated.

Each error object has the following properties:

- `geofenceId` - the geofenceId of the geofence that failed to be saved.
- `error` - an error object
  - `code` - the [error code](https://docs.aws.amazon.com/location-geofences/latest/APIReference/API_BatchItemError.html)
  - `message` - the error message

#### Example

```js
let saveGeofenceResults;
try {
  saveGeofenceResults = await Geo.saveGeofences({
    geofenceId: 'my-geofence',
    geometry: {
      polygon: [
        [-123.14695358276366, 49.290090146520434],
        [-123.1358814239502, 49.294960279811974],
        [-123.15021514892577, 49.29300108863353],
        [-123.14909934997559, 49.29132171993048],
        [-123.14695358276366, 49.290090146520434]
      ]
    }
  });
} catch (error) {
  // errors thrown by input validations of `saveGeofences`
  throw error;
}

if (saveGeofenceResults.errors.length > 0) {
  // error handling that are from the underlying API calls
  console.log(`Success count: ${saveGeofenceResults.successes.length}`);
  console.log(`Error count: ${saveGeofenceResults.errors.length}`);
}
```

### getGeofence

`geoGeofence` is used to get a single geofence from a collection.

#### API

```javascript
Geo.getGeofence(geofenceId, options) => Promise<Geofence>;
```

#### Parameters

- `geofenceId` - the `id` of the geofence to get.
- `options` - optional options object for getting a geofence
  - `collectionName` - the name of the collection to get geofence from.
    - Defaults to the default collection listed in your `amplify_outputs.json` file after provisioning a geofence collection resource.

#### Return

The return from `getGeofence` is a Promise that resolves to a geofence object.

#### Example

```javascript
let responses;
try {
  response = await Geo.getGeofence('geofenceId');
} catch (error) {
  throw error;
}
```

### listGeofences

`listGeofences` is used to get a list of geofences from a collection. It has pagination built in and will return 100 geofences per page.

#### API

```javascript
Geo.listGeofences(options) => Promise<ListGeofenceResults>;
```

#### Parameters

- `options` - optional options object for saving geofences
  - `nextToken` - the pagination token for the next page of geofences.
    - if no token is given, it will return the first page of geofences.
  - `collectionName` - the name of the collection to save geofences to.
    - Defaults to the default collection listed in your `amplify_outputs.json` file after provisioning a geofence collection resource.

#### Return

Returns a Promise that resolves to an object with the following properties:

- `entries` - an array of geofences
- `nextToken` - the pagination token for the next page of geofences

#### Example

```javascript
let response;
try {
  response = await Geo.listGeofences();
  response.entries.forEach((geofence) => console.log(geofence.geofenceId));
} catch (error) {
  throw error;
}
```

### deleteGeofences

`deleteGeofences` is used to delete a geofences from a collection. It can delete a single or multiple geofences at once.

#### API

```js
Geo.deleteGeofences(geofenceIds, options) => Promise<DeleteGeofencesResults>;
```

#### Parameters

- `geofenceIds` - a single geofenceId or array of geofenceIds to delete
- `options` - optional options object for saving geofences
  - `collectionName` - the name of the collection to save geofences to.
    - Defaults to the default collection listed in your `amplify_outputs.json` file after provisioning a geofence collection resource.

#### Return

The return from `deleteGeofences` is a Promise that resolves to an object with both successes and errors for geofences that were successfully deleted or not.

- The success object is an array of geofenceIds that were successfully deleted.
- The error object is an array of error objects that include the following properties:
  - `geofenceId` - the geofenceId of the geofence that failed to be deleted.
  - `error` - an error object
    - `code` - the [error code](https://docs.aws.amazon.com/location-geofences/latest/APIReference/API_BatchItemError.html)
    - `message` - the error

#### Example

```js
let response;
try {
  response = await Geo.deleteGeofences(
    [
      "geofence1",
      "geofence2",
      "geofence3",
    ]
  )
catch (error) {
  // error handling from logic and validation issues within `deleteGeofences`
  throw error;
}

if(response.errors.length > 0){
  // error handling that are from the underlying API calls
  console.log(`Success count: ${response.successes.length}`);
  console.log(`Error count: ${response.errors.length}`);
}
```


Contents of build-a-backend_add-aws-services_geo_google-migration_index.txt:
import { getCustomStaticPath } from '@/utils/getCustomStaticPath';

export const meta = {
  title: 'Migrate from Google Maps',
  description: 'Migrate applications from Google Maps to Amplify Geo',
  platforms: [
    'javascript',
    'angular',
    'nextjs',
    'react',
    'vue'
  ],
};

export const getStaticPaths = async () => {
  return getCustomStaticPath(meta.platforms);
};

export function getStaticProps(context) {
  return {
    props: {
      platform: context.params.platform,
      meta
    }
  };
}

Are you using Google Maps or another similar Map Provider and would like to switch over to using Amplify Geo or Amazon Location Service? This tutorial will show you how to take your existing Google Maps APIs and switch over to using Amplify Geo.

## Getting Started

Amplify Geo provides APIs for using location based functionality. Under the hood Amplify uses [Amazon Location Service](https://aws.amazon.com/location/) and is designed to work with open source mapping library [MapLibre](https://maplibre.org/).

This guide assumes that you are already familiar with the Google Maps JavaScript API and with front-end web development concepts including HTML, CSS, and JavaScript.

To complete this tutorial, you will need:

- **Amplify Geo**
- **A text editor**

## Key differences between Amplify Geo and Google Maps

### Coordinates Conventions

A key difference to notice between using Amplify Geo and Google Maps is with Google Maps Platform their convention for specifying coordinates is `[lat, lng]`. When migrating over to Amplify Geo the order is swapped to be `[lng, lat]`. This was done to match the [geojson spec](https://geojson.org/) which is also used by MapLibre.

### Authorization

When using Google Maps Platform or other similar services like Mapbox you will first be prompted to go to the Google Cloud Console to set up APIs and create an API key where you will then use the API key when requesting the Google Maps JS API. With Amplify Geo you will instead setup Amplify Auth and the `MapView` component will read the auth configuration from the `amplify_outputs.json` file. Behind the scenes Amplify Auth uses Amazon Cognito to set up client credentials with access to Location Service and Geo will use those credentials when making any location related API calls. More information on setting Amplify Auth and Geo can be found below in the `Setting Up Amplify` section.

## Create a webpage

1. Open your text editor and create a new file called `index.html`.
1. Paste the following code into the file to set up the framework for a webpage with a map.

```html
<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <title>Display a map on a webpage</title>
    <meta name="viewport" content="initial-scale=1,maximum-scale=1,user-scalable=no">
    <!-- Import MapLibre  -->
    <script src="https://cdn.amplify.aws/packages/maplibre-gl/1.15.2/maplibre-gl.js"
        integrity="sha384-rwYfkmAOpciZS2bDuwZ/Xa/Gog6jXem8D/whm3wnsZSVFemDDlprcUXHnDDUcrNU" crossorigin="anonymous"
        referrerpolicy="no-referrer"></script>
    <link href="https://cdn.amplify.aws/packages/maplibre-gl/1.15.2/maplibre-gl.css" rel="stylesheet"
        integrity="sha384-DrPVD9GufrxGb7kWwRv0CywpXTmfvbKOZ5i5pN7urmIThew0zXKTME+gutUgtpeD" crossorigin="anonymous"
        referrerpolicy="no-referrer">
    </link>
    <!-- Import Amplify  -->
    <script src="https://cdn.amplify.aws/packages/core/5.0.5/aws-amplify-core.min.js" 
        integrity="sha384-eM2urkpomL9SRm/kuPHZG3XPEItAiUAAyotT/AqlhSus8iAqs/EfHaYy1Jn5ih7K" crossorigin="anonymous"
        referrerpolicy="no-referrer"></script>
    <script src="https://cdn.amplify.aws/packages/auth/5.0.5/aws-amplify-auth.min.js"
        integrity="sha384-H25CFLYd7YHa1Oib73fs3kJN36VhaHHkLjo4AhGrhJ4HuKam05pg2/0t2MR6epun" crossorigin="anonymous"
        referrerpolicy="no-referrer"></script>
    <script src="https://cdn.amplify.aws/packages/geo/2.0.5/aws-amplify-geo.min.js"
        integrity="sha384-Esc9xx0X7ckb/yeYHuYsZGqBB4FwYr98NFHS3BRXLeRE/eB0uVrad2w+G6cGxYb5" crossorigin="anonymous"
        referrerpolicy="no-referrer"></script>
    <script src="https://cdn.amplify.aws/packages/maplibre-gl-js-amplify/1.5.0/maplibre-gl-js-amplify.umd.min.js"
        integrity="sha384-9kJyZavd3Jk6QzHeaLpugVonfZmZZZdixek6uglOwzKtZvDS9K3W4dshw1uswmlV" crossorigin="anonymous"
        referrerpolicy="no-referrer"></script>
    </link>

    <style>
        body {
            margin: 0;
            padding: 0;
        }

        #map {
            position: absolute;
            top: 0;
            bottom: 0;
            width: 100%;
        }
    </style>
</head>

<body>
    <div id="map"></div>
    <script type="module">
        import outputs from "../amplify_outputs.json" assert { type: "json" };
        const { Amplify } = aws_amplify_core;
        const { createMap } = AmplifyMapLibre;
        Amplify.configure(outputs);

        // Add code from below steps here
    </script>
</body>

</html>
```

This code imports the MapLibre GL JS library and CSS, one of the popular options for map rendering we recommend for use with Amplify Geo. In the HTML body you create a `<div>` element with an id of 'map' that will be the map's container. Finally in the script section you'll setup some Amplify configuration that is required for Amplify Geo to understand what Amplify AWS resources have been created.

### Setting up Amplify

1. You will need to setup a [Geo Map resources](/[platform]/build-a-backend/add-aws-services/geo/set-up-geo/). Follow instructions for creating a map.
1. Once the workflow has completed you should have an `amplify_outputs.json` file in the same directory as your `index.html` file.
1. Save your `index.html` file.

## Display a map

In this step we will show you how to add code to display a map in your application.

<BlockSwitcher>

  <Block name="Amplify">

With Amplify Geo and MapLibre you can add the following code to your index.html file inside the `<script>` tags, after the `Amplify.configure` command:

```js
const map = await createMap({
  container: document.getElementById('map'), // div ID
  center: [-122.4783, 37.8199], // initial coordinates [long, lat]
  zoom: 13 // initial zoom level, high number being more zoomed in
});
```

Save your HTML file and open it in a web browser to see your rendered map.

  </Block>

  <Block name="Google Maps">

With the Google Maps JS API you can display a map like so.

```js
const map = new google.maps.Map(document.getElementById('map'), {
  center: { lat: 37.8199, lng: -122.4783 },
  zoom: 13
});
```

  </Block>

</BlockSwitcher>

## Display a marker

Here you will add a marker to your map

<BlockSwitcher>

  <Block name="Amplify">

With Amplify Geo and MapLibre you can do the following.

```js
const marker = new maplibregl.Marker().setLngLat([-122.4783, 37.8199]).addTo(map);
```

Save your changes and refresh your page and you should see a default blue marker icon on your map.

<Callout>

This example uses [MapLibre's marker component](https://maplibre.org/maplibre-gl-js/docs/API/classes/Marker/) to create a marker. To see more examples with markers on from MapLibre check the examples [here](https://maplibre.org/maplibre-gl-js/docs/examples/custom-marker-icons/).

</Callout>

  </Block>

  <Block name="Google Maps">

Using the Google Maps JS API you would add a marker as show below.

```js
const marker = new google.maps.Marker({
center: { lat: 37.8199, lng: -122.4783 },
map: map
});
```

  </Block>

</BlockSwitcher>

![A search box with 'Starbucks' entered as an input, alongside a map displaying search results indicated by map marker.](/images/map-marker.png)

## Add a Popup

Now you can add a popup that displays information when a user clicks on a marker.

<BlockSwitcher>

  <Block name="Amplify">

With Amplify Geo and MapLibre you can do the following.

```js
const popup = new maplibregl.Popup().setHTML(
  `<h3>Golden Gate Bridge</h3><p>The hex code for the bridge's color is: #c0362c</p>`
);

const marker = new maplibregl.Marker()
  .setLngLat([-122.4783, 37.8199])
  .setPopup(popup)
  .addTo(map);
```

Save your changes and refresh your page and now when you click on the icon a popup should appear on the screen.

<Callout>

This example uses [MapLibre's popup component](https://maplibre.org/maplibre-gl-js/docs/API/classes/Popup/) to create a marker popup. To see more examples with popups on from MapLibre check the examples [here](https://maplibre.org/maplibre-gl-js/docs/examples/set-popup/).

</Callout>

  </Block>

  <Block name="Google Maps">

Using the Google Maps JS API you would add a marker as shown below.

```js
const marker = new google.maps.Marker({
  center: { lat: 37.8199, lng: -122.4783 },
  map: map
});

const infowindow = new google.maps.InfoWindow({
  content: `<h3>Golden Gate Bridge</h3><p>The hex code for the bridge's color is: #c0362c</p>`
});

marker.addListener('click', () => {
  infowindow.open(map, marker);
});
```

  </Block>

</BlockSwitcher>

![A map of area with a marker popup of the golden gate bridge](/images/map-marker-popup.png)

## Add a search component

Now we can try adding a search bar to your map which can return results and place markers on a map based on those results.

<BlockSwitcher>

  <Block name="Amplify">

With Amplify Geo and MapLibre you can do the following.

```js
const { createMap, createAmplifyGeocoder } = AmplifyMapLibre; // import from above updated to include createAmplifyGeocoder

const geocoder = createAmplifyGeocoder();
map.addControl(geocoder);
```

Save your changes and refresh your page and now when you should see a maplibre-gl-geocoder control in the top right corner of your map.

<Callout>

This example uses the [MapLibre's geocoder component](https://github.com/maplibre/maplibre-gl-geocoder) to create a search component. To see more options for our `createAmplifyGeocoder` utility function check out the docs [here](https://github.com/aws-amplify/maplibre-gl-js-amplify/blob/main/API.md#createAmplifyGeocoder).

</Callout>

  </Block>

  <Block name="Google Maps">

Using the Google Places JS API you would add a search bar as shown below.

```js
// Create the search box and link it to the UI element.
const input = document.getElementById("pac-input") as HTMLInputElement;
const searchBox = new google.maps.places.SearchBox(input);

map.controls[google.maps.ControlPosition.TOP_LEFT].push(input);

// Bias the SearchBox results towards current map's viewport.
map.addListener("bounds_changed", () => {
  searchBox.setBounds(map.getBounds() as google.maps.LatLngBounds);
});

// Listen for the event fired when the user selects a prediction and retrieve more details for that place.
searchBox.addListener("places_changed", () => {
  const places = searchBox.getPlaces();

  if (places.length == 0) {
    return;
  }

  // For each place, get the icon, name and location.
  places.forEach((place) => {
    // Create markers for each place
    // Extend map view for each place
  });
  map.fitBounds(bounds);
});
```

  </Block>

</BlockSwitcher>

![A search box with starbucks as input and multiple amplify logo as markers on the map](/images/geocoder-custom-images.png)

## Add a stand alone search component

Now we can try adding a search bar without adding it to a map which can return results that you can use.

<BlockSwitcher>

  <Block name="Amplify">

With Amplify Geo and MapLibre you can do the following.

```js
// Create a div to hold the search component
const el = document.createElement("div");
el.setAttribute("id", "search");
document.body.appendChild(el);

// Create the geocoder component and append it to the div you created earlier
const geocoder = createAmplifyGeocoder();
document.getElementById("search").appendChild(geocoder.onAdd());
```

Save your changes and refresh your page and now when you should see a maplibre-gl-geocoder control in the div you created.

<Callout>

This example uses the [MapLibre's geocoder component](https://github.com/maplibre/maplibre-gl-geocoder) to create a search component. To see more options for our `createAmplifyGeocoder` utility function check out the docs [here](https://github.com/aws-amplify/maplibre-gl-js-amplify/blob/main/API.md#createAmplifyGeocoder).

</Callout>

  </Block>

  <Block name="Google Maps">

Using the Google Places JS API you would add a stand alone search bar as shown below.

<Callout>

Some lines omitted for brevity, see the Google Maps Platform Places Search Box example for the full application

</Callout>

```js
// Create a input to hold the search component
const el = document.createElement("input");
el.setAttribute("id", "pac-input");
document.body.appendChild(el);

// Create the search box and link it to the UI element.
const input = document.getElementById("pac-input");
const searchBox = new google.maps.places.SearchBox(input);
```

  </Block>

</BlockSwitcher>

![A search box with starbucks as input](/images/geocoder-search-box.png)


Contents of build-a-backend_add-aws-services_geo_index.txt:
import { getCustomStaticPath } from '@/utils/getCustomStaticPath';
import { getChildPageNodes } from '@/utils/getChildPageNodes';

export const meta = {
  title: 'Geo',
  description: 'Modern, interactive maps with location markers and location search.',
  platforms: [
    'android',
    'angular',
    'javascript',
    'nextjs',
    'react',
    'swift',
    'vue'
  ],
  route: '/[platform]/build-a-backend/add-aws-services/geo',
};

export const getStaticPaths = async () => {
  return getCustomStaticPath(meta.platforms);
};

export function getStaticProps(context) {
  const childPageNodes = getChildPageNodes(meta.route);
  return {
    props: {
      meta,
      childPageNodes
    }
  };
}

<Overview childPageNodes={props.childPageNodes} />


Contents of build-a-backend_add-aws-services_geo_location-search_index.txt:
import { getCustomStaticPath } from '@/utils/getCustomStaticPath';

export const meta = {
  title: 'Work with location search',
  description: 'Use Amplify Geo to add location search and location-based search capabilities.',
  platforms: [
    'javascript',
    'swift',
    'android',
    'angular',
    'nextjs',
    'react',
    'vue'
  ]
};

export const getStaticPaths = async () => {
  return getCustomStaticPath(meta.platforms);
};

export function getStaticProps(context) {
  return {
    props: {
      platform: context.params.platform,
      meta
    }
  };
}

<InlineFilter filters={['javascript', 'angular', 'react', 'vue', 'react-native', 'nextjs']}>

## Add location search functionality on a map

First, make sure you've provisioned a search index resource and configured your app using the instructions in either [Configure Location Search](/[platform]/build-a-backend/add-aws-services/geo/configure-location-search/) or [Use existing Amazon Location Service resources](/[platform]/build-a-backend/add-aws-services/geo/existing-resources/) and you have already setup [displaying a map](/[platform]/build-a-backend/add-aws-services/geo/maps) in your application.

<Callout>

**Note:** For React, you can use the [Amplify UI Location Search component](https://ui.docs.amplify.aws/react/connected-components/geo#location-search) to generate and display the search results.

</Callout>

To add a location search UI component to your map, you can use the [maplibre-gl-geocoder](https://github.com/maplibre/maplibre-gl-geocoder) library. `maplibre-gl-js-amplify` package makes it easy to integrate `maplibre-gl-geocoder` with Amplify Geo by exporting a utility function `createAmplifyGeocoder()` that returns an instance of `maplibre-gl-geocoder` with some pre-defined settings and supports all the [options](https://maplibre.org/maplibre-gl-geocoder/types/MaplibreGeocoderOptions.html) for customizing the UI component

Install the necessary dependencies with the following command:

```bash title="Terminal" showLineNumbers={false} 
npm add @maplibre/maplibre-gl-geocoder maplibre-gl@1 maplibre-gl-js-amplify
```

> **Note:** Make sure that `maplibre-gl-js-amplify` version `4.0.0` or above is installed.

First, create a map onto which you want to add the location search UI component. See the guide on [creating and displaying maps](/[platform]/build-a-backend/add-aws-services/geo/maps).

Then, use `createAmplifyGeocoder()` to get a new instance of `MaplibreGeocoder` and add the location search UI component to the map.

> **Note:** Ensure that your package bundler (webpack, rollup, etc) is configured to handle css files. Check out the webpack documentation [here](https://webpack.js.org/loaders/css-loader/).

```javascript
import { createMap, createAmplifyGeocoder } from "maplibre-gl-js-amplify";
import maplibregl from "maplibre-gl";
import "maplibre-gl/dist/maplibre-gl.css";
import "@maplibre/maplibre-gl-geocoder/dist/maplibre-gl-geocoder.css";
import "maplibre-gl-js-amplify/dist/public/amplify-geocoder.css"; // Optional CSS for Amplify recommended styling

async function initializeMap() {
    const el = document.createElement("div");
    el.setAttribute("id", "map");
    document.body.appendChild(el);

    const map = await createMap({
        container: "map",
        center: [-123.1187, 49.2819], // [Longitude, Latitude]
        zoom: 11,
    })

    map.addControl(createAmplifyGeocoder());
}

initializeMap();
```

![A search box on the top right corner of a map](/images/geocoder-search-box-map.png)

### Display the location search box outside the map

You can also use [maplibre-gl-geocoder](https://github.com/maplibre/maplibre-gl-geocoder) to display the location search UI component anywhere in your application, even outside the map.

To do so, extract the html element using function `onAdd()` and attach it anywhere in your DOM instead of adding it via the map's `addControl()` function.

```javascript
const geocoder = createAmplifyGeocoder();
document.getElementById("search").appendChild(geocoder.onAdd());
```

![A search box with multiple Starbucks locations](/images/geocoder-search-box.png)

### Customize Search Icons

You can customize the search icons used by the [maplibre-gl-geocoder](https://github.com/maplibre/maplibre-gl-geocoder) to use any image of your choosing. [MapLibre markers](https://maplibre.org/maplibre-gl-js/docs/API/#markers-and-controls) require an [HTMLElement](https://developer.mozilla.org/en-US/docs/Web/HTML/Element) when passing in custom images.

The following example puts an existing SVG icon into an HTMLElement before being passed to `createAmplifyGeocoder` which creates a [maplibre-gl-geocoder](https://github.com/maplibre/maplibre-gl-geocoder).

```javascript
import myIcon from "./myIcon.svg" // relative path to your custom icon

const icon = new Image(100, 100);
icon.src = myIcon;

const geocoder = createAmplifyGeocoder({ showResultMarkers: { element: icon } });
map.addControl(geocoder);
```

![A search box on a map with multiple pointers](/images/geocoder-custom-images.png)

## Location-based search capabilities

Amplify Geo enables you to search for locations by text, addresses, or geo-coordinates.

### Search by text, address, business name, city, and more

The `Geo.searchByText()` API enables you to search for places or points of interest by free-form text, such as an address, name, city, or region.

```javascript
import { Geo } from "@aws-amplify/geo"

Geo.searchByText("Amazon Go Store")
```

Customize your search results further by providing:
- `countries` - to limit the search results to given countries (specified in [ISO Alpha-3 country codes](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-3))
- `maxResults` - to limit the maximum result set
- `biasPosition` - to act as the search origination location
- `searchAreaConstraints` - to limit the area to search inside of
- `searchIndexName` - to use a different Location Service search index resource than the default

 **Note:** Providing both `biasPosition` and `searchAreaConstraints` parameters simultaneously returns an error.

```javascript
const searchOptionsWithBiasPosition = {
  countries: string[], // Alpha-3 country codes
  maxResults: number, // 50 is the max and the default
  biasPosition: [
    longitude // number
    latitude // number,
  ], // Coordinates point to act as the center of the search
  searchIndexName: string, // the string name of the search index
}

const searchOptionsWithSearchAreaConstraints = {
  countries: ["USA"], // Alpha-3 country codes
  maxResults: 25, // 50 is the max and the default
  searchAreaConstraints: [SWLongitude, SWLatitude, NELongitude, NELatitude], // Bounding box to search inside of
  searchIndexName: string, // the string name of the search index
}

Geo.searchByText('Amazon Go Stores', searchOptionsWithBiasPosition)
```

This returns places and their coordinates that match the search constraints. A place can also have additional metadata as shown in the example below.

```javascript
// returns
[
  {
    geometry: {
      point:
        [
          -122.34014899999994, // Longitude point
          47.61609000000004 // Latitude point
        ],
    },
    addressNumber: "2131" // optional string for the address number alone
    country: "USA" // optional Alpha-3 country code
    label: "Amazon Go, 2131 7th Ave, Seattle, WA, 98121, USA" // Optional string
    municipality: "Seattle" // Optional string
    neighborhood: undefined // Optional string
    postalCode: "98121" // Optional string
    region: "Washington" // Optional string
    street: "7th Ave" // Optional string
    subRegion: "King County" // Optional string
  }
]
```

### Search by coordinates

The `Geo.searchByCoordinates()` API is a reverse Geocoder that takes a coordinate point and returns information about what it finds at that point on the map. The returned object is the same shape as `searchByText()` API above.

```javascript
import { Geo } from "@aws-amplify/geo";

Geo.searchByCoordinates([longitudePoint, latitudePoint])
```

You can optionally limit your result set with the `maxResults` parameter or override the default search index with the `searchIndexName` parameter.

```javascript
const searchOptionsWithBiasPosition = {
  maxResults: number, // 50 is the max and the default
  searchIndexName: string, // the string name of the search index
}

Geo.searchByCoordinates([-122.3399573, 47.616179], searchOptionsWithBiasPosition)
```

### Search for suggestions

The `Geo.searchForSuggestions()` API enables you to search for suggestions by free-form text, such as a place, address, city, or region.

```javascript
import { Geo } from "@aws-amplify/geo";

Geo.searchForSuggestions("Amazon Go Store")
```

Similar to `Geo.searchByText()` API, customize your search results further by providing:
- `countries` - to limit the search results to given countries (specified in [ISO Alpha-3 country codes](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-3))
- `maxResults` - to limit the maximum result set
- `biasPosition` - to act as the search origination location
- `searchAreaConstraints` - to limit the area to search inside of
- `searchIndexName` - to use a different Location Service search index resource than the default

 **Note:** Providing both `biasPosition` and `searchAreaConstraints` parameters simultaneously returns an error.

```javascript
const searchOptionsWithBiasPosition = {
  countries: string[], // Alpha-3 country codes
  maxResults: number, // 50 is the max and the default
  biasPosition: [
    longitude // number
    latitude // number,
  ], // Coordinates point to act as the center of the search
  searchIndexName: string, // the string name of the search index
}

const searchOptionsWithSearchAreaConstraints = {
  countries: ["USA"], // Alpha-3 country codes
  maxResults: 25, // 50 is the max and the default
  searchAreaConstraints: [SWLongitude, SWLatitude, NELongitude, NELatitude], // Bounding box to search inside of
  searchIndexName: string, // the string name of the search index
}

Geo.searchForSuggestions('Amazon Go', searchOptionsWithBiasPosition)
```
This returns a list of suggestions (places and their respective `placeId` if available) that match the search constraints.

```javascript
// returns
[
  {
    text: "Amazon Go, 2131 7th Ave, Seattle, WA, 98121, USA",
    placeId: "8fd9d4c6-2527-4190-a7df-0dae352c9dc6"
  },
  {
    text: "Amazon Go, 1906 Terry Ave, Seattle, WA, 98101, USA",
    placeId: "5d04d071-dea2-4d86-bfce-86bd6a8f4787"
  }
]
```

In cases where `placeId` is not available on the list of suggestions as below, use ``searchByText`` to search for the selected place by text.

```javascript
Geo.searchForSuggestions("Amazon", { MaxResults: 5 })

// returns
[
  {
    text: "Amazon Go",
  },
  {
    text: "Amazon 4-star",
  }
]

Geo.searchByText('Amazon Go', { MaxResults: 5 })
```

This returns places and their coordinates that match the search text.


### Search by PlaceId

The `Geo.searchByPlaceId()` API enables you to search for a place by a `placeId`, which is a unique opaque token for a place returned by the provider.

```javascript
import { Geo } from "@aws-amplify/geo";

Geo.searchByPlaceId(placeId)
```
You can optionally override the default search index with the `searchIndexName` parameter.

```javascript
const searchByPlaceIdOptions = {
  searchIndexName: string, // the string name of the search index
}

Geo.searchByPlaceId("8fd9d4c6-2527-4190-a7df-0dae352c9dc6", searchByPlaceIdOptions)
```

This returns a place with metadata as shown in the example below.

```javascript
// returns
{
  geometry: {
    point:
      [
        -122.34014899999994, // Longitude point
        47.61609000000004 // Latitude point
      ],
  },
  addressNumber: "2131" // optional string for the address number alone
  country: "USA" // optional Alpha-3 country code
  label: "Amazon Go, 2131 7th Ave, Seattle, WA, 98121, USA" // Optional string
  municipality: "Seattle" // Optional string
  neighborhood: undefined // Optional string
  postalCode: "98121" // Optional string
  region: "Washington" // Optional string
  street: "7th Ave" // Optional string
  subRegion: "King County" // Optional string
}
```
</InlineFilter>

<InlineFilter filters={['swift', 'android']}>
## Add location search functionality on a map

First, make sure you've provisioned a search index resource and configured your app using the instructions in either [Configure Location Search](/[platform]/build-a-backend/add-aws-services/geo/configure-location-search/) or [Use existing Amazon Location Service resources](/[platform]/build-a-backend/add-aws-services/geo/existing-resources/) and you have already setup [displaying a map](/[platform]/build-a-backend/add-aws-services/geo/maps/) in your application.

<InlineFilter filters={['android']}>
`AmplifyMapView` provides built-in location search, search field, and place markers. Follow the [AmplifyMapView section](/[platform]/build-a-backend/add-aws-services/geo/maps/#amplifymapview) on the Maps page to setup the `AmplifyMapView`.
</InlineFilter>

<InlineFilter filters={['swift']}>
To add a location search UI component to your `AMLMapView`, you will add an `AMLSearchBar` to your View in your desired layout. Upon searching, `Geo.Place`s are converted to `MGLPointFeature`s using `AmplifyMapLibre.createFeatures(places)`. Lastly assign those converted `MGLPointFeature`s to `mapState.features`. Alternatively, you can leverage the `AMLMapCompositeView` directly, which includes an `AMLSearchBar` among other pre-configured UI components.

```swift
import SwiftUI
import AmplifyMapLibreUI
import AmplifyMapLibreAdapter
import Amplify

struct MyMapView: View {

    @StateObject private var mapState = AMLMapViewState()
    @State private var searchText = ""
    @State private var displayState: AMLSearchBar.DisplayState = .map

    var body: some View {
        ZStack(alignment: .top) {
            AMLMapView(mapState: mapState)
                .edgesIgnoringSafeArea(.all)

            AMLSearchBar(
                text: $searchText,
                displayState: $displayState,
                onEditing: { },
                onCommit: search,
                onCancel: { mapState.features = [] }
            )
            .padding()
        }
    }

    private func search() {
        let searchArea = Geo.SearchArea.near(mapState.center)
        let searchOptions = Geo.SearchForTextOptions(area: searchArea)
        Task {
            do {
                let places = try await Amplify.Geo.search(for: searchText, options: searchOptions)
                await MainActor.run {
                    self.mapState.features = AmplifyMapLibre.createFeatures(places)
                }
            } catch let error as Geo.Error {
                print("Failed to search: \(error)")
            } catch {
                print("Unexpected error: \(error)")
            }
        }
    }
}
```

![map view of a area with search bar](/images/ios-geocoder-search-box-map.png)

### Customize Feature Icons

You can customize the feature images displayed on the `AMLMapView` or `AMLMapCompositeView`, you can leverage the `featureImage()` view modifier.

{/* // spell-checker: disable */}

```swift
var body: some View {
    AMLMapView(mapState: mapState)
        .featureImage {
            let image = UIImage(
                systemName: "paperplane.circle.fill",
                withConfiguration: UIImage.SymbolConfiguration(
                    font: .systemFont(ofSize: 22, weight: .medium)
                )
            )!
            return image
            }
        .edgesIgnoringSafeArea(.all)
}
```

{/* // spell-checker: enable */}

![AMLMapView featureImage view modifier](/images/ios-geocoder-custom-images.png)
</InlineFilter>

## Location-based search capabilities

Amplify Geo enables you to search for locations by text, addresses, or geo-coordinates.

<InlineFilter filters={['android']}>
### Search by text

The `Amplify.Geo.searchByText()` API enables you to search for places or points of interest by free-form text, such as an address, name, city, or region.

<BlockSwitcher>
<Block name="Java">

```java
String searchQuery = "Amazon Go";
Amplify.Geo.searchByText(searchQuery,
    result -> {
        for (final Place place : result.getPlaces()) {
            Log.i("MyAmplifyApp", place.toString());
        }
    },
    error -> Log.e("MyAmplifyApp", "Failed to search for " + searchQuery, error)
);
```

</Block>
<Block name="Kotlin - Callbacks">

```kotlin
val searchQuery = "Amazon Go"
Amplify.Geo.searchByText(searchQuery,
    {
        for (place in it.places) {
            Log.i("MyAmplifyApp", place.toString())
        }
    },
    { Log.e("MyAmplifyApp", "Failed to search for $searchQuery", it) }
)
```

</Block>
<Block name="Kotlin - Coroutines">

```kotlin
val searchQuery = "Amazon Go"
try {
    val result = Amplify.Geo.searchByText(searchQuery)
    for (place in result.places) {
        Log.i("MyAmplifyApp", place.toString())
    }
} catch (error: GeoException) { 
    Log.e("MyAmplifyApp", "Failed to search for $searchQuery", it)
}
```

</Block>
<Block name="RxJava">

```java
String searchQuery = "Amazon Go";
RxAmplify.Geo.searchByText(searchQuery).subscribe(
    result -> {
        for (final Place place : result.getPlaces()) {
            Log.i("MyAmplifyApp", place.toString());
        }
    },
    error -> Log.e("MyAmplifyApp", "Failed to search for " + searchQuery, error)
);
```

</Block>
</BlockSwitcher>

Restrict your search results by specifying following parameters inside `GeoSearchByTextOptions`:
- `countries` - to limit the search results to given countries. Follows [ISO Alpha-3 country codes](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-3). (defaults to "USA")
- `maxResults` - to limit the maximum result set (defaults to 50)
- `searchArea`
  - `near` - to act as the search origination location
  - `within` - to limit the area to search inside of

<BlockSwitcher>
<Block name="Java">

```java
Coordinates position = new Coordinates(47.6153, -122.3384);
GeoSearchByTextOptions options = GeoSearchByTextOptions.builder()
    .maxResults(10)
    .searchArea(SearchArea.near(position))
    .countries(Collections.singletonList(CountryCode.USA))
    .build();
```

</Block>
<Block name="Kotlin - Callbacks">

```kotlin
val position = Coordinates(47.6153, -122.3384)
val options = GeoSearchByTextOptions.builder()
    .maxResults(10)
    .searchArea(SearchArea.near(position))
    .countries(listOf(CountryCode.USA))
    .build()
```

</Block>
<Block name="Kotlin - Coroutines">

```kotlin
val position = Coordinates(47.6153, -122.3384)
val options = GeoSearchByTextOptions.builder()
    .maxResults(10)
    .searchArea(SearchArea.near(position))
    .countries(listOf(CountryCode.USA))
    .build()
```

</Block>
<Block name="RxJava">

```java
Coordinates position = new Coordinates(47.6153, -122.3384);
GeoSearchByTextOptions options = GeoSearchByTextOptions.builder()
    .maxResults(10)
    .searchArea(SearchArea.near(position))
    .countries(Collections.singletonList(CountryCode.USA))
    .build();
```

</Block>
</BlockSwitcher>
</InlineFilter>

<InlineFilter filters={['swift']}>
### Search for text

The `Amplify.Geo.search(for text:)` API enables you to search for places or points of interest by free-form text, such as an address, name, city, or region.

```swift
do {
    let places = try await Amplify.Geo.search(for: "coffee shops")
    dump(places)
} catch {
    print(error)
}
```

You can refine your search by specifying following parameters inside `Geo.SearchForTextOptions`

- `area`
  - `.near` - to act as the search origination location.
  - `.within` - to limit the area to search within.
- `countries` - to limit the search results to given countries.
- `maxResults` - to limit the maximum result set (defaults to 50).

```swift
let coordinates = Geo.Coordinates(latitude: 47.62246, longitude: -122.336775)
let options = Geo.SearchForTextOptions(area: .near(coordinates), countries: [.usa, .can], maxResults: 25)

do {
    let places = try await Amplify.Geo.search(for: "coffee shops", options: options)
    dump(places)
} catch let error as Geo.Error {
    print("Failed to search: \(error)"
} catch {
    print("Unexpected error: \(error)")
}
```

</InlineFilter>

<InlineFilter filters={['android']}>
### Search by coordinates

The `Amplify.Geo.searchByCoordinates()` API is a reverse Geocoder that takes a coordinate point and returns information about what it finds at that point on the map.
The returned object is the same shape as `Amplify.Geo.searchByText()` API.

<BlockSwitcher>
<Block name="Java">

```java
Coordinates position = new Coordinates(47.6153, -122.3384);
Amplify.Geo.searchByCoordinates(position,
    result -> {
        for (final Place place : result.getPlaces()) {
            Log.i("MyAmplifyApp", place.toString());
        }
    },
    error -> Log.e("MyAmplifyApp", "Failed to reverse geocode " + position, error)
);
```

</Block>
<Block name="Kotlin - Callbacks">

```kotlin
val position = Coordinates(47.6153, -122.3384)
Amplify.Geo.searchByCoordinates(position,
    {
        for (place in it.places) {
            Log.i("MyAmplifyApp", place.toString())
        }
    },
    { Log.e("MyAmplifyApp", "Failed to reverse geocode $position", it) }
)
```

</Block>
<Block name="Kotlin - Coroutines">

```kotlin
val position = Coordinates(47.6153, -122.3384)
try {
    val result = Amplify.Geo.searchByCoordinates(position)
    for (place in result.places) {
        Log.i("MyAmplifyApp", place.toString())
    }
} catch (error: GeoException) {
    Log.e("MyAmplifyApp", "Failed to reverse geocode $position", error)
}
```

</Block>
<Block name="RxJava">

```java
Coordinates position = new Coordinates(47.6153, -122.3384);
RxAmplify.Geo.searchByCoordinates(position).subscribe(
    result -> {
        for (final Place place : result.getPlaces()) {
            Log.i("MyAmplifyApp", place.toString());
        }
    },
    error -> Log.e("MyAmplifyApp", "Failed to reverse geocode " + position, error)
);
```

</Block>
</BlockSwitcher>

Restrict your search results by specifying following parameters inside `GeoSearchByCoordinatesOptions`:
- `maxResults` - to limit the maximum result set (defaults to 50)

<BlockSwitcher>
<Block name="Java">

```java
GeoSearchByCoordinatesOptions options = GeoSearchByCoordinatesOptions.builder()
    .maxResults(1)
    .build();
```

</Block>
<Block name="Kotlin - Callbacks">

```kotlin
val options = GeoSearchByCoordinatesOptions.builder()
    .maxResults(1)
    .build()
```

</Block>
<Block name="Kotlin - Coroutines">

```kotlin
val options = GeoSearchByCoordinatesOptions.builder()
    .maxResults(1)
    .build()
```

</Block>
<Block name="RxJava">

```java
GeoSearchByCoordinatesOptions options = GeoSearchByCoordinatesOptions.builder()
    .maxResults(1)
    .build();
```

</Block>
</BlockSwitcher>
</InlineFilter>

<InlineFilter filters={['swift']}>
### Search for coordinates

The `Amplify.Geo.search(for coordinates:)` API is a reverse Geocoder that takes a coordinate point and returns information about what it finds at that point on the map.

```swift
do {
    let places = try await Amplify.Geo.search(for: coordinates)
    dump(places)
} catch let error as Geo.Error {
    print("Failed to search: \(error)")
} catch {
    print("Unexpected error: \(error)")
}
```

You can refine your search by specifying following parameters inside `Geo.SearchForCoordinatesOptions`
- `maxResults` - to limit the maximum result set (defaults to 50)

```swift
let options = Geo.SearchForCoordinatesOptions(maxResults: 25)
```
</InlineFilter>
</InlineFilter>


Contents of build-a-backend_add-aws-services_geo_maps_index.txt:
import { getCustomStaticPath } from '@/utils/getCustomStaticPath';

export const meta = {
  title: 'Work with maps',
  description: 'Working with map displays, APIs, and more.',
  platforms: [
    'javascript',
    'swift',
    'android',
    'angular',
    'nextjs',
    'react',
    'vue'
  ],
};

export const getStaticPaths = async () => {
  return getCustomStaticPath(meta.platforms);
};

export function getStaticProps(context) {
  return {
    props: {
      platform: context.params.platform,
      meta
    }
  };
}

<InlineFilter filters={['javascript', 'angular', 'react', 'vue', 'react-native', 'nextjs']}>

## Display a map

First, ensure you've provisioned an Amazon Location Service Map resource and configured your app using the instructions in either [Set up map](/[platform]/build-a-backend/add-aws-services/geo/set-up-geo/) or [Use existing resources](/[platform]/build-a-backend/add-aws-services/geo/existing-resources/) guide.

<Callout>

**Note:** For React, you can use the [Amplify React MapView component](https://ui.docs.amplify.aws/react/components/geo)

</Callout>

To render a map, the [MapLibre GL](https://github.com/maplibre/maplibre-gl-js) and the `maplibre-gl-js-amplify` libraries are required. MapLibre GL is an open source map rendering library and `maplibre-gl-js-amplify` library makes it easy to integrate MapLibre with Amplify Geo and handles Authentication.

Add the dependencies to your app:

```bash title="Terminal" showLineNumbers={false} 
npm add maplibre-gl maplibre-gl-js-amplify
```

<Callout>

Verify the following:

- `maplibre-gl-js-amplify` version `4.0.0` or above is installed
- Any package bundlers (webpack, rollup, etc) are configured to handle css files. Check out the webpack documentation [here](https://webpack.js.org/loaders/css-loader/).

</Callout>

Import the library into your application:

```javascript
import { createMap } from 'maplibre-gl-js-amplify';
import 'maplibre-gl/dist/maplibre-gl.css';
```

Next, create and render the [Map](https://maplibre.org/maplibre-gl-js/docs/API/classes/Map/) with the help of [createMap](https://github.com/aws-amplify/maplibre-gl-js-amplify/blob/main/API.md#createmap).

**Note:** There must be a `div` with an `id="map"` on the DOM before making the call to `createMap` in this way.

```javascript
async function initializeMap() {
  const map = await createMap({
    container: 'map', // An HTML Element or HTML element ID to render the map in https://maplibre.org/maplibre-gl-js/docs/API/classes/Map/
    center: [-123.1187, 49.2819], // [Longitude, Latitude]
    zoom: 11
  });
}

initializeMap();
```

To render a map using a className or something other than the ID you can pass in a reference to the HTML Element itself.

```javascript
const element = document.getElementsByClassName("class")[0];

const map = await createMap({
    container: element,
    ...
})
```

<Callout>

The MapLibre canvas requires a defined height to display properly, otherwise you may end up with a blank screen where the map is supposed to be.

The [amplify-map.css](https://github.com/aws-amplify/maplibre-gl-js-amplify/blob/main/src/public/amplify-map.css) file has a few commonly used methods for setting the height of the map component. You can add some of the examples listed to your own styles or directly import `amplify-map.css` like so:

```
import "maplibre-gl-js-amplify/dist/public/amplify-map.css";
```

To render a map using percentage based height you need to ensure that all ancestor elements to the map container have a height:

```css
html,
body,
#root {
  /* The ancestors of the map element */
  height: 100%;
}

#map {
  height: 50%;
}
```

</Callout>

![A map centered on Vancouver](/images/display-map.png)

## Display markers on map

To display markers on a map, use the `drawPoints` function. `drawPoints` expects:

- `sourceName` - specifies the layer on which the markers are rendered on. You can edit existing markers by passing the same `sourceName`
- coordinate data - (longitude, latitude) the coordinate data of the markers to be displayed
- a maplibre-gl-js Map - the map object on which to render the markers

First, import the `drawPoints` method in your app. Your import section should include look like this

```javascript
import { drawPoints } from 'maplibre-gl-js-amplify';
```

<Callout>

The `drawPoints` method returns ids of the source and layers used to display the markers on the map. These ids can be used for further customization through maplibre-gl-js [source](https://maplibre.org/maplibre-gl-js/docs/API/#sources), [paint](https://maplibre.org/maplibre-style-spec/layers/#paint-property), and [layer](https://maplibre.org/maplibre-style-spec/layers/) options.

For more information about the parameters and options that can be used with `drawPoints` check the documentation [here](https://github.com/aws-amplify/maplibre-gl-js-amplify/blob/main/API.md#drawpoints).

</Callout>

Next, use the following code snippet when you want to display the markers on the map. Add it to the `initializeMap()` function if you want the markers to show up on map load.

```javascript
map.on('load', function () {
  drawPoints(
    'mySourceName', // Arbitrary source name
    [
      {
        coordinates: [-122.483696, 37.833818], // [Longitude, Latitude]
        title: 'Golden Gate Bridge',
        address: 'A suspension bridge spanning the Golden Gate'
      },
      {
        coordinates: [-122.477, 37.8105] // [Longitude, Latitude]
      }
    ], // An array of coordinate data, an array of Feature data, or an array of [NamedLocations](https://github.com/aws-amplify/maplibre-gl-js-amplify/blob/main/src/types.ts#L8)
    map,
    {
      showCluster: true,
      unclusteredOptions: {
        showMarkerPopup: true
      },
      clusterOptions: {
        showCount: true
      }
    }
  );
});
```

![A map with points on the golden gate bridge](/images/display-map-with-points.png)

## Display different map styles

The `getAvailableMaps` API fetches information for all maps that are available to be displayed.

This is useful if you would like to give your users a variety of maps styles to choose from.

```javascript
import { Geo } from '@aws-amplify/geo';

Geo.getAvailableMaps();
```

The available maps are returned as an array with the following contents:

```javascript
//returns
[
  {
    mapName: 'myAmplifyGeoEsriStreetMap',
    style: 'VectorEsriStreets'
  },
  {
    mapName: 'myAmplifyGeoEsriTopographicMap',
    style: 'VectorEsriTopographic'
  }
];
```

You can resize and customize a map with the `resize` and `setStyle` functions:

```javascript
map.setStyle('myAmplifyGeoEsriTopographicMap'); // map name received from getAvailableMaps()
map.resize(); // forces the map to re-render
```

## Removing a map from the DOM

When it's time to remove the map from the DOM, you can use the `.remove` method of the generated map. This will clean up and release all resources associated with the map (DOM elements, event bindings, web workers, and WebGL resources).

```javascript
map.remove();
```

<Callout warning>

After calling `.remove()`, you must not call any other methods on the map.

</Callout>

<Callout warning>

**For React users:**

Not removing the map on component unmount can cause memory leaks in your application. It's recommended to call `.remove()` in either the return function of a React `useEffect` hook or the `componentWillUnmount` lifecycle hook of a class component.

</Callout>

## Add map to html website

To display a map on your html website, add the following scripts to your html webpage.

```html
<link href="https://cdn.amplify.aws/packages/maplibre-gl/1.15.2/maplibre-gl.css" rel="stylesheet" integrity="sha384-DrPVD9GufrxGb7kWwRv0CywpXTmfvbKOZ5i5pN7urmIThew0zXKTME+gutUgtpeD" crossorigin="anonymous" referrerpolicy="no-referrer"></link>
<script src="https://cdn.amplify.aws/packages/maplibre-gl/1.15.2/maplibre-gl.js" integrity="sha384-rwYfkmAOpciZS2bDuwZ/Xa/Gog6jXem8D/whm3wnsZSVFemDDlprcUXHnDDUcrNU" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
<script src="https://cdn.amplify.aws/packages/core/4.3.0/aws-amplify-core.min.js" integrity="sha384-7Oh+5w0l7XGyYvSqbKi2Q7SA5K640V5nyW2/LEbevDQEV1HMJqJLA1A00z2hu8fJ" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
<script src="https://cdn.amplify.aws/packages/auth/4.3.8/aws-amplify-auth.min.js" integrity="sha384-jfkXCEfYyVmDXYKlgWNwv54xRaZgk14m7sjeb2jLVBtUXCD2p+WU8YZ2mPZ9Xbdw" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
<script src="https://cdn.amplify.aws/packages/geo/1.1.0/aws-amplify-geo.min.js" integrity="sha384-TFMTyWuCbiptXTzvOgzJbV8TPUupG1rA1AVrznAhCSpXTIdGw82bGd8RTk5rr3nP" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
<script src="https://cdn.amplify.aws/packages/maplibre-gl-js-amplify/1.1.0/maplibre-gl-js-amplify.umd.min.js" integrity="sha384-7/RxWonKW1nM9zCKiwU9x6bkQTjldosg0D1vZYm0Zj+K/vUSnA3sOMhlRRWAtHPi" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
```

Next, add a div element with id `map` anywhere in your webpage where you want to render the map. Include the following code snippet to configure Amplify (update the `amplify_outputs.json` file path accordingly) and instantiate the map.

```html
<script type="module">
  import outputs from './amplify_outputs.json' assert { type: 'json' };
  const { Amplify } = aws_amplify_core;
  const { createMap } = AmplifyMapLibre;
  Amplify.configure(outputs);
  createMap({
    container: 'map',
    center: [-123.1187, 49.2819], // [Longitude, Latitude]
    zoom: 13
  });
</script>
```

{/* If you provisioned your location resources manually, you can use this [guide]() to configure Amplify. */}

### Sample application

```html
<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <title>Display a map on a webpage</title>
        <meta name="viewport" content="initial-scale=1,maximum-scale=1,user-scalable=no">
        <link href="https://cdn.amplify.aws/packages/maplibre-gl/1.15.2/maplibre-gl.css" rel="stylesheet" integrity="sha384-DrPVD9GufrxGb7kWwRv0CywpXTmfvbKOZ5i5pN7urmIThew0zXKTME+gutUgtpeD" crossorigin="anonymous" referrerpolicy="no-referrer"></link>
        <script src="https://cdn.amplify.aws/packages/maplibre-gl/1.15.2/maplibre-gl.js" integrity="sha384-rwYfkmAOpciZS2bDuwZ/Xa/Gog6jXem8D/whm3wnsZSVFemDDlprcUXHnDDUcrNU" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
        <script src="https://cdn.amplify.aws/packages/core/5.0.5/aws-amplify-core.min.js" integrity="sha384-eM2urkpomL9SRm/kuPHZG3XPEItAiUAAyotT/AqlhSus8iAqs/EfHaYy1Jn5ih7K" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
        <script src="https://cdn.amplify.aws/packages/auth/5.0.5/aws-amplify-auth.min.js" integrity="sha384-H25CFLYd7YHa1Oib73fs3kJN36VhaHHkLjo4AhGrhJ4HuKam05pg2/0t2MR6epun" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
        <script src="https://cdn.amplify.aws/packages/geo/2.0.5/aws-amplify-geo.min.js" integrity="sha384-Esc9xx0X7ckb/yeYHuYsZGqBB4FwYr98NFHS3BRXLeRE/eB0uVrad2w+G6cGxYb5" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
        <script src="https://cdn.amplify.aws/packages/maplibre-gl-js-amplify/1.5.0/maplibre-gl-js-amplify.umd.min.js" integrity="sha384-9kJyZavd3Jk6QzHeaLpugVonfZmZZZdixek6uglOwzKtZvDS9K3W4dshw1uswmlV" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
        <style>
            body { margin: 0; padding: 0; }
            #map { position: absolute; top: 0; bottom: 0; width: 100%; }
        </style>
    </head>
    <body>
        <div id="map"></div>
        <script type="module">
            import outputs from "./amplify_outputs.json" assert { type: "json" };
            const { Amplify } = aws_amplify_core;
            const { createMap } = AmplifyMapLibre;
            Amplify.configure(outputs);
            createMap({
                container: "map",
                center: [-123.1187, 49.2819], // [Longitude, Latitude]
                zoom: 13,
            });
        </script>
    </body>
</html>
```

## Map API's

If you want more information about the maps you currently have configured or want a way to switch between maps programmatically, the `@aws-amplify/geo` package provides API's that return more information about your currently provisioned maps.

First, you need to import Geo from the `@aws-amplify/geo` package.

```javascript
import { Geo } from '@aws-amplify/geo';
```

### getAvailableMaps

`getAvailableMaps` will return the map resources you currently have provisioned in your Amplify project. You can switch between any of these different maps and display their different map styles.

#### API

```javascript
Geo.getAvailableMaps() => Promise<AmazonLocationServiceMapStyle[]>;
```

#### Parameters

- N/A

#### Return

The return from `getAvailableMaps` is a Promise that resolves to `AmazonLocationServiceMapStyle[]` which is an array of `mapName`, `style`, and `region`.

Each object has the following properties:

- `mapName` - name of the map you created.
- `style` - the Amazon Location Service style used to create the map.
- `region` - the AWS region the map is hosted in.

<Callout>

**Note:** When changing a map with Amplify and MapLibre the [setStyle](https://maplibre.org/maplibre-gl-js/docs/API/classes/Map/#setstyle) function should be called with the name of the Location Service map NOT the style. This is because the `transformRequest` function uses the Location Service map name to make a new request for map tile data.

</Callout>

#### Example

```js
const availableMaps = await Geo.getAvailableMaps();

map.setStyle(availableMaps[0].mapName);
```

### getDefaultMap

`getDefaultMap` is used to get a the default map object.

#### API

```javascript
Geo.getDefaultMap() => Promise<AmazonLocationServiceMapStyle>;
```

#### Parameters

- N/A

#### Return

The return from `getDefaultMap` is a Promise that resolves to a AmazonLocationServiceMapStyle object.

The object has the following properties:

- `mapName` - name of the map you created.
- `style` - the Amazon Location Service style used to create the map.
- `region` - the AWS region the map is hosted in.

#### Example

```javascript
const defaultMap = await Geo.getDefaultMap();
```

</InlineFilter>


<InlineFilter filters={['android', 'swift']}>

## Install Amplify-MapLibre adapter

<InlineFilter filters={['android']}>
Add the following dependency to your **build.gradle (Module :app)** file and click "Sync Now" when prompted:

```groovy
dependencies {
    implementation 'com.amplifyframework:aws-auth-cognito:ANDROID_VERSION'
    implementation 'com.amplifyframework:aws-geo-location:ANDROID_VERSION'

    // Add this dependency to integrate MapLibre into your app
    implementation 'com.amplifyframework:maplibre-adapter:ANDROID_VERSION'
}
```

<Callout>

**Note:** the minimum API level required for the UI components is 21.

</Callout>
</InlineFilter>

<InlineFilter filters={['swift']}>

<Callout>

MapLibre is
[not officially supported on macOS](https://github.com/maplibre/maplibre-gl-native/blob/9d37d3d4aab293675f3df3a7f9bee7b2f476daf5/platform/ios/platform/macos/README.md?plain=1#L22),
and as a result `amplify-ios-maplibre` can only be used on iOS. Apple's [MapKit](https://developer.apple.com/documentation/mapkit/)
framework may be used in order to display maps on macOS applications.

</Callout>

First, ensure you've provisioned an Amazon Location Service Map resource and configured your app using the instructions in either [Configure maps](/[platform]/build-a-backend/add-aws-services/geo/set-up-geo/) or [Use existing resources](/[platform]/build-a-backend/add-aws-services/geo/existing-resources/) guide.

Amplify-MapLibre is an open source adapter that enables the popular MapLibre SDK to work seamlessly with Amplify Geo.

1. To install the Amplify-MapLibre adapter to your application, open your project in Xcode and select **File > Add Packages...**

1. Enter the amplify-ios-maplibre GitHub repo URL (`https://github.com/aws-amplify/amplify-ios-maplibre`) into the search bar and hit **Enter**. Wait for the result to load. You'll see the repository rules for which version of amplify-ios-mapLibre you want Swift Package Manager to install. 

1. Choose the dependency rule **Up to Next Major Version**, as it will use the latest compatible version of the dependency, then click **Add Package**.

1. Lastly, choose which of the libraries you want added to your project. If you want to use the SwiftUI user interface components provided by the adapter, select both **AmplifyMapLibreAdapter** and **AmplifyMapLibreUI**. If you only want to enable Amplify Geo to work directly with MapLibre and do not wish use use the provided SwiftUI views, you can just select **AmplifyMapLibreAdapter**. After you select the libraries, click **Add Package**.

<Callout>

You can always go back and modify which SPM packages are included in your project by opening the Swift Packages tab for your project (`Project file > Project > Package Dependencies`)

</Callout>
</InlineFilter>

## Display a map

First, ensure you've provisioned an Amazon Location Service Map resource and configured your app using the instructions in either [Configure maps](/[platform]/build-a-backend/add-aws-services/geo/set-up-geo/) or [Use existing resources](/[platform]/build-a-backend/add-aws-services/geo/existing-resources/) guide.

<InlineFilter filters={['android']}>
### Select your user interface

There are two UI components available to render maps on an Android app, the `MapLibreView` and the `AmplifyMapView`. The `MapLibreView` is an extension of the standard [Android MapLibre MapView](https://docs.maptiler.com/maplibre-gl-native-android/android-basic-get-started/) that is integrated with the `Amplify.Geo` APIs, while the `AmplifyMapView` is a wrapper with built-in location search, map controls, markers and a few standard UX interactions.

#### `MapLibreView` vs `AmplifyMapView`

If the goal is to customize the UI, the `MapLibreView` provides a plain map that allows you to build and integrate your own controls and flow. If the goal is to use the map to search and select places, with a standard UI, then `AmplifyMapView` is a good choice.

Note that even though the extensibility of `AmplifyMapView` is limited, you have access to the wrapped `MapLibreView` through the `mapView` property (`getMapView()` on Java). So any API available to `MapLibreView` is also available on `AmplifyMapView`.

## MapLibreView

The `MapLibreView` is an extension of the standard `MapView` provided by the MapLibre library. The implementation adds the `Amplify.Geo` integration behind the scenes to enable developers to focus on their UI instead of the library integration. That also means all MapLibre APIs are available and will work as expected. Check the [official MapLibre SDK for Android documentation](https://docs.maptiler.com/maplibre-gl-native-android/android-basic-get-started/) for the API reference and guides.

### Add a map to your app

1. Navigate to your app's `src/main/res/layout` directory in Android Studio

2. Create a new layout named `activity_main.xml`, or use an existing layout of your choice, and add the following:

```xml
<?xml version="1.0" encoding="utf-8"?>
<androidx.constraintlayout.widget.ConstraintLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools"
    xmlns:mapbox="http://schemas.android.com/apk/res-auto"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    tools:context=".MainActivity">

    <com.amplifyframework.geo.maplibre.view.MapLibreView
        android:id="@+id/mapView"
        android:layout_width="match_parent"
        android:layout_height="match_parent"
    />

</androidx.constraintlayout.widget.ConstraintLayout>
```

### Initialize the MapLibreView

1. Navigate to your app's activity (e.g. `MainActivity`)

2. Add an import statement for MapLibreView at the top of your app's activity:

<BlockSwitcher>
<Block name="Java">

```java
import com.amplifyframework.geo.maplibre.view.MapLibreView;
```

</Block>
<Block name="Kotlin">

```kotlin
import com.amplifyframework.geo.maplibre.view.MapLibreView
```

</Block>
</BlockSwitcher>

3. Declare the view instance variable at top-level of the activity:

<BlockSwitcher>
<Block name="Java">

```java
private MapLibreView mapView;
```

</Block>
<Block name="Kotlin">

```kotlin
private val mapView by lazy {
    findViewById<MapLibreView>(R.id.mapView)
}
```

</Block>
</BlockSwitcher>

4. Interact with the map in the Activity's `onCreate`:

<BlockSwitcher>

<Block name="Java">

```java
@Override
protected void onCreate(@Nullable Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);

    // Note: make sure you configure Amplify before calling setContentView
    // See the Getting Started instructions

    setContentView(R.layout.activity_main);
    mapView = findViewById(R.id.mapView);

    // now you can interact with the mapView, see examples below
}
```

</Block>

<Block name="Kotlin">

```kotlin
override fun onCreate(savedInstanceState: Bundle?) {
    super.onCreate(savedInstanceState)

    // Note: make sure you configure Amplify before calling setContentView
    // See the Getting Started instructions

    setContentView(R.layout.activity_main)

    // now you can interact with the mapView, see examples below
}
```

</Block>

</BlockSwitcher>

### Interact with the map

The map needs to be loaded in order to interact with it. You can use either `getMapAsync` that is called when the map is ready or `getStyle` that is called when both the map and its style are ready. Some APIs, like the `SymbolManager`, require the style to also be loaded so you can draw markers and other symbols on the map, that's when `getStyle` comes in handy.

### Update the map center

<BlockSwitcher>

<Block name="Java">

```java
import com.mapbox.mapboxsdk.camera.CameraPosition;
import com.mapbox.mapboxsdk.geometry.LatLng;
```

```java
mapView.getMapAsync(map -> {
    LatLng seattle = new LatLng(47.6160281982247, -122.32642111977668);
    map.setCameraPosition(
        new CameraPosition.Builder()
            .target(seattle)
            .zoom(13.0)
            .build()
    );
});
```

</Block>

<Block name="Kotlin">

```kotlin
import com.mapbox.mapboxsdk.camera.CameraPosition
import com.mapbox.mapboxsdk.geometry.LatLng
```

```kotlin
mapView.getMapAsync { map ->
    val seattle = LatLng(47.6160281982247, -122.32642111977668)
    map.cameraPosition = CameraPosition.Builder()
        .target(seattle)
        .zoom(13.0)
        .build()
}
```

</Block>

</BlockSwitcher>

Updating `cameraPosition` moves the camera to the passed coordinates without any animation. If animation is needed, use `map.animateCamera()` instead. See the [official reference](https://docs.maptiler.com/maplibre-gl-native-android/com.mapbox.mapboxsdk.camera/) for more details.

### Add markers to your map

The MapLibre SDK for Android relies on the [MapLibre Annotation Plugin](https://docs.maptiler.com/maplibre-gl-native-android/android-annotation/) in order to display markers on a map.

<BlockSwitcher>

<Block name="Java">

```java
import com.mapbox.mapboxsdk.camera.CameraUpdateFactory;
import com.mapbox.mapboxsdk.plugins.annotation.SymbolOptions;
```

```java
mapView.getStyle((map, style) -> {
    LatLng spaceNeedle = new LatLng(47.6205063, -122.3514661);
    mapView.symbolManager.create(
        new SymbolOptions()
                .withIconImage("place")
                .withLatLng(spaceNeedle)
    );
    map.animateCamera(CameraUpdateFactory.newLatLngZoom(spaceNeedle, 16.0));
});
```

</Block>

<Block name="Kotlin">

```kotlin
import com.mapbox.mapboxsdk.camera.CameraUpdateFactory
import com.mapbox.mapboxsdk.plugins.annotation.SymbolOptions
```

```kotlin
mapView.getStyle { map, style ->
    val spaceNeedle = LatLng(47.6205063, -122.3514661)
    mapView.symbolManager.create(
        SymbolOptions()
            .withIconImage("place")
            .withLatLng(spaceNeedle)
    )
    map.animateCamera(CameraUpdateFactory.newLatLngZoom(spaceNeedle, 16.0))
}
```

</Block>

</BlockSwitcher>

**Notes:**

- The `mapView.symbolManager` is a built-in reference of `SymbolManager` from the [MapLibre Annotation Plugin](https://docs.maptiler.com/maplibre-gl-native-android/android-annotation/) with some standard configuration.
- If customized icons or render other types of shapes and layers are needed, an instance of `SymbolManager` can be created and used to manage the different types of custom use-cases.

### MapLibreView configuration parameters

The `MapLibreView` has several configuration parameters that are not present in the official guides yet. For a complete list, refer to the [source xml file](https://github.com/maplibre/maplibre-gl-native/blob/main/platform/android/MapLibreAndroid/src/main/res/values/attrs.xml).

Also, check the [official MapView API reference](https://docs.maptiler.com/maplibre-gl-native-android/com.mapbox.mapboxsdk.maps/#mapview) for the available public API documentation.


## AmplifyMapView

The `AmplifyMapView` provides a default search field, place markers, visualization modes (map or list) and map controls. It can be used to easily embed a place picker into any app. To use the search functionality of `AmplifyMapView`, provision a search index resource using the instructions in either [Configure Location Search](/[platform]/build-a-backend/add-aws-services/geo/configure-location-search/) or [Use existing Amazon Location Service resources](/[platform]/build-a-backend/add-aws-services/geo/configure-location-search/).

### Add a map to your app

1. Navigate to your app's `src/main/res/layout` directory in Android Studio

2. Create a new layout named `activity_main.xml`, or use an existing layout of your choice, and add the following:

```xml
<?xml version="1.0" encoding="utf-8"?>
<androidx.constraintlayout.widget.ConstraintLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools"
    xmlns:map="http://schemas.android.com/apk/res-auto"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    tools:context=".MainActivity">

    <com.amplifyframework.geo.maplibre.view.AmplifyMapView
        android:id="@+id/mapView"
        android:layout_width="match_parent"
        android:layout_height="match_parent"
    />

</androidx.constraintlayout.widget.ConstraintLayout>
```

### Initialize the AmplifyMapView

1. Navigate to your app's activity (e.g. `MainActivity`)

2. Add an import statement for AmplifyMapView at the top of your app's activity:

<BlockSwitcher>
<Block name="Java">

```java
import com.amplifyframework.geo.maplibre.view.AmplifyMapView;
```

</Block>
<Block name="Kotlin">

```kotlin
import com.amplifyframework.geo.maplibre.view.AmplifyMapView
```

</Block>
</BlockSwitcher>

3. Declare the view instance variable at top-level of the activity:

<BlockSwitcher>
<Block name="Java">

```java
private AmplifyMapView amplifyMapView;
```

</Block>
<Block name="Kotlin">

```kotlin
private val amplifyMapView by lazy {
    findViewById<AmplifyMapView>(R.id.mapView)
}
```

</Block>
</BlockSwitcher>

4. Interact with the map in the Activity's `onCreate`:

<BlockSwitcher>

<Block name="Java">

```java
@Override
protected void onCreate(@Nullable Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);

    // Note: make sure you configure Amplify before calling setContentView
    // See the Getting Started instructions

    setContentView(R.layout.activity_main);
    amplifyMapView = findViewById(R.id.mapView);

    // now you can interact with the mapView, see examples below
}
```

</Block>

<Block name="Kotlin">

```kotlin
override fun onCreate(savedInstanceState: Bundle?) {
    super.onCreate(savedInstanceState)

    // Note: make sure you configure Amplify before calling setContentView
    // See the Getting Started instructions

    setContentView(R.layout.activity_main)

    // now you can interact with the mapView, see examples below
}
```

</Block>

</BlockSwitcher>

### Place select

The main API provided by `AmplifyMapView` is an event listener that is called when a place is selected on the map, either by clicking on the mark or the item on the list.

<BlockSwitcher>

<Block name="Java">

```java
import android.util.Log;
```

```java
amplifyMapView.setOnPlaceSelectListener((place, symbol) -> {
    // place is an instance of AmazonLocationPlace
    // symbol is an instance of Symbol from MapLibre
    Log.i("MyAmplifyApp", "The selected place is " + place.getLabel());
    Log.i("MyAmplifyApp", "It is located at " + place.getCoordinates());
});
```

</Block>

<Block name="Kotlin">

```kotlin
import android.util.Log
```

```kotlin
amplifyMapView.onPlaceSelect { place, symbol ->
    // place is an instance of AmazonLocationPlace
    // symbol is an instance of Symbol from MapLibre
    Log.i("MyAmplifyApp", "The selected place is ${place.label}")
    Log.i("MyAmplifyApp", "It is located at ${place.coordinates}")
}
```

</Block>

</BlockSwitcher>

### AmplifyMapView configuration parameters

The view can be initialized with the following configuration parameters:

| Property                       | Type    | Description                                          | Default |
|--------------------------------|---------|------------------------------------------------------|---------|
| `map:map_centerLatitude`       | Float   | The initial center latitude                          | `0.0`   |
| `map:map_centerLongitude`      | Float   | The initial center longitude                         | `0.0`   |
| `map:map_minZoomLevel`         | Integer | The minimum zoom level (min is 0)                    | `3`     |
| `map:map_maxZoomLevel`         | Integer | The maximum zoom level (max is 22)                   | `18`    |
| `map:map_showCompassIndicator` | Boolean | Whether the compass should be displayed or not       | `true`  |
| `map:map_showZoomControls`     | Boolean | Whether the zoom controls should be displayed or not | `false` |
| `map:map_zoomLevel`            | Integer | The initial zoom level (between 0 and 22)            | `14`    |


Example:

```xml
<?xml version="1.0" encoding="utf-8"?>
<androidx.constraintlayout.widget.ConstraintLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools"
    xmlns:map="http://schemas.android.com/apk/res-auto"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    tools:context=".MainActivity">

    <com.amplifyframework.geo.maplibre.view.AmplifyMapView
        android:id="@+id/mapView"
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        map:map_zoomLevel="12"
        map:map_centerLatitude="47.6160281982247"
        map:map_centerLongitude="-122.32642111977668"
        map:map_showCompassIndicator="true"
        map:map_showZoomControls="true"
    />

</androidx.constraintlayout.widget.ConstraintLayout>
```
</InlineFilter>

<InlineFilter filters={['swift']}>
### Select your user interface

There are two ways to display a map. The easiest way to get started is to use the `AmplifyMaplibreUI` library to create an instance of `AMLMapView`. This is the recommended approach for new projects or anyone who wants to use SwiftUI.

Alternatively, if you are using UIKit or have existing code using the MapLibre/MapBox SDK, you can simply call `AmplifyMapLibre.createMap(completionHandler:)` to create an instance of `MGLMapView` that is pre-wired for use with Amazon Location Service and Amplify. For more information on using `MGLMapView` directly, please see the [MapLibre Documentation](https://docs.maptiler.com/maplibre-gl-native-ios/)

<BlockSwitcher>
<Block name="SwiftUI">

```swift
import SwiftUI
import AmplifyMapLibreUI

struct ContentView: View {    
    var body: some View {
        AMLMapView()
            .edgesIgnoringSafeArea(.all)
    }
}
```

</Block>

<Block name="UIKit">

```swift
import AmplifyMapLibreAdapter
import Mapbox
import Amplify

var mapView: MGLMapView?
do {
    mapView = try await AmplifyMapLibre.createMap()
} catch {
    print(error)
}
```

</Block>
</BlockSwitcher>

## Customize the map and access state

The `AMLMapView` can be customized through a number of view modifiers. The map state information can be set and observed through an instance of `AMLMapViewState`, which can optionally be passed into `AMLMapView` to set initial values. The following example sets an initial zoom level and center location for the map and configures the map to show the user's location.

```swift
@StateObject private var mapState = AMLMapViewState(
    zoomLevel: 8,
    center: CLLocationCoordinate2D(latitude: 39.7392, longitude: -104.9903)
)

var body: some View {
    AMLMapView(mapState: mapState)
        .showUserLocation(true)
        .edgesIgnoringSafeArea(.all)
}
```

## Inject custom behavior

The `AMLMapView` also allows for custom behavior triggered by user interaction to be injected. The following example sets a custom feature image and defines the maps behavior when that feature is tapped - zooming in two levels above the current level.

```swift
var body: some View {
    AMLMapView()
        .featureImage { MyCustomImage() }
        .featureTapped { mapView, pointFeature in
            mapView.setCenter(
                pointFeature.coordinate,
                zoomLevel: mapView.zoomLevel + 2,
                direction: mapView.camera.heading,
                animated: true
            )
        }
        .edgesIgnoringSafeArea(.all)
}
```

## AMLMapCompositeView

The `AMLMapCompositeView` combines `AMLMapView`, `AMLSearchBar`, `AMLMapControlView`, and `AMLPlaceCellView` to create a full user experience. This includes accessible map control buttons, a search bar that automatically searches for points of interest based on user input, and a list representation of points.
In its simplest form, which still leverages all of the above mentioned functionality, the `AMLMapCompositeView` can be instantiated without any arguments. All of the view modifiers and state tracking capabilities of `AMLMapView` are also available on `AMLMapCompositeView`.

```swift
var body: some View {
    AMLMapCompositeView()
}
```
<Callout>

For full details on `AMLMapView` usage and customization, see the [AmplifyMapLibre documentation](https://aws-amplify.github.io/amplify-ios-maplibre/docs/).

</Callout>
</InlineFilter>

## Display different map styles

<InlineFilter filters={['android']}>
The `getAvailableMaps` API fetches information for all maps that are available to be displayed.

This is useful if you would like to give your users a variety of map styles to choose from.

<BlockSwitcher>
<Block name="Java">

```java
Amplify.Geo.getAvailableMaps(
    result -> {
        for (final MapStyle style : result) {
            Log.i("MyAmplifyApp", style.toString());
        }
    },
    error -> Log.e("MyAmplifyApp", "Failed to get available maps.", error)
);
```

</Block>
<Block name="Kotlin - Callbacks">

```kotlin
Amplify.Geo.getAvailableMaps(
    {
        for (mapStyle in it) {
            Log.i("MyAmplifyApp", mapStyle.toString())
        }
    },
    { Log.e("MyAmplifyApp", "Failed to get available maps.", it) }
)
```

</Block>
<Block name="Kotlin - Coroutines">

```kotlin
try {
    val result = Amplify.Geo.getAvailableMaps()
    for (mapStyle in result) {
        Log.i("MyAmplifyApp", mapStyle.toString())
    }
} catch (error: GeoException) {
    Log.e("MyAmplifyApp", "Failed to get available maps.", error)
}
```

</Block>
<Block name="RxJava">

```java
RxAmplify.Geo.getAvailableMaps().subscribe(
    result -> {
        for (final MapStyle style : result) {
            Log.i("MyAmplifyApp", style.toString());
        }
    },
    error -> Log.e("MyAmplifyApp", "Failed to get available maps.", error)
);
```

</Block>
</BlockSwitcher>

You can set a different style to your map using `setStyle` method from the adapter:

<BlockSwitcher>
<Block name="Java">

With `MapLibreView`:

```java
// where mapStyle is a reference to the selected style from Amplify.Geo.getAvailableMaps
mapView.setStyle(mapStyle, style -> {
    Log.i("MyAmplifyApp", "Finished loading " + mapStyle.getStyle());
});
```

With `AmplifyMapView`:
```java
// where mapStyle is a reference to the selected style from Amplify.Geo.getAvailableMaps
amplifyMapView.getMapView().setStyle(mapStyle, style -> {
    Log.i("MyAmplifyApp", "Finished loading " + mapStyle.getStyle());
});
```


</Block>
<Block name="Kotlin">

With `MapLibreView`:

```kotlin
// where mapStyle is a reference to the selected style from Amplify.Geo.getAvailableMaps
mapView.setStyle(mapStyle) { style ->
    Log.i("MyAmplifyApp", "Finished loading ${mapStyle.style}.")
}
```

With `AmplifyMapView`:

```kotlin
// where mapStyle is a reference to the selected style from Amplify.Geo.getAvailableMaps
amplifyMapView.mapView.setStyle(mapStyle) { style ->
    Log.i("MyAmplifyApp", "Finished loading ${mapStyle.style}.")
}
```

</Block>
</BlockSwitcher>
</InlineFilter>


<InlineFilter filters={['swift']}>
The `availableMaps` API fetches information for all maps that are available to be displayed.

This is useful if you would like to give your users a variety of maps styles to choose from.

```swift
var maps = [Geo.MapStyle]()
do {
    maps = try await Amplify.Geo.availableMaps()
} catch let error as Geo.Error {
    print("Failed to get available maps: \(error)")
} catch {
    print("Unexpected error: \(error)")
}
```

You can load a different style map by passing it to the createMap function.

```swift
guard let mapStyle = maps.first else {
    print("No maps available")
    return
}

let mapView = AmplifyMapLibre.createMap(mapStyle)
```
</InlineFilter>

</InlineFilter>


Contents of build-a-backend_add-aws-services_geo_set-up-geo_index.txt:
import { getCustomStaticPath } from '@/utils/getCustomStaticPath';

export const meta = {
  title: 'Set up Amplify Geo',
  description: 'AWS Amplify Geo module provides a simple way to get map data, search for places, and reverse geocoding.',
  platforms: [
    'javascript',
    'swift',
    'android',
    'angular',
    'nextjs',
    'react',
    'vue'
  ],
};

export const getStaticPaths = async () => {
  return getCustomStaticPath(meta.platforms);
};

export function getStaticProps(context) {
  return {
    props: {
      platform: context.params.platform,
      meta
    }
  };
}

Amplify provides APIs and map UI components for maps and location search for your web apps.You can add maps and location search functionality to your app in just a few lines of code. The following is an example utilizing the [AWS Cloud Development Kit (AWS CDK)](https://docs.aws.amazon.com/cdk/latest/guide/home.html) to create a Geo resource powered by [Amazon Location Services](https://aws.amazon.com/location/). But do note there are no official hand-written (L2) constructs for this service yet.

```ts title="amplify/backend.ts"
import { defineBackend } from "@aws-amplify/backend";
import { Policy, PolicyStatement } from "aws-cdk-lib/aws-iam";
import { CfnMap } from "aws-cdk-lib/aws-location";
import { Stack } from "aws-cdk-lib/core";
import { auth } from "./auth/resource";
import { data } from "./data/resource";

const backend = defineBackend({
  auth,
  data,
  // additional resources
});

const geoStack = backend.createStack("geo-stack");

// create a location services map
const map = new CfnMap(geoStack, "Map", {
  mapName: "myMap",
  description: "Map",
  configuration: {
    style: "VectorEsriNavigation",
  },
  pricingPlan: "RequestBasedUsage",
  tags: [
    {
      key: "name",
      value: "myMap",
    },
  ],
});

// create an IAM policy to allow interacting with geo resource
const myGeoPolicy = new Policy(geoStack, "GeoPolicy", {
  policyName: "myGeoPolicy",
  statements: [
    new PolicyStatement({
      actions: [
        "geo:GetMapTile",
        "geo:GetMapSprites",
        "geo:GetMapGlyphs",
        "geo:GetMapStyleDescriptor",
      ],
      resources: [map.attrArn],
    }),
  ],
});

// apply the policy to the authenticated and unauthenticated roles
backend.auth.resources.authenticatedUserIamRole.attachInlinePolicy(myGeoPolicy);
backend.auth.resources.unauthenticatedUserIamRole.attachInlinePolicy(myGeoPolicy);

// patch the map resource to the expected output configuration
backend.addOutput({
  geo: {
    aws_region: geoStack.region,
    maps: {
      items: {
        [map.mapName]: {
          style: "VectorEsriNavigation",
        },
      },
      default: map.mapName,
    },
  },
});
```


<InlineFilter filters={['javascript', "angular", "react", "vue", "react-native", "nextjs"]}>

## Configure your application

To display a map in your application, you can use the [Amplify React MapView component](https://ui.docs.amplify.aws/react/components/geo) or the [MapLibre GL](https://github.com/maplibre/maplibre-gl-js) with `maplibre-gl-js-amplify` libraries are required.

Install the necessary dependencies by running the following command:

```bash title="Terminal" showLineNumbers={false}
npm add aws-amplify @aws-amplify/geo
```

> **Note:** Make sure that version `6.0.0` or above is installed.

Import and load the configuration file in your app. It's recommended you add the Amplify configuration step to your app's root entry point.

<InlineFilter filters={['javascript', "angular", "react", "vue", "react-native"]}>
```javascript title="src/index.js"
import { Amplify } from 'aws-amplify';
import outputs from '../amplify_outputs.json';
Amplify.configure(outputs);
```
</InlineFilter>

<InlineFilter filters={['nextjs']}>

```javascript title="pages/_app.js"
import { Amplify } from 'aws-amplify';
import outputs from '@/amplify_outputs.json';
Amplify.configure(outputs);
```

</InlineFilter>

<Callout warning="true">

Make sure you call `Amplify.configure` as early as possible in your application’s life-cycle. A missing configuration or `NoCredentials` error is thrown if `Amplify.configure` has not been called before other Amplify JavaScript APIs.

</Callout>

</InlineFilter>

<InlineFilter filters={['swift', 'android']}>

Amplify Geo provides APIs and map UI components for mobile app development such that you can add maps to your app in just a few lines of code. Amplify Geo APIs are powered by [Amazon Location Service](https://aws.amazon.com/location/) and the map UI components from [MapLibre](https://maplibre.org/) are already integrated with the Geo APIs.


## Prerequisites

<InlineFilter filters={['android']}>
* An Android application targeting at least Android SDK API level 24 with Amplify libraries integrated
    * For a full example of creating Android project, please follow the [project setup walkthrough](/[platform]/start/quickstart/)
</InlineFilter>

<InlineFilter filters={['swift']}>
An application with Amplify libraries integrated and a minimum target of any of the following:
- **iOS 13.0**, using **Xcode 14.1** or later.
- **macOS 10.15**, using **Xcode 14.1** or later.
- **tvOS 13.0**, using **Xcode 14.3** or later.
- **watchOS 9.0**, using **Xcode 14.3** or later.
- **visionOS 1.0**, using **Xcode 15 beta 2** or later. (Preview support - see below for more details.)

For a full example, please follow the [project setup walkthrough](/[platform]/start/quickstart/).

<Callout>

visionOS support is currently in **preview** and can be used by using the latest [Amplify Release](https://github.com/aws-amplify/amplify-swift/releases). 
As new Xcode and visionOS versions are released, the support will be updated with any necessary fixes on a best effort basis.

</Callout>

</InlineFilter>

## Install Amplify Libraries

<InlineFilter filters={['android']}>
Add the following dependencies to your **build.gradle.kts (Module :app)** file and click "Sync Now" when prompted:

```kotlin title="app/build.gradle.kts"
android {
    compileOptions {
        // Support for Java 8 features
        isCoreLibraryDesugaringEnabled = true
        sourceCompatibility = JavaVersion.VERSION_1_8
        targetCompatibility = JavaVersion.VERSION_1_8
    }
}

dependencies {
    // Amplify API dependencies
    // highlight-start
    implementation("com.amplifyframework:aws-auth-cognito:ANDROID_VERSION")
    implementation("com.amplifyframework:aws-geo-location:ANDROID_VERSION")
    // highlight-end
    // ... other dependencies
    coreLibraryDesugaring("com.android.tools:desugar_jdk_libs:2.0.3")
}
```

<Callout>

**Note:** The Geo plugin has a dependency on Cognito Auth.

</Callout>
</InlineFilter>

<InlineFilter filters={['swift']}>
The Geo plugin is dependent on Cognito Auth.

1. To install the Amplify Libraries in your application, open your project in Xcode and select **File > Add Packages...**.

2. Enter the **Amplify Library for Swift** GitHub repo URL (`https://github.com/aws-amplify/amplify-swift`) into the search bar and click **Add Package**.

  <Callout>

  **Note:** **Up to Next Major Version** should be selected from the **Dependency Rule** dropdown.

  </Callout>

3. Lastly, add **AWSLocationGeoPlugin**, **AWSCognitoAuthPlugin**, and **Amplify** to your target. Then click **Add Package**.

</InlineFilter>

## Initialize Amplify Geo

<InlineFilter filters={['android']}>
To initialize Amplify Geo, use the `Amplify.addPlugin()` method to add the AWS Location Geo plugin. Next, finish configuring Amplify by calling `Amplify.configure()`.

Add the following code to your `onCreate()` method in your application class:

<Callout warning>
Before calling the `Amplify.configure` function, make sure to either download the `amplify_outputs.json` file from the console, or generate it with the following command: 

```bash title="Terminal" showLineNumbers={false}
npx ampx generate outputs --app-id <app-id> --branch main --out-dir app/src/main/res/raw
```

Next, be sure the file you generated or downloaded is in the appropriate resource directory for your application (for example, `app/src/main/res/raw`) in your Android project. Otherwise, you will not be able to compile your application.
</Callout>

<BlockSwitcher>
<Block name="Java">

```java
Amplify.addPlugin(new AWSCognitoAuthPlugin());
Amplify.addPlugin(new AWSLocationGeoPlugin());
Amplify.configure(AmplifyOutputs.fromResource(R.raw.amplify_outputs), getApplicationContext());
```

Your class will look like this:

```java
public class MyAmplifyApp extends Application {
    @Override
    public void onCreate() {
        super.onCreate();

        try {
            Amplify.addPlugin(new AWSCognitoAuthPlugin());
            Amplify.addPlugin(new AWSLocationGeoPlugin());
            Amplify.configure(AmplifyOutputs.fromResource(R.raw.amplify_outputs), getApplicationContext());
            Log.i("MyAmplifyApp", "Initialized Amplify");
        } catch (AmplifyException error) {
            Log.e("MyAmplifyApp", "Could not initialize Amplify", error);
        }
    }
}
```

</Block>
<Block name="Kotlin">

```kotlin
Amplify.addPlugin(AWSCognitoAuthPlugin())
Amplify.addPlugin(AWSLocationGeoPlugin())
Amplify.configure(AmplifyOutputs.fromResource(R.raw.amplify_outputs), applicationContext)
```

Your class will look like this:

```kotlin
class MyAmplifyApp : Application() {
    override fun onCreate() {
        super.onCreate()

        try {
            Amplify.addPlugin(AWSCognitoAuthPlugin())
            Amplify.addPlugin(AWSLocationGeoPlugin())
            Amplify.configure(AmplifyOutputs.fromResource(R.raw.amplify_outputs), applicationContext)
            Log.i("MyAmplifyApp", "Initialized Amplify")
        } catch (error: AmplifyException) {
            Log.e("MyAmplifyApp", "Could not initialize Amplify", error)
        }
    }
}
```

</Block>
<Block name="RxJava">

```java
RxAmplify.addPlugin(new AWSCognitoAuthPlugin());
RxAmplify.addPlugin(new AWSLocationGeoPlugin());
RxAmplify.configure(AmplifyOutputs.fromResource(R.raw.amplify_outputs), getApplicationContext());
```

Your class will look like this:

```java
public class MyAmplifyApp extends Application {
    @Override
    public void onCreate() {
        super.onCreate();

        try {
            RxAmplify.addPlugin(new AWSCognitoAuthPlugin());
            RxAmplify.addPlugin(new AWSLocationGeoPlugin());
            RxAmplify.configure(AmplifyOutputs.fromResource(R.raw.amplify_outputs), getApplicationContext());
            Log.i("MyAmplifyApp", "Initialized Amplify");
        } catch (AmplifyException error) {
            Log.e("MyAmplifyApp", "Could not initialize Amplify", error);
        }
    }
}
```

</Block>
</BlockSwitcher>

Upon building and running this application you should see the following in your console window:

```console
Initialized Amplify
```
</InlineFilter>

<InlineFilter filters={['swift']}>
<Callout warning>
Make sure to generate the `amplify_outputs.json` file by running the following command: 

```bash title="Terminal" showLineNumbers={false}
npx ampx sandbox
```

Next, move the file to your project. You can do this by dragging and dropping the file into your Xcode project.
</Callout>

To initialize Amplify Geo, use the `Amplify.add(plugin:)` method to add the AWS Location Geo plugin. Next, finish configuring Amplify by calling `Amplify.configure(with:)`.

Open the main file of the application - `AppDelegate.swift` or `<YOUR_APP_NAME>App.swift` depending on the app's life cycle - and **add the following** import statements at the top of the file:

```swift
import Amplify
import AWSCognitoAuthPlugin
import AWSLocationGeoPlugin
```

In the same file, **create a function** to configure Amplify:
```swift
func configureAmplify() {
    do {
        try Amplify.add(plugin: AWSCognitoAuthPlugin())
        try Amplify.add(plugin: AWSLocationGeoPlugin())
        try Amplify.configure(with: .amplifyOutputs)
        print("Initialized Amplify");
    } catch {
        print("Could not initialize Amplify: \(error)")
    }
}
```

Now **call the `configureAmplify()` function** in the starting point of your application.
<BlockSwitcher>
<Block name="SwiftUI">

```swift
@main
struct <YOUR_APP_NAME>App: App {
    // add a default initializer and configure Amplify
    public init() {
        configureAmplify()
    }
}
```

</Block>
<Block name="UIKit">

```swift
@UIApplicationMain
class AppDelegate: UIResponder, UIApplicationDelegate {
    func application(_: UIApplication,
                     didFinishLaunchingWithOptions _: [UIApplication.LaunchOptionsKey: Any]?
    ) -> Bool {
        configureAmplify()
        return true
    }
    // ...
}
```

</Block>
</BlockSwitcher>

Upon building and running this application you should see the following in your console window:

```console
Initialized Amplify
```
</InlineFilter>

</InlineFilter>


**Notes:**
- If you want to use existing Amazon Location Service resources [follow this guide](/[platform]/build-a-backend/add-aws-services/geo/existing-resources/) instead.
- If you want to use Amazon Location Service APIs not directly supported by Geo, use the [escape hatch](/[platform]/build-a-backend/add-aws-services/geo/amazon-location-sdk/) to access the Amazon Location Service SDK.

### References

[Location Construct Library](https://docs.aws.amazon.com/cdk/api/v2/docs/aws-cdk-lib.aws_location-readme.html)

## Map Pricing Plan
The pricing plan for the Map example is set to `RequestBasedUsage`.
We advice you to go through the [location service pricing](https://aws.amazon.com/location/pricing/) along with the [location service terms](https://aws.amazon.com/service-terms/) (_82.5 section_) to learn more about the pricing plan.


Contents of build-a-backend_add-aws-services_in-app-messaging_clear-messages_index.txt:
import { getCustomStaticPath } from '@/utils/getCustomStaticPath';

export const meta = {
  title: 'Clear messages',
  description: "Learn more about how to clear synced in-app messages from the user's device.",
  platforms: [
    'javascript',
    'react-native',
    'angular',
    'nextjs',
    'react',
    'vue'
  ],
};

export const getStaticPaths = async () => {
  return getCustomStaticPath(meta.platforms);
};

export function getStaticProps(context) {
  return {
    props: {
      platform: context.params.platform,
      meta
    }
  };
}

Once messages have been synced to your user's device, `clearMessages()` can be used to clear the synced messages.

```js title="src/index.js"
import { clearMessages } from 'aws-amplify/in-app-messaging';

await clearMessages();
```

<Callout informational>

**Note:** If your app has authentication implemented, we recommend calling `clearMessages()` in between user log-ins to remove messages targeted for specific user segments. This is especially important if you anticipate your application will be used in shared device scenarios.

</Callout>


Contents of build-a-backend_add-aws-services_in-app-messaging_create-campaign_index.txt:
import { getCustomStaticPath } from '@/utils/getCustomStaticPath';

export const meta = {
  title: 'Create an in-app messaging campaign on AWS Console',
  description: 'Create a new Pinpoint campaign and configure it to be used with your Amplify project.',
  platforms: [
    'javascript',
    'react-native',
    'angular',
    'nextjs',
    'react',
    'vue'
  ],
};

export const getStaticPaths = async () => {
  return getCustomStaticPath(meta.platforms);
};

export function getStaticProps(context) {
  return {
    props: {
      platform: context.params.platform,
      meta
    }
  };
}

As an alternative to writing AWS Cloud Development Kit (CDK) code, you can use the AWS console to create a campaign that sends messages through any single channel that is supported by Amazon Pinpoint: Mobile Push, In-App, Email, SMS or Custom channels. [Learn how to create a campaign using Amazon Pinpoint](https://docs.aws.amazon.com/pinpoint/latest/userguide/campaigns.html) to continue integrating in-app messages in your app with Amplify.

1. Login to the [AWS Console](https://console.aws.amazon.com/console/home), and Search for **Pinpoint**.
2. Click on your project from the list of available project. Your project name would be the name you provided when you created the pinpoint project using CDK.

3. Click on **Campaigns** from the left navigation menu, and then click on **Create a campaign**

   ![A screenshot of the pinpoint campaign page on the AWS console highlighting the 'Campaigns' option on the left navigation menu and the 'Create a campaign' button on the main page](/images/lib/in-app-messaging/create-pinpoint-campaign.png)

4. Add a name to your campaign, and keep the following options as follows and then click Next:

   1. Campaign type: **Standard campaign**
   2. Channel: **In-App messaging**
   3. set prioritization: **Fairly important**

5. Click on the **Create a segment** radio button, add a name for your segment, and then click **Next**.

   1. You can add as many segments as needed to the campaign. For this quickstart, you can use **Include any audiences** under the _Segment group 1_ section.
   2. You can add a criteria to your segments to ensure that audiences that satisfy that criteria can receive the in-app message.
   3. If you see an error message titled _Segment might include multiple channels_, click **I understand** to proceed.

   ![A screenshot of the pinpoint page displaying a selected 'Create a segment' option on the 'Create a campaign' page. The page shows a input box called 'Name' with 'All my users' as an input. The page also displayed a 'Segment details' section with a radio button selected on 'Include any audiences'](/images/lib/in-app-messaging/choose-campaign-segment.png)

6. Click on the **Create a new in-app message** radio button.
7. You have the ability to customize the following attributes of the in-app message:
   - **Layout**: Which includes all of the different messaging layout options.
   - **Header**: Title of the in-app message, including the text color/alignment.
   - **Message**: The body of the Message, including the text color/alignment.
   - **Background**: Control the background color of the in-app message.
   - **Image URL**: Add an image to be displayed as part of the in-app message body.
   - **Primary button**: Allows the addition of a button to add functionality to the in-app message.
   - **Secondary button**: Allows the addition of an extra button for additional functionality.
   - **Custom Data**: Allows the in-app message to pass additional data to the frontend app once it is triggered by an event.

<InlineFilter filters={['react-native']}>
   <Callout informational>
      As React Native does not support SVG rendering out of the box, Amplify cannot render SVG images by default. For SVG image support with In-App Messaging a custom UI implementation is required.
   </Callout>
</InlineFilter>

For this tutorial you can create a simple message as shown below. Customers in your application will see the same message once the event is triggered.

![A screenshot of the 'In-app message details' page providing layout options, header, message and a sample phone display on the right side of the page. The page allows customizing the your applications in-app message displayed on various device displays](/images/lib/in-app-messaging/in-app-message-details.png)

8. Once you have finished customizing your in-app message, click on **Next**.
9. Under _Trigger events_, add the name of the analytics trigger that will be sent from your frontend app. 
   - You have the ability to customize the trigger to allow only certain attributes or metrics that are passed with the analytics event to trigger the in-app message. (Optional)

![A screenshot of Campaign setup page, titled 'Choose when to send the campaign'. The page shows options such as trigger events, attributes, metrics, campaign dates and time zone. The options allow configuring a trigger event and when the campaign should start and end in a time zone](/images/lib/in-app-messaging/campaign-setup.png)

10. By default, the number of messages shown per session is 1. You can update this threshold during campaign setup. 

![A screenshot of the optional 'Edit campaign settings' page providing configuration options 'Maximum number of session messages viewed per endpoint', 'Maximum number of daily messages viewed per endpoint' and 'Maximum number of messages viewed per endpoint'. The 'Maximum number of session messages viewed per endpoint' is the maximum number of messages that can be viewed per session for this campaign which is set to 1 by default and can be increased on a campaign creation](/images/lib/in-app-messaging/campaign-settings.png)

11. Review your campaign, and then click on **Launch campaign**.

Your campaign is now setup, and you are ready to start integrating the In-App Messaging functionality into your app.

<Callout informational>

**Note:** Campaign start time must be at least 15 minutes in future. In-app messages can only be synced to local device once the campaign becomes active (status should be "In Progress" in the campaigns screen of the Pinpoint console).

</Callout>


Contents of build-a-backend_add-aws-services_in-app-messaging_display-messages_index.txt:
import { getCustomStaticPath } from '@/utils/getCustomStaticPath';

export const meta = {
  title: 'Display messages',
  description: 'Learn how in-app messages are displayed when an In-App Messaging or analytics event is sent and matches the criteria set forth by your active In-App Messaging campaigns.',
  platforms: [
    'javascript',
    'react-native',
    'angular',
    'nextjs',
    'react',
    'vue'
  ],
};

export const getStaticPaths = async () => {
  return getCustomStaticPath(meta.platforms);
};

export function getStaticProps(context) {
  return {
    props: {
      platform: context.params.platform,
      meta
    }
  };
}

In-app messages are displayed when an In-App Messaging or analytics event is sent and matches the criteria defined by your active In-App Messaging campaigns.

## Analytics event

Now that messages have been synced to your users' devices, Amplify In-App Messaging will allow you to start displaying them with Amplify Analytics events with no additional integration steps. Any events you record or are already recording using the Analytics' `record` API are automatically picked up and processed by In-App Messaging. If the event matches the attributes and criteria defined in an in-app message, that message will be displayed.

```js title="src/index.js"
import { record } from 'aws-amplify/analytics';

record({
  name: 'first_event',
  attributes: { color: 'red' },
  metrics: { quantity: 10 }
});
```

If the event name, attributes, and metrics match those set forth by one of your In-App Messaging campaigns, you should see the in-app message displayed in your app.

## In-App Messaging events

In addition to or instead of Amplify Analytics events, you can also dispatch In-App Messaging events to trigger an in-app message display programmatically.

```js title="src/index.js"
import { dispatchEvent } from 'aws-amplify/in-app-messaging';

dispatchEvent({
  name: 'first_event',
  attributes: { color: 'red' },
  metrics: { quantity: 10 }
});
```

If the event name, attributes, and metrics match those set forth by one of your In-App Messaging campaigns, you should see the in-app message displayed in your app.


Contents of build-a-backend_add-aws-services_in-app-messaging_identify-user_index.txt:
import { getCustomStaticPath } from '@/utils/getCustomStaticPath';

export const meta = {
  title: 'Identify a user',
  description: 'Learn how to segment and target your In-App Messaging campaigns to specific user subsets.',
  platforms: [
    'javascript',
    'react-native',
    'angular',
    'nextjs',
    'react',
    'vue'
  ],
};

export const getStaticPaths = async () => {
  return getCustomStaticPath(meta.platforms);
};

export function getStaticProps(context) {
  return {
    props: {
      platform: context.params.platform,
      meta
    }
  };
}

To fully harness the potential of In-App Messaging, you must segment and target your In-App Messaging campaigns to specific user subsets. By identifying users with additional information, including their device demographics, location and any attributes of your choosing, you will be able to display intelligent, targeted in-app messages to the right users.

```js title="src/index.js"
import { identifyUser } from 'aws-amplify/in-app-messaging';

await identifyUser({
  userId: '', // E.g. user-id
  userProfile: {
    email: '', // E.g. example@service.com
    name: '', // E.g. name-of-the-user
    plan: '' // E.g. plan-they-subscribe-to
    customProperties: {
      // E.g. hobbies: ['cooking', 'knitting'],
    },
    demographic: {
      appVersion: '',
      locale: '', // E.g. en_US
      make: '', // E.g. Apple
      model: '', // E.g. iPhone
      modelVersion: '', // E.g. 13
      platform: '', // E.g. iOS
      platformVersion: '', // E.g. 15
      timezone: '' // E.g. Americas/Los_Angeles
    },
    location: {
      city: '', // E.g. Seattle
      country: '', // E.g. US,
      postalCode: '', // E.g. 98121
      region: '', // E.g. WA
      latitude: 0.0,
      longitude: 0.0
    },
    metrics: {
      // E.g. logins: 157
    },
  },
});
```

## Identify a user with Amazon Pinpoint

When using `identifyUser` with Amazon Pinpoint, in addition to the other user info properties you can configure the `address`, `optOut`, and `userAttributes` properties under `options`.

```js title="src/index.js"
import { identifyUser } from 'aws-amplify/in-app-messaging';

await identifyUser({
  userId: '', // E.g. user-id
  options: {
    address: '' // E.g. A device token or email address
    optOut: ''  // Either ALL or NONE
    userAttributes: {
      // E.g. interests: ['soccer', 'shoes'],
    }
  },
});
```


Contents of build-a-backend_add-aws-services_in-app-messaging_index.txt:
import { getChildPageNodes } from '@/utils/getChildPageNodes';
import { getCustomStaticPath } from '@/utils/getCustomStaticPath';

export const meta = {
  title: 'In-App Messaging',
  description: 'Learn how to set up In-App Messaging resource powered by Pinpoint',
  route: "/[platform]/build-a-backend/add-aws-services/in-app-messaging",
  platforms: [
    'angular',
    'javascript',
    'nextjs',
    'react',
    'react-native',
    'vue'
  ]
};

export const getStaticPaths = async () => {
  return getCustomStaticPath(meta.platforms);
};

export function getStaticProps(context) {
  const childPageNodes = getChildPageNodes(meta.route);
  return {
    props: {
      meta,
      childPageNodes
    }
  };
}

<Overview childPageNodes={props.childPageNodes} />


Contents of build-a-backend_add-aws-services_in-app-messaging_integrate-application_index.txt:
import { getCustomStaticPath } from '@/utils/getCustomStaticPath';

export const meta = {
  title: 'Integrate your application',
  description: 'Learn how to integrate your application with In-app Messaging.',
  platforms: [
    'javascript',
    'react-native',
    'angular',
    'nextjs',
    'react',
    'vue'
  ],
};

export const getStaticPaths = async () => {
  return getCustomStaticPath(meta.platforms);
};

export function getStaticProps(context) {
  return {
    props: {
      platform: context.params.platform,
      meta
    }
  };
}

<InlineFilter filters={['react-native']}>
## Install the Amplify React Native Package and other dependencies
Installing the `@aws-amplify/react-native` will bring in the necessary polyfills for React Native. 

<Accordion title="Instructions for React Native version 0.72 and below">

`@aws-amplify/react-native` requires a minimum iOS deployment target of `13.0` if you are using `react-native` version less than or equal to `0.72`. Open the _Podfile_ located in the _ios_ directory and update the `target` value:

```diff showLineNumbers={false}
- platform :ios, min_ios_version_supported
+ platform :ios, 13.0
```

</Accordion>

```bash title="Terminal" showLineNumbers={false}
npm add @aws-amplify/react-native @react-native-community/netinfo @react-native-async-storage/async-storage
```

## Install Amplify UI for React Native and its dependencies

Although Amplify In-App Messaging can be used as a standalone JavaScript library, this guide will show you how to use it together with Amplify UI, which currently supports integration with React and React Native, to get started quickly.

<Callout>

Learn more about Amplify In-App Messaging UI and how to fully unlock its capabilities here: [Amplify UI for In-App Messaging](https://ui.docs.amplify.aws/react-native/connected-components/in-app-messaging)
  
</Callout>

```bash title="Terminal" showLineNumbers={false}
npm add @aws-amplify/ui-react-native react-native-safe-area-context@^4.2.5
```
</InlineFilter>

<InlineFilter filters={['javascript', "angular", "react", "vue", "react-native", "nextjs"]}>
{/* TODO What should be done with this page for non-react frameworks */}

## Install Amplify UI for React

Although Amplify In-App Messaging can be used as a standalone JavaScript library, this guide will show you how to use it together with Amplify UI, which currently supports integration with React and React Native, to get started quickly.

<Callout>

Learn more about Amplify In-App Messaging UI and how to fully unlock its capabilities here: [Amplify UI for In-App Messaging](https://ui.docs.amplify.aws/react/connected-components/in-app-messaging)

</Callout>

```bash title="Terminal" showLineNumbers={false}
npm add @aws-amplify/ui-react @aws-amplify/ui-react-notifications
```
</InlineFilter>

## Integrate Amplify UI

Amplify UI provides a Higher-Order Component for ease of integrating the In-App Messaging UI with your application. Simply wrap your application root component in, for example, `App.js`.

<InlineFilter filters={['react-native']}>
```js
import { withInAppMessaging } from '@aws-amplify/ui-react-native';

const App = () => (
  {/* Your application code */}
);

export default withInAppMessaging(App);
```
</InlineFilter>

<InlineFilter filters={['javascript', "angular", "react", "vue", "nextjs"]}>
{/* TODO in-app validate the library here. What should this be for things other than React */}

```js title="src/App.js"
import { withInAppMessaging } from '@aws-amplify/ui-react-notifications';

import '@aws-amplify/ui-react/styles.css';

const App = () => (
  {/* Your application code */}
);

export default withInAppMessaging(App);
```
</InlineFilter>

Below is an example of what your entry file should look like:
<InlineFilter filters={['react-native']}>
```jsx title="src/index.js"
import React, { useEffect } from 'react';
import { Button, View } from 'react-native';
import {
  initializeInAppMessaging,
  syncMessages,
  dispatchEvent
} from 'aws-amplify/in-app-messaging';
import { withInAppMessaging } from '@aws-amplify/ui-react-native';
import { record } from 'aws-amplify/analytics';
import outputs from '../amplify_outputs.json';

Amplify.configure(outputs);
initializeInAppMessaging();

// To display your in-app message, make sure this event name matches one you created
// in an In-App Messaging campaign!
const myFirstEvent = { name: 'my_first_event' };

const App = () => {
  useEffect(() => {
    // Messages from your campaigns need to be synced from the backend before they
    // can be displayed. You can trigger this anywhere in your app. Here you are
    // syncing just once when this component (your app) renders for the first time.
    syncMessages();
  }, []);

  return (
    <View>
      {/* This button has an example of an analytics event triggering the in-app message. */}
      <Button
        onPress={() => {
          record(myFirstEvent);
        }}
        title="Record Analytics Event"
      />

      {/* This button has an example of an In-app Messaging event triggering the in-app message.*/}
      <Button
        onPress={() => {
          dispatchEvent(myFirstEvent);
        }}
        title="Send In-App Messaging Event"
      />
    </View>
  );
};

export default withInAppMessaging(App);
```

</InlineFilter>

<InlineFilter filters={['javascript', "angular", "react", "vue", "nextjs"]}>
{/* TODO in-app validate the library here. What should this be for things other than React */}

```jsx title="src/index.js"
import React, { useEffect } from 'react';
import {
  initializeInAppMessaging,
  syncMessages,
  dispatchEvent
} from 'aws-amplify/in-app-messaging';
import { Button, View } from '@aws-amplify/ui-react';
import { withInAppMessaging } from '@aws-amplify/ui-react-notifications';
import { record } from 'aws-amplify/analytics';
import '@aws-amplify/ui-react/styles.css';
import outputs from '../amplify_outputs.json';

Amplify.configure(outputs);
initializeInAppMessaging();

// To display your in-app message, make sure this event name matches one you created
// in an In-App Messaging campaign!
const myFirstEvent = { name: 'my_first_event' };

const App = () => {
  useEffect(() => {
    // Messages from your campaigns need to be synced from the backend before they
    // can be displayed. You can trigger this anywhere in your app. Here you are
    // syncing just once when this component (your app) renders for the first time.
    syncMessages();
  }, []);

  return (
    <View>
      {/* This button has an example of an analytics event triggering the in-app message. */}
      <Button
        onClick={() => {
          record(myFirstEvent);
        }}
      >
        Record Analytics Event
      </Button>

      {/* This button has an example of an In-app Messaging event triggering the in-app message.*/}
      <Button
        onClick={() => {
          dispatchEvent(myFirstEvent);
        }}
      >
        Send In-App Messaging Event
      </Button>
    </View>
  );
};

export default withInAppMessaging(App);
```
</InlineFilter>

{/* TODO What would happen for frameworks other than React? Would they NOT see this popup? what should we do for them? */}

You can now build and run your app in your terminal. If you click on one of the buttons shown in the above example, the in-app message you defined in the Pinpoint console should be displayed in your app.


Contents of build-a-backend_add-aws-services_in-app-messaging_resolve-conflicts_index.txt:
import { getCustomStaticPath } from '@/utils/getCustomStaticPath';

export const meta = {
  title: 'Resolve conflicts',
  description: 'Learn how to resolve conflicts when an event is sent and meets the criteria set forth by multiple in-app messages.',
  platforms: [
    'javascript',
    'react-native',
    'angular',
    'nextjs',
    'react',
    'vue'
  ],
};

export const getStaticPaths = async () => {
  return getCustomStaticPath(meta.platforms);
};

export function getStaticProps(context) {
  return {
    props: {
      platform: context.params.platform,
      meta
    }
  };
}

In the rare case where an event is sent and meets the criteria set forth by multiple in-app messages, the library needs to decide which message to return. If such a conflict should arise, In-App Messaging will choose a message by:

1. Sorting the messages in order of campaign expiration
2. Returning the top message sorted (the closest message to expiry)

However, this may not be how you wish to resolve such conflicts so you may want to set your own conflict handler.

```js title="src/index.js"
import { setConflictHandler } from 'aws-amplify/in-app-messaging';

/**
 * Regardless of your conflict resolution strategy the handler must always accept
 * an array of in-app messages and return a single in-app message.
 */
const myConflictHandler = (messages) => {
  // Return a random message
  const randomIndex = Math.floor(Math.random() * messages.length);
  return messages[randomIndex];
};

setConflictHandler(myConflictHandler);
```


Contents of build-a-backend_add-aws-services_in-app-messaging_respond-interaction-events_index.txt:
import { getCustomStaticPath } from '@/utils/getCustomStaticPath';

export const meta = {
  title: 'Respond to interaction events',
  description: 'Learn how to respond with additional behavior to your users interacting with in-app messages by adding interaction event listeners.',
  platforms: [
    'javascript',
    'react-native',
    'angular',
    'nextjs',
    'react',
    'vue'
  ],
};

export const getStaticPaths = async () => {
  return getCustomStaticPath(meta.platforms);
};

export function getStaticProps(context) {
  return {
    props: {
      platform: context.params.platform,
      meta
    }
  };
}

Your code can respond with additional behavior to your users interacting with in-app messages by adding interaction event listeners.

## Message received

Add `onMessageReceived` listeners to respond to an in-app message being received from the library as the result of an event matching the criteria of a synced in-app message. This is required if you are implementing a custom UI so that your UI can respond to event-triggered campaign messages but you may also find it helpful to listen for these messages for any other reason your application requires.

```js title="src/index.js"
import { onMessageReceived } from 'aws-amplify/in-app-messaging';

const myMessageReceivedHandler = (message) => {
  // Do something with the received message
};

const listener = onMessageReceived(myMessageReceivedHandler);

listener.remove(); // Remember to remove the listener when it is no longer needed
```

## Message displayed

Add `onMessageDisplayed` listeners to respond to an in-app message being displayed to your user.

```js title="src/index.js"
import { onMessageDisplayed } from 'aws-amplify/in-app-messaging';

const myMessageDisplayedHandler = (message) => {
  // Do something with the displayed message
};

const listener = onMessageDisplayed(myMessageDisplayedHandler);

listener.remove(); // Remember to remove the listener when it is no longer needed
```

## Message dismissed

Add `onMessageDismissed` listeners to respond to an in-app message being dismissed by your user.

```js title="src/index.js"
import { onMessageDismissed } from 'aws-amplify/in-app-messaging';

const myMessageDismissedHandler = (message) => {
  // Do something with the dismissed message
};

const listener = onMessageDismissed(myMessageDismissedHandler);

listener.remove(); // Remember to remove the listener when it is no longer needed
```

## Message action taken

Add `onMessageActionTaken` listeners to respond to an action being taken on an in-app message. Typically, this means that the user has tapped or clicked a button on an in-app message.

```js title="src/index.js"
import { onMessageActionTaken } from 'aws-amplify/in-app-messaging';

const myMessageActionTakenHandler = (message) => {
  // Do something with the message action was taken against
};

const listener = onMessageActionTaken(myMessageActionTakenHandler);

listener.remove(); // Remember to remove the listener when it is no longer needed
```

## Notifying listeners

If you are using the Amplify In-App Messaging UI, interaction events notifications are already wired up for you. However, if you are implementing your own UI, it is highly recommended to notify listeners of interaction events through your UI code so that the library can take further actions prescribed by the installed provider (for example, automatically recording corresponding Analytics events).

```ts title="src/index.js"
import { notifyMessageInteraction } from 'aws-amplify/in-app-messaging';

const message = {
  // In-app message that you want to record an interaction on
}

/**
 * Interaction events that can be notified correspond to their respective listeners:
 *    'messageReceived'
 *    'messageDisplayed'
 *    'messageDismissed'
 *    'messageActionTaken'
 */
notifyMessageInteraction({ message, type: 'messageDisplayed' });
```


Contents of build-a-backend_add-aws-services_in-app-messaging_set-up-in-app-messaging_index.txt:
import { getCustomStaticPath } from '@/utils/getCustomStaticPath';

export const meta = {
  title: 'Set up in-app messaging',
  description: 'Learn how to get started with in-app messaging.',
  platforms: [
    'javascript',
    'react-native',
    'angular',
    'nextjs',
    'react',
    'vue'
  ],
};

export const getStaticPaths = async () => {
  return getCustomStaticPath(meta.platforms);
};

export function getStaticProps(context) {
  return {
    props: {
      platform: context.params.platform,
      meta
    }
  };
}

Amplify allows interacting with In-App Messaging APIs, enabling you to send messages to your app users. In-App Messaging is a powerful tool to engage with your users and provide them with relevant information. 
A campaign is a messaging initiative that engages a specific audience segment. A campaign sends tailored messages according to a schedule that you define. You can use the [AWS Cloud Development Kit (AWS CDK)](https://docs.aws.amazon.com/cdk/latest/guide/home.html) to create a campaign that sends messages through any single channel that is supported by Amazon Pinpoint: Mobile Push, In-App, Email, SMS or Custom channels.

The following is an example utilizing the AWS CDK to create the In-App Messaging resource powered by [Amazon Pinpoint](https://aws.amazon.com/pinpoint/). Note: there are no official hand-written (L2) constructs for this service yet.

<Callout informational>

**Note:** Campaign start time must be at least 15 minutes in future. In-app messages can only be synced to local device once the campaign becomes active (Status should be "In Progress" in the campaigns screen of the Pinpoint console).

</Callout>

```ts title="amplify/backend.ts"
import { defineBackend } from "@aws-amplify/backend";
import { auth } from "./auth/resource";
import { data } from "./data/resource";
import {
  CfnApp,
  CfnCampaign,
  CfnSegment,
} from "aws-cdk-lib/aws-pinpoint";
import { Policy, PolicyStatement } from "aws-cdk-lib/aws-iam";
import { Stack } from "aws-cdk-lib/core";


const backend = defineBackend({
  auth, 
  data,
  // additional resources 
});

const inAppMessagingStack = backend.createStack("inAppMessaging-stack");

// create a Pinpoint app
const pinpoint = new CfnApp(inAppMessagingStack, "Pinpoint", {
  name: "myPinpointApp",
});

// create a segment 
const mySegment = new CfnSegment(inAppMessagingStack, "Segment", {
  applicationId: pinpoint.ref,
  name: "mySegment",
});

// create a campaign with event and in-app message template
new CfnCampaign(inAppMessagingStack, "Campaign", {
  applicationId: pinpoint.ref,
  name: "MyCampaign",
  segmentId: mySegment.attrSegmentId,
  schedule: {
    // ensure the start and end time are in the future
    startTime: "2024-02-23T14:39:34Z", 
    endTime: "2024-02-29T14:32:40Z",
    frequency: "IN_APP_EVENT",
    eventFilter: {
      dimensions: {
        eventType: {
          dimensionType: "INCLUSIVE",
          values: ["my_first_event"],
        },
      },
      filterType: "ENDPOINT",
    },
  },

  messageConfiguration: {
    inAppMessage: {
      layout: "TOP_BANNER",
      content: [
        {
          // define the content of the in-app message
          bodyConfig: {
            alignment: "CENTER",
            body: "This is an example in-app message.",
            textColor: "#FFFFFF",
          },
          backgroundColor: "#000000",
          headerConfig: {
            alignment: "CENTER",
            header: "Welcome!",
            textColor: "#FFFFFF",
          },
          // optionally, define buttons, images, etc.
        },
      ],
    },
  },
});

//create an IAM policy to allow interacting with Pinpoint in-app messaging
const pinpointPolicy = new Policy(inAppMessagingStack, "PinpointPolicy", {
  policyName: "PinpointPolicy",
  statements: [
    new PolicyStatement({
      actions: [
        "mobiletargeting:GetInAppMessages",
        "mobiletargeting:UpdateEndpoint",
        "mobiletargeting:PutEvents",
      ],
      resources: [pinpoint.attrArn + "/*", pinpoint.attrArn],
    }),
  ],
});

// apply the policy to the authenticated and unauthenticated roles
backend.auth.resources.authenticatedUserIamRole.attachInlinePolicy(pinpointPolicy);
backend.auth.resources.unauthenticatedUserIamRole.attachInlinePolicy(pinpointPolicy);

// patch the custom Pinpoint resource to the expected output configuration
backend.addOutput({
  notifications: {
    amazon_pinpoint_app_id: pinpoint.ref,
    aws_region: Stack.of(pinpoint).region,
    channels: ["IN_APP_MESSAGING"],
  },
});
```

## Install Amplify Libraries

First, install the `aws-amplify` library:

```sh title="Terminal" showLineNumbers={false}
npm add aws-amplify
```

### Initialize In-App Messaging

To finish setting up your application with Amplify, you need to configure it using the `configure` API. Next, to interact with In-App Messaging APIs, you need to first initialize In-App Messaging by calling the `initializeInAppMessaging` API directly imported from the `in-app-messaging` sub-path. This is required to be called as early as possible in the app lifecycle.

<InlineFilter filters={["javascript", "angular", "react", "vue", "react-native"]}>
```js title="src/index.js"
import { Amplify } from 'aws-amplify';
import { initializeInAppMessaging } from 'aws-amplify/in-app-messaging';
import outputs from '../amplify_outputs.json';

Amplify.configure(outputs);
initializeInAppMessaging();
```
</InlineFilter>

<InlineFilter filters={['nextjs']}> 
```js title="index.tsx"
import { Amplify } from 'aws-amplify';
import { initializeInAppMessaging } from 'aws-amplify/in-app-messaging';
import outputs from '@/amplify_outputs.json';

Amplify.configure(outputs);
initializeInAppMessaging();
```
</InlineFilter>

<Callout warning="true">

Make sure you call `Amplify.configure` as early as possible in your application’s life-cycle. A missing configuration or `NoCredentials` error is thrown if `Amplify.configure` has not been called before other Amplify JavaScript APIs. 

</Callout>

{/* [Todo] add link to the troubleshooting doc when its moved over https://docs.amplify.aws/react/build-a-backend/troubleshooting/library-not-configured/ */}

### References

[Amazon Pinpoint Construct Library](https://docs.aws.amazon.com/cdk/api/v2/docs/aws-cdk-lib.aws_pinpoint-readme.html)


Contents of build-a-backend_add-aws-services_in-app-messaging_sync-messages_index.txt:
import { getCustomStaticPath } from '@/utils/getCustomStaticPath';

export const meta = {
  title: 'Sync messages',
  description: "Learn how to sync in-app messages to your user's local device. Synced messages will be displayed when a matching event is triggered.",
  platforms: [
    'javascript',
    'react-native',
    'angular',
    'nextjs',
    'react',
    'vue'
  ],
};

export const getStaticPaths = async () => {
  return getCustomStaticPath(meta.platforms);
};

export function getStaticProps(context) {
  return {
    props: {
      platform: context.params.platform,
      meta
    }
  };
}

To trigger messages, you must sync them from your In-App Messaging campaigns to your users' devices. These messages are then triggered with an analytics or In-App Messaging event. You can control when and how often this sync is performed.

```js title="src/index.js"
import { syncMessages } from 'aws-amplify/in-app-messaging';

await syncMessages();
```

<Callout informational>

**Note:** Syncing messages will always overwrite existing messages currently on the user's device so that they are always up to date when the sync is performed.

</Callout>


Contents of build-a-backend_add-aws-services_index.txt:
import { getChildPageNodes } from '@/utils/getChildPageNodes';
import { getCustomStaticPath } from '@/utils/getCustomStaticPath';

export const meta = {
  title: 'Add any AWS service',
  description: 'Learn how you can add any AWS service.',
  route: "/[platform]/build-a-backend/add-aws-services",
  platforms: [
    'android',
    'angular',
    'flutter',
    'javascript',
    'nextjs',
    'react',
    'react-native',
    'swift',
    'vue'
  ]
};

export const getStaticPaths = async () => {
  return getCustomStaticPath(meta.platforms);
};

export function getStaticProps(context) {
  const childPageNodes = getChildPageNodes(meta.route);
  return {
    props: {
      meta,
      childPageNodes
    }
  };
}

<Overview childPageNodes={props.childPageNodes} />


Contents of build-a-backend_add-aws-services_interactions_chatbot_index.txt:
import { getCustomStaticPath } from '@/utils/getCustomStaticPath';

export const meta = {
  title: 'Interact with bots',
  description: 'Learn more about how to integrate chat bot interactions into your application using Amplify.',
  platforms: [
    'javascript',
    'react-native',
    'angular',
    'nextjs',
    'react',
    'vue'
  ],
};

export const getStaticPaths = async () => {
  return getCustomStaticPath(meta.platforms);
};

export function getStaticProps(context) {
  return {
    props: {
      platform: context.params.platform,
      meta
    }
  };
}


## Send messages to bot
You can send a text message to chatbot backend with `send()` command. The method returns a promise that includes the chatbot response.

```javascript title="src/App.tsx"
import { Interactions } from '@aws-amplify/interactions';

const userInput = "I want to reserve a hotel for tonight";

// Provide a bot name and user input
const response = await Interactions.send({
  botName: "TheBotName",
  message: userInput
});

// Log chatbot response
console.log(response.message);
```

## Display end of chat message

You can use `onComplete()` method to register a function to catch errors or chatbot confirmations when the session successfully ends.

```typescript title="src/App.tsx"
import { Interactions } from '@aws-amplify/interactions';

Interactions.onComplete({
  botName: "TheBotName",
  callback: (error?: Error, completion?: {[key: string]: any}) => {
     if (error) {
        alert('bot conversation failed');
     } else if (completion) {
        console.debug('done: ' + JSON.stringify(completion, null, 2));
        alert('Trip booked. Thank you! What would you like to do next?');
     }
  }
});
```


Contents of build-a-backend_add-aws-services_interactions_index.txt:
import { getCustomStaticPath } from '@/utils/getCustomStaticPath';
import { getChildPageNodes } from '@/utils/getChildPageNodes';

export const meta = {
  title: 'Interactions',
  description:
    'Automate customer workflows by enlisting the help of conversational chatbots powered by deep learning technologies',
  platforms: [
    'angular',
    'javascript',
    'nextjs',
    'react',
    'react-native',
    'vue'
  ],
  route: '/[platform]/build-a-backend/add-aws-services/interactions'
};

export const getStaticPaths = async () => {
  return getCustomStaticPath(meta.platforms);
};

export function getStaticProps(context) {
  const childPageNodes = getChildPageNodes(meta.route);
  return {
    props: {
      platform: context.params.platform,
      meta,
      childPageNodes
    }
  };
}

<Overview childPageNodes={props.childPageNodes} />


Contents of build-a-backend_add-aws-services_interactions_set-up-interactions_index.txt:
import { getCustomStaticPath } from '@/utils/getCustomStaticPath';

export const meta = {
  title: 'Set up Amplify Interactions',
  description: 'AWS Amplify Interactions category enables AI-powered chatbots in your web or mobile apps. You can use Interactions to configure your backend chatbot provider and to integrate a chatbot UI into your app with just a single line of code.',
  platforms: [
    'javascript',
    'react-native',
    'angular',
    'nextjs',
    'react',
    'vue'
  ],
};

export const getStaticPaths = async () => {
  return getCustomStaticPath(meta.platforms);
};

export function getStaticProps(context) {
  return {
    props: {
      platform: context.params.platform,
      meta
    }
  };
}

AWS Amplify Interactions enables AI-powered chatbots in your web or mobile apps. You can use _Interactions_ to configure your backend chatbot provider and to integrate a chatbot UI into your app with just a single line of code.

## Interactions with AWS

AWS Amplify supports [Amazon Lex](https://aws.amazon.com/lex) as the default chatbots service. Amazon Lex supports creating conversational bots with the same deep learning technologies that power Amazon Alexa.

## Setup AWS LexV2 bot

You can create an Amazon Lex V2 chatbot in Amazon Lex console. To create your bot, follow the steps shown in [Amazon Lex V2 Developer Guide](https://docs.aws.amazon.com/lexv2/latest/dg/getting-started.html).

![Amazon Lex intents page with a bot called 'BookTripNew', showing a list of two created intents 'BookCar' and 'FallbackIntent' that your users want to accomplish like booking a car](/images/interactions_lex_v2_console_edit_bot.png)

## Update your IAM Policy

Amazon Lex service requires an IAM policy in order to use the interactions APIs (_remember to replace the template with real value_):

```json
{
  "Version": "2012-10-17",
  "Statement": [
    {
      "Effect": "Allow",
      "Action": ["lex:RecognizeText", "lex:RecognizeUtterance"],
      "Resource": "arn:aws:lex:<your-app-region>:<your-account-id>:bot-alias/<your-bot-id>/<your-bot-alias-id>"
    }
  ]
}
```

## Configure your frontend

<InlineFilter filters={['javascript','angular','nextjs','react','vue' ]}>
Add the aws-amplify and interactions package to your project:

```bash title="Terminal" showLineNumbers={false} 
npm add --save @aws-amplify/interactions aws-amplify
```
</InlineFilter>

<InlineFilter filters={['react-native']}>

### Install Amplify and its dependencies

<Accordion title="Instructions for React Native version 0.72 and below">

  `@aws-amplify/react-native` requires a minimum iOS deployment target of `13.0` if you are using `react-native` version less than or equal to `0.72`. Open the _Podfile_ located in the _ios_ directory and update the `target` value:

  ```diff
   - platform :ios, min_ios_version_supported
   + platform :ios, 13.0
   ```

</Accordion>

```bash title="Terminal" showLineNumbers={false} 
npm add aws-amplify \
  @aws-amplify/react-native \
  @aws-amplify/interactions \
  @react-native-community/netinfo \
  @react-native-async-storage/async-storage \
  react-native-get-random-values
```
</InlineFilter>

<Callout>

Make sure that the `@aws-amplify/interactions` package has the same version number as the `aws-amplify` package in your `package.json` file.

</Callout>

### Configure Amplify
Import and load the configuration file in your app. It's recommended you add the Amplify configuration step to your app's root entry point. For example, **App.js** (Expo) or **index.js** (React Native CLI).

```javascript title="src/index.js"
import { Amplify } from 'aws-amplify';
import outputs from '../amplify_outputs.json';

Amplify.configure(outputs);
Amplify.configure({
  ...Amplify.getConfig(),
  Interactions: {
    LexV2: {
      '<your-bot-name>': {
        aliasId: '<your-bot-alias-id>',
        botId: '<your-bot-id>',
        localeId: '<your-bot-locale-id>',
        region: '<your-bot-region>'
      }
    }
  }
});
```

<InlineFilter filters={['react-native']}>
You need to add the `crypto.getRandomValues` polyfills to your application's entry point file (in most React Native apps this will be the top level index.js).

```js title="src/index.js"
import 'react-native-get-random-values';
import { AppRegistry } from 'react-native';
import App from './App';
import { name as appName } from './app.json';

AppRegistry.registerComponent(appName, () => App);
```
</InlineFilter>

<Callout warning="true">

Make sure you call `Amplify.configure` as early as possible in your application’s life-cycle. A missing configuration or `NoCredentials` error is thrown if `Amplify.configure` has not been called before other Amplify JavaScript APIs. Review the [Library Not Configured Troubleshooting guide](/[platform]/build-a-backend/troubleshooting/library-not-configured/) for possible causes of this issue.

</Callout>

<InlineFilter filters={['react-native']}>

## Known Issues

You may encounter the following error when starting the bundler:

> Error: Unable to resolve module stream from /path/to/node_modules/@aws-sdk/...

This is a [known issue](https://github.com/aws/aws-sdk-js-v3/issues/4877). Please follow [the steps](https://github.com/aws/aws-sdk-js-v3/issues/4877#issuecomment-1656007484) 
outlined in the linked issue to resolve the error.

</InlineFilter>


Contents of build-a-backend_add-aws-services_logging_change-local-storage_index.txt:
import { getCustomStaticPath } from '@/utils/getCustomStaticPath';

export const meta = {
  title: 'Change local storage',
  description: 'Change log local storage on a device',
  platforms: [
    'swift',
    'android'
  ]
};

export const getStaticPaths = async () => {
  return getCustomStaticPath(meta.platforms);
};

export function getStaticProps(context) {
  return {
    props: {
      platform: context.params.platform,
      meta
    }
  };
}

When using the Amplify Logger, all logged messages are saved locally on the user's device first before sending them to CloudWatch.

In this section, you will learn about how to configure the maximum amount of local logs are stored. This can be helpful to determine how much logs are stored locally depending on your network availability and offline use cases.

## Change local storage maximum size

Below is an example of setting the local storage size to 2 MB:




<BlockSwitcher>
  <Block name="With Configuration File">
Update the `localStoreMaxSizeInMB` field in the configuration file.

```json
{
    "awsCloudWatchLoggingPlugin": {
        "enable": true,
        "logGroupName": "<log-group-name>",
        "region": "<region>",
        "localStoreMaxSizeInMB": 2,
        "flushIntervalInSeconds": 60,
        "loggingConstraints": {
            "defaultLogLevel": "WARN"
        }
    }
}
```
  </Block>
  <Block name="With Code">
    <InlineFilter filters={['android']}>
    <BlockSwitcher>
<Block name="Java">

```java
AWSCloudWatchLoggingPluginConfiguration config = new AWSCloudWatchLoggingPluginConfiguration (<log-group-name>, <region>, true, 2);
Amplify.addPlugin(new AWSCloudWatchLoggingPlugin(config));
```

</Block>
<Block name="Kotlin">

```kotlin
val config = AWSCloudWatchLoggingPluginConfiguration(logGroupName = <log-group-name>, region = <region>, localStoreMaxSizeInMB = 2)
Amplify.addPlugin(AWSCloudWatchLoggingPlugin(config))
```
</Block>
<Block name="RxJava">

```java
AWSCloudWatchLoggingPluginConfiguration config = new AWSCloudWatchLoggingPluginConfiguration (<log-group-name>, <region>, true, 2);
Amplify.addPlugin(new AWSCloudWatchLoggingPlugin(config));
```

</Block>
</BlockSwitcher>

</InlineFilter>


<InlineFilter filters={['swift']}>
Provide a `localStoreMaxSizeInMB` parameter initialization and configuration of the `AWSCloudWatchLoggingPlugin`.

```swift
do {
    let loggingConfiguration = AWSCloudWatchLoggingPluginConfiguration(logGroupName: "<log-group-name>", region: "<region>", localStoreMaxSizeInMB: 2)
    let loggingPlugin = AWSCloudWatchLoggingPlugin(loggingPluginConfiguration: loggingConfiguration)
    try Amplify.add(plugin: loggingPlugin)
    try Amplify.configure(with: .amplifyOutputs)
} catch {
    assert(false, "Error initializing Amplify: \(error)")
}
```
</InlineFilter>

  </Block>
</BlockSwitcher>






Contents of build-a-backend_add-aws-services_logging_change-log-levels_index.txt:
import { getCustomStaticPath } from '@/utils/getCustomStaticPath';

export const meta = {
  title: 'Change log levels',
  description: 'Change log levels by categories and users',
  platforms: [
    'swift',
    'android'
  ]
};

export const getStaticPaths = async () => {
  return getCustomStaticPath(meta.platforms);
};

export function getStaticProps(context) {
  return {
    props: {
      platform: context.params.platform,
      meta
    }
  };
}

In this section, you will learn about how to configure the logging level in your application when using the Amplify logger. This is helpful to help you determine the logging level that works best for your use cases, and which levels of errors or warnings you want to capture in Amazon Cloudwatch.

## Change Default Log Level

Below is an example of setting the default log level to `WARN`:


<InlineFilter filters={['android']}>

<BlockSwitcher>
  <Block name="With Configuration File">
Update the `defaultLogLevel` field under `loggingConstraints`.

```json
{
    "awsCloudWatchLoggingPlugin": {
        "enable": true,
        "logGroupName": "<log-group-name>",
        "region": "<region>",
        "localStoreMaxSizeInMB": 1,
        "flushIntervalInSeconds": 60,
        "loggingConstraints": {
            "defaultLogLevel": "WARN"
        }
    }
}
```

The following are supported log levels:
* `ERROR`
* `WARN`
* `INFO`
* `DEBUG`
* `VERBOSE`
* `NONE`

Setting the log level to `NONE` effectively disables logging.
  </Block>
  <Block name="With Code">
Provide a default log level at initialization and configuration of the AWSCloudWatchLoggingPlugin.
<BlockSwitcher>
<Block name="Java">

```java
LoggingConstraints loggingConstraints = new LoggingConstraints(LogLevel.WARN);
AWSCloudWatchLoggingPluginConfiguration config = new AWSCloudWatchLoggingPluginConfiguration (<log-group-name>, <region>, loggingConstraints);
Amplify.addPlugin(new AWSCloudWatchLoggingPlugin(config));
```

</Block>
<Block name="Kotlin">

```kotlin
val loggingConstraints = LoggingConstraints(defaultLogLevel = LogLevel.WARN)
val config = AWSCloudWatchLoggingPluginConfiguration(logGroupName = <log-group-name>, region = <region>, loggingConstraints = loggingConstraints)
Amplify.addPlugin(AWSCloudWatchLoggingPlugin(config))
```
</Block>
<Block name="RxJava">

```java
LoggingConstraints loggingConstraints = new LoggingConstraints(LogLevel.WARN);
AWSCloudWatchLoggingPluginConfiguration config = new AWSCloudWatchLoggingPluginConfiguration (<log-group-name>,<region>, loggingConstraints);
Amplify.addPlugin(new AWSCloudWatchLoggingPlugin(config));
```

</Block>
</BlockSwitcher>

The following are supported log levels:
```java
LogLevel.ERROR
LogLevel.WARN
LogLevel.INFO
LogLevel.DEBUG
LogLevel.VERBOSE
LogLevel.NONE
```
Setting the log level to LogLevel.NONE effectively disables logging.


  </Block>
</BlockSwitcher>




</InlineFilter>


<InlineFilter filters={['swift']}>

<BlockSwitcher>
  <Block name="With Configuration File">
Update the `defaultLogLevel` field under `loggingConstraints`.

```json
{
    "awsCloudWatchLoggingPlugin": {
        "enable": true,
        "logGroupName": "<log-group-name>",
        "region": "<region>",
        "localStoreMaxSizeInMB": 1,
        "flushIntervalInSeconds": 60,
        "loggingConstraints": {
            "defaultLogLevel": "WARN"
        }
    }
}
```

The following are supported log levels:
* `ERROR`
* `WARN`
* `INFO`
* `DEBUG`
* `VERBOSE`
* `NONE`

Setting the log level to `NONE` effectively disables logging.
  </Block>
  <Block name="With Code">
Provide a default log level at initialization and configuration of the `AWSCloudWatchLoggingPlugin`.

```swift
do {
    let loggingConstraints = LoggingConstraints(defaultLogLevel: .warn)
    let loggingConfiguration = AWSCloudWatchLoggingPluginConfiguration(logGroupName: "<log-group-name>", region: "<region>", loggingConstraints: loggingConstraints)
    let loggingPlugin = AWSCloudWatchLoggingPlugin(loggingPluginConfiguration: loggingConfiguration)
    try Amplify.add(plugin: loggingPlugin)
} catch {
    assert(false, "Error initializing Amplify: \(error)")
}
```

The following are supported log levels:
```swift
LogLevel.error
LogLevel.warn
LogLevel.info
LogLevel.debug
LogLevel.verbose
LogLevel.none
```

Setting the log level to `LogLevel.none` effectively disables logging.
  </Block>
</BlockSwitcher>

</InlineFilter>


## Configure Log Level by Category

Each Amplify category can be configured to have its own logging level.

Below is an example of setting different logging levels for the Storage and Auth categories.



<BlockSwitcher>
  <Block name="With Configuration File">
Add a `categoryLogLevel` section and specify each category and its log level.

```json
{
    "awsCloudWatchLoggingPlugin": {
        "enable": true,
        "logGroupName": "<log-group-name>",
        "region": "<region>",
        "localStoreMaxSizeInMB": 1,
        "flushIntervalInSeconds": 60,
        "loggingConstraints": {
            "defaultLogLevel": "ERROR",
            "categoryLogLevel": {
                    "Authentication": "VERBOSE",
                    "Storage": "DEBUG"
            }
        }
    }
}
```

To disable logging for a specific category, set the log level to `NONE`.

  </Block>
  <Block name="With Code">
  <InlineFilter filters={['android']}>
Provide a map of category and corresponding log levels at initialization and configuration of the `AWSCloudWatchLoggingPlugin`.

<BlockSwitcher>
<Block name="Java">

```java
Map<CategoryType, LogLevel> categoryOverrides = new HashMap<>();
categoryOverrides.put(CategoryType.AUTH, LogLevel.VERBOSE);
categoryOverrides.put(CategoryType.STORAGE, LogLevel.DEBUG);
LoggingConstraints loggingConstraints = new LoggingConstraints(LogLevel.WARN, categoryOverrides);
AWSCloudWatchLoggingPluginConfiguration config = new AWSCloudWatchLoggingPluginConfiguration (<log-group-name>, <region>, loggingConstraints);
Amplify.addPlugin(new AWSCloudWatchLoggingPlugin(config));
```

</Block>
<Block name="Kotlin">

```kotlin
val categoryOverrides = mapOf<CategoryType, LogLevel>(CategoryType.AUTH to LogLevel.VERBOSE, CategoryType.STORAGE to LogLevel.DEBUG)
val loggingConstraints = LoggingConstraints(defaultLogLevel = LogLevel.WARN, categoryLogLevel = categoryOverrides)
val config = AWSCloudWatchLoggingPluginConfiguration(logGroupName = <log-group-name>, region = <region>, loggingConstraints = loggingConstraints)
Amplify.addPlugin(AWSCloudWatchLoggingPlugin(config))
```
</Block>
<Block name="RxJava">

```java
Map<CategoryType, LogLevel> categoryOverrides = new HashMap<>();
categoryOverrides.put(CategoryType.AUTH, LogLevel.VERBOSE);
categoryOverrides.put(CategoryType.STORAGE, LogLevel.DEBUG);
LoggingConstraints loggingConstraints = new LoggingConstraints(LogLevel.WARN, categoryOverrides);
AWSCloudWatchLoggingPluginConfiguration config = new AWSCloudWatchLoggingPluginConfiguration (<log-group-name>,<region>, loggingConstraints);
Amplify.addPlugin(new AWSCloudWatchLoggingPlugin(config));
```

</Block>
</BlockSwitcher>

  </InlineFilter>

  <InlineFilter filters={['swift']}>
  Provide a dictionary of category and corresponding log levels at initialization and configuration of the `AWSCloudWatchLoggingPlugin`.

```swift
do {
    let categoryLogLevels: [String: LogLevel] = ["Authentication": .verbose, "Storage": .debug]
    let loggingConstraints = LoggingConstraints(defaultLogLevel: .warn, categoryLogLevel: categoryLogLevels)
    let loggingConfiguration = AWSCloudWatchLoggingPluginConfiguration(logGroupName: "<log-group-name>", region: "<region>", loggingConstraints: loggingConstraints)
    let loggingPlugin = AWSCloudWatchLoggingPlugin(loggingPluginConfiguration: loggingConfiguration)
    try Amplify.add(plugin: loggingPlugin)
} catch {
    assert(false, "Error initializing Amplify: \(error)")
}
```

To disable logging for a specific category, set the log level to `LogLevel.none`.
  </InlineFilter>


  </Block>
</BlockSwitcher>

<InlineFilter filters={['android']}>

The following are existing Amplify category names that are used by default by Amplify when automatically logging errors from the library.
* `ANALYTICS`
* `API`
* `AUTH`
* `DATASTORE`
* `HUB`
* `LOGGING`
* `NOTIFICATIONS`
* `PREDICTIONS`
* `STORAGE`
* `GEO`


</InlineFilter>


<InlineFilter filters={['swift']}>


The following are existing Amplify category names that are used by default by Amplify when automatically logging errors from the library.
* `Analytics`
* `API`
* `Authentication`
* `DataStore`
* `Geo`
* `Hub`
* `Logging`
* `Predictions`
* `PushNotifications`
* `Storage`

</InlineFilter>






Contents of build-a-backend_add-aws-services_logging_configure-user_index.txt:
import { getCustomStaticPath } from '@/utils/getCustomStaticPath';

export const meta = {
  title: 'Configure user allow list',
  description: 'Learn how to configure log levels by user',
  platforms: [
    'swift',
    'android'
  ]
};

export const getStaticPaths = async () => {
  return getCustomStaticPath(meta.platforms);
};

export function getStaticProps(context) {
  return {
    props: {
      platform: context.params.platform,
      meta
    }
  };
}

Each Amplify authenticated user can be configured to have their own unique logging configuration. This is helpful in enabling you debug issues more granularly for your users.

## Retrieve userIDs with Amplify Auth.

You can use the Amplify Auth category to retrieve the userId for a specific user if needed. You can also retrieve the userId by visiting the Amazon Cognito console and inspecting the `User ID` in User pools.



<InlineFilter filters={['android']}>

<BlockSwitcher>
<Block name="Java">

```java
Amplify.Auth.getCurrentUser(
   user.userId,
   error -> // failed to fetch user
);
```
</Block>
<Block name="Kotlin">

```kotlin
Amplify.Auth.getCurrentUser({ user ->
    user.userId,{
    // failed to get user
})
```

</Block>
<Block name="RxJava">

```java
RxAmplify.Auth.getCurrentUser().subscribe(
        result -> result.userId,
        error -> // failed to get user
 );
```

</Block>
</BlockSwitcher>


</InlineFilter>


<InlineFilter filters={['swift']}>

```swift
Amplify.Auth.getCurrentUser().userId
```

</InlineFilter>

## Configure user allow list

Below is an example of setting different default and category log level for an authenticated user.

<BlockSwitcher>
  <Block name="With Configuration File">
    Add a `userLogLevel` section and for each user identifier add a `defaultLogLevel` and `categoryLogLevel`.

```json
{
    "awsCloudWatchLoggingPlugin": {
        "enable": true,
        "logGroupName": "<log-group-name>",
        "region": "<region>",
        "localStoreMaxSizeInMB": 1,
        "flushIntervalInSeconds": 60,
        "loggingConstraints": {
            "defaultLogLevel": "ERROR",
            "userLogLevel": {
                "xyz-123": {
                    "defaultLogLevel": "DEBUG",
                    "categoryLogLevel": {
                        "Storage": "VERBOSE",
                        "Api": "VERBOSE"
                    }
                }
            }
        }
    }
}
```

  </Block>
  <Block name="With Code">

<InlineFilter filters={['android']}>
Provide a map of `UserLogLevel` at initialization and configuration of the `AWSCloudWatchLoggingPlugin`.

<BlockSwitcher>
<Block name="Java">

```java
Map<CategoryType, LogLevel> categoryOverrides = new HashMap<>();
categoryOverrides.put(CategoryType.AUTH, LogLevel.VERBOSE);
categoryOverrides.put(CategoryType.STORAGE, LogLevel.DEBUG);

UserLogLevel userLogLevel = new UserLogLevel(LogLevel.WARN, categoryOverrides);

Map<String, UserLogLevel> userOverrides = new HashMap<>();
userOverrides.put("USER_ID", userLogLevel);

LoggingConstraints loggingConstraints = new LoggingConstraints(LogLevel.WARN, categoryOverrides, userOverrides);

AWSCloudWatchLoggingPluginConfiguration config = new AWSCloudWatchLoggingPluginConfiguration (<log-group-name>, <region>, loggingConstraints);
Amplify.addPlugin(new AWSCloudWatchLoggingPlugin(config));
```

</Block>
<Block name="Kotlin">

```kotlin
val categoryOverrides = mapOf(CategoryType.AUTH to LogLevel.VERBOSE, CategoryType.STORAGE to LogLevel.DEBUG)
val userOverrides = mapOf("USER_ID" to UserLogLevel(LogLevel.WARN, categoryOverrides))

val loggingConstraints = LoggingConstraints(defaultLogLevel = LogLevel.WARN, userLogLevel = userOverrides)

val config = AWSCloudWatchLoggingPluginConfiguration(logGroupName = <log-group-name>, region = <region>, loggingConstraints = loggingConstraints)
Amplify.addPlugin(AWSCloudWatchLoggingPlugin(config))
```
</Block>
<Block name="RxJava">

```java
Map<CategoryType, LogLevel> categoryOverrides = new HashMap<>();
categoryOverrides.put(CategoryType.AUTH, LogLevel.VERBOSE);
categoryOverrides.put(CategoryType.STORAGE, LogLevel.DEBUG);

UserLogLevel userLogLevel = new UserLogLevel(LogLevel.WARN, categoryOverrides);

Map<String, UserLogLevel> userOverrides = new HashMap<>();
userOverrides.put("USER_ID", userLogLevel);

LoggingConstraints loggingConstraints = new LoggingConstraints(LogLevel.WARN, categoryOverrides, userOverrides);

AWSCloudWatchLoggingPluginConfiguration config = new AWSCloudWatchLoggingPluginConfiguration (<log-group-name>, <region>, loggingConstraints);
Amplify.addPlugin(new AWSCloudWatchLoggingPlugin(config));
```

</Block>
</BlockSwitcher>

</InlineFilter>
<InlineFilter filters={['swift']}>
Provide a dictionary of `UserLogLevel` at initialization and configuration of the `AWSCloudWatchLoggingPlugin`.


```swift
do {
    let categoryLogLevels: [String: LogLevel] = ["Storage": .verbose, "API": .verbose]
    let userLogLevel = UserLogLevel(defaultLogLevel: .debug, categoryLogLevel: categoryLogLevels)
    let userLogLevels: [String: UserLogLevel] = ["xyz-123": userLogLevel]
    let loggingConstraints = LoggingConstraints(defaultLogLevel: .warn, userLogLevel: userLogLevels)
    let loggingConfiguration = AWSCloudWatchLoggingPluginConfiguration(logGroupName: "<log-group-name>", region: "<region>", loggingConstraints: loggingConstraints)
    let loggingPlugin = AWSCloudWatchLoggingPlugin(loggingPluginConfiguration: loggingConfiguration)
    try Amplify.add(plugin: loggingPlugin)
} catch {
    assert(false, "Error initializing Amplify: \(error)")
}
```
</InlineFilter>

  </Block>
</BlockSwitcher>



Contents of build-a-backend_add-aws-services_logging_enable-disable_index.txt:
import { getCustomStaticPath } from '@/utils/getCustomStaticPath';

export const meta = {
  title: 'Enable and disable logging',
  description: 'Learn more about how you can enable or disable logging',
  platforms: [
    'swift',
    'android'
  ]
};

export const getStaticPaths = async () => {
  return getCustomStaticPath(meta.platforms);
};

export function getStaticProps(context) {
  return {
    props: {
      platform: context.params.platform,
      meta
    }
  };
}

In this section, you will learn how to enable and disable logging when using the Amplify Logger. It is enabled by default, unless it is disabled in the `amplifyconfiguration_logging` file.



<InlineFilter filters={['android']}>

<BlockSwitcher>
<Block name="Java">

Enable the Amplify Logger.

```java
Amplify.Logging.enable();
```

Disable the Amplify Logger.

```java
Amplify.Logging.disable();
```

</Block>
<Block name="Kotlin">

Enable the Amplify Logger.

```kotlin
Amplify.Logging.enable()
```

Disable the Amplify Logger.

```kotlin
Amplify.Logging.disable()
```

</Block>
<Block name="RxJava">

Enable the Amplify Logger.

```java
Amplify.Logging.enable();
```

Disable the Amplify Logger.

```java
Amplify.Logging.disable();
```

</Block>
</BlockSwitcher>



</InlineFilter>


<InlineFilter filters={['swift']}>

Enable the Amplify Logger.

```swift
Amplify.Logging.enable()
```

Disable the Amplify Logger.

```swift
Amplify.Logging.disable()
```

</InlineFilter>



Contents of build-a-backend_add-aws-services_logging_flush-logs_index.txt:
import { getCustomStaticPath } from '@/utils/getCustomStaticPath';

export const meta = {
  title: 'Flush logs',
  description: 'Learn how to force flush logs',
  platforms: [
    'swift',
    'android'
  ]
};

export const getStaticPaths = async () => {
  return getCustomStaticPath(meta.platforms);
};

export function getStaticProps(context) {
  return {
    props: {
      platform: context.params.platform,
      meta
    }
  };
}

When using the Amplify Logger, all logged messages are saved locally on the user's device first and then flushed at a set interval that you can [customize](#change-automatic-log-flush-interval). You can also choose to flush events manually if needed by following the steps outlined in this section.

## Change automatic log flush interval

You can customize the time interval for when logs are automatically flushed and sent to CloudWatch.

Below is an example of setting the time interval to 120 seconds:


<InlineFilter filters={['android']}>

<BlockSwitcher>
  <Block name="With Configuration File">
Update the `flushIntervalInSeconds` field in the logging configuration file.

```json
{
    "awsCloudWatchLoggingPlugin": {
        "enable": true,
        "logGroupName": "<log-group-name>",
        "region": "<region>",
        "localStoreMaxSizeInMB": 1,
        "flushIntervalInSeconds": 120,
        "loggingConstraints": {
            "defaultLogLevel": "ERROR"
        }
    }
}
```

  </Block>
  <Block name="With Code">
Provide a `flushIntervalInSeconds` parameter initialization and configuration of the `AWSCloudWatchLoggingPlugin`.
<BlockSwitcher>
<Block name="Java">

```java
AWSCloudWatchLoggingPluginConfiguration config = new AWSCloudWatchLoggingPluginConfiguration (<log-group-name>, <region>, 120);
Amplify.addPlugin(new AWSCloudWatchLoggingPlugin(config));
```

</Block>
<Block name="Kotlin">

```kotlin
val config = AWSCloudWatchLoggingPluginConfiguration(logGroupName = <log-group-name>, region = <region>, flushIntervalInSeconds = 120)
Amplify.addPlugin(AWSCloudWatchLoggingPlugin(config))
```
</Block>
<Block name="RxJava">

```java
AWSCloudWatchLoggingPluginConfiguration config = new AWSCloudWatchLoggingPluginConfiguration (<log-group-name>,<region>, 120);
Amplify.addPlugin(new AWSCloudWatchLoggingPlugin(config));
```

</Block>
</BlockSwitcher>



  </Block>
</BlockSwitcher>




</InlineFilter>


<InlineFilter filters={['swift']}>

<BlockSwitcher>
  <Block name="With Configuration File">
Update the `flushIntervalInSeconds` field in the logging configuration file.

```json
{
    "awsCloudWatchLoggingPlugin": {
        "enable": true,
        "logGroupName": "<log-group-name>",
        "region": "<region>",
        "localStoreMaxSizeInMB": 1,
        "flushIntervalInSeconds": 120,
        "loggingConstraints": {
            "defaultLogLevel": "ERROR"
        }
    }
}
```


  </Block>
  <Block name="With Code">
Provide a `flushIntervalInSeconds` parameter initialization and configuration of the `AWSCloudWatchLoggingPlugin`.

```swift
do {
    let loggingConfiguration = AWSCloudWatchLoggingPluginConfiguration(logGroupName: "<log-group-name>", region: "<region>", flushIntervalInSeconds: 120)
    let loggingPlugin = AWSCloudWatchLoggingPlugin(loggingPluginConfiguration: loggingConfiguration)
    try Amplify.add(plugin: loggingPlugin)
    try Amplify.configure(with: .amplifyOutputs)
} catch {
    assert(false, "Error initializing Amplify: \(error)")
}
```



  </Block>
</BlockSwitcher>

</InlineFilter>


## Manually flush logs

You can choose at anytime to flush the log messages that are saved locally on the user's device, to then send them immediately to Amazon CloudWatch.








<InlineFilter filters={['android']}>

<BlockSwitcher>
<Block name="Java">
Add import statement to the `AWSCloudWatchLoggingPlugin`
```java
import com.amplifyframework.logging.cloudwatch.AWSCloudWatchLoggingPlugin;
```

Execute the flush log function from the plugin.

```java
AWSCloudWatchLoggingPlugin plugin = (AWSCloudWatchLoggingPlugin)Amplify.Logging.getPlugin("awsCloudWatchLoggingPlugin");
plugin.flushLogs(
    () -> {
        // logs flushed successfully
    }, error -> {
        // failed to flush logs
    }
);
```
</Block>
<Block name="Kotlin">

Add import statement to the `AWSCloudWatchLoggingPlugin`
```kotlin
import com.amplifyframework.logging.cloudwatch.AWSCloudWatchLoggingPlugin
```

Execute the flush log function from the plugin.

```kotlin
val plugin = Amplify.Logging.getPlugin("awsCloudWatchLoggingPlugin") as? AWSCloudWatchLoggingPlugin
plugin?.flushLogs(
    {
        // logs flushed successfully
    },{  error ->
        // failed to flush logs
    }
);
```

</Block>
<Block name="RxJava">

Add import statement to the `AWSCloudWatchLoggingPlugin`
```java
import com.amplifyframework.logging.cloudwatch.AWSCloudWatchLoggingPlugin;
```

Execute the flush log function from the plugin.

```java
AWSCloudWatchLoggingPlugin plugin = (AWSCloudWatchLoggingPlugin)Amplify.Logging.getPlugin("awsCloudWatchLoggingPlugin");
plugin.flushLogs(
    () -> {
        // logs flushed successfully
    }, error -> {
        // failed to flush logs
    }
);
```

</Block>
</BlockSwitcher>


</InlineFilter>


<InlineFilter filters={['swift']}>

Add import statement to the `AWSCloudWatchLoggingPlugin`
```swift
import AWSCloudWatchLoggingPlugin
```

Execute the flush log function from the plugin.

```swift
let cloudWatchPlugin = try Amplify.Logging.getPlugin(for: "awsCloudWatchLoggingPlugin") as? AWSCloudWatchLoggingPlugin
try await cloudWatchPlugin?.flushLogs()
```

</InlineFilter>






Contents of build-a-backend_add-aws-services_logging_hub-events_index.txt:
import { getCustomStaticPath } from '@/utils/getCustomStaticPath';

export const meta = {
  title: 'Listen to log events',
  description: 'Learn how to listen to Hub events for logging',
  platforms: [
    'swift',
    'android'
  ]
};

export const getStaticPaths = async () => {
  return getCustomStaticPath(meta.platforms);
};

export function getStaticProps(context) {
  return {
    props: {
      platform: context.params.platform,
      meta
    }
  };
}

The Amplify Logger sends errors that occur when using it through Amplify Hub. To ensure that errors do not occur when logging, log messages should be validated and follow the best security practices. Additionally, you should ensure that log messages do not exceed the [Amazon CloudWatch log event size of 256 KB](https://docs.aws.amazon.com/AmazonCloudWatchLogs/latest/APIReference/API_PutLogEvents.html).

You can get logging error events by listening/subscribing to the logging events from the Amplify Hub.


    <InlineFilter filters={['android']}>
<BlockSwitcher>
<Block name="Java">

```java
Amplify.Hub.subscribe(HubChannel.LOGGING,
            hubEvent -> {
                if (hubEvent.getName().equals(LoggingEventName.WRITE_LOG_FAILURE.toString())) {
                    Log.i("LOGGING", "Failed to write logs");
                } else if (hubEvent.getName().equals(LoggingEventName.FLUSH_LOG_FAILURE.toString())){
                    Log.i("LOGGING", "Failed to flush logs");
                }
            }
        );
```

</Block>
<Block name="Kotlin">

```kotlin
Amplify.Hub.subscribe(
    HubChannel.LOGGING
) { hubEvent: HubEvent<*> ->
    if (hubEvent.name == LoggingEventName.WRITE_LOG_FAILURE.toString()) {
        Log.i("LOGGING", "Failed to write logs")
    } else if (hubEvent.name == LoggingEventName.FLUSH_LOG_FAILURE.toString()) {
        Log.i("LOGGING", "Failed to flush logs")
    }
}
```

</Block>
<Block name="RxJava">

```java
RxAmplify.Hub.on(HubChannel.LOGGING)
.map(HubEvent::getName)
.subscribe(name -> {
    if (name.equals(LoggingEventName.WRITE_LOG_FAILURE.toString())) {
        Log.i("LOGGING", "Failed to write logs");
        return;
    } else if (name.equals(LoggingEventName.FLUSH_LOG_FAILURE.toString())) {
        Log.i("LOGGING", "Failed to flush logs");
        return;
    }
});
```
</Block>
</BlockSwitcher>

    </InlineFilter>

    <InlineFilter filters={['swift']}>
<BlockSwitcher>

<Block name="Listener">

```swift
import Amplify
```

```swift
// Assumes `unsubscribeToken` is declared as an instance variable in your view
unsubscribeToken = Amplify.Hub.listen(to: .logging) { payload in
    switch payload.eventName {
    case HubPayload.EventName.Logging.writeLogFailure:
        print("Error writing to local log")
    case HubPayload.EventName.Logging.flushLogFailure:
        print("Error sending log events to CloudWatch")
    default:
        break
    }
}
```

</Block>

<Block name="Combine">

```swift
import Amplify
```

```swift
// Assumes `sink` is declared as an instance variable in your code
sink = Amplify.Hub
    .publisher(for: .logging)
    .sink { payload in
        switch payload.eventName {
        case HubPayload.EventName.Logging.writeLogFailure:
            print("Error writing to local log")
        case HubPayload.EventName.Logging.flushLogFailure:
            print("Error sending log events to CloudWatch")
        default:
            break
        }
    }
```

</Block>

</BlockSwitcher>    
</InlineFilter>






Contents of build-a-backend_add-aws-services_logging_index.txt:
import { getChildPageNodes } from '@/utils/getChildPageNodes';
import { getCustomStaticPath } from '@/utils/getCustomStaticPath';

export const meta = {
  title: 'Logging',
  description: 'Logging',
  platforms: [
    'android',
    'swift'
  ],
  route: "/[platform]/build-a-backend/add-aws-services/logging"
};

export const getStaticPaths = async () => {
  return getCustomStaticPath(meta.platforms);
};

export function getStaticProps(context) {
  const childPageNodes = getChildPageNodes(meta.route);
  return {
    props: {
      meta,
      childPageNodes
    }
  };
}


<Overview childPageNodes={props.childPageNodes} />


Contents of build-a-backend_add-aws-services_logging_remote-configuration_index.txt:
import { getCustomStaticPath } from '@/utils/getCustomStaticPath';

export const meta = {
  title: 'Remotely change log levels',
  description: 'Setup logging to fetch remote log levels',
  platforms: [
    'swift',
    'android'
  ]
};

export const getStaticPaths = async () => {
  return getCustomStaticPath(meta.platforms);
};

export function getStaticProps(context) {
  return {
    props: {
      platform: context.params.platform,
      meta
    }
  };
}

You can remotely configure the Amplify Logger, enabling you to make changes to your logging levels or user allow list in your deployed applications.

<Callout>
  The logging configurations you set remotely will overwrite the local log level
  and persist for future app sessions.
</Callout>

## Set up remote configuration backend resources

<Callout>

You can use the Amplify to [add custom CDK resources](/[platform]/build-a-backend/add-aws-services/custom-resources/).

</Callout>

Below is an example CDK construct that provisions the Amazon CloudWatch, AWS API Gateway, AWS Lambda, and AWS S3 bucket. The CDK construct also deploys the remote configuration file to the AWS S3 bucket which you can then update to change the configuration level or user allow list.

### Permissions

The CDK construct creates IAM policies and assigns them to the Amplify authenticated and unauthenticated roles.

1. The API Gateway endpoint can only be invoked by user with the Amplify authenticated or unauthenticated roles.
2. The AWSCloudWatch logs can only be created and sent by users with the Amplify authenticated or unauthenticated roles. The permission policy cannot be modified to be more restrictive and scoped to specific users.
3. The lambda invocation is only allowed from the provisioned AWS API Gateway resource.
4. The S3 bucket containing the `remoteloggingconstraints.json` can only be read by the Lambda execution role.

### Replace the placeholder values with your own values:

- `<log-group-name>` is the log group that logs will be sent to. Note that this CDK construct sample includes logic to create the CloudWatch log group that you may have already created in previous steps.
- `<s3-bucket-name>` is the S3 bucket that will hold the logging constraints json file that gets fetched remotely.
- `<amplify-authenticated-role-name>` and `<amplify-unauthenticated-role-name>` are Amplify roles created as part of Amplify Auth configuration via Amplify CLI.

### Resource dependencies

- `lambdaConfig` provides the location and lambda for reading from S3. An example is provided in the [lambda handler](#sample-lambda-handler) section.
- `configFileName` and `loggingConfigLocation` provides the location and file name of the log level configuration file that is deployed to S3. An example is provided in the [Creating remote configuration file](#creating-remote-configuration-file) section.

```ts
import * as cdk from "aws-cdk-lib"
import { Construct } from "constructs"
import * as apigateway from "aws-cdk-lib/aws-apigateway"
import * as lambda from "aws-cdk-lib/aws-lambda"
import * as s3 from "aws-cdk-lib/aws-s3"
import * as logs from "aws-cdk-lib/aws-logs"
import { BucketDeployment, Source } from "aws-cdk-lib/aws-s3-deployment"
import * as path from "path"
import * as iam from "aws-cdk-lib/aws-iam"

export class RemoteLoggingConstraintsConstruct extends Construct {
  constructor(scope: Construct, id: string, props: RemoteLoggingConstraintProps) {
    super(scope, id)

    // ** provision CloudWatch Log Group to send logs **
    const region = cdk.Stack.of(this).region
    const account = cdk.Stack.of(this).account
    const logGroupName = <log-group-name>
    const authRoleName = <amplify-authenticated-role-name>
    const unAuthRoleName = <amplify-unauthenticated-role-name>

    new logs.LogGroup(this, 'Log Group', {
      logGroupName: logGroupName,
      retention: logs.RetentionDays.INFINITE
    })

    const authRole = iam.Role.fromRoleName(this, "Auth-Role", authRoleName)
    const unAuthRole = iam.Role.fromRoleName(this, "UnAuth-Role", unAuthRoleName)
    const logResource = `arn:aws:logs:${region}:${account}:log-group:${logGroupName}:log-stream:*`
    const logIAMPolicy = new iam.PolicyStatement({
      effect: iam.Effect.ALLOW,
      resources: [logResource],
      actions: ["logs:PutLogEvents", "logs:DescribeLogStreams", "logs:CreateLogStream"]
    })

    authRole.addToPrincipalPolicy(logIAMPolicy)
    unAuthRole.addToPrincipalPolicy(logIAMPolicy)

    // ** provision resource to support remote configuration (API Gateway, S3 bucket, and Lambda) **
    const <loggingConfigLocation> = 'resources/config/remoteloggingconstraints.json'
    const <lambdaConfig> = 'resources/lambda/remoteconfig.js'
    const <configFileName> = 'remoteloggingconstraints.json'

    const remoteConfigBucket = new s3.Bucket(this, 'AmplifyRemoteLogging-Bucket', {
        publicReadAccess: false,
        versioned: true,
        bucketName: <s3-bucket-name>
      });

    new BucketDeployment(this, `AmplifyRemoteLogging-BucketDeployment`, {
        sources: [
            Source.asset(path.dirname(path.join(<loggingConfigLocation>))),
        ],
        destinationBucket: remoteConfigBucket
    });

    const handler = new lambda.Function(this, "AmplifyRemoteLogging-Handler", {
      runtime: lambda.Runtime.NODEJS_18_X,
      code: lambda.Code.fromAsset(path.dirname(path.join(<lambdaConfig>))),
      handler: "remotelogging.main",
      environment: {
        BUCKET: <s3-bucket-name>,
        KEY: <configFileName>
      }
    })

    remoteConfigBucket.grantRead(handler)

    const api = new apigateway.RestApi(this, "AmplifyRemoteLogging-API", {
      restApiName: "Logging API",
      description: "API Gateway for Remote Logging"
    })

    const getRemoteLoggingIntegration = new apigateway.LambdaIntegration(handler)
    const loggingConstraints = api.root.addResource('loggingconstraints')
    const getLoggingConstraints = loggingConstraints.addMethod('GET', getRemoteLoggingIntegration, {
      authorizationType: apigateway.AuthorizationType.IAM
    })

    const apiInvokePolicy = new iam.PolicyStatement({
      effect: iam.Effect.ALLOW,
      resources: [ getLoggingConstraints.methodArn ],
      actions: ['execute-api:Invoke']
    })

    authRole.addToPrincipalPolicy(apiInvokePolicy)
    unAuthRole.addToPrincipalPolicy(apiInvokePolicy)

    new cdk.CfnOutput(this, 'APIEndpoint', {
      value: `https://${api.restApiId}.execute-api.${region}.amazonaws.com/prod/loggingconstraints`,
    });
    new cdk.CfnOutput(this, 'CloudWatchLogGroupName', { value: logGroupName });
    new cdk.CfnOutput(this, 'CloudWatchRegion', { value: region });
  }
}
```

The API endpoint, CloudWatch log group, and region will be printed out in the terminal. You can use this information to setup the Amplify library.

### Sample Lambda handler

Below is a sample lambda that reads and returns the `remoteloggingconstraints.json` from AWS S3. Note that the configuration is cached by version via the usages of ETag in this example. This lets lambda be more efficient and save bandwidth, as it does not need to resend a full configuration file if the content was not changed.

```js
const { S3Client, GetObjectCommand } = require('@aws-sdk/client-s3');
const s3 = new S3Client({});
const bucketName = process.env.BUCKET;
const key = process.env.KEY;
let cachedConfig = {
  expiresOn: 0,
  ETag: '',
  config: ''
};

exports.main = async function (event, context) {
  try {
    if (event.httpMethod === 'GET') {
      if (!cachedConfig.config || Date.now() > cachedConfig.expiresOn) {
        // refresh cache if cache is invalid
        const command = new GetObjectCommand({ Bucket: bucketName, Key: key });
        const s3Resp = await s3.send(command);
        await setCachedConfig(s3Resp);
      }

      if (event.headers['If-None-Match'] === cachedConfig.ETag) {
        // return 304 not modified if config has not changed
        return {
          statusCode: 304
        };
      } else {
        // return updated/modified config with latest ETag
        return {
          statusCode: 200,
          headers: { "'ETag'": cachedConfig.ETag },
          body: cachedConfig.config
        };
      }
    }
  } catch (error) {
    const resp = error.stack || JSON.stringify(error, null, 2);
    return {
      statusCode: 400,
      headers: {},
      body: JSON.stringify(resp)
    };
  }
};

const setCachedConfig = async (s3Resp) => {
  cachedConfig = {
    expiresOn: Date.now() + 600 * 1000, //10 minutes
    ETag: s3Resp.ETag.replace(/\"/gi, ''), //remove \" from string
    config: await s3Resp.Body.transformToString()
  };
};
```

## Creating remote configuration file

Below is a sample remote config file that overwrites the local file in the mobile application. This file will be deployed to S3. Once deployed, you can change your application log levels by editing this file in S3.

```json
{
  "defaultLogLevel": "ERROR",
  "categoryLogLevel": {
    "API": "DEBUG",
    "AUTH": "DEBUG"
  },
  "userLogLevel": {
    "cognito-sub-xyz-123": {
      "defaultLogLevel": "VERBOSE",
      "categoryLogLevel": {
        "API": "VERBOSE",
        "AUTH": "VERBOSE"
      }
    }
  }
}
```

## Enable remote configuration in your app

To enable Amplify Logger to fetch remote log levels, you will need to provide the API endpoint that has the log levels and the refresh interval for updating the remote configuration locally on the user's device.



<BlockSwitcher>
  <Block name="With Configuration File">
In your application, update the `amplifyconfiguration_logging` file by adding a new json section `defaultRemoteConfiguration`:

```json
{
    "awsCloudWatchLoggingPlugin": {
      "enable": true,
      "logGroupName": "<log-group-name>",
      "region": "<region>",
      "localStoreMaxSizeInMB": 1,
      "flushIntervalInSeconds": 60,
      "loggingConstraints": {
          "defaultLogLevel": "ERROR"
      },
      "defaultRemoteConfiguration": {
          "endpoint": "<your-api-endpoint>",
          "refreshIntervalInSeconds": 1200
      }
    }
}
```


  </Block>

  <Block name="With Code">

<InlineFilter filters={['android']}>
<BlockSwitcher>
<Block name="Java">

```java
LoggingConstraints loggingConstraints = new LoggingConstraints(LogLevel.WARN);
RemoteLoggingConstraintProvider remoteLoggingConstraintProvider = new DefaultRemoteLoggingConstraintProvider(<endpoint-url>, <region>)
AWSCloudWatchLoggingPluginConfiguration config = new AWSCloudWatchLoggingPluginConfiguration (<log-group-name>, <region>, loggingConstraints);
Amplify.addPlugin(new AWSCloudWatchLoggingPlugin(config, remoteLoggingConstraintProvider));
```

</Block>
<Block name="Kotlin">

```kotlin
val loggingConstraints = LoggingConstraints(defaultLogLevel = LogLevel.WARN)
val remoteLoggingConstraintProvider = DefaultRemoteLoggingConstraintProvider(<endpoint-url>, <region>)
val config = AWSCloudWatchLoggingPluginConfiguration(logGroupName = <log-group-name>, region = <region>, loggingConstraints = loggingConstraints)
Amplify.addPlugin(AWSCloudWatchLoggingPlugin(config, remoteLoggingConstraintProvider))
```
</Block>
<Block name="RxJava">

```java
LoggingConstraints loggingConstraints = new LoggingConstraints(LogLevel.WARN);
RemoteLoggingConstraintProvider remoteLoggingConstraintProvider = new DefaultRemoteLoggingConstraintProvider(<endpoint-url>, <region>)
AWSCloudWatchLoggingPluginConfiguration config = new AWSCloudWatchLoggingPluginConfiguration (<log-group-name>,<region>, loggingConstraints);
Amplify.addPlugin(new AWSCloudWatchLoggingPlugin(config, remoteLoggingConstraintProvider));
```

</Block>
</BlockSwitcher>

</InlineFilter>
<InlineFilter filters={['swift']}>
Specify the remote config provider as a parameter when constructing the `AWSCloudWatchLoggingPlugin` instance.

```swift
do {
    let endpointUrl: URL = URL(string: "<your-api-endpoint>")!
    let remoteConfigProvider = DefaultRemoteLoggingConstraintsProvider(endpoint: endpointUrl, region: "<region>")
    let loggingPlugin = AWSCloudWatchLoggingPlugin(remoteLoggingConstraintsProvider: remoteConfigProvider)
    try Amplify.add(plugin: loggingPlugin)
    try Amplify.configure(with: .amplifyOutputs)
} catch {
    assert(false, "Error initializing Amplify: \(error)")
}
```
</InlineFilter>
  </Block>
</BlockSwitcher>


Contents of build-a-backend_add-aws-services_logging_sdk_index.txt:
import { getCustomStaticPath } from '@/utils/getCustomStaticPath';

export const meta = {
  title: 'Use AWS SDK for logging',
  description: 'Get the Amplify Logging escape hatch',
  platforms: [
    'swift',
    'android'
  ]
};

export const getStaticPaths = async () => {
  return getCustomStaticPath(meta.platforms);
};

export function getStaticProps(context) {
  return {
    props: {
      platform: context.params.platform,
      meta
    }
  };
}

For advanced use cases where Amplify does not provide the functionality, you can retrieve the escape hatch to access the underlying Amazon CloudWatch client.

<InlineFilter filters={['android']}>

The escape hatch provides access to the underlying `CloudWatchLogsClient` instance. Then retrieve the escape hatch with this code:

**Gradle Imports**

```kotlin title="app/build.gradle.kts" 
implementation("aws.sdk.kotlin:cloudwatchlogs:KOTLIN_SDK_VERSION")
```

<BlockSwitcher>
<Block name="Java">

```java
AWSCloudWatchLoggingPlugin plugin = (AWSCloudWatchLoggingPlugin)Amplify.Logging.getPlugin("awsCloudWatchLoggingPlugin");
CloudWatchLogsClient client = plugin.getEscapeHatch();
```

</Block>
<Block name="Kotlin">

```kotlin
val plugin = Amplify.Logging.getPlugin("awsCloudWatchLoggingPlugin") as AWSCloudWatchLoggingPlugin
val client = plugin.escapeHatch
```

</Block>
<Block name="RxJava">

```java
AWSCloudWatchLoggingPlugin plugin = (AWSCloudWatchLoggingPlugin)Amplify.Logging.getPlugin("awsCloudWatchLoggingPlugin");
CloudWatchLogsClient client = plugin.getEscapeHatch();
```

</Block>
</BlockSwitcher>



</InlineFilter>


<InlineFilter filters={['swift']}>

Add import statements

```swift
import AWSCloudWatchLoggingPlugin
import AWSCloudWatchLogs
```

Get a direct reference to the instance of CloudWatchLogsClientProtocol and directly interact with AWSCloudWatch via the [AWS SDK for Swift](https://docs.aws.amazon.com/sdk-for-swift/index.html)

```swift
let cloudWatchPlugin = try Amplify.Logging.getPlugin(for: "awsCloudWatchLoggingPlugin") as? AWSCloudWatchLoggingPlugin
let cloudWatchClient: CloudWatchLogsClientProtocol? = cloudWatchPlugin?.getEscapeHatch()
```


</InlineFilter>


Contents of build-a-backend_add-aws-services_logging_send-logs_index.txt:
import { getCustomStaticPath } from '@/utils/getCustomStaticPath';

export const meta = {
  title: 'Send logs',
  description: 'Use of Amplify Logger to write and send logs',
  platforms: [
    'swift',
    'android'
  ]
};

export const getStaticPaths = async () => {
  return getCustomStaticPath(meta.platforms);
};

export function getStaticProps(context) {
  return {
    props: {
      platform: context.params.platform,
      meta
    }
  };
}

With the Amplify Logger, you can send logs to Amazon CloudWatch from errors that are caught by the Amplify library or by adding your own custom log messages. You can also customize which levels of log messages to send to CloudWatch.

## Log messages

<Callout>

You should follow best security practices when logging messages. This includes validating log messages and ensuring log messages don't contain personally identifiable information and/or sensitive data.

</Callout>

You can log messages using the Amplify logger to a specific namespace to help you group logs that are similar when they are sent to CloudWatch. To accomplish this, get an instance of the `Logger` and specify a `category name` and/or `namespace`. Use the `Logger` instance to log messages at the desired log level. The `category name` and `namespace` values are used to tag your log messages that will appear in CloudWatch. They are also used to identify and fetch the logger again without creating a new `Logger` instance.

You can also log JSON formatted log messages to leverage [AWS CloudWatch](https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/AnalyzingLogData.html) query and filter supports.

<InlineFilter filters={['android']}>

<BlockSwitcher>
<Block name="Java">

```java
Logger logger = Amplify.Logging.logger(AmplifyCategory.Auth, "<namespace>")
try {
  String result = doSomething();
  logger.debug("result: " + result);
} catch(Exception: exception) {
  logger.error("operation failed", exception);
}

```

</Block>
<Block name="Kotlin">

```kotlin
val logger = Amplify.Logging.logger(AmplifyCategory.Auth, "<namespace>")
try {
  val result = doSomething()
  logger.debug("result: $result")
} catch (exception: Exception) {
  logger.error("operation failed", exception)
}
```

</Block>
<Block name="RxJava">

```java
Logger logger = Amplify.Logging.logger(AmplifyCategory.Auth, "<namespace>")
try {
  String result = doSomething();
  logger.debug("result: " + result);
} catch(Exception: exception) {
  logger.error("operation failed", exception);
}
```
</Block>
</BlockSwitcher>

The following are existing Amplify category names that are used by default by Amplify when automatically logging errors from the library.
* `ANALYTICS`
* `API`
* `AUTH`
* `DATASTORE`
* `HUB`
* `LOGGING`
* `NOTIFICATIONS`
* `PREDICTIONS`
* `STORAGE`
* `GEO`


</InlineFilter>


<InlineFilter filters={['swift']}>

```swift
let logger = Amplify.Logging.logger(forCategory: "Authentication", forNamespace: "<your-code-namespace>")
do {
    let jsonEncoder = JSONEncoder()
    let person = Person(firstName: "John", lastName: "Doe", age: 25)
    let jsonData = try jsonEncoder.encode(person)
    let jsonString = String(data: jsonData, encoding: String.Encoding.utf8)!
    logger.debug(jsonString)
} catch {
    logger.error("Error encoding person instance")
}
```

The following are existing Amplify category names that are used by default by Amplify when automatically logging errors from the library.
* `Analytics`
* `API`
* `Authentication`
* `DataStore`
* `Geo`
* `Hub`
* `Logging`
* `Predictions`
* `PushNotifications`
* `Storage`

</InlineFilter>



Contents of build-a-backend_add-aws-services_logging_set-up-logging_index.txt:
import { getCustomStaticPath } from '@/utils/getCustomStaticPath';

export const meta = {
  title: 'Set up Logging',
  description: 'Learn how to set up Amplify logging',
  platforms: [
    'swift',
    'android'
  ]
};

export const getStaticPaths = async () => {
  return getCustomStaticPath(meta.platforms);
};

export function getStaticProps(context) {
  return {
    props: {
      platform: context.params.platform,
      meta
    }
  };
}

The Amplify Logger enables you to troubleshoot and debug issues with your apps, to help you provide the best experience for your customers. You can log messages for errors by the Amplify library and add custom logs as well and send them to Amazon CloudWatch. With the Amplify Logger, you also can remotely change your logging configuration to adjust your logging levels, or add an allow list of customer IDs to help you detect issues more granularly for your apps in production.

## Prerequisites

<InlineFilter filters={['android']}>




* An Android application targeting Android SDK API level 24 (Android 7.0) or above with Amplify libraries integrated
    * For a full example, please follow the [quickstart](/android/start/quickstart/).
* The Amplify Logger is available for versions 2.11.0 and beyond of the Amplify Android SDK

### Install the Amplify library

Expand **Gradle Scripts**, open **build.gradle (Module: app)**. You will already have configured Amplify by following the steps in the [quickstart guide](/[platform]/start/quickstart/).

Add these libraries into the `dependencies` block:
```kotlin title="app/build.gradle.kts"  
android {
    compileOptions {
        // Support for Java 8 features
        isCoreLibraryDesugaringEnabled = true
        sourceCompatibility = JavaVersion.VERSION_1_8
        targetCompatibility = JavaVersion.VERSION_1_8
    }
}

dependencies {
    // Amplify API dependencies
    // highlight-start
    implementation("com.amplifyframework:aws-auth-cognito:ANDROID_VERSION")
    implementation("com.amplifyframework:aws-logging-cloudwatch:ANDROID_VERSION")
    // highlight-end
    // ... other dependencies
    coreLibraryDesugaring("com.android.tools:desugar_jdk_libs:2.0.3")
}
```

`aws-auth-cognito` is used to provide authentication for Amazon CloudWatch.

Click **Sync Now**.

</InlineFilter>


<InlineFilter filters={['swift']}>


An application with Amplify libraries integrated and a minimum target of any of the following:
- **iOS 13.0**, using **Xcode 14.1** or later.
- **macOS 10.15**, using **Xcode 14.1** or later.
- **tvOS 13.0**, using **Xcode 14.3** or later.
- **watchOS 9.0**, using **Xcode 14.3** or later.
- **visionOS 1.0**, using **Xcode 15 beta 2** or later. (Preview support - see below for more details.)

For a full example, please follow the [mobile support walkthrough](/swift/start/quickstart/) .

<Callout>

visionOS support is currently in **preview** and can be used by using the latest [Amplify Release](https://github.com/aws-amplify/amplify-swift/releases). 
As new Xcode and visionOS versions are released, the support will be updated with any necessary fixes on a best effort basis.

</Callout>

</InlineFilter>

## Set up the backend



<Callout>

To add custom CDK resources, please follow the guide [here](/[platform]/build-a-backend/add-aws-services/custom-resources/).

</Callout>

You will need to create a log group in Amazon CloudWatch to send logs to. You can create and provision a log group by going through the AWS Console and creating your log group manually or using Amplify and AWS CDK to provision and deploy the AWS resources.

Below is a sample CDK construct to create the Amazon CloudWatch log group as well as creating and assigning the permission policies to Amplify roles.

The `<log-group-name>` and `<region>` configured in the CDK construct will be used later to initialize the Amplify Logger plugin.

### Replace the placeholder values with your own values:

- `<log-group-name>` is the log group that logs will be sent to. Note that this CDK construct sample includes logic to create the CloudWatch log group that you may have already created in previous steps.
- `<amplify-authenticated-role-name>` and `<amplify-unauthenticated-role-name>` are Amplify roles created as part of Amplify Auth configuration via Amplify CLI.

```ts
import * as path from "node:path"
import * as cdk from "aws-cdk-lib"
import * as logs from "aws-cdk-lib/aws-logs"
import * as iam from "aws-cdk-lib/aws-iam"
import { Construct } from "constructs"

export class RemoteLoggingConstraintsConstruct extends Construct {
  constructor(scope: Construct, id: string, props: RemoteLoggingConstraintProps) {
    super(scope, id)

    const region = cdk.Stack.of(this).region
    const account = cdk.Stack.of(this).account
    const logGroupName = <log-group-name>
    const authRoleName = <amplify-authenticated-role-name>
    const unAuthRoleName = <amplify-unauthenticated-role-name>

    new logs.LogGroup(this, 'Log Group', {
      logGroupName: logGroupName,
      retention: logs.RetentionDays.INFINITE
    })

    const authRole = iam.Role.fromRoleName(this, "Auth-Role", authRoleName)
    const unAuthRole = iam.Role.fromRoleName(this, "UnAuth-Role", unAuthRoleName)
    const logResource = `arn:aws:logs:${region}:${account}:log-group:${logGroupName}:log-stream:*`
    const logIAMPolicy = new iam.PolicyStatement({
      effect: iam.Effect.ALLOW,
      resources: [logResource],
      actions: ["logs:PutLogEvents", "logs:DescribeLogStreams", "logs:CreateLogStream"]
    })

    authRole.addToPrincipalPolicy(logIAMPolicy)
    unAuthRole.addToPrincipalPolicy(logIAMPolicy)

    new cdk.CfnOutput(this, 'CloudWatchLogGroupName', { value: logGroupName });
    new cdk.CfnOutput(this, 'CloudWatchRegion', { value: region });
  }
}
```

The `<log-group-name>` and `<region>` will be printed out in the in the terminal. You can use this information to setup the Amplify library in the next section.

## Initialize Amplify Logging

In this section, we will initialize and setup the Amplify library. The Logger can be configured via a configuration file or in code when your app is initializing.


<InlineFilter filters={['android']}>

<BlockSwitcher>
  <Block name="With Configuration File">
    In your mobile app, create and add a `amplifyconfiguration_logging.json` to the same location as the `amplify_outputs.json` file.

The `<log-group-name>` and `<region>` is the value you specified in the CDK construct as part of provisioning your backend resources.  These values can also be found at the end of the output logs when deploying the sample CDK construct.  The configuration file is the data source for the logging plugin to know where, when and what logs to sends.  The example below configures the logging plugin to automatically send all logs at log level `ERROR` at 60 seconds interval and store logs locally up to 1MB.

```json
{
    "awsCloudWatchLoggingPlugin": {
        "enable": true,
        "logGroupName": "<log-group-name>",
        "region": "<region>",
        "localStoreMaxSizeInMB": 1,
        "flushIntervalInSeconds": 60,
        "loggingConstraints": {
            "defaultLogLevel": "ERROR"
        }
    }
}
```

To use the Amplify Logger and Amplify Auth categories in your app, you need to create and configure their corresponding plugins by calling the `Amplify.addPlugin()` and `Amplify.configure()` methods.

Add the following imports to the top of your main `Application` file:

<Callout warning>
Before calling the `Amplify.configure` function, make sure to either download the `amplify_outputs.json` file from the console, or generate it with the following command: 

```bash title="Terminal" showLineNumbers={false}
npx ampx generate outputs --app-id <app-id> --branch main --out-dir app/src/main/res/raw
```

Next, be sure the file you generated or downloaded is in the appropriate resource directory for your application (for example, `app/src/main/res/raw`) in your Android project. Otherwise, you will not be able to compile your application.
</Callout>

<BlockSwitcher>
<Block name="Java">

```java
import com.amplifyframework.auth.cognito.AWSCognitoAuthPlugin;
import com.amplifyframework.core.Amplify;
import com.amplifyframework.core.configuration.AmplifyOutputs;
import com.amplifyframework.logging.cloudwatch.AWSCloudWatchLoggingPlugin;
```

```java
Amplify.addPlugin(new AWSCognitoAuthPlugin());
Amplify.addPlugin(new AWSCloudWatchLoggingPlugin());
```

Your class will look like this:

```java
public class MyAmplifyApp extends Application {
    @Override
    public void onCreate() {
        super.onCreate();

        try {
            // Add these lines to add the AWSCognitoAuthPlugin and AWSCloudWatchLoggingPlugin plugins
            Amplify.addPlugin(new AWSCognitoAuthPlugin());
            Amplify.addPlugin(new AWSCloudWatchLoggingPlugin());
            Amplify.configure(AmplifyOutputs.fromResource(R.raw.amplify_outputs), getApplicationContext());

            Log.i("MyAmplifyApp", "Initialized Amplify");
        } catch (AmplifyException error) {
            Log.e("MyAmplifyApp", "Could not initialize Amplify", error);
        }
    }
}
```

</Block>
<Block name="Kotlin">

```kotlin
import com.amplifyframework.auth.cognito.AWSCognitoAuthPlugin
import com.amplifyframework.core.Amplify
import com.amplifyframework.core.configuration.AmplifyOutputs
import com.amplifyframework.logging.cloudwatch.AWSCloudWatchLoggingPlugin
```

Add the following code to your onCreate() method in your application class. When Amplify initializes the logging plugin, it will automatically find and load the configuration in the `amplifyconfiguration_logging.json` that is bundled with your app.

```kotlin
Amplify.addPlugin(AWSCognitoAuthPlugin())
Amplify.addPlugin(AWSCloudWatchLoggingPlugin())
```

Your class will look like this:

```kotlin
class MyAmplifyApp : Application() {
    override fun onCreate() {
        super.onCreate()

        try {
            // Add these lines to add the AWSCognitoAuthPlugin and AWSCloudWatchLoggingPlugin plugins
            Amplify.addPlugin(AWSCognitoAuthPlugin())
            Amplify.addPlugin(AWSCloudWatchLoggingPlugin())
            Amplify.configure(AmplifyOutputs.fromResource(R.raw.amplify_outputs), applicationContext)

            Log.i("MyAmplifyApp", "Initialized Amplify")
        } catch (error: AmplifyException) {
            Log.e("MyAmplifyApp", "Could not initialize Amplify", error)
        }
    }
}
```

</Block>
<Block name="RxJava">

```java
import com.amplifyframework.auth.cognito.AWSCognitoAuthPlugin;
import com.amplifyframework.core.configuration.AmplifyOutputs;
import com.amplifyframework.rx.RxAmplify;
import com.amplifyframework.logging.cloudwatch.AWSCloudWatchLoggingPlugin;
```

```java
RxAmplify.addPlugin(new AWSCognitoAuthPlugin());
RxAmplify.addPlugin(new AWSCloudWatchLoggingPlugin());
```

Your class will look like this:

```java
public class MyAmplifyApp extends Application {
    @Override
    public void onCreate() {
        super.onCreate();

        try {
            // Add these lines to add the AWSCognitoAuthPlugin and AWSCloudWatchLoggingPlugin plugins
            RxAmplify.addPlugin(new AWSCognitoAuthPlugin());
            RxAmplify.addPlugin(new AWSCloudWatchLoggingPlugin());
            RxAmplify.configure(AmplifyOutputs.fromResource(R.raw.amplify_outputs), getApplicationContext());

            Log.i("MyAmplifyApp", "Initialized Amplify");
        } catch (AmplifyException error) {
            Log.e("MyAmplifyApp", "Could not initialize Amplify", error);
        }
    }
}
```
</Block>
</BlockSwitcher>

  </Block>
<Block name="With Code">

To use the Amplify Logger and Amplify Auth categories in your app, you need to create and configure their corresponding plugins by calling the `Amplify.addPlugin()` and `Amplify.configure()` methods.

Add the following imports to the top of your main `Application` file:
<BlockSwitcher>
<Block name="Java">

```java
import com.amplifyframework.auth.cognito.AWSCognitoAuthPlugin;
import com.amplifyframework.core.Amplify;
import com.amplifyframework.core.configuration.AmplifyOutputs;
import com.amplifyframework.logging.cloudwatch.AWSCloudWatchLoggingPlugin;
```
Add the following code to its initializer. If there is none, you can create a default.  The `<log-group-name>` and `<region>` are values you specified in the CDK construct as part of provisioning your backend resources.  These values can also be found at the end of the output logs when deploying the sample CDK construct.
The example below configures the logging plugin to automatically send all logs at log level `ERROR` at 60 seconds interval and store logs locally up to 1MB.
```java
Amplify.addPlugin(new AWSCognitoAuthPlugin());
AWSCloudWatchLoggingPluginConfiguration config = new AWSCloudWatchLoggingPluginConfiguration (<log-group-name>,<region>,1, 60);
Amplify.addPlugin(new AWSCloudWatchLoggingPlugin(config));
```

Your class will look like this:

```java
public class MyAmplifyApp extends Application {
    @Override
    public void onCreate() {
        super.onCreate();

        try {
            // Add these lines to add the AWSCognitoAuthPlugin and AWSCloudWatchLoggingPlugin plugins
            Amplify.addPlugin(new AWSCognitoAuthPlugin());
            AWSCloudWatchLoggingPluginConfiguration config = new AWSCloudWatchLoggingPluginConfiguration (<log-group-name>,<region>,1,60);
            Amplify.addPlugin(new AWSCloudWatchLoggingPlugin(config));
            Amplify.configure(AmplifyOutputs.fromResource(R.raw.amplify_outputs), getApplicationContext());

            Log.i("MyAmplifyApp", "Initialized Amplify");
        } catch (AmplifyException error) {
            Log.e("MyAmplifyApp", "Could not initialize Amplify", error);
        }
    }
}
```

</Block>
<Block name="Kotlin">

```kotlin
import com.amplifyframework.core.Amplify
import com.amplifyframework.core.configuration.AmplifyOutputs
import com.amplifyframework.auth.cognito.AWSCognitoAuthPlugin
import com.amplifyframework.logging.cloudwatch.AWSCloudWatchLoggingPlugin
```

Add the following code to your onCreate() method in your application class.

```kotlin
Amplify.addPlugin(AWSCognitoAuthPlugin())
val config = AWSCloudWatchLoggingPluginConfiguration(logGroupName = <log-group-name>, region = <region>, localStoreMaxSizeInMB = 1, flushIntervalInSeconds = 60)
Amplify.addPlugin(AWSCloudWatchLoggingPlugin(config))
```

Your class will look like this:

```kotlin
class MyAmplifyApp : Application() {
    override fun onCreate() {
        super.onCreate()

        try {
            // Add these lines to add the AWSCognitoAuthPlugin and AWSCloudWatchLoggingPlugin plugins
            Amplify.addPlugin(AWSCognitoAuthPlugin())
            val config = AWSCloudWatchLoggingPluginConfiguration(logGroupName = <log-group-name>, region = <region>, localStoreMaxSizeInMB = 1, flushIntervalInSeconds = 60)
            Amplify.addPlugin(AWSCloudWatchLoggingPlugin(config))
            Amplify.configure(AmplifyOutputs.fromResource(R.raw.amplify_outputs), applicationContext)

            Log.i("MyAmplifyApp", "Initialized Amplify")
        } catch (error: AmplifyException) {
            Log.e("MyAmplifyApp", "Could not initialize Amplify", error)
        }
    }
}
```

</Block>
<Block name="RxJava">

```java
import com.amplifyframework.auth.cognito.AWSCognitoAuthPlugin;
import com.amplifyframework.core.configuration.AmplifyOutputs;
import com.amplifyframework.rx.RxAmplify;
import com.amplifyframework.logging.cloudwatch.AWSCloudWatchLoggingPlugin;
```

```java
RxAmplify.addPlugin(new AWSCognitoAuthPlugin());
AWSCloudWatchLoggingPluginConfiguration config = new AWSCloudWatchLoggingPluginConfiguration (<log-group-name>,<region>, 1,60);
RxAmplify.addPlugin(new AWSCloudWatchLoggingPlugin(config));
```

Your class will look like this:

```java
public class MyAmplifyApp extends Application {
    @Override
    public void onCreate() {
        super.onCreate();

        try {
            // Add these lines to add the AWSCognitoAuthPlugin and AWSCloudWatchLoggingPlugin plugins
            RxAmplify.addPlugin(new AWSCognitoAuthPlugin());
            AWSCloudWatchLoggingPluginConfiguration config = new AWSCloudWatchLoggingPluginConfiguration (<log-group-name>,<region>,1,60);
            RxAmplify.addPlugin(new AWSCloudWatchLoggingPlugin(config));
            RxAmplify.configure(AmplifyOutputs.fromResource(R.raw.amplify_outputs), getApplicationContext());

            Log.i("MyAmplifyApp", "Initialized Amplify");
        } catch (AmplifyException error) {
            Log.e("MyAmplifyApp", "Could not initialize Amplify", error);
        }
    }
}
```
</Block>
</BlockSwitcher>

</Block>

</BlockSwitcher>

</InlineFilter>


<InlineFilter filters={['swift']}>

<BlockSwitcher>
  <Block name="With Configuration File">
In your mobile app, create and add a `amplifyconfiguration_logging.json` to the same location as the `amplify_outputs.json` file.  Ensure that the file is included in the `Copy Bundle Resources` build phase.

The `<log-group-name>` and `<region>` is the value you specified in the CDK construct as part of provisioning your backend resources.  These values can also be found at the end of the output logs when deploying the sample CDK construct.  The configuration file is the data source for the logging plugin to know where, when and what logs to sends.  The example below configures the logging plugin to automatically send all logs at log level `ERROR` at 60 seconds interval and store logs locally up to 1MB.

```json
{
    "awsCloudWatchLoggingPlugin": {
        "enable": true,
        "logGroupName": "<log-group-name>",
        "region": "<region>",
        "localStoreMaxSizeInMB": 1,
        "flushIntervalInSeconds": 60,
        "loggingConstraints": {
            "defaultLogLevel": "ERROR"
        }
    }
}
```

To use the Amplify Logger and Amplify Auth categories in your app, you need to create and configure their corresponding plugins by calling the `Amplify.add(plugin:)` and `Amplify.configure()` methods.

Add the following imports to the top of your main `App` file:

```swift
import Amplify
import AWSCognitoAuthPlugin
import AWSCloudWatchLoggingPlugin
```

Add the following code to its initializer. If there is none, you can create a default `init`. When Amplify initializes the logging plugin, it will automatically find and load the configuration in the `amplifyconfiguration_logging.json` that is bundled with your app.

```swift
init() {
    do {
        try Amplify.add(plugin: AWSCognitoAuthPlugin())
        try Amplify.add(plugin: AWSCloudWatchLoggingPlugin())
        try Amplify.configure(with: .amplifyOutputs)
    } catch {
        assert(false, "Error initializing Amplify: \(error)")
    }
}
```


  </Block>
<Block name="With Code">
To use the Amplify Logger and Amplify Auth categories in your app, you need to create and configure their corresponding plugins by calling the `Amplify.add(plugin:)` and `Amplify.configure()` methods.

Add the following imports to the top of your main `App` file:

```swift
import Amplify
import AWSCognitoAuthPlugin
import AWSCloudWatchLoggingPlugin
```

Add the following code to its initializer. If there is none, you can create a default `init`.  The `<log-group-name>` and `<region>` are values you specified in the CDK construct as part of provisioning your backend resources.  These values can also be found at the end of the output logs when deploying the sample CDK construct.
The example below configures the logging plugin to automatically send all logs at log level `ERROR` at 60 seconds interval and store logs locally up to 1MB.

```swift
init() {
    do {
        let loggingConfiguration = AWSCloudWatchLoggingPluginConfiguration(logGroupName: "<log-group-name>", region: "<region>", localStoreMaxSizeInMB: 1, flushIntervalInSeconds: 60)
        let loggingPlugin = AWSCloudWatchLoggingPlugin(loggingPluginConfiguration: loggingConfiguration)
        try Amplify.add(plugin: loggingPlugin)
        try Amplify.configure(with: .amplifyOutputs)
    } catch {
        assert(false, "Error initializing Amplify: \(error)")
    }
}
```


</Block>

</BlockSwitcher>

</InlineFilter>


Contents of build-a-backend_add-aws-services_logging_view-logs_index.txt:
import { getCustomStaticPath } from '@/utils/getCustomStaticPath';

export const meta = {
  title: 'View logs',
  description: 'Learn how to view logs in Amazon CloudWatch',
  platforms: [
    'swift',
    'android'
  ]
};

export const getStaticPaths = async () => {
  return getCustomStaticPath(meta.platforms);
};

export function getStaticProps(context) {
  return {
    props: {
      platform: context.params.platform,
      meta
    }
  };
}

Log messages are sent to the Amazon CloudWatch log group that you created and specified in the [initial set up](/[platform]/build-a-backend/add-aws-services/logging/set-up-logging). Each user log messages can be found in user-specific log stream in the log group. Log stream names are generated based on the user's device identifier and a user identifier.
For an authenticated user, the log stream name is `<device-identifier>.<user-identifier>`.  For an unauthenticated user, the log stream name is `<device-identifier>.guest`.

The device identifier is the unique identifier provided by the user's hardware device and OS. You can use the Amplify Auth category to [retrieve the user identifier](/[platform]/build-a-backend/add-aws-services/logging/configure-user/#retrieve-userids-with-amplify-auth) for a specific user if needed. You can also retrieve the user identifier by visiting the Amazon Cognito console and inspecting the `User ID` in User pools.

## View logs in AWS console
You can follow the following steps to access your logs in AWS Console:
1. Log into AWS Console
2. Navigate to Amazon CloudWatch
3. In the left navigation panel and under the **Logs** menu, click the **Log groups** menu item.
4. In the **Log groups** window, enter your log group name in the **Filter** field
5. Click on your log group that is returned in the filtered results to view all log streams


Contents of build-a-backend_add-aws-services_overriding-resources_index.txt:
import { getCustomStaticPath } from '@/utils/getCustomStaticPath';

export const meta = {
  title: 'Overriding resources',
  description: 'Learn how to override resources.',
  platforms: [
    'android',
    'angular',
    'flutter',
    'javascript',
    'nextjs',
    'react',
    'react-native',
    'swift',
    'vue'
  ]
};

export const getStaticPaths = async () => {
  return getCustomStaticPath(meta.platforms);
};

export function getStaticProps(context) {
  return {
    props: {
      meta
    }
  };

}

<Callout warning>

By using overrides, you may create a backend that the Amplify libraries or client config is unable to interpret properly. Always test changes in a staging environment.

</Callout>

When defining resources, you can access some underlying [AWS Cloud Development Kit (CDK)](https://docs.aws.amazon.com/cdk/latest/guide/home.html) construct properties to modify resource configurations. This allows you to customize backend resources beyond what is offered through the `define*` functions.

Overrides are defined in the `amplify/backend.ts` file after the `defineBackend` call has been made.

```ts title="amplify/backend.ts"
import { defineBackend } from '@aws-amplify/backend';
import { auth } from './auth/resource';
import { data } from './data/resource';

const backend = defineBackend({
  auth,
  data
});

// overrides go here
```

The `backend` object exposes a `resources` property with objects for each of the components passed into the `defineBackend` function. Each of these resource objects exposes underlying L1 and L2 AWS CDK constructs that you can modify.

For example, here is how you can access the Cognito user pool that is created by `defineAuth` and set a custom removal policy on the resource.

```ts title="amplify/backend.ts"
import { RemovalPolicy } from 'aws-cdk-lib';
import { defineBackend } from '@aws-amplify/backend';
import { auth } from './auth/resource';

const backend = defineBackend({
  auth
});

const userPool = backend.auth.resources.userPool;
userPool.applyRemovalPolicy(RemovalPolicy.RETAIN_ON_UPDATE_OR_DELETE);
```

Most L1 and L2 AWS CDK constructs that are used by the `define*` functions are accessible in this way.

## Example - Grant access permissions between resources

Consider the case that we want to grant a function created by `defineFunction` access to call the Cognito user pool created by `defineAuth`. For most cases it is recommended to use the [`access` property on `defineAuth`](/[platform]/build-a-backend/auth/grant-access-to-auth-resources/), however for permissions not exposed by this property, access can be accomplished with the following overrides.

```ts title="amplify/backend.ts"
import { defineBackend } from '@aws-amplify/backend';
import { auth } from './auth/resource';
import { data } from './data/resource';
import { authAuditorFunction } from './functions/auth-auditor-function/resource';

const backend = defineBackend({
  auth,
  data,
  authAuditorFunction,
});

const userPool = backend.auth.resources.userPool;
const lambdaFunction = backend.authAuditorFunction.resources.lambda;

// grant the lambdaFunction access to list auth events for a particular user
userPool.grant(lambdaFunction, 'cognito:AdminListUserAuthEvents');

// pass the Lambda the UserPool ID so that the Lambda can use it to make SDK calls
backend.authAuditorFunction.addEnvironment('USER_POOL_ID', userPool.userPoolId);
```

## Example - Modify L1 CDK Constructs

It's possible to reach all the way down to the raw CloudFormation to mutate properties using `addPropertyOverride` on an AWS CDK construct. To edit the password policies of the Cognito user pool in `defineAuth`, you can use the following code.

```ts title="amplify/backend.ts"
import { defineBackend } from '@aws-amplify/backend';
import { auth } from './auth/resource';

const backend = defineBackend({
  auth,
});
// extract L1 CfnUserPool resources
const { cfnUserPool } = backend.auth.resources.cfnResources;
// modify cfnUserPool policies directly
cfnUserPool.policies = {
  passwordPolicy: {
    minimumLength: 10,
    requireLowercase: true,
    requireNumbers: true,
    requireSymbols: true,
    requireUppercase: true,
    temporaryPasswordValidityDays: 20,
  },
};
```

Note the usage of `auth.resources.cfnResources`. This property exposes [L1 CDK constructs](https://docs.aws.amazon.com/cdk/v2/guide/constructs.html#constructs_l1_using) that map one-to-one with the underlying CloudFormation properties.

The `auth.resources.cfnResources.cfnUserPool` property in the above example directly maps to the [AWS::Cognito::UserPool CloudFormation resource](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-cognito-userpool.html).

This is different from `auth.resources.userPool` in the first example, which is an [L2 CDK construct](https://docs.aws.amazon.com/cdk/v2/guide/constructs.html#constructs_using). These are constructs that provide a convenient interface around several related L1 constructs.

For situations where you need even more customization of your app backend, see the documentation on [custom resources](/[platform]/build-a-backend/add-aws-services/custom-resources).


Contents of build-a-backend_add-aws-services_predictions_identify-entity_index.txt:
import { getCustomStaticPath } from '@/utils/getCustomStaticPath';

export const meta = {
  title: 'Identify entities from images',
  description: 'Learn how to identify entities from an image using Amplify.',
  platforms: [
    'angular',
    'javascript',
    'nextjs',
    'react',
    'react-native',
    'vue',
  ]
};

export async function getStaticPaths() {
  return getCustomStaticPath(meta.platforms);
}

export function getStaticProps() {
  return {
    props: {
      meta
    }
  };
}

<Callout informational>

**Note:** Make sure to complete the [getting started](../set-up-predictions) section first, where you will set up the IAM roles with the right policy actions

</Callout>


## Working with the API

`Predictions.identify({entities: {...}}) => Promise<>`
Detects entities from an image and potentially related information such as position, faces, and landmarks. Can also identify celebrities and entities that were previously added. This function returns a Promise that returns an object with the entities that was identified.  

Input can be sent directly from the browser (using File object or ArrayBuffer object) or an Amazon S3 key from project bucket.

Detect entities directly from image uploaded from the browser. (File object)

```ts
import { Predictions } from '@aws-amplify/predictions';

const response = await Predictions.identify({
  entities: {
    source: {
      file,
    },
  }
});
```

Detect entities directly from image binary from the browser. (ArrayBuffer object)
This technique is useful when you have base64 encoded binary image data, for example, from a webcam source.

```ts
import { Predictions } from '@aws-amplify/predictions';

const response = await Predictions.identify({
  entities: {
    source: {
      bytes: imageArrayBuffer,
    },
  }
});
```

From Amazon S3 key

```ts
import { Predictions } from '@aws-amplify/predictions';

const response = await Predictions.identify({
  entities: {
    source: {
      key: pathToPhoto,
      level: 'guest' | 'private' | 'protected', //optional, default is the configured on Storage category
    },
  }
});
```

The following options are independent of which `source` is specified. For demonstration purposes it will be used `file` but it can be used S3 Key as well. 

Detecting bounding box of faces from an image with its landmarks (eyes, mouth, nose).

```ts
import { Predictions } from '@aws-amplify/predictions';

const { entities } = await Predictions.identify({
  entities: {
    source: {
      file,
    },
  }
})
for (const { boundingBox, landmarks } of entities) {
  const { 
    width, // ratio of overall image width
    height, // ratio of overall image height
    left, // left coordinate as a ratio of overall image width
    top // top coordinate as a ratio of overall image height
  } = boundingBox;
  
  for (const landmark of landmarks) {
    const {
      type, // string "eyeLeft", "eyeRight", "mouthLeft", "mouthRight", "nose"
      x, // ratio of overall image width
      y // ratio of overall image height
    } = landmark;
  }
}
```

Detecting celebrities on an image. It will return only celebrities the name and urls with related information.

```ts
import { Predictions } from '@aws-amplify/predictions';

const { entities } = await Predictions.identify({
  entities: {
    source: {
      file,
    },
    celebrityDetection: true // boolean. It will only show detected celebrities 
  }
})

for (const { boundingBox, landmarks, metadata } of entities) {
  const { 
    name,
    urls 
  } = metadata; // celebrity info
  
  // ...
}
.catch(err => console.log({ err }));
```

Detecting entities from previously uploaded images (e.g. Advanced Configuration for Identify Entities)

```ts
import { Predictions } from '@aws-amplify/predictions';

const { entities } = await Predictions.identify({
  entities: {
    source: {
      file,
    },
    collection: true
  }
})

for (const { boundingBox, metadata } of entities) {
  const {
    width, // ratio of overall image width
    height, // ratio of overall image height
    left, // left coordinate as a ratio of overall image width
    top // top coordinate as a ratio of overall image height
  } = boundingBox;
  const { externalImageId } = metadata; // this is the object key on S3 from the original image
}
```


Contents of build-a-backend_add-aws-services_predictions_identify-text_index.txt:
import { getCustomStaticPath } from '@/utils/getCustomStaticPath';

export const meta = {
  title: 'Identify text',
  description: 'Learn how to identify text from images and documents in your application using AWS Amplify.',
  platforms: [
    'angular',
    'javascript',
    'nextjs',
    'react',
    'react-native',
    'vue',
  ]
};

export async function getStaticPaths() {
  return getCustomStaticPath(meta.platforms);
}

export function getStaticProps() {
  return {
    props: {
      meta
    }
  };
}

<Callout informational>

**Note:** Make sure to complete the [getting started](../set-up-predictions) section first, where you will set up the IAM roles with the right policy actions

</Callout>

## Working with the API

Detect text in an input image. Input can be sent directly from the browser or an Amazon S3 key from project bucket.

```ts
import { Predictions } from '@aws-amplify/predictions';

const response = await Predictions.identify({
  text: {
    source: {
      file
    }
  }
});
```

## Identify image stored in Amazon S3

```ts
import { Predictions } from '@aws-amplify/predictions';

const response = await Predictions.identify({
  text: {
    source: {
      key: pathToPhoto,
    }
  }
})
```

> The following options are independent of which `source` is specified. For demonstration purposes we will reference a `file` but it can be an S3 Key as well. `Predictions.identify({text : {...}})` can detect unstructured text `PLAIN`, structured text from tables `TABLE` or text from forms `FORM`.

## Identify plain text

For detecting plain text, you can see the whole detected text, the lines detected, the position of each line of text, and each word.

```ts
import { Predictions } from '@aws-amplify/predictions';

const response = await Predictions.identify({
  text: {
    source: {
      file
    },
    format: 'PLAIN'
  }
});

const {
  text: {
    fullText, // String
    lines, // Array of String ordered from top to bottom
    linesDetailed /* Array of objects that contains
        text, // String
        boundingBox: {
          width, // ratio of overall image width
          height, // ratio of overall image height
          left, // left coordinate as a ratio of overall image width
          top // top coordinate as a ratio of overall image height
        },
        polygon // Array of { x, y } coordinates as a ratio of overall image width and height
        */,
    words // Array of objects that contains { text, boundingBox, polygon}
  }
} = response;
```

## Identify structured forms

For detecting structured forms (documents, tables, etc.) from an image, `keyValues` will return a string of the entity found in the image as well as metadata such as selected checkboxes or the relative location in the image using a `boundingBox`.

```ts
import { Predictions } from '@aws-amplify/predictions';

const response = await Predictions.identify({
  text: {
    source: {
      file
    },
    format: 'FORM'
  }
});

const {
  text: {
    // same as PLAIN +
    keyValues // Array of { key: string, value: { text: string, selected: boolean}, polygon, boundingBox }
  }
} = response;
```

For example the below image would return `keyValues` with "Test" or "Checked" as a key, and `true` since they are selected. The location of these elements would be returned in the `boundingBox` value.

![A table of key values containing "Test" or "Checked" as keys, with a value of true indicating their selection status. The positions of these elements will be provided within the boundingBox parameter](/images/IdentifyTable.png)

## Identify structured tables

For detecting structured tables from an image

```ts
import { Predictions } from '@aws-amplify/predictions';

const response = await Predictions.identify({
  text: {
    source: {
      file
    },
    format: 'TABLE'
  }
});

const {
  text: {
    // same as PLAIN +
    tables: [
      {
        size: { rows, columns },
        table // Matrix Array[ Array ] of size rows
        // each element of the array contains { text, boundingBox, polygon, selected, rowSpan, columnSpan}
      }
    ]
  }
} = response;
```

For detecting tables and forms on the image just select format "ALL"

```ts
import { Predictions } from '@aws-amplify/predictions';

const { text } = await Predictions.identify({
  text: {
    source: {
      file
    },
    format: 'ALL'
  }
});
```


Contents of build-a-backend_add-aws-services_predictions_index.txt:
import { getChildPageNodes } from '@/utils/getChildPageNodes';
import { getCustomStaticPath } from '@/utils/getCustomStaticPath';

export const meta = {
  title: 'AI/ML Predictions',
  description: 'Learn how to set up AI/ML Predictions',
  route: "/[platform]/build-a-backend/add-aws-services/predictions",
  platforms: [
    'angular',
    'javascript',
    'nextjs',
    'react',
    'react-native',
    'vue',
  ]
};

export async function getStaticPaths() {
  return getCustomStaticPath(meta.platforms);
}

export function getStaticProps(context) {
  const childPageNodes = getChildPageNodes(meta.route);
  return {
    props: {
      meta,
      childPageNodes
    }
  };
}


Amplify provides provides a solution for using AI and ML cloud services to enhance your application. Some supported use cases:

- [Convert text to speech](/[platform]/build-a-backend/add-aws-services/predictions/text-to-speech/)
- [Transcribe audio to text](/[platform]/build-a-backend/add-aws-services/predictions/transcribe-audio/)
- [Translate text from one language to another](/[platform]/build-a-backend/add-aws-services/predictions/translate/)
- [Identify text from an image](/[platform]/build-a-backend/add-aws-services/predictions/identify-text/)
- [Identify entities from an image](/[platform]/build-a-backend/add-aws-services/predictions/identify-entity/)
- [Identify real world objects from an image](/[platform]/build-a-backend/add-aws-services/predictions/identify-entity)
- [Interpret text](/[platform]/build-a-backend/add-aws-services/predictions/interpret-sentiment)

Predictions is broadly organized into 3 key use cases - Identify, Convert, and Interpret - which are available in the client API as well as CLI workflows.

- `Identify` will find text (words, tables, pages from a book), entities (faces and/or celebrities) from images. You can also identify real world landmarks or objects such as chairs, desks, etc. which are referred to as “labels” from images.
- `Convert` allows you to translate text from one source language to a target language. You can also generate speech audio from text input. Lastly, you can take an audio input and transcribe it using a websocket stream.
- `Interpret` allows you to analyze text for language, entities (places, people), key phrases, sentiment (positive, neutral, negative), and syntax (pronouns, verbs, adjectives).

Some common use cases are listed below, as well as an advanced workflow which allows you to perform dynamic image indexing from a connected s3 bucket.

Predictions comes with built-in support for [Amazon Translate](https://docs.aws.amazon.com/translate/latest/dg/what-is.html), [Amazon Polly](https://docs.aws.amazon.com/polly/latest/dg/what-is.html), [Amazon Transcribe](https://docs.aws.amazon.com/transcribe/latest/dg/what-is-transcribe.html), [Amazon Rekognition](https://docs.aws.amazon.com/rekognition/latest/dg/what-is.html), [Amazon Textract](https://docs.aws.amazon.com/textract/latest/dg/what-is.html), and [Amazon Comprehend](https://docs.aws.amazon.com/comprehend/latest/dg/what-is.html).

<Overview childPageNodes={props.childPageNodes} />


Contents of build-a-backend_add-aws-services_predictions_interpret-sentiment_index.txt:
import { getCustomStaticPath } from '@/utils/getCustomStaticPath';

export const meta = {
  title: 'Interpret sentiment',
  description: 'Learn how to determine key phrases, sentiment, language, syntax, and entities from text using Amplify.',
  platforms: [
    'angular',
    'javascript',
    'nextjs',
    'react',
    'react-native',
    'vue',
  ]
};

export async function getStaticPaths() {
  return getCustomStaticPath(meta.platforms);
}

export function getStaticProps() {
  return {
    props: {
      meta
    }
  };
}

<Callout informational>

**Note:** Make sure to complete the [getting started](../set-up-predictions) section first, where you will set up the IAM roles with the right policy actions

</Callout>

## Working with the API

Analyze text to find key phrases, sentiment (positive, negative, neutral), or the syntax (pronouns, verbs, etc.). You can also find entities in the text such as names or places, or perform language detection.

```ts
import { Predictions } from '@aws-amplify/predictions';

const result = await Predictions.interpret({
  text: {
    source: {
      text: textToInterpret,
    },
    type: 'ALL'
  }
})
```


Contents of build-a-backend_add-aws-services_predictions_label-image_index.txt:
import { getCustomStaticPath } from '@/utils/getCustomStaticPath';

export const meta = {
  title: 'Label objects in an image',
  description: 'Learn more about how to detect labels in an image using Amplify. For example you can detect if an image has objects such as chairs, desks etc.',
  platforms: [
    'angular',
    'javascript',
    'nextjs',
    'react',
    'react-native',
    'vue',
  ]
};

export async function getStaticPaths() {
  return getCustomStaticPath(meta.platforms);
}

export function getStaticProps() {
  return {
    props: {
      meta
    }
  };
}

<Callout informational>

**Note:** Make sure to complete the [getting started](../set-up-predictions) section first, where you will set up the IAM roles with the right policy actions

</Callout>

## Working with the API

Detect labels, such if an image has a desk or a chair in it

```javascript
import { Predictions } from '@aws-amplify/predictions';

Predictions.identify({
  labels: {
    source: {
      file
    },
    type: 'LABELS'
  }
})
  .then((response) => {
    const { labels } = response;
    labels.forEach((object) => {
      const { name, boundingBoxes } = object;
    });
  })
  .catch((err) => console.log({ err }));
```

Detect unsafe content in an image

```ts
import { Predictions } from '@aws-amplify/predictions';

const { unsafe } = await Predictions.identify({
  labels: {
    source: {
      file
    },
    type: 'UNSAFE'
  }
})
```

For both labels and unsafe content

```ts
import { Predictions } from '@aws-amplify/predictions';

const { labels, unsafe } = await Predictions.identify({
  labels: {
    source: {
      file
    },
    type: 'ALL'
  }
})
```


Contents of build-a-backend_add-aws-services_predictions_set-up-predictions_index.txt:
import { getCustomStaticPath } from '@/utils/getCustomStaticPath';

export const meta = {
  title: 'Set up Predictions',
  description: 'Get started with integrating ML capabilities into your application using Amplify',
  platforms: [
    'angular',
    'javascript',
    'nextjs',
    'react',
    'react-native',
    'vue',
  ]
};

export async function getStaticPaths() {
  return getCustomStaticPath(meta.platforms);
}

export function getStaticProps() {
  return {
    props: {
      meta
    }
  };
}

To enable Predictions we need to set up the appropriate IAM policy for Roles in your Cognito Identity Pool in order to use an appropriate feature. Additionally, we need to use the ```addOutput``` method to patch the custom Predictions resource to the expected output configuration.

<Callout informational>

**Note:** In the following example, we configure the policy to enable all supported ML capabilities. Ensure to include only the actions & resources relevant to your specific use cases.
To learn more, check the docs of [Amazon Translate](https://docs.aws.amazon.com/translate/latest/dg/what-is.html), [Amazon Polly](https://docs.aws.amazon.com/polly/latest/dg/what-is.html), [Amazon Transcribe](https://docs.aws.amazon.com/transcribe/latest/dg/what-is-transcribe.html), [Amazon Rekognition](https://docs.aws.amazon.com/rekognition/latest/dg/what-is.html), [Amazon Textract](https://docs.aws.amazon.com/textract/latest/dg/what-is.html), and [Amazon Comprehend](https://docs.aws.amazon.com/comprehend/latest/dg/what-is.html).

</Callout>


```ts title="amplify/backend.ts"
import { PolicyStatement } from "aws-cdk-lib/aws-iam";
import { defineBackend } from "@aws-amplify/backend";
import { auth } from "./auth/resource";

const backend = defineBackend({
  auth,
});

// Configure a policy for the required use case.
// The actions included below cover all supported ML capabilities
backend.auth.resources.unauthenticatedUserIamRole.addToPrincipalPolicy(
  new PolicyStatement({
    actions: [
      "translate:TranslateText",
      "polly:SynthesizeSpeech",
      "transcribe:StartStreamTranscriptionWebSocket",
      "comprehend:DetectSentiment",
      "comprehend:DetectEntities",
      "comprehend:DetectDominantLanguage",
      "comprehend:DetectSyntax",
      "comprehend:DetectKeyPhrases",
      "rekognition:DetectFaces",
      "rekognition:RecognizeCelebrities",
      "rekognition:DetectLabels",
      "rekognition:DetectModerationLabels",
      "rekognition:DetectText",
      "rekognition:DetectLabel",
      "rekognition:SearchFacesByImage",      
      "textract:AnalyzeDocument",
      "textract:DetectDocumentText",
      "textract:GetDocumentAnalysis",
      "textract:StartDocumentAnalysis",
      "textract:StartDocumentTextDetection",
    ],
    resources: ["*"],
  })
);

backend.addOutput({
  custom: {
    Predictions: {
      convert: {
        translateText: {
          defaults: {
            sourceLanguage: "en",
            targetLanguage: "es",
          },
          proxy: false,
          region: backend.auth.stack.region,
        },
        speechGenerator: {
          defaults: {
            voiceId: "Ivy",
          },
          proxy: false,
          region: backend.auth.stack.region,
        },
        transcription: {
          defaults: {
            language: "en-US",
          },
          proxy: false,
          region: backend.auth.stack.region,
        },
      },
      identify: {
        identifyEntities: {
          defaults: {
            collectionId: "default",
            maxEntities: 10,
          },
          celebrityDetectionEnabled: true,
          proxy: false,
          region: backend.auth.stack.region,
        },
        identifyLabels: {
          defaults: {
            type: "ALL",
          },
          proxy: false,
          region: backend.auth.stack.region,
        },
        identifyText: {
          defaults: {
            format: "ALL",
          },
          proxy: false,
          region: backend.auth.stack.region,
        },
      },
      interpret: {
        interpretText: {
          defaults: {
            type: "ALL",
          },
          proxy: false,
          region: backend.auth.stack.region,
        },
      },
    },
  },
});
```

## Install Amplify Libraries

To install the Amplify library to use predictions features, run the following commands in your project's root folder:

```bash title="Terminal" showLineNumbers={false}
npm add aws-amplify @aws-amplify/predictions
```

## Configure the frontend

Import and load the configuration file in your app. It is recommended you add the Amplify configuration step to your app's root entry point. For example `main.ts` in React and Angular.

```ts title="src/main.ts"
import { Amplify } from "aws-amplify";
import outputs from "./amplify_outputs.json";

Amplify.configure(outputs);

Amplify.configure({
  ...Amplify.getConfig(),
  Predictions: outputs.custom.Predictions,
});
```


Contents of build-a-backend_add-aws-services_predictions_text-to-speech_index.txt:
import { getCustomStaticPath } from '@/utils/getCustomStaticPath';

export const meta = {
  title: 'Text to speech',
  description: 'Learn how to integrate text-to-speech capabilities into your application using Amplify.',
  platforms: [
    'angular',
    'javascript',
    'nextjs',
    'react',
    'react-native',
    'vue',
  ]
};

export async function getStaticPaths() {
  return getCustomStaticPath(meta.platforms);
}

export function getStaticProps() {
  return {
    props: {
      meta
    }
  };
}

<Callout informational>

**Note:** Make sure to complete the [getting started](../set-up-predictions) section first, where you will set up the IAM roles with the right policy actions

</Callout>

## Working with the API

Generate an audio buffer for playback from a text input.

```ts
import { Predictions } from '@aws-amplify/predictions';

const result = await Predictions.convert({
  textToSpeech: {
    source: {
      text: textToGenerateSpeech
    },
    voiceId: "Amy" 
  }
})
```

To view the complete list of voiceId options refer to [Voices in Amazon Polly](https://docs.aws.amazon.com/polly/latest/dg/voicelist.html).





Contents of build-a-backend_add-aws-services_predictions_transcribe-audio_index.txt:
import { getCustomStaticPath } from '@/utils/getCustomStaticPath';

export const meta = {
  title: 'Transcribe audio to text',
  description: 'Learn more about how to transcribe audio to text (also known as speech-to-text) for your application using Amplify',
  platforms: [
    'angular',
    'javascript',
    'nextjs',
    'react',
    'react-native',
    'vue',
  ]
};

export async function getStaticPaths() {
  return getCustomStaticPath(meta.platforms);
}

export function getStaticProps() {
  return {
    props: {
      meta
    }
  };
}

<Callout informational>

**Note:** Make sure to complete the [getting started](../set-up-predictions) section first, where you will set up the IAM roles with the right policy actions

</Callout>

## Working with the API

You can transcribe a PCM Audio byte buffer to Text, such as a recording from microphone.

```ts
import { Predictions } from '@aws-amplify/predictions';

const { transcription } = await Predictions.convert({
  transcription: {
    source: {
      bytes
    }
  }
})
```

To view the complete list of all the supported languages and language specific features refer to [the supported languages list](https://docs.aws.amazon.com/transcribe/latest/dg/supported-languages.html). The language data input type has to support streaming for it to work with Amplify Predictions.


Contents of build-a-backend_add-aws-services_predictions_translate_index.txt:
import { getCustomStaticPath } from '@/utils/getCustomStaticPath';

export const meta = {
  title: 'Translate language',
  description: 'Learn more about how to integrate translation capabilities for your application using Amplify',
  platforms: [
    'angular',
    'javascript',
    'nextjs',
    'react',
    'react-native',
    'vue',
  ]
};

export async function getStaticPaths() {
  return getCustomStaticPath(meta.platforms);
}

export function getStaticProps() {
  return {
    props: {
      meta
    }
  };
}

<Callout informational>

**Note:** Make sure to complete the [getting started](../set-up-predictions) section first, where you will set up the IAM roles with the right policy actions

</Callout>


## Working with the API

Translate text from one source language to a destination language.

```ts
import { Predictions } from '@aws-amplify/predictions';

const result = await Predictions.convert({
  translateText: {
    source: {
      text: textToTranslate,
      language : "es"
    },
    targetLanguage: "en"
  }
})
```

To view the complete list of supported languages refer to [Supported languages and language codes](https://docs.aws.amazon.com/translate/latest/dg/what-is-languages.html).




Contents of build-a-backend_add-aws-services_pubsub_index.txt:
import { getCustomStaticPath } from '@/utils/getCustomStaticPath';
import { getChildPageNodes } from '@/utils/getChildPageNodes';

export const meta = {
  title: 'PubSub',
  description: 'The AWS Amplify PubSub category provides connectivity with cloud-based message-oriented middleware. You can use PubSub to pass messages between your app instances and its backend creating real-time interactive experiences.',
  platforms: [
    'angular',
    'javascript',
    'nextjs',
    'react',
    'react-native',
    'vue'
  ],
  route: '/gen1/[platform]/build-a-backend/more-features/pubsub'
};

export const getStaticPaths = async () => {
  return getCustomStaticPath(meta.platforms);
};

export function getStaticProps(context) {
  const childPageNodes = getChildPageNodes(meta.route);
  return {
    props: {
      platform: context.params.platform,
      meta,
      childPageNodes
    }
  };
}

<Overview childPageNodes={props.childPageNodes} />


Contents of build-a-backend_add-aws-services_pubsub_publish_index.txt:
import { getCustomStaticPath } from '@/utils/getCustomStaticPath';

export const meta = {
  title: 'Publish',
  description: 'Learn more about how to publish a message using the PubSub category in Amplify',
  platforms: [
    'javascript',
    'react-native',
    'angular',
    'nextjs',
    'react',
    'vue'
  ]
};

export const getStaticPaths = async () => {
  return getCustomStaticPath(meta.platforms);
};

export function getStaticProps(context) {
  return {
    props: {
      platform: context.params.platform,
      meta
    }
  };
}

import js0 from '/src/fragments/lib/pubsub/js/publish.mdx';

<Fragments
  fragments={{
    javascript: js0,
    angular: js0,
    nextjs: js0,
    react: js0,
    vue: js0
  }}
/>

import reactnative0 from '/src/fragments/lib/pubsub/js/publish.mdx';

<Fragments fragments={{ 'react-native': reactnative0 }} />


Contents of build-a-backend_add-aws-services_pubsub_set-up-pubsub_index.txt:
import { getCustomStaticPath } from '@/utils/getCustomStaticPath';

export const meta = {
  title: 'Set up Amplify PubSub',
  description: 'Learn more about how you can use PubSub to pass messages between your app instances and your app’s backend creating real-time interactive experiences.',
  platforms: [
    'javascript',
    'react-native',
    'angular',
    'nextjs',
    'react',
    'vue'
  ]
};

export const getStaticPaths = async () => {
  return getCustomStaticPath(meta.platforms);
};

export function getStaticProps(context) {
  return {
    props: {
      platform: context.params.platform,
      meta
    }
  };
}

import pubsubGettingStarted from '/src/fragments/lib/pubsub/js/getting-started.mdx';

<Fragments
  fragments={{
    javascript: pubsubGettingStarted,
    angular: pubsubGettingStarted,
    nextjs: pubsubGettingStarted,
    react: pubsubGettingStarted,
    vue: pubsubGettingStarted,
    'react-native': pubsubGettingStarted
  }}
/>


Contents of build-a-backend_add-aws-services_pubsub_subscribe_index.txt:
import { getCustomStaticPath } from '@/utils/getCustomStaticPath';

export const meta = {
  title: 'Subscribe and unsubscribe',
  description: "Learn more about how to subscribe to and unsubscribe from topics using Amplify's PubSub category",
  platforms: [
    'javascript',
    'react-native',
    'angular',
    'nextjs',
    'react',
    'vue'
  ]
};

export const getStaticPaths = async () => {
  return getCustomStaticPath(meta.platforms);
};

export function getStaticProps(context) {
  return {
    props: {
      platform: context.params.platform,
      meta
    }
  };
}

import js0 from '/src/fragments/lib/pubsub/js/subunsub.mdx';

<Fragments
  fragments={{
    javascript: js0,
    angular: js0,
    nextjs: js0,
    react: js0,
    vue: js0
  }}
/>

import reactnative0 from '/src/fragments/lib/pubsub/js/subunsub.mdx';

<Fragments fragments={{ 'react-native': reactnative0 }} />


Contents of build-a-backend_add-aws-services_rest-api_customize-authz_index.txt:
import { getCustomStaticPath } from '@/utils/getCustomStaticPath';

export const meta = {
  title: 'Define authorization rules',
  description: "Learn more about how to define authorization rules for Amplify's REST API capabilities",
  platforms: [
    'angular',
    'javascript',
    'nextjs',
    'react',
    'react-native',
    'vue'
  ],
};

export async function getStaticPaths() {
  return getCustomStaticPath(meta.platforms);
}

export function getStaticProps(context) {
  return {
    props: {
      platform: context.params.platform,
      meta
    }
  };
}

When determining the authorization mode for your REST endpoint, there are a few customizations you can do.

## IAM Authorization

By default, the API will be using IAM authorization and the requests will be signed for you automatically. IAM authorization has two modes: one using an **unauthenticated** role, and one using an **authenticated** role. When the user has not signed in, the unauthenticated role is used by default. Once the user has signed in, the authenticate role is used, instead.

## API Key

If you want to configure a public REST API, you can set an API key in Amazon API Gateway or create one using the [CDK construct](https://docs.aws.amazon.com/cdk/api/v2/docs/aws-cdk-lib.aws_apigateway.ApiKey.html). Then, you can set the API key header in the API configuration which will be applied to all requests.

```ts
Amplify.configure(outputs, {
  API: {
    REST: {
      headers: async () => {
        return { 'X-Api-Key': apiKey };
      }
    }
  }
});
```

## Cognito User Pool Authorization

You can use the access token from configured Cognito User Pool to authenticate against REST endpoint. The JWT token can be retrieved from the `Auth` category.

```ts
import { fetchAuthSession } from 'aws-amplify/auth'

const session = await fetchAuthSession();
const token = session.tokens?.idToken
```

Then you need to set the Authorization header in the API category configuration. The following example shows how to set the Authorization header for all requests.

```ts
Amplify.configure(outputs, {
  API: {
    REST: {
      headers: async () => {
        return { Authorization: authToken };
      }
    }
  }
});
```

For more details on how to configure the API Gateway with the custom authorization, see [this](https://docs.aws.amazon.com/apigateway/latest/developerguide/apigateway-integrate-with-cognito.html)

### Note related to use of Access Token or ID Token

The ID Token contains claims about the identity of the authenticated user such as name, email, and phone_number. On the Amplify Authentication category you can retrieve the Id Token using:

```ts
const session = await fetchAuthSession();
const token = session.tokens?.idToken
```

The Access Token contains scopes and groups and is used to grant access to authorized resources. [This is a tutorial for enabling custom scopes](https://aws.amazon.com/premiumsupport/knowledge-center/cognito-custom-scopes-api-gateway/). You can retrieve the Access Token using

```textSpanIntersectsWith
const session = await fetchAuthSession();
const token = session.tokens?.accessToken
```

## Custom Authorization Token

If you want to use a custom authorization token, you can set the token in the API category configuration. The custom authorization token will be applied to all requests.

```ts
Amplify.configure(outputs, {
  API: {
    REST: {
      headers: async () => {
        return { Authorization: customAuthToken };
      }
    }
  }
});
```

## Setting Authorization Headers per Request

Alternatively, you can set the authorization headers per request. For example, if you want to use a custom header named `Authorization` for a specific REST request, you can set the following configuration:

```ts
async function updateItem() {
  await del({
    apiName: 'myRestApi',
    path: 'items/1',
    options: {
      headers: {
        Authorization: authToken
      }
    }
  }).response;
}
```


Contents of build-a-backend_add-aws-services_rest-api_delete-data_index.txt:
import { getCustomStaticPath } from '@/utils/getCustomStaticPath';

export const meta = {
  title: 'Delete data',
  description: 'Using the Delete API REST in Amplify',
  platforms: [
    'angular',
    'javascript',
    'nextjs',
    'react',
    'react-native',
    'vue'
  ],
};

export async function getStaticPaths() {
  return getCustomStaticPath(meta.platforms);
}

export function getStaticProps(context) {
  return {
    props: {
      platform: context.params.platform,
      meta
    }
  };
}

## DELETE requests

To delete an item via the API endpoint:

```ts
import { del } from 'aws-amplify/api';

async function deleteItem() {
  try {
    const restOperation = del({
      apiName: 'myRestApi',
      path: 'items/1'
    });
    await restOperation.response;
    console.log('DELETE call succeeded');
  } catch (e) {
    console.log('DELETE call failed: ', JSON.parse(e.response.body));
  }
}
```


Contents of build-a-backend_add-aws-services_rest-api_existing-resources_index.txt:
import { getCustomStaticPath } from '@/utils/getCustomStaticPath';

export const meta = {
  title: 'Use existing AWS resources',
  description: 'Configure the Amplify Libraries to use existing Amazon API Gateway resources by referencing them in your configuration.',
  platforms: [
    'angular',
    'javascript',
    'nextjs',
    'react',
    'react-native',
    'vue'
  ],
};

export async function getStaticPaths() {
  return getCustomStaticPath(meta.platforms);
}

export function getStaticProps(context) {
  return {
    props: {
      platform: context.params.platform,
      meta
    }
  };
}

Existing Amazon API Gateway resources can be used with the Amplify Libraries by calling `Amplify.configure()` with the API Gateway API name and options. Note, you will need to supply the full resource configuration and library options objects when calling `Amplify.configure()`. The following example shows how to configure additional API Gateway resources to an existing Amplify application:

```ts
import { Amplify } from 'aws-amplify';
import outputs from '../amplify_outputs.json';
Amplify.configure(outputs):

const existingConfig = Amplify.getConfig();

// Add existing resource to the existing configuration.
Amplify.configure({
  ...existingConfig,
  API: {
    ...existingConfig.API,
    REST: {
      ...existingConfig.API?.REST,
      YourAPIName: {
        endpoint:
          'https://abcdefghij1234567890.execute-api.us-east-1.amazonaws.com/stageName',
        region: 'us-east-1' // Optional
      }
    }
  }
});
```

- **YourAPIName**: Friendly name for the API
  - **endpoint**: The HTTPS endpoint of the API
  - **region**: AWS Region where the resources are provisioned. If not specified, the region will be inferred from the endpoint.

Note that before you can add an AWS resource to your application, the application must have the Amplify libraries installed. If you need to perform this step, see [Install Amplify Libraries](/[platform]/build-a-backend/add-aws-services/rest-api/set-up-rest-api/#install-amplify-libraries).


Contents of build-a-backend_add-aws-services_rest-api_fetch-data_index.txt:
import { getCustomStaticPath } from '@/utils/getCustomStaticPath';

export const meta = {
  title: 'Fetch data',
  description: 'Using the GET API REST in Amplify',
  platforms: [
    'angular',
    'javascript',
    'nextjs',
    'react',
    'react-native',
    'vue'
  ],
};

export async function getStaticPaths() {
  return getCustomStaticPath(meta.platforms);
}

export function getStaticProps(context) {
  return {
    props: {
      platform: context.params.platform,
      meta
    }
  };
}

To invoke an endpoint, you need to set input object with required `apiName` option and optional `headers`, `queryParams`, and `body` options. API status code response > 299 are thrown as an `ApiError` instance. The error instance provides `name` and `message` properties parsed from the response.

## GET requests

```ts
import { get } from 'aws-amplify/api';

async function getItem() {
  try {
    const restOperation = get({ 
      apiName: 'myRestApi',
      path: 'items' 
    });
    const response = await restOperation.response;
    console.log('GET call succeeded: ', response);
  } catch (error) {
    console.log('GET call failed: ', JSON.parse(error.response.body));
  }
}
```

## Accessing response payload

You can consume the response payload by accessing the `body` property of the response object. Depending on the use case and the content type of the body, you can consume they payload in string, blob, or JSON.

```ts
// ...
const { body } = await restOperation.response;
// consume as a string:
const str = await body.text();
// OR consume as a blob:
const blob = await body.blob();
// OR consume as a JSON:
const json = await body.json();
```

<Callout warning>

You can not consume the response payload more than once.

</Callout>

## Access HTTP response from errors

The REST API handler may throw an `ApiError` error instance. If the error is caused by an HTTP response with a non-2xx status code, the error instance will provide a `response` property. The `response` property contains following
properties:
* `statusCode`: HTTP status code
* `headers`: HTTP response headers
* `body`: HTTP response body as a string

The following example shows how to access the HTTP response from an `ApiError` instance, so that you can handle the error response from your REST API endpoint:

```ts
import { ApiError, get } from 'aws-amplify/api';

try {
  const restOperation = get({ 
    apiName: 'myRestApi',
    path: 'items' 
  });
  await restOperation.response;
} catch (error) {
  if (error instanceof ApiError) {
    if (error.response) {
      const { 
        statusCode, 
        headers, 
        body 
      } = error.response;
      console.error(`Received ${statusCode} error response with payload: ${body}`);
    }
    // Handle API errors not caused by HTTP response.
  }
  // Handle other errors.
}
```


Contents of build-a-backend_add-aws-services_rest-api_index.txt:
import { getCustomStaticPath } from '@/utils/getCustomStaticPath';
import { getChildPageNodes } from '@/utils/getChildPageNodes';

export const meta = {
  title: 'API (REST)',
  description: 'A straightforward and secure solution for making HTTP requests using REST APIs',
  platforms: [
    'angular',
    'javascript',
    'nextjs',
    'react',
    'react-native',
    'vue'
  ],
  route: '/[platform]/build-a-backend/add-aws-services/rest-api',
};

export async function getStaticPaths() {
  return getCustomStaticPath(meta.platforms);
}

export function getStaticProps(context) {
  const childPageNodes = getChildPageNodes(meta.route);
  return {
    props: {
      platform: context.params.platform,
      meta,
      childPageNodes
    }
  };
}

<Overview childPageNodes={props.childPageNodes} />


Contents of build-a-backend_add-aws-services_rest-api_post-data_index.txt:
import { getCustomStaticPath } from '@/utils/getCustomStaticPath';

export const meta = {
  title: 'Post data',
  description: 'Using Post, Put, etc. in Amplify',
  platforms: [
    'angular',
    'javascript',
    'nextjs',
    'react',
    'react-native',
    'vue'
  ],
};

export async function getStaticPaths() {
  return getCustomStaticPath(meta.platforms);
}

export function getStaticProps(context) {
  return {
    props: {
      platform: context.params.platform,
      meta
    }
  };
}

## POST Requests

Send a POST request with a JSON body.

```ts
import { post } from 'aws-amplify/api';

async function postItem() {
  try {
    const restOperation = post({
      apiName: 'myRestApi',
      path: 'items',
      options: {
        body: {
          message: 'Mow the lawn'
        }
      }
    });

    const { body } = await restOperation.response;
    const response = await body.json();

    console.log('POST call succeeded');
    console.log(response);
  } catch (error) {
    console.log('POST call failed: ', JSON.parse(error.response.body));
  }
}
```


Contents of build-a-backend_add-aws-services_rest-api_set-up-http-api_index.txt:
import { getCustomStaticPath } from '@/utils/getCustomStaticPath';

export const meta = {
  title: 'Set up Amplify HTTP API',
  description: 'The API category provides a solution for making HTTP requests to HTTP API endpoints. The API library can be used for creating signed requests against Amazon API Gateway when the API Gateway Authorization is set to AWS_IAM or Cognito User Pools.',
  platforms: [
    'angular',
    'javascript',
    'nextjs',
    'react',
    'react-native',
    'vue'
  ],
};

export async function getStaticPaths() {
  return getCustomStaticPath(meta.platforms);
}

export function getStaticProps(context) {
  return {
    props: {
      platform: context.params.platform,
      meta
    }
  };
}

Using the [AWS Cloud Development Kit (AWS CDK)](https://aws.amazon.com/cdk/), you can configure Amplify Functions as resolvers for routes of an [HTTP API powered by Amazon API Gateway](https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api.html).

## Set up HTTP API with Lambda Function

To get started, create a new directory and a resource file, `amplify/functions/api-function/resource.ts`. Then, define the function with `defineFunction`:

```ts title="amplify/functions/api-function/resource.ts"
import { defineFunction } from "@aws-amplify/backend";

export const myApiFunction = defineFunction({
  name: "api-function",
});
```

Then, create the corresponding handler file, `amplify/functions/api-function/handler.ts`, file with the following contents:

```ts title="amplify/functions/api-function/handler.ts"
import type { APIGatewayProxyHandlerV2 } from "aws-lambda";

export const handler: APIGatewayProxyHandlerV2 = async (event) => {
  console.log("event", event);
  return {
    statusCode: 200,
    // Modify the CORS settings below to match your specific requirements
    headers: {
      "Access-Control-Allow-Origin": "*", // Restrict this to domains you trust
      "Access-Control-Allow-Headers": "*", // Specify only the headers you need to allow
    },
    body: JSON.stringify("Hello from api-function!"),
  };
};
```

Next, using the AWS CDK, create an HTTP API in your backend file:

```ts title="amplify/backend.ts"
import { defineBackend } from "@aws-amplify/backend";
import { Stack } from "aws-cdk-lib";
import {
  CorsHttpMethod,
  HttpApi,
  HttpMethod,
} from "aws-cdk-lib/aws-apigatewayv2";
import {
  HttpIamAuthorizer,
  HttpUserPoolAuthorizer,
} from "aws-cdk-lib/aws-apigatewayv2-authorizers";
import { HttpLambdaIntegration } from "aws-cdk-lib/aws-apigatewayv2-integrations";
import { Policy, PolicyStatement } from "aws-cdk-lib/aws-iam";
import { myApiFunction } from "./functions/api-function/resource";
import { auth } from "./auth/resource";
import { data } from "./data/resource";

const backend = defineBackend({
  auth,
  data,
  myApiFunction,
});

// create a new API stack
const apiStack = backend.createStack("api-stack");

// create a IAM authorizer
const iamAuthorizer = new HttpIamAuthorizer();

// create a User Pool authorizer
const userPoolAuthorizer = new HttpUserPoolAuthorizer(
  "userPoolAuth",
  backend.auth.resources.userPool,
  {
    userPoolClients: [backend.auth.resources.userPoolClient],
  }
);

// create a new HTTP Lambda integration
const httpLambdaIntegration = new HttpLambdaIntegration(
  "LambdaIntegration",
  backend.myApiFunction.resources.lambda
);

// create a new HTTP API with IAM as default authorizer
const httpApi = new HttpApi(apiStack, "HttpApi", {
  apiName: "myHttpApi",
  corsPreflight: {
    // Modify the CORS settings below to match your specific requirements
    allowMethods: [
      CorsHttpMethod.GET,
      CorsHttpMethod.POST,
      CorsHttpMethod.PUT,
      CorsHttpMethod.DELETE,
    ],
    // Restrict this to domains you trust
    allowOrigins: ["*"],
    // Specify only the headers you need to allow
    allowHeaders: ["*"],
  },
  createDefaultStage: true,
});

// add routes to the API with a IAM authorizer and different methods
httpApi.addRoutes({
  path: "/items",
  methods: [HttpMethod.GET, HttpMethod.PUT, HttpMethod.POST, HttpMethod.DELETE],
  integration: httpLambdaIntegration,
  authorizer: iamAuthorizer,
});

// add a proxy resource path to the API
httpApi.addRoutes({
  path: "/items/{proxy+}",
  methods: [HttpMethod.ANY],
  integration: httpLambdaIntegration,
  authorizer: iamAuthorizer,
});

// add the options method to the route
httpApi.addRoutes({
  path: "/items/{proxy+}",
  methods: [HttpMethod.OPTIONS],
  integration: httpLambdaIntegration,
});

// add route to the API with a User Pool authorizer
httpApi.addRoutes({
  path: "/cognito-auth-path",
  methods: [HttpMethod.GET],
  integration: httpLambdaIntegration,
  authorizer: userPoolAuthorizer,
});

// create a new IAM policy to allow Invoke access to the API
const apiPolicy = new Policy(apiStack, "ApiPolicy", {
  statements: [
    new PolicyStatement({
      actions: ["execute-api:Invoke"],
      resources: [
        `${httpApi.arnForExecuteApi("*", "/items")}`,
        `${httpApi.arnForExecuteApi("*", "/items/*")}`,
        `${httpApi.arnForExecuteApi("*", "/cognito-auth-path")}`,
      ],
    }),
  ],
});

// attach the policy to the authenticated and unauthenticated IAM roles
backend.auth.resources.authenticatedUserIamRole.attachInlinePolicy(apiPolicy);
backend.auth.resources.unauthenticatedUserIamRole.attachInlinePolicy(apiPolicy);

// add outputs to the configuration file
backend.addOutput({
  custom: {
    API: {
      [httpApi.httpApiName!]: {
        endpoint: httpApi.url,
        region: Stack.of(httpApi).region,
        apiName: httpApi.httpApiName,
      },
    },
  },
});
```

## Install Amplify Libraries

<InlineFilter filters={['javascript', "angular", "react", "vue", "react-native", "nextjs"]}>
Use the package manager of your choice to install the Amplify JavaScript library. For example, with `npm`:

```bash title="Terminal" showLineNumbers={false}
npm add aws-amplify
```
</InlineFilter>

<InlineFilter filters={["react-native"]}>
Use the package manager of your choice to install the Amplify JavaScript library. For example, with `npm`:

<Accordion title="Instructions for React Native version 0.72 and below">

  `@aws-amplify/react-native` requires a minimum iOS deployment target of `13.0` if you are using `react-native` version less than or equal to `0.72`. Open the _Podfile_ located in the _ios_ directory and update the `target` value:

  ```diff
   - platform :ios, min_ios_version_supported
   + platform :ios, 13.0
   ```

</Accordion>

```bash title="Terminal" showLineNumbers={false}
npm add aws-amplify @aws-amplify/react-native
```

</InlineFilter>

## Initialize Amplify API

<InlineFilter filters={['javascript', "angular", "react", "vue", "react-native", "nextjs"]}>
To initialize the Amplify API category you need to configure Amplify with `Amplify.configure()`.

Import and load the configuration file in your app. It's recommended you add the Amplify configuration step to your app's root entry point. For example `src/main.ts`:

<InlineFilter filters={['javascript', "angular", "react", "vue", "react-native"]}>
```ts title="src/main.ts"
import { Amplify } from 'aws-amplify';
import outputs from '../amplify_outputs.json';

Amplify.configure(outputs);
const existingConfig = Amplify.getConfig();
Amplify.configure({
  ...existingConfig,
  API: {
    ...existingConfig.API,
    REST: outputs.custom.API,
  },
});
```
</InlineFilter>

<InlineFilter filters={["nextjs"]}>
```tsx title="pages/_app.tsx"
import { Amplify } from 'aws-amplify';
import outputs from '@/amplify_outputs.json';

Amplify.configure(outputs);
const existingConfig = Amplify.getConfig();
Amplify.configure({
  ...existingConfig,
  API: {
    ...existingConfig.API,
    REST: outputs.custom.API,
  },
});
```
</InlineFilter>

<Callout warning="true">

Make sure you call `Amplify.configure` as early as possible in your application’s life-cycle. A missing configuration or `NoCredentials` error is thrown if `Amplify.configure` has not been called before other Amplify JavaScript APIs. Review the [Library Not Configured Troubleshooting guide](/[platform]/build-a-backend/troubleshooting/library-not-configured/) for possible causes of this issue.

</Callout>
</InlineFilter>


Contents of build-a-backend_add-aws-services_rest-api_set-up-rest-api_index.txt:
import { getCustomStaticPath } from '@/utils/getCustomStaticPath';

export const meta = {
  title: 'Set up Amplify REST API',
  description: 'The API category provides a solution for making HTTP requests to REST API endpoints. The API library can be used for creating signed requests against Amazon API Gateway when the API Gateway Authorization is set to AWS_IAM or Cognito User Pools.',
  platforms: [
    'angular',
    'javascript',
    'nextjs',
    'react',
    'react-native',
    'vue'
  ],
};

export async function getStaticPaths() {
  return getCustomStaticPath(meta.platforms);
}

export function getStaticProps(context) {
  return {
    props: {
      platform: context.params.platform,
      meta
    }
  };
}

Using the [AWS Cloud Development Kit (AWS CDK)](https://aws.amazon.com/cdk/), you can configure Amplify Functions as resolvers for routes of a [REST API powered by Amazon API Gateway](https://docs.aws.amazon.com/apigateway/latest/developerguide/apigateway-rest-api.html).

## Set up REST API with Lambda Function

Create a new directory and a resource file, `amplify/functions/api-function/resource.ts`. Then, define the function with `defineFunction`:

```ts title="amplify/functions/api-function/resource.ts"
import { defineFunction } from "@aws-amplify/backend";

export const myApiFunction = defineFunction({
  name: "api-function",
});
```

Create the corresponding handler file, `amplify/functions/api-function/handler.ts`, file with the following contents:

```ts title="amplify/functions/api-function/handler.ts"
import type { APIGatewayProxyHandler } from "aws-lambda";

export const handler: APIGatewayProxyHandler = async (event) => {
  console.log("event", event);
  return {
    statusCode: 200,
    // Modify the CORS settings below to match your specific requirements
    headers: {
      "Access-Control-Allow-Origin": "*", // Restrict this to domains you trust
      "Access-Control-Allow-Headers": "*", // Specify only the headers you need to allow
    },
    body: JSON.stringify("Hello from myFunction!"),
  };
};
```

Use the [AWS CDK](https://docs.aws.amazon.com/cdk/latest/guide/home.html) to create an REST API resource powered by [Amazon API Gateway](https://aws.amazon.com/api-gateway/).

```ts title="amplify/backend.ts"
import { defineBackend } from "@aws-amplify/backend";
import { Stack } from "aws-cdk-lib";
import {
  AuthorizationType,
  CognitoUserPoolsAuthorizer,
  Cors,
  LambdaIntegration,
  RestApi,
} from "aws-cdk-lib/aws-apigateway";
import { Policy, PolicyStatement } from "aws-cdk-lib/aws-iam";
import { myApiFunction } from "./functions/api-function/resource";
import { auth } from "./auth/resource";
import { data } from "./data/resource";

const backend = defineBackend({
  auth,
  data,
  myApiFunction,
});

// create a new API stack
const apiStack = backend.createStack("api-stack");

// create a new REST API
const myRestApi = new RestApi(apiStack, "RestApi", {
  restApiName: "myRestApi",
  deploy: true,
  deployOptions: {
    stageName: "dev",
  },
  defaultCorsPreflightOptions: {
    allowOrigins: Cors.ALL_ORIGINS, // Restrict this to domains you trust
    allowMethods: Cors.ALL_METHODS, // Specify only the methods you need to allow
    allowHeaders: Cors.DEFAULT_HEADERS, // Specify only the headers you need to allow
  },
});

// create a new Lambda integration
const lambdaIntegration = new LambdaIntegration(
  backend.myApiFunction.resources.lambda
);

// create a new resource path with IAM authorization
const itemsPath = myRestApi.root.addResource("items", {
  defaultMethodOptions: {
    authorizationType: AuthorizationType.IAM,
  },
});

// add methods you would like to create to the resource path
itemsPath.addMethod("GET", lambdaIntegration);
itemsPath.addMethod("POST", lambdaIntegration);
itemsPath.addMethod("DELETE", lambdaIntegration);
itemsPath.addMethod("PUT", lambdaIntegration);

// add a proxy resource path to the API
itemsPath.addProxy({
  anyMethod: true,
  defaultIntegration: lambdaIntegration,
});

// create a new Cognito User Pools authorizer
const cognitoAuth = new CognitoUserPoolsAuthorizer(apiStack, "CognitoAuth", {
  cognitoUserPools: [backend.auth.resources.userPool],
});

// create a new resource path with Cognito authorization
const booksPath = myRestApi.root.addResource("cognito-auth-path");
booksPath.addMethod("GET", lambdaIntegration, {
  authorizationType: AuthorizationType.COGNITO,
  authorizer: cognitoAuth,
});

// create a new IAM policy to allow Invoke access to the API
const apiRestPolicy = new Policy(apiStack, "RestApiPolicy", {
  statements: [
    new PolicyStatement({
      actions: ["execute-api:Invoke"],
      resources: [
        `${myRestApi.arnForExecuteApi("*", "/items", "dev")}`,
        `${myRestApi.arnForExecuteApi("*", "/items/*", "dev")}`,
        `${myRestApi.arnForExecuteApi("*", "/cognito-auth-path", "dev")}`,
      ],
    }),
  ],
});

// attach the policy to the authenticated and unauthenticated IAM roles
backend.auth.resources.authenticatedUserIamRole.attachInlinePolicy(
  apiRestPolicy
);
backend.auth.resources.unauthenticatedUserIamRole.attachInlinePolicy(
  apiRestPolicy
);

// add outputs to the configuration file
backend.addOutput({
  custom: {
    API: {
      [myRestApi.restApiName]: {
        endpoint: myRestApi.url,
        region: Stack.of(myRestApi).region,
        apiName: myRestApi.restApiName,
      },
    },
  },
});
```

## Install Amplify Libraries

<InlineFilter filters={['javascript', "angular", "react", "vue", "react-native", "nextjs"]}>
Use the package manager of your choice to install the Amplify JavaScript library. For example, with `npm`:

```bash title="Terminal" showLineNumbers={false}
npm add aws-amplify
```
</InlineFilter>

<InlineFilter filters={["react-native"]}>
Use the package manager of your choice to install the Amplify JavaScript library. For example, with `npm`:

<Accordion title="Instructions for React Native version 0.72 and below">

  `@aws-amplify/react-native` requires a minimum iOS deployment target of `13.0` if you are using `react-native` version less than or equal to `0.72`. Open the _Podfile_ located in the _ios_ directory and update the `target` value:

  ```diff
   - platform :ios, min_ios_version_supported
   + platform :ios, 13.0
   ```

</Accordion>

```bash title="Terminal" showLineNumbers={false}
npm add aws-amplify @aws-amplify/react-native
```

</InlineFilter>

## Initialize Amplify API

<InlineFilter filters={['javascript', "angular", "react", "vue", "react-native", "nextjs"]}>
To initialize the Amplify API category you need to configure Amplify with `Amplify.configure()`.

Import and load the configuration file in your app. It's recommended you add the Amplify configuration step to your app's root entry point. For example `index.js` in React or `main.ts` in Angular.

<InlineFilter filters={['javascript', "angular", "react", "vue", "react-native"]}>
```javascript title="src/main.ts"
import { Amplify } from 'aws-amplify';
import outputs from '../amplify_outputs.json';

Amplify.configure(outputs);
const existingConfig = Amplify.getConfig();
Amplify.configure({
  ...existingConfig,
  API: {
    ...existingConfig.API,
    REST: outputs.custom.API,
  },
});
```
</InlineFilter>

<InlineFilter filters={["nextjs"]}>
```tsx title="pages/_app.tsx"
import { Amplify } from 'aws-amplify';
import outputs from '@/amplify_outputs.json';

Amplify.configure(outputs);
const existingConfig = Amplify.getConfig();
Amplify.configure({
  ...existingConfig,
  API: {
    ...existingConfig.API,
    REST: outputs.custom.API,
  },
});
```
</InlineFilter>

<Callout warning="true">

Make sure you call `Amplify.configure` as early as possible in your application’s life-cycle. A missing configuration or `NoCredentials` error is thrown if `Amplify.configure` has not been called before other Amplify JavaScript APIs. Review the [Library Not Configured Troubleshooting guide](/[platform]/build-a-backend/troubleshooting/library-not-configured/) for possible causes of this issue.

</Callout>
</InlineFilter>


Contents of build-a-backend_add-aws-services_rest-api_test-api_index.txt:
import { getCustomStaticPath } from '@/utils/getCustomStaticPath';
                  
export const meta = {
  title: 'Test the REST API',
  description: 'Learn how you can test the REST API from the terminal, with Amplify Mock, or with the API Gateway console.',
  platforms: [
    'angular',
    'javascript',
    'nextjs',
    'react',
    'react-native',
    'vue'
  ],
};

export async function getStaticPaths() {
  return getCustomStaticPath(meta.platforms);
}

export function getStaticProps(context) {
  return {
    props: {
      platform: context.params.platform,
      meta
    }
  };
}
          

## Test the API from the terminal

If unauthenticated guest users have access to your REST API you can test it from the terminal using [curl](https://github.com/curl/curl). curl is a command-line tool that lets you transfer data to and from a server using various protocols.

> Curl is available in many distributions including Mac, Windows and Linux. Follow the install instructions in the [docs](https://curl.haxx.se/docs/install.html).

<BlockSwitcher>
<Block name="Mac and Linux">

### GET method example

```bash title="Terminal" showLineNumbers={false} 
curl <your-api-endpoint>/<your-api-stage>/items
```

### POST method example

```bash title="Terminal" showLineNumbers={false} 
curl -H "Content-Type: application/json" -d '{"name":"item-1"}' <your-api-endpoint>/<your-api-stage>/items
```

</Block>
<Block name="Windows">

### GET method example

```bash title="Terminal" showLineNumbers={false} 
curl <your-api-endpoint>/<your-api-stage>/items
```

### POST method example

```bash title="Terminal" showLineNumbers={false} 
curl -H "Content-Type: application/json" -d {\"name\":\"item-1\"} <your-api-endpoint>/<your-api-stage>/items
```

</Block>
</BlockSwitcher>

## Test the API with API Gateway console

Let's test your new REST API using the route below with HTTP Method `GET` and path `/items?limit=10` which includes a `limit` query string parameter.

```console title="Terminal" showLineNumbers={false}
GET /items?limit=10
```

1. Sign in to the [API Gateway console](https://console.aws.amazon.com/apigateway)  
2. Choose the `myRestApi` REST API  
3. In the Resources pane, choose the method you want to test. Select `GET` right under `/items`.  

  ```console title="Terminal" showLineNumbers={false}
  /                        
  |_ /items               Main resource. Eg: /items  
    GET                   Methods  
    DELETE  
    PUT  
    POST  
    OPTIONS               Allow pre-flight requests in CORS by browser  
      |_ /{proxy+}         Proxy resource. Eg: /items/, /items/id, items/object/{id}  
      ANY                  Includes methods: DELETE, GET, HEAD, OPTIONS, PATCH, POST, PUT  
      OPTIONS              Allow pre-flight requests in CORS by browser  
  ```
4. In the Method Execution pane, select **TEST**. Choose the `GET` method and add `limit=10` to the query string `{items}` field.
5. Choose **Test** to run the test for `GET /items?limit=10`. The following information will be displayed: request, status, latency, response body, response headers and logs.


```console title="Terminal" showLineNumbers={false} /* cSpell:disable */
Request
/items
Latency
111
Status
200
Response body
"Hello from myFunction!"
Response headers
{
  "Access-Control-Allow-Headers": "*",
  "Access-Control-Allow-Origin": "*",
  "X-Amzn-Trace-Id": "Root=1-661eee4b-f400fbebc6cfe65c3dadebcd;Parent=189f175e8de8d3a7;Sampled=0;lineage=c22c6ce1:0"
}
Log
Execution log for request 9bd9d8dc-95e2-494b-be1b-716393f83c49
Tue Apr 16 21:31:55 UTC 2024 : Starting execution for request: 9bd9d8dc-95e2-494b-be1b-716393f83c49
Tue Apr 16 21:31:55 UTC 2024 : HTTP Method: GET, Resource Path: /items
Tue Apr 16 21:31:55 UTC 2024 : Method request path: {}
Tue Apr 16 21:31:55 UTC 2024 : Method request query string: {}
Tue Apr 16 21:31:55 UTC 2024 : Method request headers: {}
Tue Apr 16 21:31:55 UTC 2024 : Method request body before transformations: 
Tue Apr 16 21:31:55 UTC 2024 : Endpoint request URI: https://lambda.us-east-1.amazonaws.com/2015-03-31/functions/arn:aws:lambda:us-east-1:[TRUNCATED:function:amplify-nextamplifygen2-y-testfunctionlambdaC407E8-zttuHxtL6x0V/invocations
Tue Apr 16 21:31:55 UTC 2024 : Endpoint request headers: {X-Amz-Date=20240416T213155Z, x-amzn-apigateway-api-id=bnyiitr69a, Accept=application/json, User-Agent=AmazonAPIGateway_bnyiitr69a, Host=lambda.us-east-1.amazonaws.com, X-Amz-Content-Sha256=246bd274ab578bc88286bd20a7371b0f08a1ec8cc2c8cacffb41e60430254c82, X-Amzn-Trace-Id=Root=1-661eee4b-f400fbebc6cfe65c3dadebcd, x-amzn-lambda-integration-tag=9bd9d8dc-95e2-494b-be1b-716393f83c49, Authorization=*********************************************************************************************************************************************************************************************************************************************************************************************************************************************bc00f2, X-Amz-Source-Arn=arn:aws:execute-api:us-east-1:[TRUNCATED]:bnyiitr69a/test-invoke-stage/GET/items, X-Amz-Security-Token= [TRUNCATED]
Tue Apr 16 21:31:55 UTC 2024 : Endpoint request body after transformations: {"resource":"/items","path":"/items","httpMethod":"GET","headers":null,"multiValueHeaders":null,"queryStringParameters":null,"multiValueQueryStringParameters":null,"pathParameters":null,"stageVariables":null,"requestContext":{"resourceId":"1m3yhu","resourcePath":"/items","httpMethod":"GET","extendedRequestId":"WVorzEQzoAMFubg=","requestTime":"16/Apr/2024:21:31:55 +0000","path":"/items","accountId":"[TRUNCATED]
","protocol":"HTTP/1.1","stage":"test-invoke-stage","domainPrefix":"testPrefix","requestTimeEpoch":1713303115234,"requestId":"9bd9d8dc-95e2-494b-be1b-716393f83c49","identity":{"cognitoIdentityPoolId":null,"cognitoIdentityId":null,"apiKey":"test-invoke-api-key","principalOrgId":null,"cognitoAuthenticationType":null,"userArn":"arn:aws:iam::[TRUNCATED]:user/ykethan","apiKeyId":"test-invoke-api-key-id","userAgent":"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/123.0.0.0 Safari/537.36","accountId":"05364941472 [TRUNCATED]
Tue Apr 16 21:31:55 UTC 2024 : Sending request to https://lambda.us-east-1.amazonaws.com/2015-03-31/functions/arn:aws:lambda:us-east-1:[TRUNCATED]
:function:amplify-nextamplifygen2-y-testfunctionlambdaC407E8-zttuHxtL6x0V/invocations
Tue Apr 16 21:31:55 UTC 2024 : Received response. Status: 200, Integration latency: 108 ms
Tue Apr 16 21:31:55 UTC 2024 : Endpoint response headers: {Date=Tue, 16 Apr 2024 21:31:55 GMT, Content-Type=application/json, Content-Length=135, Connection=keep-alive, x-amzn-RequestId=67cfbdff-46cf-4355-8475-50a22e1f3234, x-amzn-Remapped-Content-Length=0, X-Amz-Executed-Version=$LATEST, X-Amzn-Trace-Id=root=1-661eee4b-f400fbebc6cfe65c3dadebcd;parent=189f175e8de8d3a7;sampled=0;lineage=c22c6ce1:0}
Tue Apr 16 21:31:55 UTC 2024 : Endpoint response body before transformations: {"statusCode":200,"headers":{"Access-Control-Allow-Origin":"*","Access-Control-Allow-Headers":"*"},"body":"\"Hello from myFunction!\""}
Tue Apr 16 21:31:55 UTC 2024 : Method response body after transformations: "Hello from myFunction!"
Tue Apr 16 21:31:55 UTC 2024 : Method response headers: {Access-Control-Allow-Origin=*, Access-Control-Allow-Headers=*, X-Amzn-Trace-Id=Root=1-661eee4b-f400fbebc6cfe65c3dadebcd;Parent=189f175e8de8d3a7;Sampled=0;lineage=c22c6ce1:0}
Tue Apr 16 21:31:55 UTC 2024 : Successfully completed execution
Tue Apr 16 21:31:55 UTC 2024 : Method completed with status: 200
```


Contents of build-a-backend_add-aws-services_rest-api_update-data_index.txt:
import { getCustomStaticPath } from '@/utils/getCustomStaticPath';

export const meta = {
  title: 'Update data',
  description: 'Using Post, Put, etc. in Amplify',
  platforms: [
    'angular',
    'javascript',
    'nextjs',
    'react',
    'react-native',
    'vue'
  ],
};

export async function getStaticPaths() {
  return getCustomStaticPath(meta.platforms);
}

export function getStaticProps(context) {
  return {
    props: {
      platform: context.params.platform,
      meta
    }
  };
}

## PUT requests

To create or update a item via the API endpoint:

```ts
import { put } from 'aws-amplify/api';

async function updateItems() {
  try {
    const Item = { name: 'My first Item', message: 'Hello world!' };
    const restOperation = put({
      apiName: 'myRestApi',
      path: 'items/1',
      options: {
        body: Item
      }
    });
    const response = await restOperation.response;
    console.log('PUT call succeeded: ', response);
  } catch (error) {
    console.log('PUT call failed: ', JSON.parse(error.response.body));
  }
}
```


Contents of build-a-backend_add-aws-services_tagging-resources_index.txt:
import { getCustomStaticPath } from '@/utils/getCustomStaticPath';

export const meta = {
  title: 'Tagging resources',
  description: 'Decorate resources with tags for categorization.',
  platforms: [
    'android',
    'angular',
    'flutter',
    'javascript',
    'nextjs',
    'react',
    'react-native',
    'swift',
    'vue'
  ],
};

export async function getStaticPaths() {
  return getCustomStaticPath(meta.platforms);
}

export function getStaticProps(context) {
  return {
    props: {
      platform: context.params.platform,
      meta
    }
  };
}

Tags are a key-value pair that are applied to AWS resources to hold metadata. Tags are often used to decorate resources with metadata that helps categorize resources for billing or viewing purposes. Learn more about tags by visiting the [AWS documentation for best practices for tagging resources](https://docs.aws.amazon.com/whitepapers/latest/tagging-best-practices/what-are-tags.html).

Amplify applies the following tags by default:

| Deployment type | Tag key                   | Tag value                |
|-----------------|---------------------------|--------------------------|
| sandbox         | `created-by`              | `amplify`                |
| sandbox         | `amplify:deployment-type` | `sandbox`                |
| branch          | `created-by`              | `amplify`                |
| branch          | `amplify:deployment-type` | `branch`                 |
| branch          | `amplify:app-id`          | `<your-amplify-app-id>`  |
| branch          | `amplify:branch-name`     | `<your-git-branch-name>` |

In your Amplify backend you can use the [`Tags`](https://docs.aws.amazon.com/cdk/api/v2/docs/aws-cdk-lib.Tags.html) class from the [AWS Cloud Development Kit (CDK)](https://docs.aws.amazon.com/cdk/latest/guide/home.html) to apply tags at the root level, which then cascades to child resources.

```ts title="amplify/backend.ts"
import { Tags } from 'aws-cdk-lib';
import { defineBackend } from '@aws-amplify/backend';
import { auth } from './auth/resource';
import { data } from './data/resource';

/**
 * @see https://docs.amplify.aws/react/build-a-backend/ to add storage, functions, and more
 */
const backend = defineBackend({
  auth,
  data
});

const tags = Tags.of(backend.stack);
// add a new tag
tags.add('my-key', 'my-value');
// remove tags
tags.remove('my-key');
```



Contents of build-a-backend_auth_advanced-workflows_index.txt:
import { getCustomStaticPath } from '@/utils/getCustomStaticPath';

export const meta = {
  title: 'Advanced workflows',
  description: 'Learn more about advanced workflows in the Amplify auth category. This includes subscribing to events, identity pool federation, auth-related Lambda triggers and working with AWS service objects.',
  platforms: [
    'javascript',
    'react-native',
    'flutter',
    'swift',
    'android',
    'angular',
    'nextjs',
    'react',
    'vue'
  ],
};

export const getStaticPaths = async () => {
  return getCustomStaticPath(meta.platforms);
};

export function getStaticProps(context) {
  return {
    props: {
      platform: context.params.platform,
      meta
    }
  };
}

<InlineFilter filters={['flutter']}>
## Identity Pool Federation

With identity federation, you don't need to create custom sign-in code or manage your own user identities. Instead, users of your app can sign in using a well-known external identity 
provider (IdP), such as Login with Amazon, Facebook, Google, or any other OpenID Connect (OIDC)-compatible IdP. They can receive an authentication token, and then exchange that token for 
temporary security credentials in AWS that map to an IAM role with permissions to use the resources in your AWS account. Using an IdP helps you keep your AWS account secure because you 
don't have to embed and distribute long-term security credentials with your application.

Imagine that you are creating a mobile app that accesses AWS resources, such as a game that runs on a mobile device and stores player and score information using Amazon S3 and DynamoDB.

When you write such an app, you make requests to AWS services that must be signed with an AWS access key. However, we strongly recommend that you do not embed or distribute long-term 
AWS credentials with apps that a user downloads to a device, even in an encrypted store. Instead, build your app so that it requests temporary AWS security credentials dynamically when 
needed using identity federation. The supplied temporary credentials map to an AWS role that has only the permissions needed to perform the tasks required by the mobile app.

You can use `federateToIdentityPool` to get AWS credentials directly from Cognito Federated Identities and not use User Pool federation. If you logged in with `Auth.signIn` you **cannot** 
call `federateToIdentityPool` as Amplify will perform this federation automatically for you in the background. In general, you should only call `Auth.federatedSignIn()` when using OAuth flows.

You can use the escape hatch API `federateToIdentityPool` with a valid token from other social providers.

```dart
final cognitoPlugin =
    Amplify.Auth.getPlugin(AmplifyAuthCognito.pluginKey);
const googleIdToken = 'idToken';
final session = await cognitoPlugin.federateToIdentityPool(
  token: googleIdToken,
  provider: AuthProvider.google,
);
```

<Callout>

Note that when federated, APIs such as `Auth.getCurrentUser` will throw an error as the user is not authenticated with User Pools.

</Callout>

### Retrieve Session

After federated login, you can retrieve the session using the `Auth.fetchAuthSession` API.

### Token Refresh

<Callout>

Automatic authentication token refresh is NOT supported when federated.

</Callout>

By default, Amplify will **NOT** automatically refresh the tokens from the federated providers. You will need to handle the token refresh logic and provide the new token to the `federateToIdentityPool` API.

### Clear Session

You can clear the federated session using the `clearFederationToIdentityPool` API.

```dart
final cognitoPlugin =
    Amplify.Auth.getPlugin(AmplifyAuthCognito.pluginKey);
await cognitoPlugin.clearFederationToIdentityPool();
```

<Callout>

`clearFederationToIdentityPool` will only clear the session from the local cache; the developer needs to handle signing out from the federated identity provider.

</Callout>

### Provide Custom Identity ID

You can provide a custom identity ID to the `federateToIdentityPool` API. This is useful when you want to use the same identity ID across multiple sessions.

```dart
final cognitoPlugin =
    Amplify.Auth.getPlugin(AmplifyAuthCognito.pluginKey);
const googleIdToken = 'idToken';
const identityId = 'us-west-2:b4cd4809-7ab1-42e1-b044-07dab9eaa768';
final session = await cognitoPlugin.federateToIdentityPool(
  token: googleIdToken,
  provider: AuthProvider.google,
  options: FederateToIdentityPoolOptions(
    developerProvidedIdentityId: identityId,
  ),
);
```
</InlineFilter>
<InlineFilter filters={['android']}>
## Subscribing Events

You can take specific actions when users sign-in or sign-out by subscribing to authentication events in your app. Please see our [Hub Module Developer Guide](/[platform]/build-a-backend/auth/connect-your-frontend/listen-to-auth-events/) for more information.

## Identity Pool Federation

Imagine that you are creating a mobile app that accesses AWS resources, such as a game that runs on a mobile device and stores player and score information using Amazon S3 and DynamoDB.

When you write such an app, you make requests to AWS services that must be signed with an AWS access key. However, we strongly recommend that you do not embed or distribute long-term AWS credentials with apps that a user downloads to a device, even in an encrypted store. Instead, build your app so that it requests temporary AWS security credentials dynamically when needed using web identity federation. The supplied temporary credentials map to an AWS role that has only the permissions needed to perform the tasks required by the mobile app.

With web identity federation, you don't need to create custom sign-in code or manage your own user identities. Instead, users of your app can sign in using a well-known external identity provider (IdP), such as Login with Amazon, Facebook, Google, or any other OpenID Connect (OIDC)-compatible IdP. They can receive an authentication token, and then exchange that token for temporary security credentials in AWS that map to an IAM role with permissions to use the resources in your AWS account. Using an IdP helps you keep your AWS account secure because you don't have to embed and distribute long-term security credentials with your application.

You can use `federateToIdentityPool` to get AWS credentials directly from Cognito Federated Identities and not use User Pool federation. If you logged in with `Auth.signIn` you **cannot** call `federateToIdentityPool` as Amplify will perform this federation automatically for you in the background. In general, you should only call `Auth.federatedSignIn()` when using OAuth flows.

You can use the escape hatch API `federateToIdentityPool` with a valid token from other social providers.

<BlockSwitcher>
<Block name="Java">

```java
if (Amplify.Auth.getPlugin("awsCognitoAuthPlugin") instanceof AWSCognitoAuthPlugin) {
    AWSCognitoAuthPlugin plugin = (AWSCognitoAuthPlugin) Amplify.Auth.getPlugin("awsCognitoAuthPlugin");
    plugin.federateToIdentityPool(
        "YOUR_TOKEN",
        AuthProvider.facebook(),
        result -> {
            Log.i("AuthQuickstart", "Successful federation to Identity Pool.");
            // use result.getCredentials()
        },
        e -> {
            Log.e("AuthQuickstart", "Failed to federate to Identity Pool.", e)
        }
    );
}
```

</Block>
<Block name="Kotlin - Callbacks">

```kotlin
(Amplify.Auth.getPlugin("awsCognitoAuthPlugin") as? AWSCognitoAuthPlugin)?.let { plugin ->
    plugin.federateToIdentityPool(
        "YOUR_TOKEN",
        AuthProvider.facebook(),
        {
            Log.i("AuthQuickstart", "Successful federation to Identity Pool.")
            // use "it.credentials"
        },
        {
            Log.e("AuthQuickstart", "Failed to federate to Identity Pool.", it)
        }
    )
}
```

</Block>
</BlockSwitcher>

<Callout>
Note that when federated, APIs such as Auth.getCurrentUser will throw an error as the user is not authenticated with User Pools.
</Callout>

### Retrieve Session

After federated login, you can retrieve the session using the `Auth.fetchAuthSession` API.

### Token Refresh

<Callout>
Automatic authentication token refresh is NOT supported when federated.
</Callout>

By default, Amplify will **NOT** automatically refresh the tokens from the federated providers. You will need to handle the token refresh logic and provide the new token to the `federateToIdentityPool` API.

### Clear Session

You can clear the federated session using the `clearFederationToIdentityPool` API.

<BlockSwitcher>
<Block name="Java">

```java
if (Amplify.Auth.getPlugin("awsCognitoAuthPlugin") instanceof AWSCognitoAuthPlugin) {
    AWSCognitoAuthPlugin plugin = (AWSCognitoAuthPlugin) Amplify.Auth.getPlugin("awsCognitoAuthPlugin");
    plugin.clearFederationToIdentityPool(
        () -> Log.i("AuthQuickstart", "Federation cleared successfully."),
        e -> Log.e("AuthQuickstart", "Failed to clear federation.", e)
    );
}
```

</Block>
<Block name="Kotlin - Callbacks">

```kotlin
(Amplify.Auth.getPlugin("awsCognitoAuthPlugin") as? AWSCognitoAuthPlugin)?.let { plugin ->
    plugin.clearFederationToIdentityPool(
        { Log.i("AuthQuickstart", "Federation cleared successfully.") },
        { Log.e("AuthQuickstart", "Failed to clear federation.", it) }
    )
}
```

</Block>
</BlockSwitcher>

<Callout>
`clearFederationToIdentityPool` will only clear the session from the local cache, the developer needs to handle signing out from the federated provider.
</Callout>

### Provide Custom Identity Id

You can provide a custom identity id to the `federateToIdentityPool` API. This is useful when you want to use the same identity id across multiple devices.

<BlockSwitcher>
<Block name="Java">

```java
FederateToIdentityPoolOptions options = FederateToIdentityPoolOptions.builder()
    .developerProvidedIdentityId("YOUR_CUSTOM_IDENTITY_ID")
    .build();

if (Amplify.Auth.getPlugin("awsCognitoAuthPlugin") instanceof AWSCognitoAuthPlugin) {
    AWSCognitoAuthPlugin plugin = (AWSCognitoAuthPlugin) Amplify.Auth.getPlugin("awsCognitoAuthPlugin");
    plugin.federateToIdentityPool(
        "YOUR_TOKEN",
        AuthProvider.facebook(),
        options,
        result -> {
            Log.i("AuthQuickstart", "Successful federation to Identity Pool.");
            // use result.getCredentials()
        },
        e -> {
            Log.e("AuthQuickstart", "Failed to federate to Identity Pool.", e)
        }
    );
}
```

</Block>
<Block name="Kotlin - Callbacks">

```kotlin
val options = FederateToIdentityPoolOptions.builder()
    .developerProvidedIdentityId("YOUR_CUSTOM_IDENTITY_ID")
    .build()

(Amplify.Auth.getPlugin("awsCognitoAuthPlugin") as? AWSCognitoAuthPlugin)?.let { plugin ->
    plugin.federateToIdentityPool(
        "YOUR_TOKEN",
        AuthProvider.facebook(),
        options,
        {
            Log.i("AuthQuickstart", "Successful federation to Identity Pool.")
            // use "it.credentials"
        },
        {
            Log.e("AuthQuickstart", "Failed to federate to Identity Pool.", it)
        }
    )
}
```

</Block>
</BlockSwitcher>

</InlineFilter>
<InlineFilter filters={['swift']}>
## Subscribing Events

You can take specific actions when users sign-in or sign-out by subscribing authentication events in your app. Please see our [Hub Module Developer Guide](/[platform]/build-a-backend/auth/connect-your-frontend/listen-to-auth-events/) for more information.

## Identity Pool Federation

Imagine that you are creating a mobile app that accesses AWS resources, such as a game that runs on a mobile device and stores player and score information using Amazon S3 and DynamoDB.

When you write such an app, you make requests to AWS services that must be signed with an AWS access key. However, we strongly recommend that you do not embed or distribute long-term AWS credentials with apps that a user downloads to a device, even in an encrypted store. Instead, build your app so that it requests temporary AWS security credentials dynamically when needed using web identity federation. The supplied temporary credentials map to an AWS role that has only the permissions needed to perform the tasks required by the mobile app.

With web identity federation, you don't need to create custom sign-in code or manage your own user identities. Instead, users of your app can sign in using a well-known external identity provider (IdP), such as Login with Amazon, Facebook, Google, or any other OpenID Connect (OIDC)-compatible IdP. They can receive an authentication token, and then exchange that token for temporary security credentials in AWS that map to an IAM role with permissions to use the resources in your AWS account. Using an IdP helps you keep your AWS account secure, because you don't have to embed and distribute long-term security credentials with your application.

You can use `federateToIdentityPool` to get AWS credentials directly from Cognito Federated Identities and not use User Pool federation. If you have logged in with `Auth.signIn` you **can not** call `federateToIdentityPool` as Amplify will perform this federation automatically for you in the background. In general, you should only call `Auth.federateToIdentityPool` when using OAuth flows. 

You can use the escape hatch API `federateToIdentityPool` with a valid token from other social providers.

```swift
func federateToIdentityPools() async throws {
    guard let authCognitoPlugin = try Amplify.Auth.getPlugin(
        for: "awsCognitoAuthPlugin") as? AWSCognitoAuthPlugin else {
        fatalError("Unable to get the Auth plugin")
    }
    do {
        let result = try await authCognitoPlugin.federateToIdentityPool(
            withProviderToken: "YOUR_TOKEN", for: .facebook)
        print("Federation successful with result: \(result)")
    } catch {
        print("Failed to federate to identity pools with error: \(error)")
    }
}
```

<Callout>
Note that when federated, API's such as Auth.getCurrentUser() will throw an error as the user is not authenticated with User Pools.
</Callout>

### Retrieve Session

After federated login, you can retrieve session using the `Auth.fetchAuthSession` API.

### Token Refresh

<Callout>
NOTE: Automatic authentication token refresh is NOT supported when federated.
</Callout>

By default, Amplify will **NOT** automatically refresh the tokens from the federated providers. You will need to handle the token refresh logic and provide the new token to the `federateToIdentityPool` API.

### Clear Session

You can clear the federated session using the `clearFederationToIdentityPool` API.

```swift
func clearFederationToIdentityPools() async throws {
    guard let authCognitoPlugin = try Amplify.Auth.getPlugin(
        for: "awsCognitoAuthPlugin") as? AWSCognitoAuthPlugin else {
        fatalError("Unable to get the Auth plugin")
    }
    do {
        try await authCognitoPlugin.clearFederationToIdentityPool()
        print("Federation cleared successfully")
    } catch {
        print("Clear federation failed with error: \(error)")
    }
}
```

<Callout>
clearFederationToIdentityPool will only clear the session from local cache, developer need to handle signing out from the federated provider.
</Callout>

### Provide Custom Identity Id

You can provide a custom identity id to the `federateToIdentityPool` API. This is useful when you want to use the same identity id across multiple devices.

```swift
func federateToIdentityPoolsUsingCustomIdentityId() async throws {
    guard let authCognitoPlugin = try Amplify.Auth.getPlugin(
        for: "awsCognitoAuthPlugin") as? AWSCognitoAuthPlugin else {
        fatalError("Unable to get the Auth plugin")
    }
    do {
        let identityId = "YOUR_CUSTOM_IDENTITY_ID"
        let result = try await authCognitoPlugin.federateToIdentityPool(
            withProviderToken: "YOUR_TOKEN",
            for: .facebook,
            options: .init(developerProvidedIdentityID: identityId))
        print("Federation successful with result: \(result)")
    } catch {
        print("Failed to federate to identity pools with error: \(error)")
    }
}
```

</InlineFilter>
<InlineFilter filters={['javascript','react-native','angular','nextjs','react','vue']}>
## Subscribing to Events

You can take specific actions when users sign-in or sign-out by subscribing to authentication events in your app. Please see our [Hub Module Developer Guide](/[platform]/build-a-backend/auth/connect-your-frontend/listen-to-auth-events/) for more information.

## Identity Pool Federation

You can alternatively create your own custom credentials provider to get AWS credentials directly from Cognito Federated Identities and not use User Pool federation. You must supply the custom credentials provider to Amplify via the `Amplify.configure` method call. Below, you can see sample code of how such a custom provider can be built to achieve the use case.

```js
import { Amplify } from 'aws-amplify';
import {
  fetchAuthSession,
  CredentialsAndIdentityIdProvider,
  CredentialsAndIdentityId,
  GetCredentialsOptions,
  AuthTokens,
} from 'aws-amplify/auth';

// Note: This example requires installing `@aws-sdk/client-cognito-identity` to obtain Cognito credentials
// npm i @aws-sdk/client-cognito-identity
import { CognitoIdentity } from '@aws-sdk/client-cognito-identity';

// You can make use of the sdk to get identityId and credentials
const cognitoidentity = new CognitoIdentity({
  region: '<region-from-config>',
});

// Note: The custom provider class must implement CredentialsAndIdentityIdProvider
class CustomCredentialsProvider implements CredentialsAndIdentityIdProvider {

  // Example class member that holds the login information
  federatedLogin?: {
    domain: string,
    token: string
  };

  // Custom method to load the federated login information
  loadFederatedLogin(login?: typeof this.federatedLogin) {
    // You may also persist this by caching if needed
    this.federatedLogin = login;
  }

  async getCredentialsAndIdentityId(
    getCredentialsOptions: GetCredentialsOptions
  ): Promise<CredentialsAndIdentityId | undefined> {
    try {

      // You can add in some validation to check if the token is available before proceeding
      // You can also refresh the token if it's expired before proceeding

      const getIdResult = await cognitoidentity.getId({
        // Get the identityPoolId from config
        IdentityPoolId: '<identity-pool-id-from-config>',
        Logins: { [this.federatedLogin.domain]: this.federatedLogin.token },
      });

      const cognitoCredentialsResult = await cognitoidentity.getCredentialsForIdentity({
        IdentityId: getIdResult.IdentityId,
        Logins: { [this.federatedLogin.domain]: this.federatedLogin.token },
      });

      const credentials: CredentialsAndIdentityId = {
        credentials: {
          accessKeyId: cognitoCredentialsResult.Credentials?.AccessKeyId,
          secretAccessKey: cognitoCredentialsResult.Credentials?.SecretKey,
          sessionToken: cognitoCredentialsResult.Credentials?.SessionToken,
          expiration: cognitoCredentialsResult.Credentials?.Expiration,
        },
        identityId: getIdResult.IdentityId,
      };
      return credentials;
    } catch (e) {
      console.log('Error getting credentials: ', e);
    }
  }
  // Implement this to clear any cached credentials and identityId. This can be called when signing out of the federation service.
  clearCredentialsAndIdentityId(): void {}
}

// Create an instance of your custom provider
const customCredentialsProvider = new CustomCredentialsProvider();
Amplify.configure(awsconfig, {
  Auth: {
    // Supply the custom credentials provider to Amplify
    credentialsProvider: customCredentialsProvider
  },
});

```

Now that the custom credentials provider is built and supplied to `Amplify.configure`, let's look at how you can use the custom credentials provider to finish federation into Cognito identity pool.

<InlineFilter filters={['react-native']}>

### Facebook Sign-in (React Native - Expo)

```javascript
import Expo from 'expo';
import React from 'react';
import { fetchAuthSession } from 'aws-amplify/auth';

const App = () => {
  const signIn = async () => {
    const { type, token, expires } =
      await Expo.Facebook.logInWithReadPermissionsAsync(
        'YOUR_FACEBOOK_APP_ID',
        {
          permissions: ['public_profile']
        }
      );
    if (type === 'success') {
      // sign in with federated identity
      try {
        customCredentialsProvider.loadFederatedLogin({
          domain: 'graph.facebook.com',
          token: token
        });
        const fetchSessionResult = await fetchAuthSession(); // will return the credentials
        console.log('fetchSessionResult: ', fetchSessionResult);
      } catch (err) {
        console.log(err);
      }
    }
  };

  // ...

  return (
    <View style={styles.container}>
      <Button title="FBSignIn" onPress={signIn} />
    </View>
  );
};
```

</InlineFilter>

<InlineFilter filters={['javascript', "angular", "nextjs", "react", "vue"]}>

### Facebook sign-in (React)

```js
import React, { useEffect } from 'react';
import {
  fetchAuthSession,
} from 'aws-amplify/auth';

// To federated sign in from Facebook
const SignInWithFacebook = () => {

  useEffect(() => {
    if (!window.FB) createScript();
  }, [])

  const signIn = () => {
    const fb = window.FB;
    fb.getLoginStatus(response => {
      if (response.status === 'connected') {
        getAWSCredentials(response.authResponse);
      } else {
        fb.login(
          response => {
            if (!response || !response.authResponse) {
              return;
            }
            customCredentialsProvider.loadFederatedLogin({
              domain: 'graph.facebook.com',
              token: response.authResponse.accessToken,
            });
            const fetchSessionResult = await fetchAuthSession(); // will return the credentials
            console.log('fetchSessionResult: ', fetchSessionResult);
          },
          {
            // the authorized scopes
            scope: 'public_profile,email'
          }
        );
      }
    });
  }

  const createScript = () => {
    // load the sdk
    window.fbAsyncInit = fbAsyncInit;
    const script = document.createElement('script');
    script.src = 'https://connect.facebook.net/en_US/sdk.js';
    script.async = true;
    script.onload = initFB;
    document.body.appendChild(script);
  }

  const initFB = () => {
    const fb = window.FB;
    console.log('FB SDK initialized');
  }

  const fbAsyncInit = () => {
    // init the fb sdk client
    const fb = window.FB;
    fb.init({
      appId   : 'your_facebook_app_id',
      cookie  : true,
      xfbml   : true,
      version : 'v2.11'
    });
  }

  return (
    <div>
      <button onClick={signIn}>Sign in with Facebook</button>
    </div>
  );
}
```

### Google sign-in (React)

```jsx
import React, { useEffect } from 'react';
import jwt from 'jwt-decode';
import {
  fetchAuthSession,
} from 'aws-amplify/auth';

const SignInWithGoogle = () => {
  useEffect(() => {
  // Check for an existing Google client initialization
    if (!window.google?.accounts) createScript();
  }, []);

  // Load the Google client
  const createScript = () => {
    const script = document.createElement('script');
    script.src = 'https://accounts.google.com/gsi/client';
    script.async = true;
    script.defer = true;
    script.onload = initGsi;
    document.body.appendChild(script);
  }

  // Initialize Google client and render Google button
  const initGsi = () => {
    if (window.google?.accounts) {
      window.google.accounts.id.initialize({
        client_id: process.env.GOOGLE_CLIENT_ID,
        callback: (response: any) => {
          customCredentialsProvider.loadFederatedLogin({
            domain: 'accounts.google.com',
            token: response.credential,
          });
          const fetchSessionResult = await fetchAuthSession(); // will return the credentials
          console.log('fetchSessionResult: ', fetchSessionResult);
        },
      });
      window.google.accounts.id.renderButton(
        document.getElementById('googleSignInButton'),
        { theme: 'outline', size: 'large' }
      );
    }
  }

  return (
    <div>
      <button id='googleSignInButton'/>
    </div>
  );
}
```

### Federate with Auth0

You can use `Auth0` as one of the providers of your Cognito Identity Pool. This will allow users authenticated via Auth0 have access to your AWS resources.

Step 1. [Follow Auth0 integration instructions for Cognito Federated Identity Pools](https://auth0.com/docs/integrations/integrating-auth0-amazon-cognito-mobile-apps)

Step 2. Login with `Auth0`, then use the id token returned to get AWS credentials from `Cognito Federated Identity Pools` using custom credentials provider you created at the start:

```js
import { fetchAuthSession } from 'aws-amplify/auth';

const { idToken, domain, name, email, phoneNumber } = getFromAuth0(); // get the user credentials and info from auth0

async function getCognitoCredentials() {
  try {
    customCredentialsProvider.loadFederatedLogin({
      domain,
      token: idToken
    });
    const fetchSessionResult = await fetchAuthSession(); // will return the credentials
    console.log('fetchSessionResult: ', fetchSessionResult);
  } catch (err) {
    console.log(err);
  }
}
```

</InlineFilter>

## Lambda Triggers

With the triggers property of defineAuth and defineFunction from the new Functions implementation, you can define [Lambda Triggers](https://docs.aws.amazon.com/cognito/latest/developerguide/cognito-user-identity-pools-working-with-aws-lambda-triggers.html) for your Cognito User Pool. These enable you to add custom functionality to your registration and authentication flows. [Check out a preSignUp hook example here.](/[platform]/build-a-backend/functions/examples/email-domain-filtering/)

### Pre Authentication and Pre Sign-up Lambda triggers

If you have a Pre Authentication Lambda trigger enabled, you can pass `clientMetadata` as an option for `signIn`. This metadata can be used to implement additional validations around authentication.

```ts
import { signIn } from 'aws-amplify/auth';

async function handleSignIn(username: string, password: string) {
  try {
    await signIn({
      username,
      password,
      options: {
        clientMetadata: {} // Optional, an object of key-value pairs which can contain any key and will be passed to your Lambda trigger as-is.
      }
    });
  } catch (err) {
    console.log(err);
  }
}
```

### Passing metadata to other Lambda triggers

Many Cognito Lambda Triggers also accept unsanitized key/value pairs in the form of a `clientMetadata` attribute. This attribute can be specified for various Auth APIs which result in Cognito Lambda Trigger execution.

These APIs include:

- `signIn`
- `signUp`
- `confirmSignIn`
- `confirmSignUp`
- `resetPassword`
- `confirmResetPassword`
- `resendSignUpCode`
- `updateUserAttributes`

Please note that some of triggers which accept a `validationData` attribute will use `clientMetadata` as the value for `validationData`. Exercise caution with using `clientMetadata` when you are relying on `validationData`.

## Working with AWS service objects

You can use AWS _Service Interface Objects_ to work with AWS Services in authenticated State. You can call methods on any AWS Service interface object by passing your credentials from Amplify `fetchAuthSession` to the service call constructor:

```javascript
import { fetchAuthSession } from 'aws-amplify/auth';
import Route53 from 'aws-sdk/clients/route53';

async function changeResourceRecordSets() {
  try {
    const { credentials } = await fetchAuthSession();

    const route53 = new Route53({
      apiVersion: '2013-04-01',
      credentials
    });

    // more code working with route53 object
    //route53.changeResourceRecordSets();
  } catch (err) {
    console.log(err);
  }
}
```

<Callout warning>

Note: To work with Service Interface Objects, your Amazon Cognito users' [IAM role](https://docs.aws.amazon.com/cognito/latest/developerguide/iam-roles.html) must have the appropriate permissions to call the requested services.

</Callout>

## Custom Token providers

Create a custom Auth token provider for situations where you would like provide your own tokens for a service. For example, using OIDC Auth with AppSync.  You must supply the token provider to Amplify via the `Amplify.configure` method call. Below, you can see sample code of how such a custom provider can be built to achieve the use case.

```javascript
import { Amplify } from 'aws-amplify';
import { TokenProvider, decodeJWT } from 'aws-amplify/auth';

// ...

const myTokenProvider: TokenProvider = {
  async getTokens({ forceRefresh } = {}) {
    if (forceRefresh) {
      // try to obtain new tokens if possible
    }

    const accessTokenString = '<insert JWT from provider>';
    const idTokenString = '<insert JWT from provider>';
    
    return {
      accessToken: decodeJWT(accessTokenString),
      idToken: decodeJWT(idTokenString),
    };
  },
};

Amplify.configure(awsconfig, {
  Auth: {
    tokenProvider: myTokenProvider
  }
});

```
## API reference

For the complete API documentation for Authentication module, visit our [API Reference](https://aws-amplify.github.io/amplify-js/api/modules/aws_amplify.auth.html)

</InlineFilter>


Contents of build-a-backend_auth_app-uninstall_index.txt:
import { getCustomStaticPath } from '@/utils/getCustomStaticPath';

export const meta = {
  title: 'Uninstalling the app',
  description:
    'Understand how to handle persistent data on a device when a user uninstalls the app.',
  platforms: ['swift', 'android']
};

export const getStaticPaths = async () => {
  return getCustomStaticPath(meta.platforms);
};

export function getStaticProps(context) {
  return {
    props: {
      platform: context.params.platform,
      meta
    }
  };
}

<InlineFilter filters={['android']}>
Some Amplify categories such as Analytics and Auth persist data to the local device. This application data is removed when a user uninstalls the application from the device.

If the [Android Auto Backup for Apps](https://developer.android.com/guide/topics/data/autobackup) service was enabled, this service will attempt to restore application data.

Amplify Auth uses [EncryptedSharedPreferences](https://developer.android.com/reference/androidx/security/crypto/EncryptedSharedPreferences) when persisting auth data. When an application is uninstalled, the [Android Keystore](https://developer.android.com/training/articles/keystore) keys used to create our EncryptedSharedPreferences files are deleted. Upon an application re-install, these restored files are no longer readable due to the key removal from the Android Keystore.

Due to this limitation with EncryptedSharedPreferences, Auth information can’t be restored on an application re-install. The user will have to re-authenticate.
</InlineFilter>

<InlineFilter filters={['swift']}>
Some Amplify categories such as Analytics and Auth persist data to the local device. Some of that data is automatically removed when a user uninstalls the app from the device.

Amplify stores Auth information in the local [system keychain](https://developer.apple.com/documentation/security/keychain_services), which does not guarantee any particular behavior around whether data is removed when an app is uninstalled.

Deciding on when to clear this auth information is not something that the SDK can do in a generic way, so App developers should decide when to clear the data by signing out. One strategy for accomplishing this would be to use [UserDefaults](https://developer.apple.com/documentation/foundation/userdefaults) to detect whether or not the app is launching for the first time, and invoking [`Auth.signOut()`](/[platform]/build-a-backend/auth/connect-your-frontend/sign-out/) if the app has not been launched before.

</InlineFilter>


Contents of build-a-backend_auth_concepts_email_index.txt:
import { getCustomStaticPath } from '@/utils/getCustomStaticPath';

export const meta = {
  title: 'Email',
  description: 'Learn more about what Amplify Auth provisions and supports',
  platforms: [
    'android',
    'angular',
    'flutter',
    'javascript',
    'nextjs',
    'react',
    'react-native',
    'swift',
    'vue'
  ]
};

export function getStaticPaths() {
  return getCustomStaticPath(meta.platforms);
}

export function getStaticProps() {
  return {
    props: {
      meta
    }
  };
}

By default Amplify Auth is scaffolded with `email` as the default method for user sign-in.

```ts title="amplify/auth/resource.ts"
import { defineAuth } from "@aws-amplify/backend"

export const auth = defineAuth({
  loginWith: {
    email: true,
  },
})
```

This will configure an `email` attribute that is required for sign-up and cannot be changed. 

{/* how to use client-side */}
{/* callout for moving to prod */}

## Next steps

- [Learn how to use the `signIn` API](/[platform]/build-a-backend/auth/connect-your-frontend/sign-in/)
- [Learn how to customize emails](/[platform]/build-a-backend/auth/customize-auth-lifecycle/email-customization/)
- [Learn how to configure your auth resource for production workloads](/[platform]/build-a-backend/auth/moving-to-production/)


Contents of build-a-backend_auth_concepts_external-identity-providers_index.txt:
import { getCustomStaticPath } from '@/utils/getCustomStaticPath';

export const meta = {
  title: 'External identity providers',
  description: 'Learn more about what Amplify Auth provisions and supports',
  platforms: [
    'android',
    'angular',
    'flutter',
    'javascript',
    'nextjs',
    'react',
    'react-native',
    'swift',
    'vue'
  ]
};

export function getStaticPaths() {
  return getCustomStaticPath(meta.platforms);
}

export function getStaticProps() {
  return {
    props: {
      meta
    }
  };
}

Before you configure external sign-in with Amplify Auth you will need to set up your developer account with each provider you are using.

<Callout>

**Note:** Amazon Cognito provides first class support for Facebook Login, Google Sign-In, Login with Amazon, and Sign in with Apple for seamless setup. However you can configure other Identity Providers that support SAML or OpenID Connect (OIDC).

</Callout>

<Callout warning>

**Warning:** When configuring external sign-in it's important to exercise caution when designating attributes as "required." Different external identity providers have varied scopes in terms of the information they respond back to Cognito with.  User pool attributes that are initially set up as "required" cannot be changed later, and may require you to migrate the users or create a new user pool.

</Callout>

<BlockSwitcher>
<Block name="Facebook Login">

1. Create a [developer account with Facebook](https://developers.facebook.com/docs/facebook-login).
2. [Sign in](https://developers.facebook.com/) with your Facebook credentials.
3. Choose _My Apps_ from the top navigation bar, and on the page that loads choose _Create App_. ![Create App button in the My Apps page of the Facebook developer account.](/images/cognitoHostedUI/facebook1.png)
4. For your use case, choose _Set up Facebook Login_. ![Set up Facebook Login option selected from list.](/images/cognitoHostedUI/facebook2.png)
5. For platform, choose _Website_ and select _No, I'm not building a game_.
6. Give your Facebook app a name and choose _Create app_. ![Form fields for the Facebook create app form.](/images/cognitoHostedUI/facebook3.png)
7. On the left navigation bar, choose _Settings_ and then _Basic_. ![App ID and App Secret in the basic settings tab of the dashboard.](/images/cognitoHostedUI/facebook4.png)
8. Note the _App ID_ and the _App Secret_. You will use them in the next section in the CLI flow.

</Block>
<Block name="Google Sign-In">

1. Go to [Google developer console](https://console.developers.google.com).
2. Click _Select a project_. ![Select a project button on the nav bar is circled.](/images/cognitoHostedUI/google1.png)
3. Click _NEW PROJECT_. ![The new project button is circled on the select a project popup.](/images/cognitoHostedUI/google2.png)
4. Type in project name and click _CREATE_. ![The create button is circled in the new project page.](/images/cognitoHostedUI/google3.png)
5. Once the project is created, from the left navigation menu, select _APIs & Services_, then select _Credentials_. ![The top left menu icon is selected, then the APIs and services option, then the credentials option.](/images/cognitoHostedUI/google4.png)
6. Click _CONFIGURE CONSENT SCREEN_. ![The configure consent screen button is circled in the oauth consent screen section.](/images/cognitoHostedUI/google5.png)
7. Click _CREATE_. ![The create button is circled in the OAuth consent screen section.](/images/cognitoHostedUI/google6.png)
8. Type in _App Information_ and _Developer contact information_ which are required fields and click _SAVE AND CONTINUE_ three times (OAuth consent screen -> Scopes -> Test Users) to finish setting up the consent screen.
9. Back under the _Credentials_ tab, Create your OAuth2.0 credentials by choosing _OAuth client ID_ from the _Create credentials_ drop-down list. ![The Create credentials button is circled, then the oauth client ID button is circled in the credentials section.](/images/cognitoHostedUI/google7.png).
10. Choose _Web application_ as _Application type_ and name your OAuth Client.
11. Click _Create_.
12. Take note of _Your client ID_ and _Your Client Secret_. You will need them for the next section in the CLI flow.
13. Choose _OK_.

</Block>
<Block name="Login with Amazon">

1. Create a [developer account with Amazon](https://developer.amazon.com/login-with-amazon).
2. [Sign in](https://developer.amazon.com/loginwithamazon/console/site/lwa/overview.html) with your Amazon credentials.
3. You need to create an Amazon security profile to receive the Amazon Client ID and Client Secret. Choose _Create a Security Profile_. ![The login with Amazon console with a create a new security profile button displayed.](/images/cognitoHostedUI/amazon1.png)
4. Type in a _Security Profile Name_, a _Security Profile Description_, and a _Consent Privacy Notice URL_. ![Security profile management page with steps to fill out a form for the new security profile.](/images/cognitoHostedUI/amazon2.png)
5. Choose _Save_.
6. Choose _Show Client ID_ and _Client Secret_ to show the client ID and secret. You will need them for the next section in the CLI flow. ![Choosing client ID and client secret.](/images/cognitoHostedUI/amazon3.png)

</Block>

<Block name="Sign in with Apple">

1. [Sign In](https://developer.apple.com/account/) with your Apple developer credentials.
2. On the main developer portal page, select _Certificates, IDs, & Profiles_.
3. On the left navigation bar, select _Identifier_.
4. On the _Identifiers_ page, select the _plus icon (+)_.
5. On the _Register a New Identifier_ page, select _App IDs_.
6. On the _Register an App ID_ page, under _App ID Prefix_, take note of the _Team ID_ value.
7. Provide a description in the _Description_ text box and provide the `bundleID` of the iOS app. ![Register an App ID in the certificates, identifiers and profiles section.](/images/cognitoHostedUI/apple1.png)
8. Under _Capabilities_, select _Sign in with Apple_.
9. Select _Continue_, review the configuration, and then select _Register_.
10. On the _Identifiers_ page, on the right, select _App IDs_, and then select _Services ID_.
11. Select the _plus icon (+)_ and, on the _Register a New Identifier_ page, select _Services IDs_.
12. Provide a description in the _Description_ text box and provide an identifier for the Service ID. ![Register a services ID in the certificates, identifiers and profiles section.](/images/cognitoHostedUI/apple2.png)
13. Select _Continue_ and register the Service ID.

</Block>
</BlockSwitcher>

Your developer accounts with the external providers are now set up and you can return to the Amplify specific configuration.

## Configure external sign-in backend

In `amplify/auth/resource.ts` the external providers need to be added.

The following is an example of how you would set up access to all of the external providers supported by Amplify Auth. Please note you will need to configure your `callbackUrls` and `logoutUrls` URLs for your application, which will inform your backend resources how to behave when initiating sign in and sign out operations in your app.

<Callout>

Secrets must be created manually with [`ampx sandbox secret`](/[platform]/reference/cli-commands#npx-ampx-sandbox-secret) for use with cloud sandbox, or via the Amplify Console for branch environments.

</Callout>

<InlineFilter filters={["angular", "javascript", "nextjs", "react", "vue"]}>

```ts title="amplify/auth/resource.ts"
import { defineAuth, secret } from '@aws-amplify/backend';

export const auth = defineAuth({
  loginWith: {
    email: true,
    externalProviders: {
      google: {
        clientId: secret('GOOGLE_CLIENT_ID'),
        clientSecret: secret('GOOGLE_CLIENT_SECRET')
      },
      signInWithApple: {
        clientId: secret('SIWA_CLIENT_ID'),
        keyId: secret('SIWA_KEY_ID'),
        privateKey: secret('SIWA_PRIVATE_KEY'),
        teamId: secret('SIWA_TEAM_ID')
      },
      loginWithAmazon: {
        clientId: secret('LOGINWITHAMAZON_CLIENT_ID'),
        clientSecret: secret('LOGINWITHAMAZON_CLIENT_SECRET')
      },
      facebook: {
        clientId: secret('FACEBOOK_CLIENT_ID'),
        clientSecret: secret('FACEBOOK_CLIENT_SECRET')
      },
      callbackUrls: [
        'http://localhost:3000/profile',
        'https://mywebsite.com/profile'
      ],
      logoutUrls: ['http://localhost:3000/', 'https://mywebsite.com'],
    }
  }
});
```

</InlineFilter>
<InlineFilter filters={["android", "flutter", "swift", "react-native"]}>

```ts title="amplify/auth/resource.ts"
import { defineAuth, secret } from '@aws-amplify/backend';

export const auth = defineAuth({
  loginWith: {
    email: true,
    externalProviders: {
      google: {
        clientId: secret('GOOGLE_CLIENT_ID'),
        clientSecret: secret('GOOGLE_CLIENT_SECRET')
      },
      signInWithApple: {
        clientId: secret('SIWA_CLIENT_ID'),
        keyId: secret('SIWA_KEY_ID'),
        privateKey: secret('SIWA_PRIVATE_KEY'),
        teamId: secret('SIWA_TEAM_ID')
      },
      loginWithAmazon: {
        clientId: secret('LOGINWITHAMAZON_CLIENT_ID'),
        clientSecret: secret('LOGINWITHAMAZON_CLIENT_SECRET')
      },
      facebook: {
        clientId: secret('FACEBOOK_CLIENT_ID'),
        clientSecret: secret('FACEBOOK_CLIENT_SECRET')
      },
      callbackUrls: ["myapp://callback/"],
      logoutUrls: ["myapp://signout/"],
    }
  }
});
```

</InlineFilter>

You need to now inform your external provider of the newly configured authentication resource and its OAuth redirect URI:

<BlockSwitcher>
<Block name="Facebook Login">

1. [Sign In](https://developers.facebook.com/) to your Facebook developer account with your Facebook credentials.
2. Choose _My Apps_ from the top navigation bar, and on the _Apps_ page, choose your app you created before.
3. On the left navigation bar, choose _Products_. Add _Facebook Login_ if it isn't already added.
4. If already added, choose _Settings_ under the _Configure_ dropdown. ![The Settings option is circled from the configure dropdown.](/images/cognitoHostedUI/facebook5.png)
5. Under _Valid OAuth Redirect URIs_ type your user pool domain with the `/oauth2/idpresponse` endpoint.

   `https://<your-user-pool-domain>/oauth2/idpresponse`

![Userpool domain is pasted into the text field with /oauth2/ endpoint.](/images/cognitoHostedUI/facebook6.png)

6. Save your changes.

</Block>
<Block name="Google Sign-In">

1. Go to the [Google developer console](https://console.developers.google.com).
2. On the left navigation bar, look for _APIs and Services_ under _Pinned_ or under _More Products_ if not pinned.
3. Within the _APIs and Services_ sub menu, choose _Credentials_.
4. Select the client you created in the first step and click the _Edit_ button.
5. Type your user pool domain into the _Authorized JavaScript origins_ form.
6. Type your user pool domain with the `/oauth2/idpresponse` endpoint into _Authorized Redirect URIs_.

   ![The URLs 1 form fields for authorized JavaScript origins and authorized redirect URLs are circled.](/images/cognitoHostedUI/google8.png)

   Note: If you saw an error message `Invalid Redirect: domain must be added to the authorized domains list before submitting.` when adding the endpoint, please go to the _Authorized Domains List_ and add the domain.

7. Click _Save_.

</Block>
<Block name="Login with Amazon">

1. [Sign in](https://developer.amazon.com/loginwithamazon/console/site/lwa/overview.html) with your Amazon credentials.
2. Hover over the gear and choose _Web Settings_ associated with the security profile you created in the previous step, and then choose _Edit_. ![The web settings option is selected in the dropdown menu from the gear icon.](/images/cognitoHostedUI/amazon4.png)
3. Type your user pool domain into _Allowed Origins_ and type your user pool domain with the `/oauth2/idpresponse` endpoint into _Allowed Return URLs_. ![Userpool domain is typed into the allowed origins field with /oauth2/ as the endpoint in the Allowed Return URLs field.](/images/cognitoHostedUI/amazon5.png)
4. Choose _Save_.

</Block>
<Block name="Sign in with Apple">

1. [Sign In](https://developer.apple.com/account/) with your Apple developer credentials.
2. On the main developer portal page, select _Certificates, IDs, & Profiles_.
3. On the left navigation bar, select _Identifiers_ and then select _Service IDs_ from the drop down list on the right.
4. Select the Service ID created when you set up your auth provider as outlined in the section above.
5. Enable _Sign In with Apple_ and select _Configure_.
6. Under _Primary App ID_ select the App ID that was created before.
7. Type your user pool domain into _Domains and Subdomains_.
8. Type your user pool domain with the `/oauth2/idpresponse` endpoint into _Return URLs_. ![The return URLs text field is selected.](/images/cognitoHostedUI/apple3.png)
9. Click _Next_, review the information, then select _Done_.
10. On _Edit your Services ID Configuration_ click _Continue_, review the information, then select _Save_.
11. On the main _Certificates, Identifiers & Profiles_, select _Keys_.
12. On the _Keys_ page, select the _plus icon (+)_.
13. Provide a name for the key under _Key Name_.
14. Enable _Sign in with Apple_ and select _Configure_. ![The sign in with apple option is enabled and the key name text field is filled out.](/images/cognitoHostedUI/apple4.png)
15. Under _Primary App ID_ select the App ID that was created before.
16. Click on _Save_.
17. On _Register a New Key_ click _Continue_, review the information, then select _Register_.
18. You will be redirected to a new page. Take note of the _Key ID_ and download the .p8 file containing the private key. ![The download key page is shown with the option to download the .p8 file with the private key.](/images/cognitoHostedUI/apple5.png)

</Block>
</BlockSwitcher>

Learn more about using social identity providers with user pool](https://docs.aws.amazon.com/cognito/latest/developerguide/cognito-user-pools-social-idp.html)

### Customizing scopes for retrieving user data from external providers

You can determine the pieces of data you want to retrieve from each external provider when setting them up in the `amplify/auth/resource.ts` file using `scopes`.

<InlineFilter filters={["angular", "javascript", "nextjs", "react", "vue"]}>

```ts title="amplify/auth/resource.ts"
import { defineAuth } from '@aws-amplify/backend';

export const auth = defineAuth({
  loginWith: {
    email: true,
    externalProviders: {
      loginWithAmazon: {
        clientId: secret('LOGINWITHAMAZON_CLIENT_ID'),
        clientSecret: secret('LOGINWITHAMAZON_CLIENT_SECRET'),
        // highlight-next-line
        scopes: ['profile']
      },
      callbackUrls: [
        'http://localhost:3000/profile',
        'https://mywebsite.com/profile'
      ],
      logoutUrls: ['http://localhost:3000/', 'https://mywebsite.com'],
    }
  }
});
```

</InlineFilter>
<InlineFilter filters={["android", "flutter", "swift", "react-native"]}>

```ts title="amplify/auth/resource.ts"
import { defineAuth } from '@aws-amplify/backend';

export const auth = defineAuth({
  loginWith: {
    email: true,
    externalProviders: {
      loginWithAmazon: {
        clientId: secret('LOGINWITHAMAZON_CLIENT_ID'),
        clientSecret: secret('LOGINWITHAMAZON_CLIENT_SECRET'),
        // highlight-next-line
        scopes: ['email']
      },
      callbackUrls: ["myapp://callback/"],
      logoutUrls: ["myapp://signout/"],
    }
  }
});
```

</InlineFilter>

### Attribute mapping

You can map which attributes are mapped between your external identity provider and your users created in Cognito. We will be able to have the best level of protection for developers if we ensure that attribute mappings that would not work are called out by the type system.

<Callout>

If you specify an attribute in your authentication resource as required, and it is not allowed for your external providers, signing in with that external provider will cause an error.

</Callout>

<InlineFilter filters={["angular", "javascript", "nextjs", "react", "vue"]}>

```ts title="amplify/auth/resource.ts"
import { defineAuth } from '@aws-amplify/backend';

export const auth = defineAuth({
  loginWith: {
    email: true,
    externalAuthProviders: {
      loginWithAmazon: {
        clientId: secret('LOGINWITHAMAZON_CLIENT_ID'),
        clientSecret: secret('LOGINWITHAMAZON_CLIENT_SECRET'),
        // highlight-start
        attributeMapping: {
          email: 'email'
        }
        // highlight-end
      },
      callbackUrls: [
        'http://localhost:3000/profile',
        'https://mywebsite.com/profile'
      ],
      logoutUrls: ['http://localhost:3000/', 'https://mywebsite.com'],
    }
  }
});
```

</InlineFilter>
<InlineFilter filters={["android", "flutter", "swift", "react-native"]}>

```ts title="amplify/auth/resource.ts"
import { defineAuth } from '@aws-amplify/backend';

export const auth = defineAuth({
  loginWith: {
    email: true,
    externalAuthProviders: {
      loginWithAmazon: {
        clientId: secret('LOGINWITHAMAZON_CLIENT_ID'),
        clientSecret: secret('LOGINWITHAMAZON_CLIENT_SECRET'),
        // highlight-start
        attributeMapping: {
          email: 'email'
        }
        // highlight-end
      },
      callbackUrls: ["myapp://callback/"],
      logoutUrls: ["myapp://signout/"],
    }
  }
});
```

</InlineFilter>


<InlineFilter filters={["angular", "javascript", "nextjs", "react", "vue"]}>
[Learn more about configuring the React Authenticator component for external providers](https://ui.docs.amplify.aws/react/connected-components/authenticator/configuration#external-providers)
</InlineFilter>

## Configure OIDC provider

To setup a OIDC provider, you can configure them in your `amplify/auth/resource.ts` file. For example, if you would like to setup a Microsoft EntraID provider, you can do so as follows:

<InlineFilter filters={["angular", "javascript", "nextjs", "react", "vue"]}>

```ts title="amplify/auth/resource.ts"
import { defineAuth, secret } from '@aws-amplify/backend';

export const auth = defineAuth({
  loginWith: {
    email: true,
    externalProviders: {
      oidc: [
        {
          name: 'MicrosoftEntraID',
          clientId: secret('MICROSOFT_ENTRA_ID_CLIENT_ID'),
          clientSecret: secret('MICROSOFT_ENTRA_ID_CLIENT_SECRET'),
          issuerUrl: '<your-issuer-url>',
        },
      ],
      logoutUrls: ['http://localhost:3000/', 'https://mywebsite.com'],
      callbackUrls: [
        'http://localhost:3000/profile',
        'https://mywebsite.com/profile',
      ],
    },
  },
});
```

</InlineFilter>
<InlineFilter filters={["android", "flutter", "swift", "react-native"]}>

```ts title="amplify/auth/resource.ts"
import { defineAuth, secret } from '@aws-amplify/backend';

export const auth = defineAuth({
  loginWith: {
    email: true,
    externalProviders: {
      oidc: [
        {
          name: 'MicrosoftEntraID',
          clientId: secret('MICROSOFT_ENTRA_ID_CLIENT_ID'),
          clientSecret: secret('MICROSOFT_ENTRA_ID_CLIENT_SECRET'),
          issuerUrl: '<your-issuer-url>',
        },
      ],
      callbackUrls: ["myapp://callback/"],
      logoutUrls: ["myapp://signout/"],
    },
  },
});
```

</InlineFilter>


<InlineFilter filters={["angular", "javascript", "nextjs", "react", "vue"]}>

Use the `signInWithRedirect` API to initiate sign-in with an OIDC identity provider.

```ts title="src/my-client-side-js.js"
import { signInWithRedirect } from 'aws-amplify/auth';

await signInWithRedirect({
  provider: {
    custom: 'MicrosoftEntraID'
  }
});
```
</InlineFilter>

## Configure SAML provider

To setup a SAML provider, you can configure them in your `amplify/auth/resource.ts` file. For example, if you would like to setup a Microsoft EntraID provider, you can do so as follows:

<InlineFilter filters={["angular", "javascript", "nextjs", "react", "vue"]}>

```ts title="amplify/auth/resource.ts"
import { defineAuth } from '@aws-amplify/backend';

export const auth = defineAuth({
  loginWith: {
    email: true,
    externalProviders: {
      saml: {
        name: 'MicrosoftEntraIDSAML',
        metadata: {
          metadataContent: '<your-url-hosting-saml-metadata>', // or content of the metadata file
          metadataType: 'URL', // or 'FILE'
        },
      },
      logoutUrls: ['http://localhost:3000/', 'https://mywebsite.com'],
      callbackUrls: [
        'http://localhost:3000/profile',
        'https://mywebsite.com/profile',
      ],
    },
  },
});
```

</InlineFilter>
<InlineFilter filters={["android", "flutter", "swift", "react-native"]}>

```ts title="amplify/auth/resource.ts"
import { defineAuth } from '@aws-amplify/backend';

export const auth = defineAuth({
  loginWith: {
    email: true,
    externalProviders: {
      saml: {
        name: 'MicrosoftEntraIDSAML',
        metadata: {
          metadataContent: '<your-url-hosting-saml-metadata>', // or content of the metadata file
          metadataType: 'URL', // or 'FILE'
        },
      },
      callbackUrls: ["myapp://callback/"],
      logoutUrls: ["myapp://signout/"],
    },
  },
});
```

</InlineFilter>


<InlineFilter filters={["angular", "javascript", "nextjs", "react", "vue"]}>

Use the `signInWithRedirect` API to initiate sign-in with a SAML identity provider.

```ts title="src/my-client-side-js.js"
import { signInWithRedirect } from 'aws-amplify/auth';

await signInWithRedirect({
  provider: {
    custom: 'MicrosoftEntraIDSAML'
  }
});
```
</InlineFilter>

<InlineFilter filters={["angular", "javascript", "nextjs", "react", "vue"]}>

{/* @TODO refactor with connect-your-frontend/sign-in */}
## Set up your frontend

<Callout info>

If you are using the [Authenticator component](https://ui.docs.amplify.aws/react/connected-components/authenticator/configuration#external-providers) with Amplify, this feature works without any additional code. The guide below is for writing your own implementation.

</Callout>

Use the `signInWithRedirect` API to initiate sign-in with an external identity provider.

```ts title="src/my-client-side-js.js"
import { signInWithRedirect } from 'aws-amplify/auth';

await signInWithRedirect({
  provider: 'Apple'
});
```

### Redirect URLs

_Sign in_ & _Sign out_ redirect URL(s) are used to redirect end users after the sign in or sign out operation has occurred. You may want to specify multiple URLs for various use-cases such as having different URLs for development/ production or redirect users to an intermediate URL before returning them to the app. 

#### Specifying a redirect URL on sign out
If you have multiple sign out redirect URLs configured, you may choose to override the default behavior of selecting a redirect URL and provide the one of your choosing when calling `signOut`. The provided redirect URL should match at least one of the configured redirect URLs. If no redirect URL is provided to `signOut`, one will be selected based on the current app domain.

```ts
import { Amplify } from 'aws-amplify';
import { signOut } from 'aws-amplify/auth';

// Assuming the following URLS were provided manually or via the Amplify configuration file,
// redirectSignOut: 'http://localhost:3000/,https://authProvider/logout?logout_uri=https://mywebsite.com/'

signOut({
  global: false,
  oauth: {
    redirectUrl: 'https://authProvider/logout?logout_uri=https://mywebsite.com/'
  }
});

```

</InlineFilter>
<InlineFilter filters={["angular", "javascript", "nextjs", "react", "vue"]}>

### (Required for Multi-Page Applications) Complete external Sign In after Redirect

If you are developing a multi-page application, and the redirected page is not the same page that initiated the sign in, you will need to add the following code to the redirected page to ensure the sign in gets completed:

```ts title="src/my-redirected-page.ts"
import 'aws-amplify/auth/enable-oauth-listener';
import { getCurrentUser, fetchUserAttributes } from 'aws-amplify/auth';
import { Hub } from 'aws-amplify/utils';

Hub.listen("auth", ({ payload }) => {
  switch (payload.event) {
    case "signInWithRedirect":
      const user = await getCurrentUser();
      const userAttributes = await fetchUserAttributes();
      console.log({user, userAttributes});
      break;
    case "signInWithRedirect_failure":
      // handle sign in failure
      break;
    case "customOAuthState":
      const state = payload.data; // this will be customState provided on signInWithRedirect function
      console.log(state);
      break;
  }
});
```

<Callout>

**Note:** The listener only works on the client side in the context of a SSR-enabled project, so ensure to import the listener on the client side only. For example, in a Next.js project, you should add the above import statement to a component that renders on the client side only by `'use client'`.

</Callout>

<Accordion eyebrow="Under the hood" headingLevel="4" title="Why external Sign In needs to be explicitly handled for Multi-Page Applications">

When you import and use the `signInWithRedirect` function, it will add a listener as a side effect that will complete the external sign in when an end user is redirected back to your app. This works well in a single-page application but in a multi-page application, you might get redirected to a page that doesn't include the listener that was originally added as a side-effect. Hence you must include the specific OAuth listener on your login success page.

</Accordion>
</InlineFilter>

<InlineFilter filters={["react-native"]}>

## Set up your frontend

<Callout info>

If you are using the [Authenticator component](https://ui.docs.amplify.aws/react/connected-components/authenticator/configuration#external-providers) with Amplify, this feature works without any additional code. The guide below is for writing your own implementation.

</Callout>

Use the `signInWithRedirect` API to initiate sign-in with an external identity provider.

```ts title="src/my-client-side-js.js"
import { signInWithRedirect } from 'aws-amplify/auth';

signInWithRedirect({
  provider: 'Apple'
});
```

### Redirect URLs

_Sign in_ & _Sign out_ redirect URL(s) are used to redirect end users after the sign in or sign out operation has occurred. You may want to specify multiple URLs for various use-cases such as having different URLs for development/ production or redirect users to an intermediate URL before returning them to the app. 

#### Specifying a redirect URL on sign out
If you have multiple sign out redirect URLs configured, you may choose to override the default behavior of selecting a redirect URL and provide the one of your choosing when calling `signOut`. The provided redirect URL should match at least one of the configured redirect URLs. If no redirect URL is provided to `signOut`, the first item from the the configured redirect URLs list that does not contain a HTTP nor HTTPS prefix will be picked.

```ts
import { signOut } from 'aws-amplify/auth';

// Assuming the following URLS were provided manually or via the Amplify configuration file,
// redirectSignOut: 'myDevApp://,https://authProvider/logout?logout_uri=myDevApp://'

signOut({
  global: false,
  oauth: {
    redirectUrl: 'https://authProvider/logout?logout_uri=myapp://'
  }
});
```
<Callout> Irrespective of whether a `redirectUrl` is provided to `signOut`, a URL that does not contain http or https is expected to be present in the configured redirect URL list. This is because iOS requires an appScheme when creating the web session. </Callout>

</InlineFilter>

## Next steps

- [Learn how to sign in with external providers](/[platform]/build-a-backend/auth/connect-your-frontend/sign-in/#sign-in-with-an-external-identity-provider)


Contents of build-a-backend_auth_concepts_guest-access_index.txt:
import { getCustomStaticPath } from '@/utils/getCustomStaticPath';

export const meta = {
  title: 'Guest access',
  description: 'Access services without needing to sign in.',
  platforms: [
    'javascript',
    'react-native',
    'flutter',
    'swift',
    'android',
    'angular',
    'nextjs',
    'react',
    'vue'
  ]
};

export const getStaticPaths = async () => {
  return getCustomStaticPath(meta.platforms);
};

export function getStaticProps(context) {
  return {
    props: {
      platform: context.params.platform,
      meta
    }
  };
}

<InlineFilter filters={['flutter','swift','android']}>
The Auth Plugin can be configured to automatically obtain guest credentials once the device is online so that you are able to use other categories "anonymously" without the need to sign in. You will not be able to perform user specific methods while in this state such as updating attributes, changing your password, or getting the current user. However, you can obtain the unique Identity ID which is assigned to the device through the `fetchAuthSession` method [described here](/[platform]/build-a-backend/auth/concepts/tokens-and-credentials/).


</InlineFilter>
<InlineFilter filters={['javascript','react-native','angular','nextjs','react','vue']}>
Amplify Auth can be configured to automatically obtain guest credentials once the device is online so that you are able to use other categories "anonymously" without the need to sign in. You will not be able to perform user specific methods while in this state such as updating attributes, changing your password, or getting the current user. However, you can obtain the unique Identity ID which is assigned to the device through the `fetchAuthSession` method [described here](/[platform]/build-a-backend/auth/connect-your-frontend/manage-user-sessions/).

</InlineFilter>

Amplify Gen 2 enables guest access by default. To disable it, you can update the `backend.ts` file with the following changes:

```ts title="amplify/backend.ts"
import { defineBackend } from '@aws-amplify/backend'
import { auth } from './auth/resource'
import { data } from './data/resource'

const backend = defineBackend({
  auth,
  data,
});

// highlight-start
const { cfnIdentityPool } = backend.auth.resources.cfnResources;
cfnIdentityPool.allowUnauthenticatedIdentities = false;
// highlight-end
```




Contents of build-a-backend_auth_concepts_index.txt:
import { getChildPageNodes } from '@/utils/getChildPageNodes';
import { getCustomStaticPath } from '@/utils/getCustomStaticPath';

export const meta = {
  title: 'Concepts',
  description:
    'Learn more about what Amplify Auth provisions and supports',
  route: '/[platform]/build-a-backend/auth/concepts',
  platforms: [
    'android',
    'angular',
    'flutter',
    'javascript',
    'nextjs',
    'react',
    'react-native',
    'swift',
    'vue'
  ]
};

export function getStaticPaths() {
  return getCustomStaticPath(meta.platforms);
}

export function getStaticProps() {
  const childPageNodes = getChildPageNodes(meta.route);
  return {
    props: {
      meta,
      childPageNodes
    }
  };
}

Amplify helps you secure your application while providing an easy sign-in experience for your users. This experience is influenced by your security strategy. This security strategy includes the authentication method, security credentials, and enabling additional verification when needed.

- _Authentication_ is a process to validate **who you are** (abbreviated as _AuthN_). The system that does this validation is referred to as an Identity Provider or IdP. This can be your own self-hosted IdP or a cloud service. Oftentimes, this IdP is an external provider such as Apple, Facebook, Google, or Amazon.
- _Authorization_ is the process of validating **what you can access** (abbreviated as _AuthZ_). This is sometimes done by looking at tokens with custom logic, predefined rules, or signed requests with policies.

Common authentication methods and associated risks include:

- External provider federation which enables easier access for your users but shares data with third parties.

You can improve security credentials and verification for these authentication methods by:

- Modifying the default password policy to ensure your users create stronger passwords.
- Requiring additional contact information from users before they can reset passwords.
- Enabling multi-factor authentication (MFA) which adds a layer of security at sign-in but may also add friction for your users.

## What is Amazon Cognito?

Amplify Auth is powered by [Amazon Cognito](https://aws.amazon.com/cognito/). Amazon Cognito is an identity and access management service, enabling you to secure your web or mobile applications, and is comprised of two services:

1. [Amazon Cognito User Pools](https://docs.aws.amazon.com/cognito/latest/developerguide/cognito-user-identity-pools.html) is a full-featured user directory service to handle user registration, authentication, and account recovery
2. [Amazon Cognito Federated Identities or Identity Pools](https://docs.aws.amazon.com/cognito/latest/developerguide/cognito-identity.html) is a service used to authorize your users to interact with other AWS services

Amplify interfaces with User Pools to store your user information, including federation with other OpenID providers like Apple, Facebook, Google, or Amazon, and leverages federated identities to manage user access to AWS resources.

Authorization is often done in one of two ways:

1. Clients pass the tokens to the backend that perform custom logic to allow or deny actions
2. Clients sign the requests and the backend validates the signature, allowing or denying actions depending on predefined policy. The predefined rules, known as [IAM access policies](https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies.html), are automatically configured by Amplify.

The first is a common authorization method for HTTP or GraphQL APIs, while the second is necessary for interfacing with AWS services such as Amazon S3, Amazon Pinpoint, and others.

### Before you build

Amazon Cognito can be customized based on your security strategy for authentication. However, some initial configuration options cannot be changed after the backend resources are configured:

- User attributes that are used to identify your individual users (such as email and phone) cannot be renamed or deleted.
- Sign-in methods (including username, email, and phone) cannot be added or changed after the initial configuration. This includes both defining which attributes are used to sign in and which attributes are required. Required attributes must have a value for all users once set.
- Verification methods (including username and email) are the same as required attributes and cannot be removed once configured.
- The `sub` attribute is a unique identifier within each user pool that cannot be modified and can be used to index and search users.
- If MFA is set to **required** with phone number for all users, you will need to include MFA setup (i.e. mandating phone number) when users sign up.

Visit the [Amazon Cognito documentation](https://docs.aws.amazon.com/cognito/latest/developerguide/what-is-amazon-cognito.html) for more details on these settings, including [User pool attributes](https://docs.aws.amazon.com/cognito/latest/developerguide/user-pool-settings-attributes.html) and [Adding MFA to a user pool](https://docs.aws.amazon.com/cognito/latest/developerguide/user-pool-settings-mfa.html).

<Overview childPageNodes={props.childPageNodes} />


Contents of build-a-backend_auth_concepts_multi-factor-authentication_index.txt:
import { getCustomStaticPath } from '@/utils/getCustomStaticPath';

export const meta = {
  title: 'Multi-factor authentication',
  description: 'Learn more about what Amplify Auth provisions and supports',
  platforms: [
    'android',
    'angular',
    'flutter',
    'javascript',
    'nextjs',
    'react',
    'react-native',
    'swift',
    'vue'
  ]
};

export function getStaticPaths() {
  return getCustomStaticPath(meta.platforms);
}

export function getStaticProps() {
  return {
    props: {
      meta
    }
  };
}

Amplify Auth supports multi-factor authentication (MFA) for user sign-in flows. MFA is an extra layer of security used to make sure that users trying to gain access to an account are who they say they are. It requires users to provide additional information to verify their identity. Amplify Auth supports MFA with time-based one-time passwords (TOTP), text messages (SMS), and email. 

In this guide we will review how you can set up MFA with each of these methods and the discuss tradeoffs between them to help you choose the right setup for your application. We will also review how to set up MFA to remember a device and reduce sign-in friction for your users.

## Configure multi-factor authentication

Use `defineAuth` to enable MFA for your app. The example below is setting up MFA with TOTP but not SMS as you can see that the phone number is not a required attribute. 
- If you plan to use SMS for MFA, then the `phoneNumber` attribute must be marked as required in your `userAttributes`. Note that if you have `loginWith.phone` as `true` this attribute will automatically be marked as required.
- If you plan to use email for MFA, then the `email` attribute must also be `true` must be marked as required in your `userAttributes`. Note that if you have `loginWith.email` as `true` this attribute will automatically be marked as required.

```ts title="amplify/auth/resource.ts"
import { defineAuth } from '@aws-amplify/backend';

export const auth = defineAuth({
  loginWith: {
    email: true
  },
// highlight-start
  multifactor: {
    mode: 'OPTIONAL',
    totp: true,
  },
// highlight-end
  userAttributes: {
    phoneNumber: { 
      required: true
    }
  }
});
```

<Callout info>
**Note:** Email-based MFA is currently not supported with `defineAuth`. We are working towards supporting this feature. For more information, visit the [feature request in GitHub](https://github.com/aws-amplify/amplify-backend/issues/2159).

To take advantage of this feature with an Amplify generated backend, the underlying CDK construct can be extended manually. See [overriding Cognito User Pool multi-factor authentication options](/[platform]/build-a-backend/auth/modify-resources-with-cdk/#override-cognito-userpool-multi-factor-authentication-options) for more information.
</Callout>

When MFA is `REQUIRED` with SMS in your backend auth resource, you will need to pass the phone number during sign-up API call. If you are using the `email` or `username` as the primary sign-in mechanism, you will need to pass the `phone_number` attribute as a user attribute. 

Similarly, when MFA is `REQUIRED` with email as your delivery mechanism, you will need to pass an email address during the sign-up API call. If you are using `phoneNumber` or `username` as the primary sign-in mechanism, you will need to pass the `email` attribute as a user attribute. 

This configuration may change depending on the combination of MFA methods enabled in your user pool.

### Understand your MFA options

When enabling MFA you will have two key decisions to make:

- **MFA enforcement:** As part of this setup you will determine how MFA is enforced. If you require MFA by setting MFA mode to `REQUIRED`, all your users will need to complete MFA to sign in. If you keep it `OPTIONAL`, your users will have the choice whether to enable MFA or not for their account.
- **MFA methods:** You will also specify which MFA method you are using: TOTP (Time-based One-time Password), SMS (text message), email, or any combination thereof. We recommend that you use TOTP-based MFA as it is more secure and you can reserve SMS or email for account recovery.

<Accordion title='Compare TOTP, SMS, and EMAIL MFA methods' headingLevel='4' eyebrow='Learn more'>

|  | Time-based One-time Password (TOTP) | Short Message Service (SMS) | Email |
| --- | --- | --- | --- |
| **Description** | Generates a short-lived numeric code for user authentication that includes a shared secret key and current time using an authenticator app. | Generates a one-time code shared via text message that is entered with other credentials for user authentication. | Generates a one-time code sent to the user's registered email address. The user must access the email and enter the code to complete the authentication process. |
| **Benefits** | More secure than SMS since the code is generated locally and not transmitted over a network. TOTP also works without cell service as long as the TOTP app is installed. | Easy to set up with a user-provided phone number and is familiar to users as a common authentication method. | Email is a widely used and familiar communication channel that requires no additional hardware or software requirements on the user's end. |
| **Constraints** | Requires an app to generate codes and adds to the initial setup of an account. Codes also expire quickly and must be used promptly after it is generated. | SMS requires cell service and can include an additional cost for the user. Although rare, SMS messages can also be intercepted. | Depends on the availability and reliability of email services. Although rare, emails can be intercepted or accounts can become compromised. |

</Accordion>


<InlineFilter filters={["angular", "javascript", "nextjs", "react", "react-native", "vue", "android"]}>
If multiple MFA methods are enabled for the user, and none are set as preferred, the `signIn` API will return `CONTINUE_SIGN_IN_WITH_MFA_SELECTION` as the next step in the auth flow. During this scenario, the user should be prompted to select the MFA method they want to use to sign in and their preference should be passed to `confirmSignIn`.

</InlineFilter>

<InlineFilter filters={["angular", "javascript", "nextjs", "react-native", "react", "vue"]}>
```ts
import { confirmSignIn, type SignInOutput } from 'aws-amplify/auth';

function handleSignInNextSteps(output: SignInOutput) {
	const { nextStep } = output;
	switch (nextStep.signInStep) {
		// ...
		case 'CONTINUE_SIGN_IN_WITH_MFA_SELECTION':
			const allowedMFATypes = nextStep.allowedMFATypes;
			const mfaType = promptUserForMFAType(allowedMFATypes);
		case 'CONFIRM_SIGN_IN_WITH_SMS_CODE':
			// prompt user to enter otp code delivered via SMS
			break;
		case 'CONFIRM_SIGN_IN_WITH_TOTP_CODE':
			// prompt user to enter otp code from their authenticator app
			break;
		case 'CONFIRM_SIGN_IN_WITH_EMAIL_CODE':
			// prompt user to enter otp code delivered via EMAIL
			break;
		// ...
	}
}

type MfaType = 'SMS' | 'TOTP' | 'EMAIL';

function promptUserForMFAType(allowedMFATypes?: MfaType[]): MfaType {
	// Prompt user to select MFA type
}

async function handleMFASelection(mfaType: MfaType) {
	try {
		const output = await confirmSignIn({
			challengeResponse: mfaType,
		});
		handleSignInNextSteps(output);
	} catch (error) {
		console.log(error);
	}
}
```
</InlineFilter>

<InlineFilter filters={["android"]}>
```kotlin
fun signIn(username: String, password: String) {
    val result: AuthSignInResult
    try {
        result = Amplify.Auth.signIn(username, password)
    } catch (e: AuthException) {
        Log.e("MFASelection", "Failed to sign in", e)
    }
    handleNextSignInStep(username, result.nextStep)
}

fun handleNextSignInStep(
    username: String,
    nextStep: AuthNextSignInStep
) {
    when (nextStep.signInStep) {
        AuthSignInStep.CONTINUE_SIGN_IN_WITH_MFA_SELECTION -> {
            // User has multiple MFA methods and none are preferred
            promptUserForMfaType(nextStep.allowedMFATypes)
        }
        else -> {
            // Handle other SignInSteps
        }
    }
}

fun promptUserForMfaType(mfaTypes: Set<MFAType>?) {
    // Prompt user to select one of the passed-in MFA Types
    // Then invoke Amplify.Auth.confirmSignIn(selectedMfaType.challengeResponse)
}
```
</InlineFilter>

<InlineFilter filters={["swift", "flutter"]}>
If multiple MFA methods are enabled for the user, and none are set as preferred, the `signIn` API will return `continueSignInWithMFASelection` as the next step in the auth flow. During this scenario, the user should be prompted to select the MFA method they want to use to sign in and their preference should be passed to `confirmSignIn`.
</InlineFilter>

<InlineFilter filters={["flutter"]}>

```dart
Future<void> _handleSignInResult(SignInResult result) async {
  switch (result.nextStep.signInStep) {
    // ···
    case AuthSignInStep.continueSignInWithMfaSelection:
      final allowedMfaTypes = result.nextStep.allowedMfaTypes!;
      final selection = await _promptUserPreference(allowedMfaTypes);
      return _handleMfaSelection(selection);
    // ···
  }
}

Future<MfaType> _promptUserPreference(Set<MfaType> allowedTypes) async {
  // ···
}

Future<void> _handleMfaSelection(MfaType selection) async {
  try {
    final result = await Amplify.Auth.confirmSignIn(
      confirmationValue: selection.confirmationValue,
    );
    return _handleSignInResult(result);
  } on AuthException catch (e) {
    safePrint('Error sending MFA selection: ${e.message}');
  }
}
```
</InlineFilter>

<InlineFilter filters={["swift"]}>

```swift
func signIn(username: String, password: String) async {
    do {
        let signInResult = try await Amplify.Auth.signIn(username: username, password: password)
        switch signInResult.nextStep {

        case .continueSignInWithMFASelection(let allowedMFATypes):
            print("Received next step as continue sign in by selecting MFA type")
            print("Allowed MFA types \(allowedMFATypes)")
            
            // Prompt the user to select the MFA type they want to use
            // Then invoke `confirmSignIn` api with the MFA type
        
        default:
            
            // Use has successfully signed in to the app
            print("Step: \(signInResult.nextStep)")
        }
    } catch let error as AuthError{
        print ("Sign in failed \(error)")
    } catch {
        print("Unexpected error: \(error)")
    }
}

func confirmSignInWithTOTPAsMFASelection() async {
    do {
        let signInResult = try await Amplify.Auth.confirmSignIn(
            challengeResponse: MFAType.totp.challengeResponse)

        if case .confirmSignInWithTOTPCode = signInResult.nextStep {
            print("Received next step as confirm sign in with TOTP")
        }

    } catch {
        print("Confirm sign in failed \(error)")
    }
}
```
</InlineFilter>


## Multi-factor authentication with SMS
<InlineFilter filters={["react"]}>
<Callout info>

If you are using the [Authenticator component](https://ui.docs.amplify.aws/react/connected-components/authenticator) with Amplify, this feature works without any additional code. The guide below is for writing your own implementation.

</Callout>
</InlineFilter>

<InlineFilter filters={["swift"]}>
<Callout info>

If you are using the [Authenticator component](https://ui.docs.amplify.aws/swift/connected-components/authenticator) with Amplify, this feature works without any additional code. The guide below is for writing your own implementation.

</Callout>
</InlineFilter>

<InlineFilter filters={["flutter"]}>
<Callout info>

If you are using the [Authenticator component](https://ui.docs.amplify.aws/flutter/connected-components/authenticator) with Amplify, this feature works without any additional code. The guide below is for writing your own implementation.

</Callout>
</InlineFilter>

<InlineFilter filters={["android"]}>
<Callout info>

If you are using the [Authenticator component](https://ui.docs.amplify.aws/android/connected-components/authenticator) with Amplify, this feature works without any additional code. The guide below is for writing your own implementation.

</Callout>
</InlineFilter>

Once you have setup SMS as your second layer of authentication with MFA as shown above, your users will get an authentication code via a text message to complete sign-in after they sign in with their username and password.

<Callout warning>

**Warning:** In order to send SMS authentication codes, you must [request an origination number](https://docs.aws.amazon.com/pinpoint/latest/userguide/settings-request-number.html). [Learn more about configuring your auth resource for production workloads](/[platform]/build-a-backend/auth/moving-to-production/).

</Callout>

{/* moving-to-production */}
{/* If you do not have one already, you will need to configure an IAM role to use with Amazon Simple Notification Service (Amazon SNS) to manage SMS messages. You will then add this role under the "Messaging" tab for your user pool in the Amazon Cognito console. For additional information see the [_Amazon Cognito SMS text message MFA_](https://docs.aws.amazon.com/cognito/latest/developerguide/user-pool-settings-mfa-sms-text-message.html) documentation. */}

### Enable SMS MFA during sign-up

You will need to pass `phone_number` as a user attribute to enable SMS MFA for your users during sign-up. However, if the primary sign-in mechanism for your Cognito resource is `phone_number` (without enabling `username`), then you do not need to pass it as an attribute.

<InlineFilter filters={["angular", "javascript", "nextjs", "react", "vue", "android"]}>
```ts
import { signUp } from 'aws-amplify/auth';

await signUp({
  username: "hello@mycompany.com",
  password: "hunter2",
  options: {
    userAttributes: {
      phone_number: "+15555555555",
      email: "hello@mycompany.com",
    },
  },
});
```
</InlineFilter>

<InlineFilter filters={["flutter"]}>
```dart
Future<void> signUpWithPhoneVerification(
  String username,
  String password,
) async {
  await Amplify.Auth.signUp(
    username: username,
    password: password,
    options: SignUpOptions(
      userAttributes: <AuthUserAttributeKey, String>{
        // ... if required
        AuthUserAttributeKey.email: 'test@example.com',
        AuthUserAttributeKey.phoneNumber: '+18885551234',
      },
    ),
  );
}
```
</InlineFilter>

<InlineFilter filters={["swift"]}>
```swift
func signUp(username: String, password: String, email: String, phonenumber: String) async {
    do {
        let signUpResult = try await Amplify.Auth.signUp(
            username: username,
            password: password,
            options: .init(userAttributes: [
                AuthUserAttribute(.email, value: email), 
                AuthUserAttribute(.phoneNumber, value: phonenumber)
            ])
        )
        if case let .confirmUser(deliveryDetails, _, userId) = signUpResult.nextStep {
            print("Delivery details \(String(describing: deliveryDetails)) for userId: \(String(describing: userId)))")
        } else {
            print("SignUp Complete")
        }
    } catch let error as AuthError {
        print("An error occurred while registering a user \(error)")
    } catch {
        print("Unexpected error: \(error)")
    }
}
```
</InlineFilter>

By default, you have to verify a user account after they sign up using the `confirmSignUp` API, which will send a one-time password to the user's phone number or email, depending on your Amazon Cognito configuration.

<InlineFilter filters={["angular", "javascript", "nextjs", "react", "vue", "android"]}>
```ts
import { confirmSignUp } from 'aws-amplify/auth';

await confirmSignUp({
  username: "hello@mycompany.com",
  confirmationCode: "123456",
})
```
</InlineFilter>

<InlineFilter filters={["flutter"]}>
```dart
Future<void> confirmSignUpPhoneVerification(
  String username,
  String otpCode,
) async {
  await Amplify.Auth.confirmSignUp(
    username: username,
    confirmationCode: otpCode,
  );
}
```
</InlineFilter>


<InlineFilter filters={["swift"]}>
```swift
func confirmSignUp(for username: String, with confirmationCode: String) async {
    do {
        let confirmSignUpResult = try await Amplify.Auth.confirmSignUp(
            for: username,
            confirmationCode: confirmationCode
        )
        print("Confirm sign up result completed: \(confirmSignUpResult.isSignUpComplete)")
    } catch let error as AuthError {
        print("An error occurred while confirming sign up \(error)")
    } catch {
        print("Unexpected error: \(error)")
    }
}
```
</InlineFilter>

### Manage SMS MFA during sign-in

After a user signs in, if they have MFA enabled for their account, a challenge will be returned that you would need to call the `confirmSignIn` API where the user provides their confirmation code sent to their phone number.

If MFA is **ON** or enabled for the user, you must call `confirmSignIn` with the OTP sent to their phone.

<InlineFilter filters={["angular", "javascript", "nextjs", "react", "vue", "android"]}>
```ts
import { confirmSignIn } from 'aws-amplify/auth';

await confirmSignIn({
  challengeResponse: "123456"
});
```
</InlineFilter>

<InlineFilter filters={["flutter"]}>
```dart
Future<void> confirmSignInPhoneVerification(String otpCode) async {
  await Amplify.Auth.confirmSignIn(
    confirmationValue: otpCode,
  );
}
```
</InlineFilter>

<InlineFilter filters={["swift"]}>
```swift
func confirmSignIn() async {
    do {
        let signInResult = try await Amplify.Auth.confirmSignIn(
            challengeResponse: "<confirmation code received via SMS>")
        print("Confirm sign in succeeded. Next step: \(signInResult.nextStep)")
    } catch let error as AuthError {
        print("Confirm sign in failed \(error)")
    } catch {
        print("Unexpected error: \(error)")
    }
}
```
</InlineFilter>

After a user has been signed in, call `updateMFAPreference` to record the MFA type as enabled for the user and optionally set it as preferred so that subsequent logins default to using this MFA type.

<InlineFilter filters={["angular", "javascript", "nextjs", "react", "vue", "android"]}>
```ts
import { updateMFAPreference } from 'aws-amplify/auth';

await updateMFAPreference({ sms: 'PREFERRED' });
```
</InlineFilter>

<InlineFilter filters={["flutter"]}>
```dart
Future<void> updateMfaPreferences() async {
  final cognitoPlugin = Amplify.Auth.getPlugin(AmplifyAuthCognito.pluginKey);

  await cognitoPlugin.updateMfaPreference(
    sms: MfaPreference.enabled, // or .preferred
  );
}
```
</InlineFilter>

<InlineFilter filters={["swift"]}>
```swift
func updateMFAPreferences() async throws {
    let authCognitoPlugin = try Amplify.Auth.getPlugin(
        for: "awsCognitoAuthPlugin") as? AWSCognitoAuthPlugin

    let smsMfaPreference: MFAPreference = .preferred

    try await authCognitoPlugin?.updateMFAPreference(
        sms: smsMfaPreference)
}
```
</InlineFilter>

## Multi-factor authentication with TOTP

<InlineFilter filters={["react"]}>
<Callout info>

If you are using the [Authenticator component](https://ui.docs.amplify.aws/react/connected-components/authenticator) with Amplify, this feature works without any additional code. The guide below is for writing your own implementation.

</Callout>
</InlineFilter>

<InlineFilter filters={["swift"]}>
<Callout info>

If you are using the [Authenticator component](https://ui.docs.amplify.aws/swift/connected-components/authenticator) with Amplify, this feature works without any additional code. The guide below is for writing your own implementation.

</Callout>
</InlineFilter>

<InlineFilter filters={["flutter"]}>
<Callout info>

If you are using the [Authenticator component](https://ui.docs.amplify.aws/flutter/connected-components/authenticator) with Amplify, this feature works without any additional code. The guide below is for writing your own implementation.

</Callout>
</InlineFilter>

<InlineFilter filters={["android"]}>
<Callout info>

If you are using the [Authenticator component](https://ui.docs.amplify.aws/android/connected-components/authenticator) with Amplify, this feature works without any additional code. The guide below is for writing your own implementation.

</Callout>
</InlineFilter>

You can use Time-based One-Time Password (TOTP) for multi-factor authentication (MFA) in your web or mobile applications. The Amplify Auth category includes support for TOTP setup and verification using authenticator apps, offering an integrated solution and enhanced security for your users. These apps, such as Google Authenticator, Microsoft Authenticator, have the TOTP algorithm built-in and work by using a shared secret key and the current time to generate short-lived, six digit passwords.

### Set up TOTP for a user

<InlineFilter filters={["angular", "javascript", "nextjs", "react", "vue", "android"]}>

After you initiate a user sign in with the `signIn` API where a user is required to set up TOTP as an MFA method, the API call will return `CONTINUE_SIGN_IN_WITH_TOTP_SETUP` as a challenge and next step to handle in your app. You will get that challenge if the following conditions are met:

- MFA is marked as **Required** in your user pool.
- TOTP is enabled in your user pool.
- User does not have TOTP MFA set up already.

The `CONTINUE_SIGN_IN_WITH_TOTP_SETUP` step signifies that the user must set up TOTP before they can sign in. The step returns an associated value of type `TOTPSetupDetails` which must be used to configure an authenticator app like Microsoft Authenticator or Google Authenticator. `TOTPSetupDetails` provides a helper method called `getSetupURI` which generates a URI that can be used, for example, in a button to open the user's installed authenticator app. For more advanced use cases, `TOTPSetupDetails` also contains a `sharedSecret` which can be used to either generate a QR code or be manually entered into an authenticator app.

Once the authenticator app is set up, the user can generate a TOTP code and provide it to the library to complete the sign in process.

```ts
import { signIn, SignInOutput } from 'aws-amplify/auth';

const output = await signIn({
  username: "hello@mycompany.com",
  password: "hunter2"
});

const { nextStep } = output;
switch (nextStep.signInStep) {
  // ...
  case 'CONTINUE_SIGN_IN_WITH_TOTP_SETUP':
    const totpSetupDetails = nextStep.totpSetupDetails;
    const appName = 'my_app_name';
    const setupUri = totpSetupDetails.getSetupUri(appName);
    // Open setupUri with an authenticator APP to retrieve an OTP code
    break;
  // ...
}
```
</InlineFilter>

<InlineFilter filters={["swift", "flutter"]}>
After you initiate a user sign in with the `signIn` API where a user is required to set up TOTP as an MFA method, the API call will return `continueSignInWithTOTPSetup` as a challenge and next step to handle in your app. You will get that challenge if the following conditions are met:

- MFA is marked as **Required** in your user pool.
- TOTP is enabled in your user pool.
- User does not have TOTP MFA set up already.

The `continueSignInWithTOTPSetup` step signifies that the user must set up TOTP before they can sign in. The step returns an associated value of type `TOTPSetupDetails` which must be used to configure an authenticator app like Microsoft Authenticator or Google Authenticator. `TOTPSetupDetails` provides a helper method called `getSetupURI` which generates a URI that can be used, for example, in a button to open the user's installed authenticator app. For more advanced use cases, `TOTPSetupDetails` also contains a `sharedSecret` which can be used to either generate a QR code or be manually entered into an authenticator app.

Once the authenticator app is set up, the user can generate a TOTP code and provide it to the library to complete the sign in process.
</InlineFilter>

<InlineFilter filters={["flutter"]}>

```dart
Future<void> signInUser(String username, String password) async {
  try {
    final result = await Amplify.Auth.signIn(
      username: username,
      password: password,
    );
    return _handleSignInResult(result);
  } on AuthException catch (e) {
    safePrint('Error signing in: ${e.message}');
  }
}

Future<void> _handleSignInResult(SignInResult result) async {
  switch (result.nextStep.signInStep) {
    // ···
    case AuthSignInStep.continueSignInWithTotpSetup:
      final totpSetupDetails = result.nextStep.totpSetupDetails!;
      final setupUri = totpSetupDetails.getSetupUri(appName: 'MyApp');
      safePrint('Open URI to complete setup: $setupUri');
    // ···
  }
}
```
</InlineFilter>

<InlineFilter filters={["swift"]}>

```swift
func signIn(username: String, password: String) async {
    do {
        let signInResult = try await Amplify.Auth.signIn(
            username: username,
            password: password
        )

        if case .continueSignInWithTOTPSetup(let setUpDetails) = signInResult.nextStep {

            print("Received next step as continue sign in by setting up TOTP")
            print("Shared secret that will be used to set up TOTP in the authenticator app \(setUpDetails.sharedSecret)")

            // appName parameter will help distinguish the account in the Authenticator app
            let setupURI = try setUpDetails.getSetupURI(appName: "<Your_App_Name>>")

            print("TOTP Setup URI: \(setupURI)")

            // Prompt the user to enter the TOTP code generated in their authenticator app
            // Then invoke `confirmSignIn` api with the code

        }
    } catch let error as AuthError {
        print("Sign in failed \(error)")
    } catch {
        print("Unexpected error: \(error)")
    }
}
```
</InlineFilter>

The TOTP code can be obtained from the user via a text field or any other means. Once the user provides the TOTP code, call `confirmSignIn` with the TOTP code as the `challengeResponse` parameter.

<InlineFilter filters={["angular", "javascript", "nextjs", "react", "vue", "android"]}>
```ts
import { confirmSignIn } from 'aws-amplify/auth';

await confirmSignIn({
  challengeResponse: "123456"
});
```
</InlineFilter>

<InlineFilter filters={["flutter"]}>
```dart
Future<void> confirmTotpUser(String totpCode) async {
  try {
    final result = await Amplify.Auth.confirmSignIn(
      confirmationValue: totpCode,
    );
    return _handleSignInResult(result);
  } on AuthException catch (e) {
    safePrint('Error confirming TOTP code: ${e.message}');
  }
}
```
</InlineFilter>

<InlineFilter filters={["swift"]}>
```swift
func confirmSignIn() async {
    do {
        let signInResult = try await Amplify.Auth.confirmSignIn(
            challengeResponse: "<confirmation code received from Authenticator app>")
        print("Confirm sign in succeeded. Next step: \(signInResult.nextStep)")
    } catch let error as AuthError {
        print("Confirm sign in failed \(error)")
    } catch {
        print("Unexpected error: \(error)")
    }
}
```
</InlineFilter>

After a user has been signed in, call `updateMFAPreference` to record the MFA type as enabled for the user and optionally set it as preferred so that subsequent logins default to using this MFA type.

<InlineFilter filters={["angular", "javascript", "nextjs", "react", "vue", "android"]}>
```ts
import { updateMFAPreference } from 'aws-amplify/auth';

await updateMFAPreference({ totp: 'PREFERRED' });
```
</InlineFilter>

<InlineFilter filters={["flutter"]}>
```dart
Future<void> updateMfaPreferences() async {
  final cognitoPlugin = Amplify.Auth.getPlugin(AmplifyAuthCognito.pluginKey);

  await cognitoPlugin.updateMfaPreference(
    totp: MfaPreference.preferred,
  );
}
```
</InlineFilter>

<InlineFilter filters={["swift"]}>
```swift
func updateMFAPreferences() async throws {
    let authCognitoPlugin = try Amplify.Auth.getPlugin(
        for: "awsCognitoAuthPlugin") as? AWSCognitoAuthPlugin

    let totpMfaPreference: MFAPreference = .preferred

    try await authCognitoPlugin?.updateMFAPreference(
        totp: totpMfaPreference)
}
```
</InlineFilter>

### Enable TOTP after a user is signed in

TOTP MFA can be set up after a user has signed in. This can be done when the following conditions are met:

- MFA is marked as **Optional** or **Required** in your user pool.
- TOTP is marked as an enabled MFA method in your user pool.

TOTP can be set up by calling the `setUpTOTP` and `verifyTOTPSetup` APIs in the `Auth` category.

Invoke the `setUpTOTP` API to generate a `TOTPSetupDetails` object which should be used to configure an Authenticator app like Microsoft Authenticator or Google Authenticator. `TOTPSetupDetails` provides a helper method called `getSetupURI` which generates a URI that can be used, for example, in a button to open the user's installed Authenticator app. For more advanced use cases, `TOTPSetupDetails` also contains a `sharedSecret` which can be used to either generate a QR code or be manually entered into an Authenticator app.

that contains the `sharedSecret` which will be used to either to generate a QR code or can be manually entered into an Authenticator app.

<InlineFilter filters={["angular", "javascript", "nextjs", "react", "vue", "android"]}>
```ts
import { setUpTOTP } from 'aws-amplify/auth';

const totpSetupDetails = await setUpTOTP();
const appName = 'my_app_name';
const setupUri = totpSetupDetails.getSetupUri(appName);
// Open setupUri with an authenticator APP to retrieve an OTP code
```
</InlineFilter>

<InlineFilter filters={["flutter"]}>
```dart
Future<void> setUpTotp() async {
  try {
    final totpSetupDetails = await Amplify.Auth.setUpTotp();
    final setupUri = totpSetupDetails.getSetupUri(appName: 'MyApp');
    safePrint('Open URI to complete setup: $setupUri');
  } on AuthException catch (e) {
    safePrint('An error occurred setting up TOTP: $e');
  }
}
```
</InlineFilter>

<InlineFilter filters={["swift"]}>
```swift
func setUpTOTP() async {
    do {
        let setUpDetails = try await Amplify.Auth.setUpTOTP()

        print("Received next step as continue sign in by setting up TOTP")
        print("Shared secret that will be used to set up TOTP in the authenticator app \(setUpDetails.sharedSecret)")

        // appName parameter will help distinguish the account in the Authenticator app
        let setupURI = try setUpDetails.getSetupURI(appName: "<Your_App_Name>>")

        print("TOTP Setup URI: \(setupURI)")

        // Prompt the user to enter the TOTP code generated in their authenticator app
        // Then invoke `confirmSignIn` api with the code
    } catch {
        print("TOTP Setup Initiation failed \(error)")
    }
}
```
</InlineFilter>

Once the Authenticator app is set up, the user must generate a TOTP code and provide it to the library. Pass the code to `verifyTOTPSetup` to complete the TOTP setup process.

<InlineFilter filters={["angular", "javascript", "nextjs", "react", "vue", "android"]}>
```ts
import { verifyTOTPSetup } from 'aws-amplify/auth';

await verifyTOTPSetup({ code: "123456" });
```
</InlineFilter>

<InlineFilter filters={["flutter"]}>
```dart
Future<void> verifyTotpSetup(String totpCode) async {
  try {
    await Amplify.Auth.verifyTotpSetup(totpCode);
  } on AuthException catch (e) {
    safePrint('An error occurred verifying TOTP: $e');
  }
}
```
</InlineFilter>

<InlineFilter filters={["swift"]}>
```swift
func verifyTOTPSetup(totpCodeFromAuthenticatorApp: String) async {
    do {
        try await Amplify.Auth.verifyTOTPSetup(
            code: totpCodeFromAuthenticatorApp)
    } catch {
        print("TOTP Setup Verification failed \(error)")
    }
}
```
</InlineFilter>

After TOTP setup is complete, call `updateMFAPreference` to record the MFA type as enabled for the user and optionally set it as preferred so that subsequent logins default to using this MFA type.

<InlineFilter filters={["angular", "javascript", "nextjs", "react", "vue", "android"]}>
```ts
import { updateMFAPreference } from 'aws-amplify/auth';

await updateMFAPreference({ sms: 'ENABLED', totp: 'PREFERRED' });
```
</InlineFilter>

<InlineFilter filters={["flutter"]}>
```dart
Future<void> updateMfaPreferences() async {
  final cognitoPlugin = Amplify.Auth.getPlugin(AmplifyAuthCognito.pluginKey);

  await cognitoPlugin.updateMfaPreference(
    sms: MfaPreference.enabled,
    totp: MfaPreference.preferred,
  );
}
```
</InlineFilter>

<InlineFilter filters={["swift"]}>
```swift
func updateMFAPreferences() async throws {
    let authCognitoPlugin = try Amplify.Auth.getPlugin(
        for: "awsCognitoAuthPlugin") as? AWSCognitoAuthPlugin

    let smsMfaPreference: MFAPreference = .enabled
    let totpMfaPreference: MFAPreference = .preferred

    try await authCognitoPlugin?.updateMFAPreference(
        sms: smsMfaPreference,
        totp: totpMfaPreference)
}
```
</InlineFilter>

### Recover from a lost TOTP device

<Callout warning>

If a user loses access to their TOTP device, they will need to contact an administrator to get help accessing their account. Based on the Cognito user pool configuration, the administrator can use the [AdminSetUserMFAPreference](https://docs.aws.amazon.com/cognito-user-identity-pools/latest/APIReference/API_AdminSetUserMFAPreference.html) to either change the MFA preference to a different MFA method or to disable MFA for the user.

</Callout>

In a scenario where MFA is marked as "Required" in the Cognito User Pool and another MFA method is not set up, the administrator would need to first initiate an [`AdminUpdateUserAttributes`](https://docs.aws.amazon.com/cognito-user-identity-pools/latest/APIReference/API_AdminUpdateUserAttributes.html) call and update the user's phone number attribute. Once this is complete, the administrator can continue changing the MFA preference to SMS as suggested above.

## Multi-factor authentication with EMAIL
<InlineFilter filters={["react"]}>
<Callout info>
**Note:** Email-based MFA is currently not supported in the [Authenticator component](https://ui.docs.amplify.aws/react/connected-components/authenticator). We are working towards supporting this feature. For more information, visit the [feature request in GitHub](https://github.com/aws-amplify/amplify-ui/issues/5983).

</Callout>
</InlineFilter>

<InlineFilter filters={["swift"]}>
<Callout info>

If you are using the [Authenticator component](https://ui.docs.amplify.aws/swift/connected-components/authenticator) with Amplify, this feature works without any additional code. The guide below is for writing your own implementation.

</Callout>
</InlineFilter>

<InlineFilter filters={["flutter"]}>
<Callout info>

If you are using the [Authenticator component](https://ui.docs.amplify.aws/flutter/connected-components/authenticator) with Amplify, this feature works without any additional code. The guide below is for writing your own implementation.

</Callout>
</InlineFilter>

<InlineFilter filters={["android"]}>
<Callout info>

If you are using the [Authenticator component](https://ui.docs.amplify.aws/android/connected-components/authenticator) with Amplify, this feature works without any additional code. The guide below is for writing your own implementation.

</Callout>
</InlineFilter>

Once you have setup email as your second layer of authentication with MFA as shown above, your users will get an authentication code via email to complete sign-in after they sign in with their username and password.

<Callout warning>

In order to send email authentication codes, the following prerequisites must be met:
- Cognito must be configured to send emails using [Amazon Simple Email Service (Amazon SES)](/[platform]/build-a-backend/auth/moving-to-production/#email).
- [Advanced Security Features (ASF)](https://docs.aws.amazon.com/cognito/latest/developerguide/cognito-user-pool-settings-advanced-security.html) must be enabled in your user pool.
- If account recovery is enabled in Cognito, the delivery method for recovery messages cannot be set to `Email only`
</Callout>


<Callout info>
Additional pricing applies for ASF. [Learn more about Amazon Cognito pricing](https://aws.amazon.com/cognito/pricing/)
</Callout>

### Enable EMAIL MFA during sign-up

You will need to pass `email` as a user attribute to enable email MFA for your users during sign-up. However, if the primary sign-in mechanism for your Cognito resource is already `email` (without enabling `username`), then you do not need to pass it as an attribute.

<InlineFilter filters={["angular", "javascript", "nextjs", "react", "vue"]}>
```ts
import { signUp } from 'aws-amplify/auth';

await signUp({
  username: "+15555555555",
  password: "hunter2",
  options: {
    userAttributes: {
      email: "hello@mycompany.com",
    },
  },
});
```
</InlineFilter>

<InlineFilter filters={["android"]}>

<BlockSwitcher>
<Block name="Java">

```java
ArrayList<AuthUserAttribute> attributes = new ArrayList<>();
attributes.add(new AuthUserAttribute(AuthUserAttributeKey.email(), "my@email.com"));
attributes.add(new AuthUserAttribute(AuthUserAttributeKey.phoneNumber(), "+15551234567"));

Amplify.Auth.signUp(
    "username",
    "Password123",
    AuthSignUpOptions.builder().userAttributes(attributes).build(),
    result -> Log.i("AuthQuickstart", result.toString()),
    error -> Log.e("AuthQuickstart", error.toString())
);
```

</Block>
<Block name="Kotlin - Callbacks">

```kotlin
val attrs = mapOf(
    AuthUserAttributeKey.email() to "my@email.com",
    AuthUserAttributeKey.phoneNumber() to "+15551234567"
)
val options = AuthSignUpOptions.builder()
    .userAttributes(attrs.map { AuthUserAttribute(it.key, it.value) })
    .build()
Amplify.Auth.signUp("username", "Password123", options,
    { Log.i("AuthQuickstart", "Sign up result = $it") },
    { Log.e("AuthQuickstart", "Sign up failed", it) }
)
```

</Block>
<Block name="Kotlin - Coroutines">

```kotlin
val attrs = mapOf(
    AuthUserAttributeKey.email() to "my@email.com",
    AuthUserAttributeKey.phoneNumber() to "+15551234567"
)
val options = AuthSignUpOptions.builder()
    .userAttributes(attrs.map { AuthUserAttribute(it.key, it.value) })
    .build()
try {
    val result = Amplify.Auth.signUp("username", "Password123", options)
    Log.i("AuthQuickstart", "Sign up OK: $result")
} catch (error: AuthException) {
    Log.e("AuthQuickstart", "Sign up failed", error)
}
```

</Block>
<Block name="RxJava">

```java
ArrayList<AuthUserAttribute> attributes = new ArrayList<>();
attributes.add(new AuthUserAttribute(AuthUserAttributeKey.email(), "my@email.com"));
attributes.add(new AuthUserAttribute(AuthUserAttributeKey.phoneNumber(), "+15551234567"));

RxAmplify.Auth.signUp(
    "username",
    "Password123",
    AuthSignUpOptions.builder().userAttributes(attributes).build())
    .subscribe(
        result -> Log.i("AuthQuickstart", result.toString()),
        error -> Log.e("AuthQuickstart", error.toString())
    );
```

</Block>
</BlockSwitcher>

</InlineFilter>

<InlineFilter filters={["flutter"]}>
```dart
Future<void> signUpWithEmailVerification(
  String username,
  String password,
) async {
  await Amplify.Auth.signUp(
    username: username,
    password: password,
    options: SignUpOptions(
      userAttributes: <AuthUserAttributeKey, String>{
        AuthUserAttributeKey.email: 'test@example.com',
        // ... if required
        AuthUserAttributeKey.phoneNumber: '+18885551234',
      },
    ),
  );
}
```
</InlineFilter>

<InlineFilter filters={["swift"]}>
```swift
func signUp(username: String, password: String, email: String, phonenumber: String) async {
    do {
        let signUpResult = try await Amplify.Auth.signUp(
            username: username,
            password: password,
            options: .init(userAttributes: [
                AuthUserAttribute(.email, value: email), 
                AuthUserAttribute(.phoneNumber, value: phonenumber)
            ])
        )
        if case let .confirmUser(deliveryDetails, _, userId) = signUpResult.nextStep {
            print("Delivery details \(String(describing: deliveryDetails)) for userId: \(String(describing: userId)))")
        } else {
            print("SignUp Complete")
        }
    } catch let error as AuthError {
        print("An error occurred while registering a user \(error)")
    } catch {
        print("Unexpected error: \(error)")
    }
}
```
</InlineFilter>

By default, you have to verify a user account after they sign up using the `confirmSignUp` API. Following the initial `signUp` request, a one-time passcode will be sent to the user's phone number or email, depending on your Amazon Cognito configuration.

<InlineFilter filters={["angular", "javascript", "nextjs", "react", "vue"]}>
```ts
import { confirmSignUp } from 'aws-amplify/auth';

await confirmSignUp({
  username: "+15555555555",
  confirmationCode: "123456",
})
```
</InlineFilter>

<InlineFilter filters={["android"]}>
<BlockSwitcher>

<Block name="Java">

```java
 try {
      Amplify.Auth.confirmSignUp(
             "username",
             "confirmation code",
             result -> Log.i("AuthQuickstart", "Confirm signUp result completed: " + result.isSignUpComplete()),
             error -> Log.e("AuthQuickstart", "An error occurred while confirming sign up: " + error)
      );
} catch (Exception error) {
   Log.e("AuthQuickstart", "unexpected error: " + error);
}
```
</Block>

<Block name="Kotlin - Callbacks">

```kotlin
 try {
      Amplify.Auth.confirmSignUp(
          "username",
          "confirmation code",
          { result ->
              Log.i("AuthQuickstart", "Confirm signUp result completed: ${result.isSignUpComplete}")
          }
      ) { error ->
          Log.e("AuthQuickstart", "An error occurred while confirming sign up: $error")
      }
} catch (error: Exception) {
    Log.e("AuthQuickstart", "unexpected error: $error")
}
```
</Block>

<Block name="Kotlin - Coroutines">

```kotlin
try {
     val result = Amplify.Auth.confirmSignUp(
         "username",
         "confirmation code"
     )
     Log.i("AuthQuickstart", "Confirm signUp result completed: ${result.isSignUpComplete}")
} catch (error: Exception) {
   Log.e("AuthQuickstart", "unexpected error: $error")
}
```
</Block>

<Block name="RxJava">

```java
RxAmplify.Auth.confirmSignUp(
        "username",
        "confirmation code").subscribe(
        result -> Log.i("AuthQuickstart", "Confirm signUp result completed: " + result.isSignUpComplete()),
        error -> Log.e("AuthQuickstart", "An error occurred while confirming sign up: " + error)
);
```
</Block>

</BlockSwitcher>
</InlineFilter>

<InlineFilter filters={["flutter"]}>
```dart
Future<void> confirmSignUpEmailVerification(
  String username,
  String otpCode,
) async {
  await Amplify.Auth.confirmSignUp(
    username: username,
    confirmationCode: otpCode,
  );
}
```
</InlineFilter>


<InlineFilter filters={["swift"]}>
```swift
func confirmSignUp(for username: String, with confirmationCode: String) async {
    do {
        let confirmSignUpResult = try await Amplify.Auth.confirmSignUp(
            for: username,
            confirmationCode: confirmationCode
        )
        print("Confirm sign up result completed: \(confirmSignUpResult.isSignUpComplete)")
    } catch let error as AuthError {
        print("An error occurred while confirming sign up \(error)")
    } catch {
        print("Unexpected error: \(error)")
    }
}
```
</InlineFilter>

### Manage EMAIL MFA during sign-in

After a user signs in, if they have MFA enabled for their account, a challenge will be issued that requires calling the `confirmSignIn` API with the user provided confirmation code sent to their email address.

If MFA is **ON** or enabled for the user, you must call `confirmSignIn` with the OTP sent to their email address.

<InlineFilter filters={["angular", "javascript", "nextjs", "react", "vue"]}>
```ts
import { confirmSignIn } from 'aws-amplify/auth';

await confirmSignIn({
  challengeResponse: "123456"
});
```
</InlineFilter>
<InlineFilter filters={["android"]}>
<BlockSwitcher>

<Block name="Java">

```java
try {
      Amplify.Auth.confirmSignIn(
            "confirmation code",
            result -> {
                if (result.isSignedIn()) {
                    Log.i("AuthQuickstart", "Confirm signIn succeeded");
                } else {
                    Log.i("AuthQuickstart", "Confirm sign in not complete. There might be additional steps: " + result.getNextStep());
                    // Switch on the next step to take appropriate actions.
                    // If `result.isSignedIn` is true, the next step
                    // is 'done', and the user is now signed in.
                }
            },
            error -> Log.e("AuthQuickstart", "Confirm sign in failed: " + error)
    );
} catch (Exception error) {
    Log.e("AuthQuickstart", "Unexpected error: " + error);
}
```
</Block>

<Block name="Kotlin - Callbacks">

```kotlin
try {
    Amplify.Auth.confirmSignIn(
          "confirmation code",
          { result ->
              if (result.isSignedIn) {
                  Log.i("AuthQuickstart","Confirm signIn succeeded")
              } else {
                  Log.i("AuthQuickstart", "Confirm sign in not complete. There might be additional steps: ${result.nextStep}")
                  // Switch on the next step to take appropriate actions.
                  // If `result.isSignedIn` is true, the next step
                  // is 'done', and the user is now signed in.
              }
          }
    ) { error -> Log.e("AuthQuickstart", "Confirm sign in failed: $error")}
} catch (error: Exception) {
    Log.e("AuthQuickstart", "Unexpected error: $error")
}
```
</Block>

<Block name="Kotlin - Coroutines">

```kotlin
try {
    val result = Amplify.Auth.confirmSignIn(
        "confirmation code"
    )
    if (result.isSignedIn) {
        Log.i("AuthQuickstart", "Confirm signIn succeeded")
    } else {
        Log.i("AuthQuickstart", "Confirm sign in not complete. There might be additional steps: ${result.nextStep}"
        )
        // Switch on the next step to take appropriate actions.
        // If `result.isSignedIn` is true, the next step
        // is 'done', and the user is now signed in.
    }
} catch (error: Exception) {
    Log.e("AuthQuickstart", "Unexpected error: $error")
}
```
</Block>

<Block name="RxJava">

```java

RxAmplify.Auth.confirmSignIn(
                "confirmation code").subscribe(
                result -> {
                    if (result.isSignedIn()) {
                        Log.i("AuthQuickstart", "Confirm signIn succeeded");
                    } else {
                        Log.i("AuthQuickstart", "Confirm sign in not complete. There might be additional steps: " + result.getNextStep());
                        // Switch on the next step to take appropriate actions.
                        // If `result.isSignedIn` is true, the next step
                        // is 'done', and the user is now signed in.
                    }
                },
                error -> Log.e("AuthQuickstart", "Confirm sign in failed: " + error)
        );
```
</Block>

</BlockSwitcher>
</InlineFilter>

<InlineFilter filters={["flutter"]}>
```dart
Future<void> confirmSignInEmailVerification(String otpCode) async {
  await Amplify.Auth.confirmSignIn(
    confirmationValue: otpCode,
  );
}
```
</InlineFilter>

<InlineFilter filters={["swift"]}>
```swift
func confirmSignIn() async {
    do {
        let signInResult = try await Amplify.Auth.confirmSignIn(
            challengeResponse: "<confirmation code received via email>")
        print("Confirm sign in succeeded. Next step: \(signInResult.nextStep)")
    } catch let error as AuthError {
        print("Confirm sign in failed \(error)")
    } catch {
        print("Unexpected error: \(error)")
    }
}
```
</InlineFilter>

After a user has been signed in, call `updateMFAPreference` to record the MFA type as enabled for the user and optionally set it as preferred so that subsequent logins default to using this MFA type.

<InlineFilter filters={["angular", "javascript", "nextjs", "react", "vue"]}>
```ts
import { updateMFAPreference } from 'aws-amplify/auth';

await updateMFAPreference({ email: 'PREFERRED' });
```
</InlineFilter>

<InlineFilter filters={['android']}>
<BlockSwitcher>
<Block name="Java">

```java
if (Amplify.Auth.getPlugin("awsCognitoAuthPlugin") instanceof AWSCognitoAuthPlugin) {
            AWSCognitoAuthPlugin plugin = (AWSCognitoAuthPlugin) Amplify.Auth.getPlugin("awsCognitoAuthPlugin");
            plugin.updateMFAPreference(
                    MFAPreference.DISABLED, // SMS Preference
                    MFAPreference.DISABLED, // TOTP Preference
                    MFAPreference.PREFERRED, // Email Preference
                    () -> Log.i("AuthQuickstart", "MFA preference updated successfully"),
                    e -> Log.e("AuthQuickstart", "Failed to update MFA preference.", e)
            );
        }
```

</Block>
<Block name="Kotlin">

```kotlin
if (Amplify.Auth.getPlugin("awsCognitoAuthPlugin") is AWSCognitoAuthPlugin) {
    val plugin = Amplify.Auth.getPlugin("awsCognitoAuthPlugin") as? AWSCognitoAuthPlugin
    plugin?.updateMFAPreference(
            MFAPreference.DISABLED, // SMS Preference
            MFAPreference.DISABLED, // TOTP Preference
            MFAPreference.PREFERRED, // Email Preference
        { Log.i("AuthQuickstart", "MFA preference updated successfully" ) },
        { e: AuthException? -> Log.e("AuthQuickstart", "Failed to update MFA preference", e) }
    )
}
```

</Block>
</BlockSwitcher>

</InlineFilter>

<InlineFilter filters={["flutter"]}>
```dart
Future<void> updateMfaPreferences() async {
  final cognitoPlugin = Amplify.Auth.getPlugin(AmplifyAuthCognito.pluginKey);

  await cognitoPlugin.updateMfaPreference(
    email: MfaPreference.enabled, // or .preferred
  );
}
```
</InlineFilter>

<InlineFilter filters={["swift"]}>
```swift
func updateMFAPreferences() async throws {
    let authCognitoPlugin = try Amplify.Auth.getPlugin(
        for: "awsCognitoAuthPlugin") as? AWSCognitoAuthPlugin

    let emailMfaPreference: MFAPreference = .preferred

    try await authCognitoPlugin?.updateMFAPreference(
        email: emailMfaPreference)
}
```
</InlineFilter>

## Set up a user's preferred MFA method

Depending on your user pool configuration, it's possible that multiple MFA options may be available to a given user. In order to avoid requiring your users to select an MFA method each time they sign-in to your application, Amplify provides two utility APIs to manage an individual user's MFA preferences.

### Fetch the current user's MFA preferences

Invoke the following API to get the current MFA preference and enabled MFA types, if any, for the current user.

<InlineFilter filters={["angular", "javascript", "nextjs", "react", "vue"]}>
```ts
import { fetchMFAPreference } from 'aws-amplify/auth';

const { enabled, preferred } = await fetchMFAPreference();
```
</InlineFilter>

<InlineFilter filters={["android"]}>
<BlockSwitcher>
<Block name="Java">

```java
if (Amplify.Auth.getPlugin("awsCognitoAuthPlugin") instanceof AWSCognitoAuthPlugin) {
    AWSCognitoAuthPlugin plugin = (AWSCognitoAuthPlugin) Amplify.Auth.getPlugin("awsCognitoAuthPlugin");
    plugin.fetchMFAPreference(
        preference -> Log.i(
            "AuthQuickStart",
            "Fetched MFA preference, enabled: " + preference.getEnabled() + ", preferred: " + preference.getPreferred()
        ),
        e -> Log.e("AuthQuickStart", "Failed to fetch MFA preference.", e)
    );
}
```

</Block>
<Block name="Kotlin">

```kotlin
val cognitoAuthPlugin = Amplify.Auth.getPlugin("awsCognitoAuthPlugin") as? AWSCognitoAuthPlugin
cognitoAuthPlugin?.fetchMFAPreference(
    { Log.d("AuthQuickStart", "Fetched MFA preference, enabled: ${it.enabled}, preferred: ${it.preferred}") },
    { Log.e("AuthQuickStart", "Failed to fetch MFA preference.", it) }
)
```

</Block>
</BlockSwitcher>
</InlineFilter>

<InlineFilter filters={["flutter"]}>
```dart
Future<void> getCurrentMfaPreference() async {
  final cognitoPlugin = Amplify.Auth.getPlugin(AmplifyAuthCognito.pluginKey);

  final currentPreference = await cognitoPlugin.fetchMfaPreference();
  safePrint('Enabled MFA types for user: ${currentPreference.enabled}');
  safePrint('Preferred MFA type for user: ${currentPreference.preferred}');
}
```
</InlineFilter>

<InlineFilter filters={["swift"]}>
```swift
func getMFAPreferences() async throws {
    let authCognitoPlugin = try Amplify.Auth.getPlugin(
        for: "awsCognitoAuthPlugin") as? AWSCognitoAuthPlugin

    let result = try await authCognitoPlugin?.fetchMFAPreference()

    print("Enabled MFA types: \(result?.enabled)")
    print("Preferred MFA type: \(result?.preferred)")
}
```
</InlineFilter>

### Update the current user's MFA preferences

Invoke the following API to update the MFA preference for the current user.

<Callout warning>

Only one MFA method can be marked as preferred at a time. If the user has multiple MFA methods enabled and tries to mark more than one MFA method as preferred, the API will throw an error.

</Callout>

<InlineFilter filters={["angular", "javascript", "nextjs", "react", "vue"]}>
```ts
import { updateMFAPreference } from 'aws-amplify/auth';

await updateMFAPreference({ sms: 'ENABLED', totp: 'PREFERRED' });
```
</InlineFilter>

<InlineFilter filters={["android"]}>
<BlockSwitcher>
<Block name="Java">

```java
if (Amplify.Auth.getPlugin("awsCognitoAuthPlugin") instanceof AWSCognitoAuthPlugin) {
    AWSCognitoAuthPlugin plugin = (AWSCognitoAuthPlugin) Amplify.Auth.getPlugin("awsCognitoAuthPlugin");
    plugin.updateMFAPreference(
        MFAPreference.DISABLED, // SMS Preference
        MFAPreference.PREFERRED, // TOTP Preference
        null // Email Preference
        () -> Log.i( "AuthQuickStart", "Preference updated successfully"),
        e -> Log.e("AuthQuickStart", "Failed to update MFA preference.", e)
    );
}
```

</Block>
<Block name="Kotlin - Callbacks">

```kotlin
val cognitoAuthPlugin = Amplify.Auth.getPlugin("awsCognitoAuthPlugin") as? AWSCognitoAuthPlugin
cognitoAuthPlugin?.updateMFAPreference(
    MFAPreference.DISABLED, // SMS Preference
    MFAPreference.PREFERRED, // TOTP Preference
    null, // Email Preference
    { Log.d("AuthQuickStart", "Preference updated successfully") },
    { Log.e("AuthQuickStart", "Failed to update MFA preference.", it) }
)
```

</Block>

</BlockSwitcher>
</InlineFilter>

<InlineFilter filters={["flutter"]}>
```dart
Future<void> updateMfaPreferences() async {
  final cognitoPlugin = Amplify.Auth.getPlugin(AmplifyAuthCognito.pluginKey);

  await cognitoPlugin.updateMfaPreference(
    sms: MfaPreference.enabled,
    totp: MfaPreference.preferred,
  );
}
```
</InlineFilter>

<InlineFilter filters={["swift"]}>
```swift
func updateMFAPreferences() async throws {
    let authCognitoPlugin = try Amplify.Auth.getPlugin(
        for: "awsCognitoAuthPlugin") as? AWSCognitoAuthPlugin

    let smsMfaPreference: MFAPreference = .enabled
    let totpMfaPreference: MFAPreference = .preferred

    try await authCognitoPlugin?.updateMFAPreference(
        sms: smsMfaPreference,
        totp: totpMfaPreference)
}
```
</InlineFilter>

## Remember a device

Remembering a device is useful in conjunction with MFA because it allows the second factor requirement to be automatically met when your user signs in on that device and reduces friction in their sign-in experience. By default, this feature is turned off.

<Callout info>

**Note:** The [device tracking and remembering](https://aws.amazon.com/blogs/mobile/tracking-and-remembering-devices-using-amazon-cognito-your-user-pools/) features are not available if any of the following conditions are met:

- the federated OAuth flow with Cognito User Pools or Hosted UI is used, or
- when the `signIn` API uses the `USER_PASSWORD_AUTH` as the `authFlowType`.

</Callout>

### Configure device tracking

You can configure device tracking with `deviceTracking` construct.

```ts title="amplify/backend.ts"
import { defineBackend } from '@aws-amplify/backend';
import { auth } from './auth/resource';
import { data } from './data/resource';

const backend = defineBackend({
  auth,
  data
});

const { cfnUserPool } = backend.auth.resources.cfnResources;

cfnUserPool.addPropertyOverride('DeviceConfiguration', {
  ChallengeRequiredOnNewDevice: true,
  DeviceOnlyRememberedOnUserPrompt: false
});
```

<Accordion title='Understand key terms used for tracking devices' headingLevel='4' eyebrow='Learn more'>

There are differences to keep in mind when working with remembered, forgotten, and tracked devices.

- **Tracked:** Every time the user signs in with a new device, the client is given the device key at the end of a successful authentication event. We use this device key to generate a salt and password verifier which is used to call the `ConfirmDevice` API. At this point, the device is considered to be "tracked". Once the device is in a tracked state, you can use the Amazon Cognito console to see the time it started to be tracked, last authentication time, and other information about that device.
- **Remembered:** Remembered devices are also tracked. During user authentication, the device key and secret pair assigned to a remembered device is used to authenticate the device to verify that it is the same device that the user previously used to sign in.
- **Not Remembered:** A not-remembered device is a tracked device where Cognito has been configured to require users to "Opt-in" to remember a device but the user has chosen not to remember the device. This use case is for users signing into their application from a device that they don't own.
- **Forgotten:** In the event that you no longer want to remember or track devices, you can use the `forgetDevice()` API to remove devices from being both remembered and tracked.

</Accordion>

## Next steps

- [Learn how to sign-up with MFA enabled](/[platform]/build-a-backend/auth/connect-your-frontend/sign-in/#with-multi-factor-auth-enabled)
- [Learn how to manage user devices](/[platform]/build-a-backend/auth/manage-users/manage-devices/)


Contents of build-a-backend_auth_concepts_passwordless_index.txt:
import { getCustomStaticPath } from '@/utils/getCustomStaticPath';

export const meta = {
  title: 'Passwordless',
  description: 'Learn how to configure passwordless sign-in flows',
  platforms: [
    'android',
    'angular',
    'javascript',
    'nextjs',
    'react',
    'react-native',
    'swift',
    'vue'
  ]
};

export function getStaticPaths() {
  return getCustomStaticPath(meta.platforms);
}

export function getStaticProps() {
  return {
    props: {
      meta
    }
  };
}

Amplify supports the use of passwordless authentication flows using the following methods:

- [SMS-based one-time password (SMS OTP)](#sms-otp)
- [Email-based one-time password (Email OTP)](#email-otp)
- [WebAuthn passkey](#webauthn-passkey)

Passwordless authentication removes the security risks and user friction associated with traditional passwords.
{/* add more color */}

<Callout warning>

**Warning:** Passwordless configuration is currently not available in `defineAuth`. We are currently working towards enabling support for passwordless configurations. [Visit the GitHub issue to track the progress](https://github.com/aws-amplify/amplify-backend/issues/2276)

</Callout>

Learn how to implement passwordless sign-in flows by [overriding the Cognito UserPool to enable the sign-in methods below](/[platform]/build-a-backend/auth/modify-resources-with-cdk/#override-cognito-userpool-to-enable-passwordless-sign-in-methods).

{/* need a section about what a "preferred" factor is */}

## SMS OTP

SMS-based authentication uses phone numbers as the identifier and text messages as the verification channel. At a high level end users will perform the following steps to authenticate:

1. User enters their phone number to sign up/sign in
2. They receive a text message with a time-limited code
3. After the user enters their code they are authenticated

{/* quick blurb of basic usage */}
<InlineFilter filters={["angular", "javascript", "nextjs", "react", "react-native", "vue"]}>

{/*  */}

</InlineFilter>
<InlineFilter filters={["android"]}>

{/*  */}

</InlineFilter>

<InlineFilter filters={["swift"]}>

{/*  */}

</InlineFilter>

<Callout info>

SMS-based one-time password requires your Amazon Cognito user pool to be configured to use Amazon Simple Notification Service (SNS) to send text messages. [Learn how to configure your auth resource with SNS](/[platform]/build-a-backend/auth/moving-to-production/#sms).

{/* NOTE the linked page will need to be updated with sns instructions */}

</Callout>

[Learn more about using SMS OTP in your application code](/[platform]/build-a-backend/auth/connect-your-frontend/sign-in/#sms-otp).

## Email OTP

Email-based authentication uses email addresses for identification and verification. At a high level end users will perform the following steps to authenticate:

1. User enters their email address to sign up/sign in
2. They receive an email message with a time-limited code
3. After the users enters their code they are authenticated

{/* quick blurb of basic usage */}
<InlineFilter filters={["angular", "javascript", "nextjs", "react", "react-native", "vue"]}>

{/*  */}

</InlineFilter>
<InlineFilter filters={["android"]}>

{/*  */}

</InlineFilter>
<InlineFilter filters={["swift"]}>

{/*  */}

</InlineFilter>

<Callout info>

Email-based one-time password requires your Amazon Cognito user pool to be configured to use Amazon Simple Email Service (SES) to send email messages. [Learn how to configure your auth resource with SES](/[platform]/build-a-backend/auth/moving-to-production/#email).

</Callout>

[Learn more about using email OTP in your application code](/[platform]/build-a-backend/auth/connect-your-frontend/sign-in/#email-otp).

## WebAuthn Passkey

WebAuthn uses biometrics or security keys for authentication, leveraging device-specific security features. At a high level end users will perform the following steps to authenticate:

1. User chooses to register a passkey
2. Their device prompts for biometric/security key verification
3. For future logins, they'll authenticate using the same method

{/* quick blurb of basic usage */}
<InlineFilter filters={["angular", "javascript", "nextjs", "react", "react-native", "vue"]}>

{/*  */}

</InlineFilter>
<InlineFilter filters={["android"]}>

{/*  */}

</InlineFilter>
<InlineFilter filters={["swift"]}>

{/*  */}

</InlineFilter>

[Learn more about using WebAuthn passkeys in your application code](/[platform]/build-a-backend/auth/connect-your-frontend/sign-in/#webauthn-passkeys).

### Managing credentials

{/* quick blurb then segue over to "manage WebAuthn credentials" page */}

[Learn more about managing WebAuthn credentials](/[platform]/build-a-backend/auth/manage-users/manage-webauthn-credentials).


Contents of build-a-backend_auth_concepts_phone_index.txt:
import { getCustomStaticPath } from '@/utils/getCustomStaticPath';

export const meta = {
  title: 'Phone',
  description: 'Learn more about what Amplify Auth provisions and supports',
  platforms: [
    'android',
    'angular',
    'flutter',
    'javascript',
    'nextjs',
    'react',
    'react-native',
    'swift',
    'vue'
  ]
};

export function getStaticPaths() {
  return getCustomStaticPath(meta.platforms);
}

export function getStaticProps() {
  return {
    props: {
      meta
    }
  };
}

By default Amplify Auth is scaffolded with `email` as the default method for user sign-in, however this can be changed or extended to also allow your users to sign in using their phone number.

```ts title="amplify/auth/resource.ts"
import { defineAuth } from "@aws-amplify/backend"

export const auth = defineAuth({
  loginWith: {
    // highlight-next-line
    phone: true,
  },
})
```

This will configure the `phone_number` attribute that is required for sign-up and cannot be changed.

{/* how to use client-side */}
{/* callout for customizing SMS messages */}

## Next steps

- [Learn how to use the `signIn` API](/[platform]/build-a-backend/auth/connect-your-frontend/sign-in/)
- [Learn how to configure your account for production SMS workloads](/[platform]/build-a-backend/auth/moving-to-production/)


Contents of build-a-backend_auth_concepts_tokens-and-credentials_index.txt:
import { getCustomStaticPath } from '@/utils/getCustomStaticPath';

export const meta = {
  title: 'Tokens and credentials',
  description: 'Learn about how tokens and credentials are used in Amplify applications',
  platforms: [
    'android',
    'angular',
    'flutter',
    'javascript',
    'nextjs',
    'react',
    'react-native',
    'swift',
    'vue'
  ]
};

export function getStaticPaths() {
  return getCustomStaticPath(meta.platforms);
}

export function getStaticProps() {
  return {
    props: {
      meta
    }
  };
}

Amplify Auth interacts with its underlying [Amazon Cognito user pool](https://docs.aws.amazon.com/cognito/latest/developerguide/cognito-user-identity-pools.html) as an OpenID Connect (OIDC) provider. When users successfully authenticate you receive OIDC-compliant JSON web tokens (JWT). These tokens are used to _identity_ your user, and _access_ resources.

[**Access tokens**](https://docs.aws.amazon.com/cognito/latest/developerguide/amazon-cognito-user-pools-using-the-access-token.html) are used to verify the bearer of the token (i.e. the Cognito user) is authorized to perform an action against a resource. Below is an example payload of an access token vended by Cognito:

```json
{
  "sub": "54288468-e051-706d-a73f-03892273d7e9",
  "iss": "https://cognito-idp.us-east-1.amazonaws.com/us-east-1_yoKn9s4Tq",
  "client_id": "1sg675g08g6g0e9f64grv9n5sk",
  "origin_jti": "0eadb994-a6e0-419e-b309-a7a0d522d72f",
  "event_id": "b180897a-181c-4f73-94bb-a2946e8b4ef1",
  "token_use": "access",
  "scope": "aws.cognito.signin.user.admin",
  "auth_time": 1714241873,
  "exp": 1714245473,
  "iat": 1714241873,
  "jti": "57f10a4d-a1f2-453b-8672-d1cfa8187047",
  "username": "54288468-e051-706d-a73f-03892273d7e9"
}
```

[**ID tokens**](https://docs.aws.amazon.com/cognito/latest/developerguide/amazon-cognito-user-pools-using-the-id-token.html) are intended to be used within your frontend application only. This token contains personally identifiable information (PII) and should not be used to authorize access against a resource. Below is an example of an ID token with the default Amplify Auth configuration of email and password auth.

```json
{
  "sub": "54288468-e051-706d-a73f-03892273d7e9",
  "email_verified": true,
  "iss": "https://cognito-idp.us-east-1.amazonaws.com/us-east-1_yoKn9s4Tq",
  "cognito:username": "54288468-e051-706d-a73f-03892273d7e9",
  "origin_jti": "0eadb994-a6e0-419e-b309-a7a0d522d72f",
  "aud": "1sg675g08g6g0e9f64grv9n5sk",
  "event_id": "b180897a-181c-4f73-94bb-a2946e8b4ef1",
  "token_use": "id",
  "auth_time": 1714241873,
  "exp": 1714245473,
  "iat": 1714241873,
  "jti": "bb69af10-3ce0-47c2-8d8d-5bdc8630ab58",
  "email": "hello@mycompany.com"
}
```

When additional user attributes are specified for Amplify Auth, their values will be found in the ID token. For example, if a `nickname` attribute is requested it will be available on the ID token with the `nickname` claim:

```diff
{
  "sub": "54288468-e051-706d-a73f-03892273d7e9",
  "email_verified": true,
  "iss": "https://cognito-idp.us-east-1.amazonaws.com/us-east-1_yoKn9s4Tq",
  "cognito:username": "54288468-e051-706d-a73f-03892273d7e9",
  "origin_jti": "0eadb994-a6e0-419e-b309-a7a0d522d72f",
  "aud": "1sg675g08g6g0e9f64grv9n5sk",
  "event_id": "b180897a-181c-4f73-94bb-a2946e8b4ef1",
  "token_use": "id",
  "auth_time": 1714241873,
+ "nickname": "hello",
  "exp": 1714245473,
  "iat": 1714241873,
  "jti": "bb69af10-3ce0-47c2-8d8d-5bdc8630ab58",
  "email": "hello@mycompany.com"
}
```

Conversely, user pool group claims are found in both the access token and ID token on the `cognito:groups` claim:

```json
{
  "sub": "54288468-e051-706d-a73f-03892273d7e9",
  "email_verified": true,
  "iss": "https://cognito-idp.us-east-1.amazonaws.com/us-east-1_yoKn9s4Tq",
  "cognito:username": "54288468-e051-706d-a73f-03892273d7e9",
  "cognito:groups": ["ADMINS"],
  "origin_jti": "0eadb994-a6e0-419e-b309-a7a0d522d72f",
  "aud": "1sg675g08g6g0e9f64grv9n5sk",
  "event_id": "b180897a-181c-4f73-94bb-a2946e8b4ef1",
  "token_use": "id",
  "auth_time": 1714241873,
  "nickname": "hello",
  "exp": 1714245473,
  "iat": 1714241873,
  "jti": "bb69af10-3ce0-47c2-8d8d-5bdc8630ab58",
  "email": "hello@mycompany.com"
}
```

Visit the [AWS documentation for using tokens with Cognito user pools](https://docs.aws.amazon.com/cognito/latest/developerguide/amazon-cognito-user-pools-using-tokens-with-identity-providers.html) to learn more about tokens, how they're used with Cognito, and their intended usage.

<InlineFilter filters={["angular", "javascript", "nextjs", "react", "react-native", "vue"]}>

## Understand token management options

Token keys are automatically rotated for you for added security but you can update how they are stored, customize the refresh rate and expiration times, and revoke tokens on sign-out.

### Update your token-saving mechanism

You can update the storage mechanism to choose where and how tokens are persisted in your application. The default option is `localStorage`. Additionally, you can import the `sessionStorage`, `sharedInMemoryStorage` or `CookieStorage` options as well.

If you want to customize your own mechanism, you can import the `KeyValueStorageInterface` interface and implement it in your own class.

#### Browser Local Storage

In Amplify the `localStorage` is the default storage mechanism. It saves the tokens in the browser's `localStorage`. This local storage will persist across browser sessions and tabs. You can explicitly set to this storage by calling:

```ts
import { cognitoUserPoolsTokenProvider } from 'aws-amplify/auth/cognito';
import { defaultStorage } from 'aws-amplify/utils';

cognitoUserPoolsTokenProvider.setKeyValueStorage(defaultStorage);
```

#### Cookie Storage

`CookieStorage` saves the tokens in the browser's `Cookies`. The cookies will persist across browser sessions and tabs. You can explicitly set to this storage by calling:

```ts
import { cognitoUserPoolsTokenProvider } from 'aws-amplify/auth/cognito';
import { CookieStorage } from 'aws-amplify/utils';

cognitoUserPoolsTokenProvider.setKeyValueStorage(new CookieStorage());
```

#### Browser Session Storage

`sessionStorage` saves the tokens in the browser's `sessionStorage` and these tokens will clear when a tab is closed. The benefit to this storage mechanism is that the session only lasts as long as the browser is open and you can sign out users when they close the tab. You can update to this storage by calling:

```ts
import { cognitoUserPoolsTokenProvider } from 'aws-amplify/auth/cognito';
import { sessionStorage } from 'aws-amplify/utils';

cognitoUserPoolsTokenProvider.setKeyValueStorage(sessionStorage);
```

#### Custom Storage

You can implement your own custom storage mechanism by creating a class that implements the storage interface. Here is an example that uses memory storage:

```ts
import { cognitoUserPoolsTokenProvider } from 'aws-amplify/auth/cognito';
import { KeyValueStorageInterface } from 'aws-amplify/utils';

class MyCustomStorage implements KeyValueStorageInterface {
  storageObject: Record<string, string> = {};
  async setItem(key: string, value: string): Promise<void> {
    this.storageObject[key] = value;
  }
  async getItem(key: string): Promise<string | null> {
    return this.storageObject[key];
  }
  async removeItem(key: string): Promise<void> {
    delete this.storageObject[key];
  }
  async clear(): Promise<void> {
    this.storageObject = {};
  }
}

cognitoUserPoolsTokenProvider.setKeyValueStorage(new MyCustomStorage());
```

When you get the current user session, the tokens will be saved in your custom location.

</InlineFilter>
<InlineFilter filters={['flutter']}>

Amplify Auth persists authentication-related information to make it available to other Amplify categories and to your application.

Amplify Flutter securely manages credentials and user identity information. You do not need to store, refresh, or delete credentials yourself. Amplify Flutter stores auth data on the device using platform capabilities such as [Keychain Services](https://developer.apple.com/documentation/security/keychain_services/) on iOS and macOS and [EncryptedSharedPreferences](https://developer.android.com/reference/androidx/security/crypto/EncryptedSharedPreferences) on Android.

<Callout info>

Amplify will refresh the [access token](https://docs.aws.amazon.com/cognito/latest/developerguide/amazon-cognito-user-pools-using-the-access-token.html) and [ID token](https://docs.aws.amazon.com/cognito/latest/developerguide/amazon-cognito-user-pools-using-the-id-token.html) as long as the [refresh token](https://docs.aws.amazon.com/cognito/latest/developerguide/amazon-cognito-user-pools-using-the-refresh-token.html) is valid. Once the refresh token expires, the user will need to reauthenticate to obtain a new one.

</Callout>

Some platform specific option can be customized with the out of the box options. In the example below, credentials will be stored in-memory on Web instead of the default behavior of using browser storage.

```dart
await Amplify.addPlugin(
  AmplifyAuthCognito(
    secureStorageFactory: AmplifySecureStorage.factoryFrom(
      webOptions: WebSecureStorageOptions(
        persistenceOption: WebPersistenceOption.inMemory,
      ),
    ),
  ),
);
```

If you would like further customization, you can provide your own factory for creating `SecureStorageInterface` instances to `AmplifyAuthCognito`. The example below shows the use of a custom implementation that stores data in-memory on all platforms.

```dart
await Amplify.addPlugin(
  AmplifyAuthCognito(secureStorageFactory: InMemoryStorage.new),
);
```

```dart
class InMemoryStorage implements SecureStorageInterface {
  InMemoryStorage(this.scope);

  /// The scope of the item being stored.
  ///
  /// This can be used as a namespace for stored items.
  final AmplifySecureStorageScope scope;

  static final Map<String, String> _data = {};

  @override
  void write({required String key, required String value}) {
    _data['${scope.name}.$key'] = value;
  }

  @override
  String? read({required String key}) {
    return _data['${scope.name}.$key'];
  }

  @override
  void delete({required String key}) {
    _data.remove('${scope.name}.$key');
  }
}
```
</InlineFilter>

## Token Revocation

<InlineFilter filters={["angular", "javascript", "nextjs", "react", "vue", "android"]}>

Token revocation is enabled automatically in Amplify Auth. To revoke tokens you can set up global sign-out with `signOut({ global: true })` to globally sign out your user from all of their devices.

</InlineFilter>
<InlineFilter filters={["flutter"]}>

Token revocation is enabled automatically in Amplify Auth. To revoke tokens you can invoke `await Amplify.Auth.signOut(options: const signOutOptions(globalSignOut: true))` to globally sign out your user from all of their devices.

</InlineFilter>
<InlineFilter filters={["swift"]}>

Token revocation is enabled automatically in Amplify Auth. To revoke tokens you can invoke `await Amplify.Auth.signOut(options: .init(globalSignOut: true))` to globally sign out your user from all of their devices.

</InlineFilter>

## Next steps

<InlineFilter filters={["javascript","nextjs","angular","vue","react","react-native"]}>

- [Learn how to customize the ID token](/[platform]/build-a-backend/functions/examples/override-token/)
- [Learn how to bring your own tokens from external providers](/[platform]/build-a-backend/auth/advanced-workflows/#custom-token-providers)
- [Learn how to use cookie storage server-side](/[platform]/build-a-backend/server-side-rendering/#configure-amplify-library-for-client-side-usage)

</InlineFilter>
<InlineFilter filters={["android", "swift", "flutter"]}>

- [Learn how to customize the ID token](/[platform]/build-a-backend/functions/examples/override-token/)
- [Learn how to bring your own tokens from external providers](/[platform]/build-a-backend/auth/advanced-workflows/#custom-token-providers)

</InlineFilter>


Contents of build-a-backend_auth_concepts_user-attributes_index.txt:
import { getCustomStaticPath } from '@/utils/getCustomStaticPath';

export const meta = {
  title: 'User attributes',
  description: 'Learn more about what Amplify Auth provisions and supports',
  platforms: [
    'android',
    'angular',
    'flutter',
    'javascript',
    'nextjs',
    'react',
    'react-native',
    'swift',
    'vue'
  ]
};

export function getStaticPaths() {
  return getCustomStaticPath(meta.platforms);
}

export function getStaticProps() {
  return {
    props: {
      meta
    }
  };
}

Amplify Auth stores user profile information in user attributes. When the default method for user sign-in, Amplify Auth will automatically configure an `email` or `phoneNumber` attribute that is required for sign-in.

{/* what standard attributes are */}
To extend a user profile beyond the default `email` or `phoneNumber` attribute that is automatically configured when specified in your auth resource's `loginWith` property, you can configure attributes with the `userAttributes` property:

<Callout warning>

**Warning**: After you create your auth resource, you cannot switch an attribute between required and not required.

</Callout>

```ts title="amplify/auth/resource.ts"
import { defineAuth } from "@aws-amplify/backend"

export const auth = defineAuth({
  loginWith: {
    // this configures a required "email" attribute
    email: true,
  },
  // highlight-start
  userAttributes: {
    // specify a "birthdate" attribute
    birthdate: {
      mutable: true,
      required: false,
    }
  },
  // highlight-end
})
```

## Standard attributes

User attributes are defined as [Cognito Standard Attributes](https://docs.aws.amazon.com/cognito/latest/developerguide/user-pool-settings-attributes.html#cognito-user-pools-standard-attributes). Attributes can be configured to be _required_ for user sign-up in addition to whether the values are _mutable_. When configuring your resource to allow your users to login with `email`, an email must be specified for user sign-up and cannot be changed later. However additional attributes can be configured to be optional, and mutable after sign-up.

## Custom attributes

In addition to the provided standard attributes, you can configure [Custom Attributes](https://docs.aws.amazon.com/cognito/latest/developerguide/user-pool-settings-attributes.html#user-pool-settings-custom-attributes). These are attributes that are typically unique to your use case, such as a tenant ID or a user's display name. Custom attributes are identified by the `custom:` prefix:

```ts title="amplify/auth/resource.ts"
import { defineAuth } from "@aws-amplify/backend"

export const auth = defineAuth({
  loginWith: {
    // this configures a required "email" attribute
    email: true,
  },
  userAttributes: {
    // highlight-start
    "custom:display_name": {
      dataType: "String",
      mutable: true,
      maxLen: 16,
      minLen: 1,
    },
    "custom:favorite_number": {
      dataType: "Number",
      mutable: true,
      min: 1,
      max: 100,
    },
    "custom:is_beta_user": {
      dataType: "Boolean",
      mutable: true,
    },
    "custom:started_free_trial": {
      dataType: "DateTime",
      mutable: true,
    },
    // highlight-end
  },
})
```

Unlike standard attributes, custom attributes cannot natively be required for sign-up, however can be codified to require some value by [validating user attributes upon sign-up with a pre sign-up trigger](/[platform]/build-a-backend/functions/examples/user-attribute-validation/).

Custom attributes can also be configured with specific data types. The following data types are supported:

- `String`
- `Number`
- `Boolean`
- `DateTime`

Shown in the snippet above, `String` and `Number` can be assigned minimum and maximum constraints. This is useful to defer simple validations to the underlying service, although does not extend to complex validations such as matching against a regular expression.

## Next steps

- [Learn how attributes are surfaced to tokens](/[platform]/build-a-backend/auth/concepts/tokens-and-credentials/)
- [Learn how to manage your user attributes](/[platform]/build-a-backend/auth/connect-your-frontend/manage-user-attributes)


Contents of build-a-backend_auth_concepts_user-groups_index.txt:
import { getCustomStaticPath } from '@/utils/getCustomStaticPath';

export const meta = {
  title: 'User groups',
  description: 'Learn more about what Amplify Auth provisions and supports',
  platforms: [
    // 'android',
    'angular',
    // 'flutter',
    'javascript',
    'nextjs',
    'react',
    // 'react-native',
    // 'swift',
    'vue'
  ]
};

export function getStaticPaths() {
  return getCustomStaticPath(meta.platforms);
}

export function getStaticProps() {
  return {
    props: {
      meta
    }
  };
}

Amplify Auth provides a mechanism that allows you to group users. Assigning users to groups enable you to customize access for a collection of users, or leverage for auditing purposes. For example, only "ADMINS" users are permitted to delete posts from a bulletin, or only "EDITORS" are permitted to modify posts in a "draft" state. To get started with groups, configure the `groups` property:

```ts title="amplify/auth/resource.ts"
import { defineAuth } from "@aws-amplify/backend"

export const auth = defineAuth({
  loginWith: {
    email: true,
  },
  // highlight-start
  groups: ["ADMINS", "EDITORS"],
  // highlight-end
})
```

<Callout>

**Note:** There are a few [limitations with groups](https://docs.aws.amazon.com/cognito/latest/developerguide/cognito-user-pools-user-groups.html#user-pool-user-groups-limitations), including a limit of 10,000 groups per user pool.

</Callout>

## Defining access

Amplify resources enable you to define access for groups using common language. For example, you can use `allow.groups` in data:

```ts title="amplify/data/resource.ts"
import { type ClientSchema, a, defineData } from "@aws-amplify/backend"

const schema = a.schema({
  Article: a.model({}).authorization(allow => [
    allow.groups(["EDITORS"]).to(["read", "update"])
  ])
})

// ...
```

Or in storage:

```ts title="amplify/storage/articles/resource.ts"
import { defineStorage } from "@aws-amplify/backend"

export const storage = defineStorage({
  name: "articles",
  access: (allow) => ({
    "drafts/*": [allow.groups(["EDITORS"]).to(["read", "write"])],
  }),
})
```

By defining access with groups, Amplify configures authorization rules to read from the current user's groups. User pool groups are available as a claim in the user's ID token and access token as `cognito:groups`. Requests can be made to secure resources using the access token and validated against this claim to permit action on the resource.

## Group roles

Each Cognito user pool group is assigned an [IAM role](https://aws.amazon.com/iam/features/manage-roles/). IAM roles can be modified to extend access to other AWS resources. Roles can be accessed from your backend on the `role` property of your group:

```ts title="amplify/backend.ts"
import { defineBackend } from '@aws-amplify/backend';
import { auth } from './auth/resource';
import { data } from './data/resource';

/**
 * @see https://docs.amplify.aws/react/build-a-backend/ to add storage, functions, and more
 */
const backend = defineBackend({
  auth,
  data,
});

// highlight-start
const { groups } = backend.auth.resources

// https://docs.aws.amazon.com/cdk/api/v2/docs/aws-cdk-lib.aws_iam.IRole.html
groups["ADMINS"].role
// highlight-end
```

## Next steps

- [Learn how to automatically add a user to a group upon account confirmation](/[platform]/build-a-backend/functions/examples/add-user-to-group/)
- [Learn how to secure access to data models using groups](/[platform]/build-a-backend/data/customize-authz/user-group-based-data-access)
- [Learn how to secure access to storage objects using groups](/[platform]/build-a-backend/storage/set-up-storage/)


Contents of build-a-backend_auth_concepts_usernames_index.txt:
import { getCustomStaticPath } from '@/utils/getCustomStaticPath';

export const meta = {
  title: 'Usernames',
  description: 'Learn more about what Amplify Auth provisions and supports',
  platforms: [
    // 'android',
    'angular',
    // 'flutter',
    'javascript',
    'nextjs',
    'react',
    // 'react-native',
    // 'swift',
    'vue'
  ]
};

export function getStaticPaths() {
  return getCustomStaticPath(meta.platforms);
}

export function getStaticProps() {
  return {
    props: {
      meta
    }
  };
}

Amplify Auth does not support signing in with only username and password, however can be configured to enable usernames for display purposes. Amazon Cognito offers two ways of provisioning login mechanisms:

1. **Username attributes**
2. **Alias attributes**

Each are described in more detail on the [AWS documentation for Cognito user pool settings](https://docs.aws.amazon.com/cognito/latest/developerguide/user-pool-settings-attributes.html#user-pool-settings-aliases), however at a high-level can be described as follows:

- **Username attributes** allow you to customize which attribute can be used as the "username", or allowing users to sign in with an email or phone in place of a username
- **Alias attributes** allow you to specify with attribute(s) can be used with sign in _in addition to_ a username

With Amazon Cognito, usernames are immutable, which means after the initial sign-up users are unable to change their username later. In some applications this may be undesirable, which can motivate the use of alias attributes. Alias attributes allow you to define a mutable "preferred username" in addition to an immutable username. 

Amplify Auth leverages **username attributes** to configure Cognito to accept an email or a phone number as the "username". Users will then need to verify their ownership of specified email or phone number to confirm their account.

However, it is common to consider a "username" for display purposes. For example, you can configure your auth resource to accept a "preferred username" to be used as the display name:

```ts title="amplify/auth/resource.ts"
import { defineAuth } from '@aws-amplify/backend';

/**
 * Define and configure your auth resource
 * @see https://docs.amplify.aws/gen2/build-a-backend/auth
 */
export const auth = defineAuth({
  loginWith: {
    email: true,
  },
  // highlight-start
  userAttributes: {
    preferredUsername: {
      mutable: true,
      required: false
    }
  }
  // highlight-end
});
```

This is not a username the user will be able to sign in with, but it can be used to mask their personal information such as their email or phone number when displaying publicly.

{/* frontend examples of vanity username */}

If you would like to override the default behavior and allow your users to sign up with an immutable username, you can use CDK to modify your auth resource's [`usernameAttributes`](https://docs.aws.amazon.com/cdk/api/v2/docs/aws-cdk-lib.aws_cognito.CfnUserPool.html#usernameattributes-1) configuration directly:

```ts title="amplify/backend.ts"
import { defineBackend } from "@aws-amplify/backend"
import { auth } from "./auth/resource"
import { data } from "./data/resource"

const backend = defineBackend({
  auth,
  data,
})

const { cfnUserPool } = backend.auth.resources.cfnResources
// an empty array denotes "email" and "phone_number" cannot be used as a username
cfnUserPool.usernameAttributes = []
```

## Next Steps

- [Learn how to configure email sign-up](/[platform]/build-a-backend/auth/concepts/email/)
- [Learn how to configure phone sign-up](/[platform]/build-a-backend/auth/concepts/phone/)


Contents of build-a-backend_auth_connect-your-frontend_delete-user-account_index.txt:
import { getCustomStaticPath } from '@/utils/getCustomStaticPath';

export const meta = {
  title: 'Delete user account',
  description: 'Enable users to delete their account.',
  platforms: [
    'android',
    'angular',
    'flutter',
    'javascript',
    'nextjs',
    'react',
    'react-native',
    'swift',
    'vue'
  ]
};

export async function getStaticPaths() {
  return getCustomStaticPath(meta.platforms);
}

export function getStaticProps(context) {
  return {
    props: {
      platform: context.params.platform,
      meta
    }
  };
}

Empowering users to delete their account can improve trust and transparency. You can programmatically enable self-service account deletion with Amplify Auth.

If you have not yet created an Amplify Gen 2 app, visit the [quickstart](/[platform]/start/quickstart).

## Allow users to delete their account

You can quickly set up account deletion for your users with the Amplify Libraries. Invoking the `deleteUser` API to delete a user from the Auth category will also sign out your user.

If your application uses a Cognito User Pool, which is the default configuration, this action will only delete the user from the Cognito User Pool. It will have no effect if you are federating with a Cognito Identity Pool alone.

<Callout warning>

Before invoking the `deleteUser` API, you may need to first delete associated user data that is not stored in Cognito. For example, if you are using Amplify Data to persist user data, you could follow [these instructions](https://gist.github.com/aws-amplify-ops/27954c421bd72930874d48c15c284807) to delete associated user data. This allows you to address any guidelines (such as GDPR) that require your app to delete data associated with a user who deletes their account.

</Callout>

You can enable account deletion using the following method:

<InlineFilter filters={["javascript",  "react-native", "angular", "nextjs", "react", "vue"]}>
```ts
import { deleteUser } from 'aws-amplify/auth';

async function handleDeleteUser() {
  try {
    await deleteUser();
  } catch (error) {
    console.log(error);
  }
}
```
</InlineFilter>
<InlineFilter filters={['flutter']}>
```dart
Future<void> deleteUser() async {
  try {
    await Amplify.Auth.deleteUser();
    safePrint('Delete user succeeded');
  } on AuthException catch (e) {
    safePrint('Delete user failed with error: $e');
  }
}
```
</InlineFilter>
<InlineFilter filters={['android']}>
<BlockSwitcher>
<Block name="Java">

```java
Amplify.Auth.deleteUser(
    () -> Log.i("AuthQuickStart", "Delete user succeeded"),
    error -> Log.e("AuthQuickStart", "Delete user failed with error " + error.toString())
);
```

</Block>
<Block name="Kotlin - Callbacks">

```kotlin
Amplify.Auth.deleteUser(
    { Log.i("AuthQuickStart", "Delete user succeeded") },
    { Log.e("AuthQuickStart", "Delete user failed with error", it) }
)
```

</Block>
<Block name="Kotlin - Coroutines">

```kotlin
try {
    Amplify.Auth.deleteUser()
    Log.i("AuthQuickStart", "Delete user succeeded")
} catch (error: AuthException) {
    Log.e("AuthQuickStart", "Delete user failed with error", error)
}
```

</Block>
<Block name="RxJava">

```java
RxAmplify.Auth.deleteUser()
    .subscribe(
      () -> Log.i("AuthQuickStart", "Delete user succeeded"),
      error -> Log.e("AuthQuickStart", "Delete user failed with error " + error.toString())
    );
```

</Block>
</BlockSwitcher>
</InlineFilter>
<InlineFilter filters={['swift']}>
<BlockSwitcher>

<Block name="Async/Await">

```swift
func deleteUser() async {
    do {
        try await Amplify.Auth.deleteUser()
        print("Successfully deleted user")
    } catch let error as AuthError {
        print("Delete user failed with error \(error)")
    } catch {
        print("Unexpected error: \(error)")
    }
}
```

</Block>

<Block name="Combine">

```swift
func deleteUser() -> AnyCancellable {
    Amplify.Publisher.create {
        try await Amplify.Auth.deleteUser()
    }.sink {
            if case let .failure(authError) = $0 {
                print("Delete user failed with error \(authError)")
            }
        }
        receiveValue: {
            print("Successfully deleted user")
        }
}
```

</Block>
</BlockSwitcher>

</InlineFilter>

We recommend you update your UI to let your users know that their account is deleted and test the functionality with a test user. Note that your user will be signed out of your application when they delete their account.


Contents of build-a-backend_auth_connect-your-frontend_index.txt:
import { getChildPageNodes } from '@/utils/getChildPageNodes';
import { getCustomStaticPath } from '@/utils/getCustomStaticPath';

export const meta = {
  title: 'Connect your frontend',
  description:
    'Learn how to connect your frontend to your backend auth resource',
  route: '/[platform]/build-a-backend/auth/connect-your-frontend',
  platforms: [
    'android',
    'angular',
    'flutter',
    'javascript',
    'nextjs',
    'react',
    'react-native',
    'swift',
    'vue'
  ]
};

export function getStaticPaths() {
  return getCustomStaticPath(meta.platforms);
}

export function getStaticProps() {
  const childPageNodes = getChildPageNodes(meta.route);
  return {
    props: {
      meta,
      childPageNodes
    }
  };
}

<Overview childPageNodes={props.childPageNodes} />


Contents of build-a-backend_auth_connect-your-frontend_listen-to-auth-events_index.txt:
import { getCustomStaticPath } from '@/utils/getCustomStaticPath';

export const meta = {
  title: 'Listen to auth events',
  description: 'Learn how to listen to auth events',
  platforms: [
    'android',
    'angular',
    'flutter',
    'javascript',
    'nextjs',
    'react',
    'react-native',
    'swift',
    'vue'
  ]
};

export function getStaticPaths() {
  return getCustomStaticPath(meta.platforms);
}

export function getStaticProps(context) {
  return {
    props: {
      platform: context.params.platform,
      meta
    }
  };
}

Amplify Auth emits events during authentication flows, which enables you to react to user flows in real time and trigger custom business logic. For example, you may want to capture data, synchronize your app's state, and personalize the user's experience. You can listen to and respond to events across the Auth lifecycle such as sign-in and sign-out.

<InlineFilter filters={['angular', 'javascript', 'nextjs', 'react', 'react-native', 'vue']}>

## Expose hub events triggered in response to auth actions

You can use Amplify Hub with its built in Amplify Auth events to subscribe a listener using a publish-subscribe pattern and capture events between different parts of your application. The Amplify Auth category publishes in the `auth` channel when auth events such as `signedIn` or `signedOut` happen independent from your app code.

You can review the Amplify Hub guide to [learn more](/gen1/react/build-a-backend/utilities/hub/).

<Callout warning>

Channels are logical group names that help you organize dispatching and listening. However, some channels are protected and cannot be used to publish custom events, and `auth` is one of these channels. Sending unexpected payloads to protected channels can have undesirable side effects such as impacting authentication flows. See the [Amplify Hub](/gen1/react/build-a-backend/utilities/hub/) guide for more protected channels.

</Callout>

Here is a basic example of setting up a listener that logs an event emitted through the `auth` channel:

```js
import { Hub } from 'aws-amplify/utils';

Hub.listen('auth', (data) => {
  console.log(data)
});
```

Once your app is set up to subscribe and listen to specific event types from the `auth` channel, the listeners will be notified asynchronously when an event occurs. This pattern allows for a one-to-many relationship where one auth event can be shared with many different listeners that have been subscribed. This lets your app react based on the event rather than proactively poll for information.

Additionally, you can set up your listener to extract data from the event payload and execute a callback that you define. For example, you might update UI elements in your app to reflect your user's authenticated state after the `signedIn` or `signedOut` events.

### Listen to and log auth events

One of the most common workflows will be to log events. In this example you can see how you can listen and target specific `auth` events using a `switch` to log your own messages.

```js
import { Hub } from 'aws-amplify/utils';

Hub.listen('auth', ({ payload }) => {
  switch (payload.event) {
    case 'signedIn':
      console.log('user have been signedIn successfully.');
      break;
    case 'signedOut':
      console.log('user have been signedOut successfully.');
      break;
    case 'tokenRefresh':
      console.log('auth tokens have been refreshed.');
      break;
    case 'tokenRefresh_failure':
      console.log('failure while refreshing auth tokens.');
      break;
    case 'signInWithRedirect':
      console.log('signInWithRedirect API has successfully been resolved.');
      break;
    case 'signInWithRedirect_failure':
      console.log('failure while trying to resolve signInWithRedirect API.');
      break;
    case 'customOAuthState':
      logger.info('custom state returned from CognitoHosted UI');
      break;
  }
});
```

### Stop listening to events

You can also stop listening for messages by calling the result of the `Hub.listen()` function. This may be useful if you no longer need to receive messages in your application flow. This can also help you avoid any memory leaks on low powered devices when you are sending large amounts of data through Amplify Hub on multiple channels.

To stop listening to a certain event, you need to wrap the listener function with a variable and call it once you no longer need it:

```js
/* start listening for messages */
const hubListenerCancelToken = Hub.listen('auth', (data) => {
  console.log('Listening for all auth events: ', data.payload.data);
});

/* later */
hubListenerCancelToken(); // stop listening for messages
```

You now have a few use cases and examples for listening to and responding to auth events.

</InlineFilter>
<InlineFilter filters={['flutter']}>
AWS Cognito Auth Plugin sends important events through Amplify Hub. You can listen to these events like the following:

```dart
final subscription = Amplify.Hub.listen(HubChannel.Auth, (AuthHubEvent event) {
  switch (event.type) {
    case AuthHubEventType.signedIn:
      safePrint('User is signed in.');
      break;
    case AuthHubEventType.signedOut:
      safePrint('User is signed out.');
      break;
    case AuthHubEventType.sessionExpired:
      safePrint('The session has expired.');
      break;
    case AuthHubEventType.userDeleted:
      safePrint('The user has been deleted.');
      break;
  }
});
```
</InlineFilter>
<InlineFilter filters={['android']}>
AWS Cognito Auth Plugin sends important events through Amplify Hub. You can listen to these events like the following:

<BlockSwitcher>
<Block name="Java">

```java
Amplify.Hub.subscribe(HubChannel.AUTH,
    hubEvent -> {
        if (hubEvent.getName().equals(InitializationStatus.SUCCEEDED.name())) {
            Log.i("AuthQuickstart", "Auth successfully initialized");
        } else if (hubEvent.getName().equals(InitializationStatus.FAILED.name())){
            Log.i("AuthQuickstart", "Auth failed to succeed");
        } else {
            String eventName = hubEvent.getName();
            if (eventName.equals(SIGNED_IN.name())) {
                Log.i("AuthQuickstart", "Auth just became signed in.");
            }
            else if (eventName.equals(SIGNED_OUT.name())) {
                Log.i("AuthQuickstart", "Auth just became signed out.");
            }
            else if (eventName.equals(SESSION_EXPIRED.name())) {
                Log.i("AuthQuickstart", "Auth session just expired.");
            }
            else if (eventName.equals(USER_DELETED.name())) {
                Log.i("AuthQuickstart", "User has been deleted.");
            }
            else {
                Log.w("AuthQuickstart", "Unhandled Auth Event: " + eventName);
            }
        }
    }
);

```

</Block>
<Block name="Kotlin - Callbacks">

```kotlin
Amplify.Hub.subscribe(HubChannel.AUTH) { event ->
    when (event.name) {
        InitializationStatus.SUCCEEDED.name ->
            Log.i("AuthQuickstart", "Auth successfully initialized")
        InitializationStatus.FAILED.name ->
            Log.i("AuthQuickstart", "Auth failed to succeed")
        else -> when (event.name) {
            AuthChannelEventName.SIGNED_IN.name ->
                Log.i("AuthQuickstart", "Auth just became signed in")
            AuthChannelEventName.SIGNED_OUT.name ->
                Log.i("AuthQuickstart", "Auth just became signed out")
            AuthChannelEventName.SESSION_EXPIRED.name ->
                Log.i("AuthQuickstart", "Auth session just expired")
            AuthChannelEventName.USER_DELETED.name ->
                Log.i("AuthQuickstart", "User has been deleted")
            else ->
                Log.w("AuthQuickstart", "Unhandled Auth Event: ${event.name}")
        }
    }
}
```

</Block>
<Block name="Kotlin - Coroutines">

```kotlin
Amplify.Hub.subscribe(HubChannel.AUTH).collect {
    when (it.name) {
        InitializationStatus.SUCCEEDED.name ->
            Log.i("AuthQuickstart", "Auth successfully initialized")
        InitializationStatus.FAILED.name ->
            Log.i("AuthQuickstart", "Auth failed to succeed")
        else -> when (it.name) {
            AuthChannelEventName.SIGNED_IN.name ->
                Log.i("AuthQuickstart", "Auth just became signed in.")
            AuthChannelEventName.SIGNED_OUT.name ->
                Log.i("AuthQuickstart", "Auth just became signed out.")
            AuthChannelEventName.SESSION_EXPIRED.name ->
                Log.i("AuthQuickstart", "Auth session just expired.")
            AuthChannelEventName.USER_DELETED.name ->
                Log.i("AuthQuickstart", "User has been deleted.")
            else ->
                Log.w("AuthQuickstart", "Unhandled Auth Event: ${it.name}")
        }
    }
}
```

</Block>
<Block name="RxJava">

```java
RxAmplify.Hub.on(HubChannel.AUTH)
    .map(HubEvent::getName)
    .subscribe(name -> {
        if (name.equals(InitializationStatus.SUCCEEDED.name())) {
            Log.i("AuthQuickstart", "Auth successfully initialized");
            return;
        } else if (name.equals(InitializationStatus.FAILED.name())) {
            Log.i("AuthQuickstart", "Auth failed to succeed");
            return;
        } else {
            if (name.equals(SIGNED_IN.name())) {
                Log.i("AuthQuickstart", "Auth just became signed in.");
            }
            else if (name.equals(SIGNED_OUT.name())) {
                Log.i("AuthQuickstart", "Auth just became signed out.");
            }
            else if (name.equals(SESSION_EXPIRED.name())) {
                Log.i("AuthQuickstart", "Auth session just expired.");
            }
            else if (name.equals(USER_DELETED.name())) {
                Log.i("AuthQuickstart", "User has been deleted.");
            }
            else {
                Log.w("AuthQuickstart", "Unhandled Auth Event: " + hubEvent.getName());
            }
        }
    });
```

</Block>
</BlockSwitcher>

</InlineFilter>
<InlineFilter filters={['swift']}>
AWS Cognito Auth Plugin sends important events through Amplify Hub. You can listen to these events like the following:

<BlockSwitcher>
<Block name="Listener">

```swift
override func viewDidLoad() {
    super.viewDidLoad()
    // Do any additional setup after loading the view.

    // Assumes `unsubscribeToken` is declared as an instance variable in your view
    unsubscribeToken = Amplify.Hub.listen(to: .auth) { payload in
        switch payload.eventName {
        case HubPayload.EventName.Auth.signedIn:
            print("User signed in")
            // Update UI

        case HubPayload.EventName.Auth.sessionExpired:
            print("Session expired")
            // Re-authenticate the user

        case HubPayload.EventName.Auth.signedOut:
            print("User signed out")
            // Update UI

        case HubPayload.EventName.Auth.userDeleted:
            print("User deleted")
            // Update UI

        default:
            break
        }
    }
}
```

</Block>
<Block name="Combine">

```swift
override func viewDidLoad() {
    super.viewDidLoad()
    // Do any additional setup after loading the view.

    // Assumes `sink` is declared as an instance variable in your view controller
    sink = Amplify.Hub
        .publisher(for: .auth)
        .sink { payload in
            switch payload.eventName {
            case HubPayload.EventName.Auth.signedIn:
                print("User signed in")
                // Update UI

            case HubPayload.EventName.Auth.sessionExpired:
                print("Session expired")
                // Re-authenticate the user

            case HubPayload.EventName.Auth.signedOut:
                print("User signed out")
                // Update UI

            case HubPayload.EventName.Auth.userDeleted:
                print("User deleted")
                // Update UI

            default:
                break
            }
        }
}
```

</Block>
</BlockSwitcher>
</InlineFilter>


Contents of build-a-backend_auth_connect-your-frontend_manage-user-attributes_index.txt:
import { getCustomStaticPath } from '@/utils/getCustomStaticPath';

export const meta = {
  title: 'Manage user attributes',
  description: 'Learn about managing user attributes in your Amplify app',
  platforms: [
    'android',
    'angular',
    'flutter',
    'javascript',
    'nextjs',
    'react',
    'react-native',
    'swift',
    'vue'
  ]
};

export function getStaticPaths() {
  return getCustomStaticPath(meta.platforms);
}

export function getStaticProps() {
  return {
    props: {
      meta
    }
  };
}

User attributes such as email address, phone number help you identify individual users. Defining the user attributes you include for your user profiles makes user data easy to manage at scale. This information will help you personalize user journeys, tailor content, provide intuitive account control, and more. You can capture information upfront during sign-up or enable customers to update their profile after sign-up. In this section we take a closer look at working with user attributes, how to set them up and manage them.

<InlineFilter filters={['javascript', 'angular', 'react', 'vue', 'react-native', 'nextjs']}>
## Pass user attributes during sign-up

You can create user attributes during sign-up or when the user is authenticated. To do this as part of sign-up you can pass them in the `userAttributes` object of the `signUp` API:

```ts
import { signUp } from "aws-amplify/auth";

await signUp({
  username: "jdoe",
  password: "mysecurerandompassword#123",
  options: {
    userAttributes: {
      email: "me@domain.com",
      phone_number: "+12128601234", // E.164 number convention
      given_name: "Jane",
      family_name: "Doe",
      nickname: "Jane",
    },
  },
});
```
</InlineFilter>

<InlineFilter filters={['javascript', 'angular', 'react', 'vue', 'react-native', 'nextjs', 'flutter', 'swift']}>

## Configure custom user attributes during sign-up

Custom attributes can be passed in with the `userAttributes` option of the `signUp` API:

<InlineFilter filters={['javascript', 'angular', 'react', 'vue', 'react-native', 'nextjs']}>

```ts
import { signUp } from "aws-amplify/auth";

await signUp({
  username: 'john.doe@example.com',
  password: 'hunter2',
  options: {
    userAttributes: {
      'custom:display_name': 'john_doe123',
    }
  }
});
```

</InlineFilter>
<InlineFilter filters={['flutter']}>

```dart
Future<void> _signUp({
    required String username,
    required String password,
    required String email,
    required String customValue,
}) async  {
  final userAttributes = {
    AuthUserAttributeKey.email: email,
    // Create and pass a custom attribute
    const CognitoUserAttributeKey.custom('my-custom-attribute'): customValue
  };
  await Amplify.Auth.signUp(
    username: username,
    password: password,
    options: SignUpOptions(
      userAttributes: userAttributes,
    ),
  );
}
```

</InlineFilter>
<InlineFilter filters={['swift']}>

```swift
func signUp(username: String, password: String, email: String) async {
    do {
        let signUpResult = try await Amplify.Auth.signUp(
            username: username,
            password: password,
            options: .init(userAttributes: [
                AuthUserAttribute(.email, value: email), 
                AuthUserAttribute(.custom("my-custom-attribute"), value: <custom attribute value>)
            ])
        )
        if case let .confirmUser(deliveryDetails, _, userId) = signUpResult.nextStep {
            print("Delivery details \(String(describing: deliveryDetails)) for userId: \(String(describing: userId)))")
        } else {
            print("SignUp Complete")
        }
    } catch let error as AuthError {
        print("An error occurred while registering a user \(error)")
    } catch {
        print("Unexpected error: \(error)")
    }
}
```

</InlineFilter>
</InlineFilter>

## Retrieve user attributes

You can retrieve user attributes for your users to read in their profile using the `fetchUserAttributes` API. This helps you personalize their frontend experience as well as control what they will see.

<InlineFilter filters={['javascript', 'angular', 'react', 'vue', 'react-native', 'nextjs']}>

```ts
import { fetchUserAttributes } from 'aws-amplify/auth';

await fetchUserAttributes();
```

</InlineFilter>
<InlineFilter filters={['swift']}>

<BlockSwitcher>
<Block name="Async/Await">

```swift
func fetchAttributes() async {
    do {
        let attributes = try await Amplify.Auth.fetchUserAttributes()
        print("User attributes - \(attributes)")
    } catch let error as AuthError{
        print("Fetching user attributes failed with error \(error)")
    } catch {
        print("Unexpected error: \(error)")
    }
}
```

</Block>
<Block name="Combine">

```swift
func fetchAttributes() -> AnyCancellable {
    Amplify.Publisher.create {
        try await Amplify.Auth.fetchUserAttributes()
        }.sink {
            if case let .failure(authError) = $0 {
                print("Fetch user attributes failed with error \(authError)")
            }
        }
        receiveValue: { attributes in
            print("User attributes - \(attributes)")
        }
}
```

</Block>
</BlockSwitcher>

</InlineFilter>
<InlineFilter filters={['android']}>

<BlockSwitcher>
<Block name="Java">

```java
Amplify.Auth.fetchUserAttributes(
    attributes -> Log.i("AuthDemo", "User attributes = " + attributes.toString()),
    error -> Log.e("AuthDemo", "Failed to fetch user attributes.", error)
);
```

</Block>
<Block name="Kotlin - Callbacks">

```kotlin
Amplify.Auth.fetchUserAttributes(
    { Log.i("AuthDemo", "User attributes = $it") },
    { Log.e("AuthDemo", "Failed to fetch user attributes", it) }
)
```

</Block>
<Block name="Kotlin - Coroutines">

```kotlin
try {
    val attributes = Amplify.Auth.fetchUserAttributes()
    Log.i("AuthDemo", "User attributes = $attributes")
} catch (error: AuthException) {
    Log.e("AuthDemo", "Failed to fetch user attributes", error)
}
```

</Block>
<Block name="RxJava">

```java
RxAmplify.Auth.fetchUserAttributes()
    .doOnSubscribe(() -> Log.i("AuthDemo", "Attributes:"))
    .flatMapObservable(Observable::fromIterable)
    .subscribe(
        eachAttribute -> Log.i("AuthDemo", eachAttribute.toString()),
        error -> Log.e("AuthDemo", "Failed to fetch attributes.", error)
    );
```

</Block>
</BlockSwitcher>

</InlineFilter>
<InlineFilter filters={['flutter']}>

```dart
Future<void> fetchCurrentUserAttributes() async {
  try {
    final result = await Amplify.Auth.fetchUserAttributes();
    for (final element in result) {
      safePrint('key: ${element.userAttributeKey}; value: ${element.value}');
    }
  } on AuthException catch (e) {
    safePrint('Error fetching user attributes: ${e.message}');
  }
}
```

</InlineFilter>

## Update user attribute

You can use the `updateUserAttribute` API to create or update existing user attributes.

<InlineFilter filters={['javascript', 'angular', 'react', 'vue', 'react-native', 'nextjs']}>
<BlockSwitcher>
<Block name="TypeScript">

```typescript
import {
  updateUserAttribute,
  type UpdateUserAttributeOutput
} from 'aws-amplify/auth';

async function handleUpdateUserAttribute(attributeKey: string, value: string) {
  try {
    const output = await updateUserAttribute({
      userAttribute: {
        attributeKey,
        value
      }
    });
    handleUpdateUserAttributeNextSteps(output);
  } catch (error) {
    console.log(error);
  }
}

function handleUpdateUserAttributeNextSteps(output: UpdateUserAttributeOutput) {
  const { nextStep } = output;

  switch (nextStep.updateAttributeStep) {
    case 'CONFIRM_ATTRIBUTE_WITH_CODE':
      const codeDeliveryDetails = nextStep.codeDeliveryDetails;
      console.log(
        `Confirmation code was sent to ${codeDeliveryDetails?.deliveryMedium}.`
      );
      // Collect the confirmation code from the user and pass to confirmUserAttribute.
      break;
    case 'DONE':
      console.log(`attribute was successfully updated.`);
      break;
  }
}
```

</Block>
<Block name="JavaScript">

```javascript
import { updateUserAttribute } from 'aws-amplify/auth';

async function handleUpdateUserAttribute(attributeKey, value) {
  try {
    const output = await updateUserAttribute({
      userAttribute: {
        attributeKey,
        value
      }
    });
    handleUpdateUserAttributeNextSteps(output);
  } catch (error) {
    console.log(error);
  }
}

function handleUpdateUserAttributeNextSteps(output) {
  const { nextStep } = output;

  switch (nextStep.updateAttributeStep) {
    case 'CONFIRM_ATTRIBUTE_WITH_CODE':
      const codeDeliveryDetails = nextStep.codeDeliveryDetails;
      console.log(
        `Confirmation code was sent to ${codeDeliveryDetails?.deliveryMedium}.`
      );
      // Collect the confirmation code from the user and pass to confirmUserAttribute.
      break;
    case 'DONE':
      console.log(`attribute was successfully updated.`);
      break;
  }
}
```

</Block>
</BlockSwitcher>

<Callout>
  Note: If you change an attribute that requires confirmation (i.e. email or phone_number), the user will receive a confirmation code either to their email or cellphone. This code can be used with the confirmUserAttribute API to confirm the change.
</Callout>
</InlineFilter>

<InlineFilter filters={['swift']}>
<BlockSwitcher>

<Block name="Async/Await">

```swift
func updateAttribute() async {
    do {
        let updateResult = try await Amplify.Auth.update(
            userAttribute: AuthUserAttribute(.phoneNumber, value: "+2223334444")
        )

        switch updateResult.nextStep {
        case .confirmAttributeWithCode(let deliveryDetails, let info):
            print("Confirm the attribute with details send to - \(deliveryDetails) \(String(describing: info))")
        case .done:
            print("Update completed")
        }
    } catch let error as AuthError {
        print("Update attribute failed with error \(error)")
    } catch {
        print("Unexpected error: \(error)")
    }
}
```

</Block>

<Block name="Combine">

```swift
func updateAttribute() -> AnyCancellable {
    Amplify.Publisher.create {
        try await Amplify.Auth.update(
          userAttribute: AuthUserAttribute(.phoneNumber, value: "+2223334444")
        )
    }.sink {
        if case let .failure(authError) = $0 {
            print("Update attribute failed with error \(authError)")
        }
    }
    receiveValue: { updateResult in
        switch updateResult.nextStep {
        case .confirmAttributeWithCode(let deliveryDetails, let info):
            print("Confirm the attribute with details send to - \(deliveryDetails) \(info)")
        case .done:
            print("Update completed")
        }
    }
}
```

</Block>

</BlockSwitcher>
</InlineFilter>

<InlineFilter filters={['android']}>
<BlockSwitcher>
<Block name="Java">

```java
AuthUserAttribute userEmail =
    new AuthUserAttribute(AuthUserAttributeKey.email(), "email@email.com");
Amplify.Auth.updateUserAttribute(userEmail,
    result -> Log.i("AuthDemo", "Updated user attribute = " + result.toString()),
    error -> Log.e("AuthDemo", "Failed to update user attribute.", error)
);
```

</Block>
<Block name="Kotlin - Callbacks">

```kotlin
Amplify.Auth.updateUserAttribute(
    AuthUserAttribute(AuthUserAttributeKey.email(), "email@email.com"),
    { Log.i("AuthDemo", "Updated user attribute = $it") },
    { Log.e("AuthDemo", "Failed to update user attribute.", it) }
)
```

</Block>
<Block name="Kotlin - Coroutines">

```kotlin
val attribute =
    AuthUserAttribute(AuthUserAttributeKey.email(), "email@email.com")
try {
    val result = Amplify.Auth.updateUserAttribute(attribute)
    Log.i("AuthDemo", "Updated user attribute = $result")
} catch (error: AuthException) {
    Log.e("AuthDemo", "Failed to update user attribute.", error)
}
```

</Block>
<Block name="RxJava">

```java
AuthUserAttribute userEmail =
    new AuthUserAttribute(AuthUserAttributeKey.email(), "email@email.com");
RxAmplify.Auth.updateUserAttribute(userEmail)
    .subscribe(
        result -> Log.i("AuthDemo", "Updated user attribute = " + result.toString()),
        error -> Log.e("AuthDemo", "Failed to update user attribute.", error)
    );
```

</Block>
</BlockSwitcher>

</InlineFilter>

<InlineFilter filters={['flutter']}>

```dart
Future<void> updateUserEmail({
  required String newEmail,
}) async {
  try {
    final result = await Amplify.Auth.updateUserAttribute(
      userAttributeKey: AuthUserAttributeKey.email,
      value: newEmail,
    );
    _handleUpdateUserAttributeResult(result);
  } on AuthException catch (e) {
    safePrint('Error updating user attribute: ${e.message}');
  }
}
```

User attribute updates may require additional verification before they're complete. Check the
`UpdateUserAttributeResult` returned from `Amplify.Auth.updateUserAttribute` to see which next
step, if any, is required. When the update is complete, the next step will be `done`.

```dart
void _handleUpdateUserAttributeResult(
  UpdateUserAttributeResult result,
) {
  switch (result.nextStep.updateAttributeStep) {
    case AuthUpdateAttributeStep.confirmAttributeWithCode:
      final codeDeliveryDetails = result.nextStep.codeDeliveryDetails!;
      _handleCodeDelivery(codeDeliveryDetails);
      break;
    case AuthUpdateAttributeStep.done:
      safePrint('Successfully updated attribute');
      break;
  }
}

void _handleCodeDelivery(AuthCodeDeliveryDetails codeDeliveryDetails) {
  safePrint(
    'A confirmation code has been sent to ${codeDeliveryDetails.destination}. '
    'Please check your ${codeDeliveryDetails.deliveryMedium.name} for the code.',
  );
}
```

To update multiple user attributes at a time, call `updateUserAttributes`:

```dart
Future<void> updateUserAttributes() async {
  const attributes = [
    AuthUserAttribute(
      userAttributeKey: AuthUserAttributeKey.email,
      value: 'email@email.com',
    ),
    AuthUserAttribute(
      userAttributeKey: AuthUserAttributeKey.familyName,
      value: 'MyFamilyName',
    ),
  ];
  try {
    final result = await Amplify.Auth.updateUserAttributes(
      attributes: attributes,
    );
    result.forEach((key, value) {
      switch (value.nextStep.updateAttributeStep) {
        case AuthUpdateAttributeStep.confirmAttributeWithCode:
          final destination = value.nextStep.codeDeliveryDetails?.destination;
          safePrint('Confirmation code sent to $destination for $key');
          break;
        case AuthUpdateAttributeStep.done:
          safePrint('Update completed for $key');
          break;
      }
    });
  } on AuthException catch (e) {
    safePrint('Error updating user attributes: ${e.message}');
  }
}
```
</InlineFilter>

<InlineFilter filters={['javascript', 'angular', 'react', 'vue', 'react-native', 'nextjs', 'android']}>
## Update user attributes

You can use the `updateUserAttributes` API to create or update multiple existing user attributes.

<InlineFilter filters={['javascript', 'angular', 'react', 'vue', 'react-native', 'nextjs']}>
```typescript
import { updateUserAttributes, type UpdateUserAttributesOutput } from "aws-amplify/auth";

await updateUserAttributes({
  userAttributes: {
    email: "me@domain.com",
    name: "Jon Doe",
  },
});
```
</InlineFilter>

<InlineFilter filters={['android']}>

<BlockSwitcher>
<Block name="Java">

```java
Amplify.Auth.updateUserAttributes(
    attributes, // attributes is a list of AuthUserAttribute
    result -> Log.i("AuthDemo", "Updated user attributes = " + result.toString()),
    error -> Log.e("AuthDemo", "Failed to update user attributes.", error)
);
```

</Block>
<Block name="Kotlin - Callbacks">

```kotlin
Amplify.Auth.updateUserAttributes(
    attributes, // attributes is a list of AuthUserAttribute
    { Log.i("AuthDemo", "Updated user attributes = $it") },
    { Log.e("AuthDemo", "Failed to update user attributes", it) }
)
```

</Block>
<Block name="Kotlin - Coroutines">

```kotlin
try {
    val result = Amplify.Auth.updateUserAttributes(attributes)
    Log.i("AuthDemo", "Updated user attributes = $result")
} catch (error: AuthException) {
    Log.e("AuthDemo", "Failed to update user attributes", error)
}
```

</Block>
<Block name="RxJava">

```java
// attributes is a list of AuthUserAttribute
RxAmplify.Auth.updateUserAttributes(attributes)
    .subscribe(
        result -> Log.i("AuthDemo", "Updated user attributes = " + result.toString()),
        error -> Log.e("AuthDemo", "Failed to update user attributes.", error)
    );
```

</Block>
</BlockSwitcher>
</InlineFilter>
</InlineFilter>

## Verify user attribute

<InlineFilter filters={['javascript', 'angular', 'react', 'vue', 'react-native', 'nextjs', 'flutter', 'android']}>
Some attributes require confirmation for the attribute update to complete. If the attribute needs to be confirmed, part of the result of the `updateUserAttribute` or `updateUserAttributes` APIs will be `CONFIRM_ATTRIBUTE_WITH_CODE`. A confirmation code will be sent to the delivery medium mentioned in the delivery details. When the user gets the confirmation code, you can present a UI to the user to enter the code and invoke the `confirmUserAttribute` API with their input:
</InlineFilter>

<InlineFilter filters={['swift']}>
Some attributes require confirmation for the attribute update to complete. If the attribute needs to be confirmed, part of the result of the `updateUserAttribute` or `updateUserAttributes` APIs will be `confirmAttributeWithCode`. A confirmation code will be sent to the delivery medium mentioned in the delivery details. When the user gets the confirmation code, you can present a UI to the user to enter the code and invoke the `confirmUserAttribute` API with their input:
</InlineFilter>

<InlineFilter filters={['javascript', 'angular', 'react', 'vue', 'react-native', 'nextjs']}>
```typescript
import {
  confirmUserAttribute,
  type ConfirmUserAttributeInput
} from 'aws-amplify/auth';

async function handleConfirmUserAttribute({
  userAttributeKey,
  confirmationCode
}: ConfirmUserAttributeInput) {
  try {
    await confirmUserAttribute({ userAttributeKey, confirmationCode });
  } catch (error) {
    console.log(error);
  }
}
```
</InlineFilter>

<InlineFilter filters={['swift']}>
<BlockSwitcher>

<Block name="Async/Await">

```swift
func confirmAttribute() async {
    do {
        try await Amplify.Auth.confirm(userAttribute: .email, confirmationCode: "390739")
        print("Attribute verified")
    } catch let error as AuthError {
        print("Update attribute failed with error \(error)")
    } catch {
        print("Unexpected error: \(error)")
    }
}
```

</Block>

<Block name="Combine">

```swift
func confirmAttribute() -> AnyCancellable {
    Amplify.Publisher.create {
        try await Amplify.Auth.confirm(userAttribute: .email, confirmationCode: "390739")
        }.sink {
            if case let .failure(authError) = $0 {
                print("Update attribute failed with error \(authError)")
            }
        }
        receiveValue: { _ in
            print("Attribute verified")
        }
}
```

</Block>

</BlockSwitcher>
</InlineFilter>

<InlineFilter filters={['android']}>
<BlockSwitcher>
<Block name="Java">

```java
Amplify.Auth.confirmUserAttribute(AuthUserAttributeKey.email(), "344299",
    () -> Log.i("AuthDemo", "Confirmed user attribute with correct code."),
    error -> Log.e("AuthDemo", "Failed to confirm user attribute. Bad code?", error)
);
```

</Block>
<Block name="Kotlin - Callbacks">

```kotlin
Amplify.Auth.confirmUserAttribute(AuthUserAttributeKey.email(), "344299",
    { Log.i("AuthDemo", "Confirmed user attribute with correct code.") },
    { Log.e("AuthDemo", "Failed to confirm user attribute. Bad code?", it) }
)
```

</Block>
<Block name="Kotlin - Coroutines">

```kotlin
try {
    Amplify.Auth.confirmUserAttribute(AuthUserAttributeKey.email(), "344299")
    Log.i("AuthDemo", "Confirmed user attribute with correct code.") 
} catch (error: AuthException) {
    Log.e("AuthDemo", "Failed to confirm user attribute. Bade code?", error) 
}
```

</Block>
<Block name="RxJava">

```java
RxAmplify.Auth.confirmUserAttribute(AuthUserAttributeKey.email(), "344299")
    .subscribe(
        () -> Log.i("AuthDemo", "Confirmed user attribute using correct code."),
        error -> Log.e("AuthDemo", "Failed to confirm user attribute. Bad code?", error)
    );
```

</Block>
</BlockSwitcher>
</InlineFilter>

<InlineFilter filters={['flutter']}>
```dart
Future<void> verifyAttributeUpdate() async {
  try {
    await Amplify.Auth.confirmUserAttribute(
      userAttributeKey: AuthUserAttributeKey.email,
      confirmationCode: '390739',
    );
  } on AuthException catch (e) {
    safePrint('Error confirming attribute update: ${e.message}');
  }
}
```
</InlineFilter>


## Send user attribute verification code

If an attribute needs to be verified while the user is authenticated, invoke the `sendUserAttributeVerificationCode` API as shown below:

<InlineFilter filters={['javascript', 'angular', 'react', 'vue', 'react-native', 'nextjs']}>
```ts
import {
  sendUserAttributeVerificationCode,
  type VerifiableUserAttributeKey
} from 'aws-amplify/auth';

async function handleSendUserAttributeVerificationCode(
  key: VerifiableUserAttributeKey
) {
  try {
    await sendUserAttributeVerificationCode({
      userAttributeKey: key
    });
  } catch (error) {
    console.log(error);
  }
}
```
</InlineFilter>

<InlineFilter filters={['swift']}>
<BlockSwitcher>

<Block name="Async/Await">

```swift
func sendVerificationCode() async {
    do {
        let deliveryDetails = try await Amplify.Auth.sendVerificationCode(forUserAttributeKey: .email)
        print("Resend code send to - \(deliveryDetails)")
    } catch let error as AuthError {
        print("Resend code failed with error \(error)")
    } catch {
        print("Unexpected error: \(error)")
    }
}
```

</Block>

<Block name="Combine">

```swift
func sendVerificationCode() -> AnyCancellable {
    Amplify.Publisher.create {
        try await Amplify.Auth.sendVerificationCode(forUserAttributeKey: .email)
        }.sink {
            if case let .failure(authError) = $0 {
                print("Resend code failed with error \(authError)")
            }
        }
        receiveValue: { deliveryDetails in
            print("Resend code sent to - \(deliveryDetails)")
        }
}
```

</Block>

</BlockSwitcher>
</InlineFilter>

<InlineFilter filters={['android']}>
<BlockSwitcher>
<Block name="Java">

```java
Amplify.Auth.resendUserAttributeConfirmationCode(AuthUserAttributeKey.email(),
    result -> Log.i("AuthDemo", "Code was sent again: " + result.toString()),
    error -> Log.e("AuthDemo", "Failed to resend code.", error)
);
```

</Block>
<Block name="Kotlin - Callbacks">

```kotlin
Amplify.Auth.resendUserAttributeConfirmationCode(
    AuthUserAttributeKey.email(),
    { Log.i("AuthDemo", "Code was sent again: $it") },
    { Log.e("AuthDemo", "Failed to resend code", it) }
)
```

</Block>
<Block name="Kotlin - Coroutines">

```kotlin
try {
    val attr = AuthUserAttributeKey.email()
    val result = Amplify.Auth.resendUserAttributeConfirmationCode(attr)
    Log.i("AuthDemo", "Code was sent again: $result."),
} catch (error: AuthException) {
    Log.e("AuthDemo", "Failed to resend code.", error)
}
```

</Block>
<Block name="RxJava">

```java
RxAmplify.Auth.resendUserAttributeConfirmationCode(AuthUserAttributeKey.email())
    .subscribe(
        result -> Log.i("AuthDemo", "Code was resent: " + result.toString()),
        error -> Log.e("AuthDemo", "Failed to resend code.", error)
    );
```

</Block>
</BlockSwitcher>
</InlineFilter>

<InlineFilter filters={['flutter']}>
 ```dart
Future<void> resendVerificationCode() async {
  try {
    final result = await Amplify.Auth.resendUserAttributeConfirmationCode(
      userAttributeKey: AuthUserAttributeKey.email,
    );
    _handleCodeDelivery(result.codeDeliveryDetails);
  } on AuthException catch (e) {
    safePrint('Error resending code: ${e.message}');
  }
}
```
</InlineFilter>

<InlineFilter filters={['javascript', 'angular', 'react', 'vue', 'react-native', 'nextjs']}>
## Delete user attributes

The `deleteUserAttributes` API allows to delete one or more user attributes.

```ts
import {
  deleteUserAttributes,
  type DeleteUserAttributesInput
} from 'aws-amplify/auth';

async function handleDeleteUserAttributes(
  keys: DeleteUserAttributesInput['userAttributeKeys']
) {
  try {
    await deleteUserAttributes({
      userAttributeKeys: ['custom:my_custom_attribute', ...keys]
    });
  } catch (error) {
    console.log(error);
  }
}
```
</InlineFilter>

## Next Steps 

- [Learn how to set up password change and recovery](/[platform]/build-a-backend/auth/manage-users/manage-passwords/)
- [Learn how to set up custom attributes](/[platform]/build-a-backend/auth/concepts/user-attributes#custom-attributes)


Contents of build-a-backend_auth_connect-your-frontend_manage-user-sessions_index.txt:
import { getCustomStaticPath } from '@/utils/getCustomStaticPath';

export const meta = {
  title: 'Manage user sessions',
  description: 'Learn how to manage user sessions',
  platforms: [
    'android',
    'angular',
    'flutter',
    'javascript',
    'nextjs',
    'react',
    'react-native',
    'swift',
    'vue'
  ]
};

export function getStaticPaths() {
  return getCustomStaticPath(meta.platforms);
}

export function getStaticProps() {
  return {
    props: {
      meta,
    }
  };
}

Amplify Auth provides access to current user sessions and tokens to help you retrieve your user's information to determine if they are signed in with a valid session and control their access to your app.

<InlineFilter filters={["angular", "javascript", "nextjs", "react", "react-native", "vue"]}>


## Retrieve your current authenticated user

You can use the `getCurrentUser` API to get information about the currently authenticated user including the `username`, `userId` and `signInDetails`.

```ts
import { getCurrentUser } from 'aws-amplify/auth';

const { username, userId, signInDetails } = await getCurrentUser();

console.log("username", username);
console.log("user id", userId);
console.log("sign-in details", signInDetails);
```

This method can be used to check if a user is signed in. It throws an error if the user is not authenticated.

<Callout info>

The user's `signInDetails` are not supported when using the `Hosted UI` or the `signInWithRedirect` API.

</Callout>

## Retrieve a user session

Your user's session is their signed-in state, which grants them access to your app. When your users sign in, their credentials are exchanged for temporary access tokens. You can get session details to access these tokens and use this information to validate user access or perform actions unique to that user.

If you only need the session details, you can use the `fetchAuthSession` API which returns a `tokens` object containing the JSON Web Tokens (JWT).

```ts
import { fetchAuthSession } from 'aws-amplify/auth';

const session = await fetchAuthSession();

console.log("id token", session.tokens.idToken)
console.log("access token", session.tokens.accessToken)
```

### Refreshing sessions

The `fetchAuthSession` API automatically refreshes the user's session when the authentication tokens have expired and a valid `refreshToken` is present. Additionally, you can also refresh the session explicitly by calling the `fetchAuthSession` API with the `forceRefresh` flag enabled. 

```ts
import { fetchAuthSession } from 'aws-amplify/auth';

await fetchAuthSession({ forceRefresh: true });
```

<Callout warning>

**Warning:** by default, sessions from external identity providers cannot be refreshed.

</Callout>

</InlineFilter>
<InlineFilter filters={["flutter"]}>
An intentional decision with Amplify Auth was to avoid any public methods exposing credentials or manipulating them.

With Auth, you simply sign in and it handles everything else needed to keep the credentials up to date and vend them to the other categories.

However, if you need to access them in relation to working with an API outside Amplify or want access to AWS specific identifying information (e.g. IdentityId), you can access these implementation details by calling `fetchAuthSession` on the Cognito Auth Plugin. This will return a `CognitoAuthSession`, which has additional attributes compared to `AuthSession`, which is typically returned by `fetchAuthSession`. See the example below:

```dart
Future<void> fetchAuthSession() async {
  try {
    final result = await Amplify.Auth.fetchAuthSession();
    safePrint('User is signed in: ${result.isSignedIn}');
  } on AuthException catch (e) {
    safePrint('Error retrieving auth session: ${e.message}');
  }
}
```

## Retrieving AWS credentials

Sometimes it can be helpful to retrieve the instance of the underlying plugin which has more specific typing. In case of Cognito, calling `fetchAuthSession` on the Cognito plugin returns AWS-specific values such as the identity ID, AWS credentials, and Cognito User Pool tokens.

```dart
Future<void> fetchCognitoAuthSession() async {
  try {
    final cognitoPlugin = Amplify.Auth.getPlugin(AmplifyAuthCognito.pluginKey);
    final result = await cognitoPlugin.fetchAuthSession();
    final identityId = result.identityIdResult.value;
    safePrint("Current user's identity ID: $identityId");
  } on AuthException catch (e) {
    safePrint('Error retrieving auth session: ${e.message}');
  }
}
```

</InlineFilter>
<InlineFilter filters={['android']}>

An intentional decision with Amplify Auth was to avoid any public methods exposing credentials or manipulating them.

With Auth, you simply sign in and it handles everything else needed to keep the credentials up to date and vend them to the other categories.

However, if you need to access them in relation to working with an API outside Amplify or want access to AWS specific identifying information (e.g. IdentityId), you can access these implementation details by casting the result of `fetchAuthSession` as follows:

<BlockSwitcher>
<Block name="Java">

```java
Amplify.Auth.fetchAuthSession(
    result -> {
        AWSCognitoAuthSession cognitoAuthSession = (AWSCognitoAuthSession) result;
            switch(cognitoAuthSession.getIdentityIdResult().getType()) {
                case SUCCESS:
                    Log.i("AuthQuickStart", "IdentityId: " + cognitoAuthSession.getIdentityIdResult().getValue());
                    break;
                case FAILURE:
                    Log.i("AuthQuickStart", "IdentityId not present because: " + cognitoAuthSession.getIdentityIdResult().getError().toString());
            }
        },
        error -> Log.e("AuthQuickStart", error.toString())
);
```

</Block>
<Block name="Kotlin - Callbacks">

```kotlin
Amplify.Auth.fetchAuthSession(
    {
        val session = it as AWSCognitoAuthSession
        when (session.identityIdResult.type) {
            AuthSessionResult.Type.SUCCESS ->
                Log.i("AuthQuickStart", "IdentityId = ${session.identityIdResult.value}")
            AuthSessionResult.Type.FAILURE ->
                Log.w("AuthQuickStart", "IdentityId not found", session.identityIdResult.error)
        }
    },
    { Log.e("AuthQuickStart", "Failed to fetch session", it) }
)
```

</Block>
<Block name="Kotlin - Coroutines">

```kotlin
try {
    val session = Amplify.Auth.fetchAuthSession() as AWSCognitoAuthSession
    val id = session.identityIdResult
    if (id.type == AuthSessionResult.Type.SUCCESS) {
        Log.i("AuthQuickStart", "IdentityId: ${id.value}")
    } else if (id.type == AuthSessionResult.Type.FAILURE) {
        Log.i("AuthQuickStart", "IdentityId not present: ${id.error}")
    }
} catch (error: AuthException) {
    Log.e("AuthQuickStart", "Failed to fetch session", error)
}
```

</Block>
<Block name="RxJava">

```java
RxAmplify.Auth.fetchAuthSession()
    .subscribe(
        result -> {
            AWSCognitoAuthSession cognitoAuthSession = (AWSCognitoAuthSession) result;

            switch (cognitoAuthSession.getIdentityIdResult().getType()) {
                case SUCCESS:
                    Log.i("AuthQuickStart", "IdentityId: " + cognitoAuthSession.getIdentityIdResult().getValue());
                    break;
                case FAILURE:
                    Log.i("AuthQuickStart", "IdentityId not present because: " + cognitoAuthSession.getIdentityIdResult().getError().toString());
            }
        },
        error -> Log.e("AuthQuickStart", error.toString())
    );
```

</Block>
</BlockSwitcher>

## Force refreshing session

Through the plugin, you can force refresh the internal session by setting the `forceRefresh` option when calling the fetchAuthSession API.

<BlockSwitcher>
<Block name="Java">

```java
AuthFetchSessionOptions options = AuthFetchSessionOptions.builder().forceRefresh(true).build();
```

</Block>
<Block name="Kotlin - Callbacks">

```kotlin
val option = AuthFetchSessionOptions.builder().forceRefresh(true).build()
```

</Block>
<Block name="Kotlin - Coroutines">

```kotlin
val option = AuthFetchSessionOptions.builder().forceRefresh(true).build()
```

</Block>
<Block name="RxJava">

```java
AuthFetchSessionOptions options = AuthFetchSessionOptions.builder().forceRefresh(true).build();
```

</Block>
</BlockSwitcher>

</InlineFilter>
<InlineFilter filters={['swift']}>

An intentional decision with Amplify Auth was to avoid any public methods exposing credentials or manipulating them.

With Auth, you simply sign in and it handles everything else needed to keep the credentials up to date and vend them to the other categories.

However, if you need to access them in relation to working with an API outside Amplify or want access to AWS specific identifying information (e.g. IdentityId), you can access these implementation details by casting the result of `fetchAuthSession` as follows:

```swift
import AWSPluginsCore

do {
    let session = try await Amplify.Auth.fetchAuthSession()

    // Get user sub or identity id
    if let identityProvider = session as? AuthCognitoIdentityProvider {
        let usersub = try identityProvider.getUserSub().get()
        let identityId = try identityProvider.getIdentityId().get()
        print("User sub - \(usersub) and identity id \(identityId)")
    }

    // Get AWS credentials
    if let awsCredentialsProvider = session as? AuthAWSCredentialsProvider {
        let credentials = try awsCredentialsProvider.getAWSCredentials().get()
        // Do something with the credentials
    }

    // Get cognito user pool token
    if let cognitoTokenProvider = session as? AuthCognitoTokensProvider {
        let tokens = try cognitoTokenProvider.getCognitoTokens().get()
        // Do something with the JWT tokens
    }
} catch let error as AuthError {
    print("Fetch auth session failed with error - \(error)")
} catch {
}
```
If you have enabled guest user in Cognito Identity Pool and no user is signed in, you will be able to access only identityId and AWS credentials. All other session details will give you an error.

```swift
import AWSPluginsCore

do {
    let session = try await Amplify.Auth.fetchAuthSession()

    // Get identity id
    if let identityProvider = session as? AuthCognitoIdentityProvider {
        let identityId = try identityProvider.getIdentityId().get()
        print("Identity id \(identityId)")
    }

    // Get AWS credentials
    if let awsCredentialsProvider = session as? AuthAWSCredentialsProvider {
        let credentials = try awsCredentialsProvider.getAWSCredentials().get()
        // Do something with the credentials
    }
} catch let error as AuthError {
    print("Fetch auth session failed with error - \(error)")
} catch {
    print("Unexpected error: \(error)")
}
```

## Force refreshing session

Through the plugin, you can force refresh the internal session by passing an api options `forceRefresh` while calling the fetchAuthSession api.

```swift
Amplify.Auth.fetchAuthSession(options: .forceRefresh())

```
</InlineFilter>

{/* ## Next steps */}
{/* https://github.com/aws-amplify/docs/issues/7355 */}
{/* - [Learn how to access and validate user sessions server-side](/[platform]/build-a-backend/auth/connect-your-frontend/server-side/#session-validation) */}



Contents of build-a-backend_auth_connect-your-frontend_multi-step-sign-in_index.txt:
import { getCustomStaticPath } from '@/utils/getCustomStaticPath';

export const meta = {
  title: 'Multi-step sign-in',
  description:
    'Use Amazon Cognito Auth plugin to complete a multi step authentication flow',
  platforms: ['android', 'swift', 'flutter', 'react', 'nextjs', 'javascript', 'react-native', 'vue', 'angular']
};

export const getStaticPaths = async () => {
  return getCustomStaticPath(meta.platforms);
};

export function getStaticProps(context) {
  return {
    props: {
      platform: context.params.platform,
      meta
    }
  };
}

<InlineFilter filters={["angular", "javascript", "nextjs", "react", "react-native", "vue"]}>
After a user has finished signup, they can proceed to sign in. Amplify Auth signin flows can be multi-step processes. The required steps are determined by the configuration provided when you define your auth resources. See the [multi-factor authentication](/[platform]/build-a-backend/auth/concepts/multi-factor-authentication/) page for more information.

Depending on the configuration, you may need to call various APIs to finish authenticating a user's signin attempt. To identify the next step in a signin flow, inspect the `nextStep` parameter of the signin result.

```typescript
import {
	confirmSignIn,
	confirmSignUp,
	resetPassword,
	signIn,
} from 'aws-amplify/auth';

const { nextStep } = await signIn({
	username: 'hello@mycompany.com',
	password: 'hunter2',
});

if (
	nextStep.signInStep === 'CONFIRM_SIGN_IN_WITH_SMS_CODE' ||
	nextStep.signInStep === 'CONFIRM_SIGN_IN_WITH_EMAIL_CODE' ||
	nextStep.signInStep === 'CONFIRM_SIGN_IN_WITH_TOTP_CODE'
) {
	// collect OTP from user
	await confirmSignIn({
		challengeResponse: '123456',
	});
}

if (nextStep.signInStep === 'CONTINUE_SIGN_IN_WITH_MFA_SELECTION') {
	// present nextStep.allowedMFATypes to user
	// collect user selection
	await confirmSignIn({
		challengeResponse: 'EMAIL', // 'EMAIL', 'SMS', or 'TOTP'
	});
}

if (nextStep.signInStep === 'CONTINUE_SIGN_IN_WITH_MFA_SETUP_SELECTION') {
	// present nextStep.allowedMFATypes to user
	// collect user selection
	await confirmSignIn({
		challengeResponse: 'EMAIL', // 'EMAIL' or 'TOTP'
	});
}

if (nextStep.signInStep === 'CONTINUE_SIGN_IN_WITH_EMAIL_SETUP') {
	// collect email address from user
	await confirmSignIn({
		challengeResponse: 'hello@mycompany.com',
	});
}

if (nextStep.signInStep === 'CONTINUE_SIGN_IN_WITH_TOTP_SETUP') {
	// present nextStep.totpSetupDetails.getSetupUri() to user
	// collect OTP from user
	await confirmSignIn({
		challengeResponse: '123456',
	});
}

if (nextStep.signInStep === 'CONFIRM_SIGN_IN_WITH_PASSWORD') {
    // collect password from user
    await confirmSignIn({
        challengeResponse: 'hunter2',
    });
}

if (nextStep.signInStep === 'CONTINUE_SIGN_IN_WITH_FIRST_FACTOR_SELECTION') {
    // present nextStep.availableChallenges to user
    // collect user selection
    await confirmSignIn({
        challengeResponse: 'SMS_OTP', // or 'EMAIL_OTP', 'WEB_AUTHN', 'PASSWORD', 'PASSWORD_SRP'
    });
}

if (nextStep.signInStep === 'CONFIRM_SIGN_IN_WITH_CUSTOM_CHALLENGE') {
	// collect custom challenge answer from user
	await confirmSignIn({
		challengeResponse: 'custom-challenge-answer',
	});
}

if (nextStep.signInStep === 'CONFIRM_SIGN_IN_WITH_NEW_PASSWORD_REQUIRED') {
	// collect new password from user
	await confirmSignIn({
		challengeResponse: 'new-password',
	});
}

if (nextStep.signInStep === 'RESET_PASSWORD') {
	// initiate reset password flow
	await resetPassword({
		username: 'username',
	});
}

if (nextStep.signInStep === 'CONFIRM_SIGN_UP') {
	// user was not confirmed during sign up process
	// if user has confirmation code, invoke `confirmSignUp` api
	// otherwise, invoke `resendSignUpCode` to resend the code
	await confirmSignUp({
		username: 'username',
		confirmationCode: '123456',
	});
}

if (nextStep.signInStep === 'DONE') {
	// signin complete
}
```

## Confirm sign-in with SMS MFA

If the next step is `CONFIRM_SIGN_IN_WITH_SMS_CODE`, Amplify Auth has sent the user a random code over SMS and is waiting for the user to verify that code. To handle this step, your app's UI must prompt the user to enter the code. After the user enters the code, pass the value to the `confirmSignIn` API.

<Callout>

The result includes an `AuthCodeDeliveryDetails` member. It includes additional information about the code delivery, such as the partial phone number of the SMS recipient, which can be used to prompt the user on where to look for the code.

</Callout>

```ts
import { type SignInOutput, confirmSignIn } from '@aws-amplify/auth';

async function handleSignInResult(result: SignInOutput) {
	switch (result.nextStep.signInStep) {
		case 'CONFIRM_SIGN_IN_WITH_SMS_CODE': {
			const { codeDeliveryDetails } = result.nextStep;
			// OTP has been delivered to user via SMS
			// Inspect codeDeliveryDetails for additional delivery information
			console.log(
				`A confirmation code has been sent to ${codeDeliveryDetails?.destination}`,
			);
			console.log(
				`Please check your ${codeDeliveryDetails?.deliveryMedium} for the code.`,
			);
			break;
		}
	}
}

async function confirmMfaCode(mfaCode: string) {
	const result = await confirmSignIn({ challengeResponse: mfaCode });

	return handleSignInResult(result);
}

```

## Confirm sign-in with TOTP MFA

If the next step is `CONFIRM_SIGN_IN_WITH_TOTP_CODE`, you should prompt the user to enter the TOTP code from their associated authenticator app during set up. The code is a six-digit number that changes every 30 seconds. The user must enter the code before the 30-second window expires.

After the user enters the code, your implementation must pass the value to Amplify Auth `confirmSignIn` API.


```ts
import { type SignInOutput, confirmSignIn } from '@aws-amplify/auth';

async function handleSignInResult(result: SignInOutput) {
	switch (result.nextStep.signInStep) {
		case 'CONFIRM_SIGN_IN_WITH_TOTP_CODE': {
			// Prompt user to open their authenticator app to retrieve the code
			console.log(
				`Enter a one-time code from your registered authenticator app`,
			);
			break;
		}
	}
}
// Then, pass the TOTP code to `confirmSignIn`
async function confirmTotpCode(totpCode: string) {
	const result = await confirmSignIn({ challengeResponse: totpCode });

	return handleSignInResult(result);
}

```

## Confirm sign-in with Email MFA

If the next step is `CONFIRM_SIGN_IN_WITH_EMAIL_CODE`, Amplify Auth has sent the user a random code to their email address and is waiting for the user to verify that code. To handle this step, your app's UI must prompt the user to enter the code. After the user enters the code, pass the value to the `confirmSignIn` API.

<Callout>

The result includes an `AuthCodeDeliveryDetails` member. It includes additional information about the code delivery, such as the partial email address of the recipient, which can be used to prompt the user on where to look for the code.

</Callout>

```ts
import { type SignInOutput, confirmSignIn } from '@aws-amplify/auth';

async function handleSignInResult(result: SignInOutput) {
	switch (result.nextStep.signInStep) {
		case 'CONFIRM_SIGN_IN_WITH_EMAIL_CODE': {
			const { codeDeliveryDetails } = result.nextStep;
			// OTP has been delivered to user via Email
			// Inspect codeDeliveryDetails for additional delivery information
			console.log(
				`A confirmation code has been sent to ${codeDeliveryDetails?.destination}`,
			);
			console.log(
				`Please check your ${codeDeliveryDetails?.deliveryMedium} for the code.`,
			);
			break;
		}
	}
}

async function confirmMfaCode(mfaCode: string) {
	const result = await confirmSignIn({ challengeResponse: mfaCode });

	return handleSignInResult(result);
}

```


## Continue sign-in with MFA Selection

If the next step is `CONTINUE_SIGN_IN_WITH_MFA_SELECTION`, the user must select the MFA method to use. Amplify Auth currently supports SMS, TOTP, and EMAIL as MFA methods. After the user selects an MFA method, your implementation must pass the selected MFA method to Amplify Auth using `confirmSignIn` API.

The MFA types which are currently supported by Amplify Auth are:

- `SMS`
- `TOTP`
- `EMAIL`

Once Amplify receives the users selection, you can expect to handle a follow up `nextStep` corresponding with the selected MFA type for setup:
- If `SMS` is selected, `CONFIRM_SIGN_IN_WITH_SMS_CODE` will be the next step.
- If `TOTP` is selected, `CONFIRM_SIGN_IN_WITH_TOTP_CODE` will be the next step.
- If `EMAIL` is selected, `CONFIRM_SIGN_IN_WITH_EMAIL_CODE` will be the next step.


```ts
import { type SignInOutput, confirmSignIn } from '@aws-amplify/auth';

async function handleSignInResult(result: SignInOutput) {
	switch (result.nextStep.signInStep) {
		case 'CONTINUE_SIGN_IN_WITH_MFA_SELECTION': {
			const { allowedMFATypes } = result.nextStep;
			// Present available MFA options to user
			// Prompt for selection
			console.log(`There are multiple MFA options available for sign in.`);
			console.log(`Select an MFA type from the allowedMfaTypes list.`);
			break;
		}
	}
}

type MfaType = 'SMS' | 'TOTP' | 'EMAIL';

async function handleMfaSelection(mfaType: MfaType) {
	const result = await confirmSignIn({ challengeResponse: mfaType });

	return handleSignInResult(result);
}

```

## Continue sign-in with Email Setup

If the next step is `CONTINUE_SIGN_IN_WITH_EMAIL_SETUP`, then the user must provide an email address to complete the sign in process. Once this value has been collected from the user, call the `confirmSignIn` API to continue.

```ts
import { type SignInOutput, confirmSignIn } from '@aws-amplify/auth';

async function handleSignInResult(result: SignInOutput) {
	switch (result.nextStep.signInStep) {
		case 'CONTINUE_SIGN_IN_WITH_EMAIL_SETUP': {
			// Prompt the user to enter an email address they would like to use for MFA
			break;
		}
	}
}

// Then, pass the email address to `confirmSignIn`
async function confirmEmail(email: string) {
	const result = await confirmSignIn({ challengeResponse: email });

	return handleSignInResult(result);
}

```

## Continue sign-in with TOTP Setup

The `CONTINUE_SIGN_IN_WITH_TOTP_SETUP` step signifies that the user must set up TOTP before they can sign in. The step returns an associated value of type TOTPSetupDetails which must be used to configure an authenticator app like Microsoft Authenticator or Google Authenticator. TOTPSetupDetails provides a helper method called getSetupURI which generates a URI that can be used, for example, in a button to open the user's installed authenticator app. For more advanced use cases, TOTPSetupDetails also contains a sharedSecret which can be used to either generate a QR code or be manually entered into an authenticator app.

Once the authenticator app is set up, the user can generate a TOTP code and provide it to the library to complete the sign in process.


```ts
import { type SignInOutput, confirmSignIn } from '@aws-amplify/auth';

async function handleSignInResult(result: SignInOutput) {
	switch (result.nextStep.signInStep) {
		case 'CONTINUE_SIGN_IN_WITH_TOTP_SETUP': {
			const { totpSetupDetails } = result.nextStep;
			const appName = 'my_app_name';
			const setupUri = totpSetupDetails.getSetupUri(appName);
			// Open setupUri with an authenticator app
			// Prompt user to enter OTP code to complete setup
			break;
		}
	}
}

// Then, pass the collected OTP code to `confirmSignIn`
async function confirmTotpCode(totpCode: string) {
	const result = await confirmSignIn({ challengeResponse: totpCode });

	return handleSignInResult(result);
}

```

## Continue sign-in with MFA Setup Selection

If the next step is `CONTINUE_SIGN_IN_WITH_MFA_SETUP_SELECTION`, then the user must indicate which of the available MFA methods they would like to setup. After the user selects an MFA method to setup, your implementation must pass the selected MFA method to the `confirmSignIn` API.

The MFA types which are currently supported by Amplify Auth for setup are:

- `TOTP`
- `EMAIL`

Once Amplify receives the users selection, you can expect to handle a follow up `nextStep` corresponding with the selected MFA type for setup:
- If `EMAIL` is selected, `CONTINUE_SIGN_IN_WITH_EMAIL_SETUP` will be the next step.
- If `TOTP` is selected, `CONTINUE_SIGN_IN_WITH_TOTP_SETUP` will be the next step.

```ts
import { type SignInOutput, confirmSignIn } from '@aws-amplify/auth';

async function handleSignInResult(result: SignInOutput) {
	switch (result.nextStep.signInStep) {
		case 'CONTINUE_SIGN_IN_WITH_MFA_SETUP_SELECTION': {
			const { allowedMFATypes } = result.nextStep;
			// Present available MFA options to user
			// Prompt for selection
			console.log(`There are multiple MFA options available for setup.`);
			console.log(`Select an MFA type from the allowedMFATypes list.`);
			break;
		}
	}
}

type MfaType = 'SMS' | 'TOTP' | 'EMAIL';

async function handleMfaSelection(mfaType: MfaType) {
	const result = await confirmSignIn({ challengeResponse: mfaType });

	return handleSignInResult(result);
}

```

## Confirm sign-in with Password

If the next step is `CONFIRM_SIGN_IN_WITH_PASSWORD`, the user must provide their password as the first factor authentication method. To handle this step, your implementation should prompt the user to enter their password. After the user enters the password, pass the value to the `confirmSignIn` API.

```ts
import { type SignInOutput, confirmSignIn } from '@aws-amplify/auth';

async function handleSignInResult(result: SignInOutput) {
    switch (result.nextStep.signInStep) {
        case 'CONFIRM_SIGN_IN_WITH_PASSWORD': {
            // Prompt user to enter their password
            console.log(`Please enter your password.`);
            break;
        }
    }
}

async function confirmWithPassword(password: string) {
    const result = await confirmSignIn({ challengeResponse: password });

    return handleSignInResult(result);
}
```

## Continue sign-in with First Factor Selection

If the next step is `CONTINUE_SIGN_IN_WITH_FIRST_FACTOR_SELECTION`, the user must select a first factor method for authentication. After the user selects an option, your implementation should pass the selected method to the `confirmSignIn` API.

The first factor types which are currently supported by Amplify Auth are:
- `SMS_OTP`
- `EMAIL_OTP`
- `WEB_AUTHN`
- `PASSWORD`
- `PASSWORD_SRP`

Depending on your configuration and what factors the user has previously setup, not all options may be available. Only the available options will be presented in `availableChallenges` for selection.

Once Amplify receives the user's selection via the `confirmSignIn` API, you can expect to handle a follow up `nextStep` corresponding with the first factor type selected:
- If `SMS_OTP` is selected, `CONFIRM_SIGN_IN_WITH_SMS_CODE` will be the next step.
- If `EMAIL_OTP` is selected, `CONFIRM_SIGN_IN_WITH_EMAIL_CODE` will be the next step.
- If `PASSWORD` or `PASSWORD_SRP` is selected, `CONFIRM_SIGN_IN_WITH_PASSWORD` will be the next step.
- If `WEB_AUTHN` is selected, Amplify Auth will initiate the authentication ceremony on the user's device. If successful, the next step will be `DONE`.


```ts
import { type SignInOutput, confirmSignIn } from '@aws-amplify/auth';

async function handleSignInResult(result: SignInOutput) {
	switch (result.nextStep.signInStep) {
		case 'CONTINUE_SIGN_IN_WITH_FIRST_FACTOR_SELECTION': {
			const { availableChallenges } = result.nextStep;
			// Present available first factor options to user
			// Prompt for selection
			console.log(
				`There are multiple first factor options available for sign in.`,
			);
			console.log(
				`Select a first factor type from the availableChallenges list.`,
			);
			break;
		}
	}
}

async function handleFirstFactorSelection(firstFactorType: string) {
	const result = await confirmSignIn({ challengeResponse: firstFactorType });

	return handleSignInResult(result);
}

```

## Confirm sign-in with custom challenge

If the next step is `CONFIRM_SIGN_IN_WITH_CUSTOM_CHALLENGE`, Amplify Auth is awaiting completion of a custom authentication challenge. The challenge is based on the AWS Lambda trigger you configured as part of a custom sign in flow.

For example, your custom challenge Lambda may pass a prompt to the frontend which requires the user to enter a secret code.

```ts
import { type SignInOutput, confirmSignIn } from '@aws-amplify/auth';

async function handleSignInResult(result: SignInOutput) {
	switch (result.nextStep.signInStep) {
		case 'CONFIRM_SIGN_IN_WITH_CUSTOM_CHALLENGE': {
			const params = result.nextStep.additionalInfo;
			const hint = params.hint!;
			// Prompt user to enter custom challenge response
			console.log(hint); // `Enter the secret code`
			break;
		}
	}
}

```

To complete this step, you should prompt the user for the custom challenge answer, and pass the answer to the `confirmSignIn` API.

```ts
async function confirmCustomChallenge(answer: string) {
	const result = await confirmSignIn({ challengeResponse: answer });

	return handleSignInResult(result);
}
```

<Callout warning>

**Special Handling on `confirmSignIn`**

If `failAuthentication=true` is returned by the Lambda, Cognito will invalidate the session of the request. This is represented by a `NotAuthorizedException` and requires restarting the sign-in flow by calling `signIn` again.

</Callout>

## Confirm sign-in with new password

If the next step is `CONFIRM_SIGN_IN_WITH_NEW_PASSWORD_REQUIRED`, Amplify Auth requires the user choose a new password they proceeding with the sign in. 

Prompt the user for a new password and pass it to the `confirmSignIn` API.

See the [sign-in](/[platform]/build-a-backend/auth/connect-your-frontend/sign-in/) and [manage-password](/[platform]/build-a-backend/auth/manage-users/manage-passwords/) docs for more information.

```ts
import { type SignInOutput, confirmSignIn } from '@aws-amplify/auth';

async function handleSignInResult(result: SignInOutput) {
	switch (result.nextStep.signInStep) {
		case 'CONFIRM_SIGN_IN_WITH_NEW_PASSWORD_REQUIRED': {
			// Prompt user to enter a new password
			console.log(`Please enter a new password.`);
			break;
		}
	}
}

async function confirmNewPassword(newPassword: string) {
	const result = await confirmSignIn({ challengeResponse: newPassword });

	return handleSignInResult(result);
}

```

## Reset password

If the next step is `RESET_PASSWORD`, Amplify Auth requires that the user reset their password before proceeding.
Use the `resetPassword` API to guide the user through resetting their password, then call `signIn` to restart the sign-in flow.

See the [reset password](/[platform]/build-a-backend/auth/manage-users/manage-passwords/) docs for more information.

```ts
import {
	type ResetPasswordOutput,
	type SignInOutput,
	resetPassword,
} from '@aws-amplify/auth';

async function handleSignInResult(result: SignInOutput) {
	switch (result.nextStep.signInStep) {
		case 'RESET_PASSWORD': {
			const resetPasswordResult = await resetPassword({ username });
			// initiate reset password flow
			await handleResetPasswordResult(resetPasswordResult);
			break;
		}
	}
}

async function handleResetPasswordResult(
	resetPasswordResult: ResetPasswordOutput,
) {
	switch (resetPasswordResult.nextStep.resetPasswordStep) {
		case 'CONFIRM_RESET_PASSWORD_WITH_CODE': {
			const { codeDeliveryDetails } = resetPasswordResult.nextStep;
			console.log(
				`A confirmation code has been sent to ${codeDeliveryDetails.destination}.`,
			);
			console.log(
				`Please check your ${codeDeliveryDetails.destination} for the code.`,
			);
			break;
		}
		case 'DONE': {
			console.log(`Successfully reset password.`);
			break;
		}
	}
}

```

## Confirm Signup

If the next step is `CONFIRM_SIGN_UP`, Amplify Auth requires that the user confirm their email or phone number before proceeding.
Use the `resendSignUpCode` API to send a new sign up code to the registered email or phone number, followed by `confirmSignUp` to complete the sign up.

See the [sign up](/[platform]/build-a-backend/auth/connect-your-frontend/sign-up/) docs for more information.

<Callout>

The result includes an `AuthCodeDeliveryDetails` member. It includes additional information about the code delivery, such as the partial phone number of the SMS recipient, which can be used to prompt the user on where to look for the code.

</Callout>

```ts
import {
	type SignInOutput,
	confirmSignUp,
	resendSignUpCode,
} from '@aws-amplify/auth';

async function handleSignInResult(result: SignInOutput) {
	switch (result.nextStep.signInStep) {
		case 'CONFIRM_SIGN_UP': {
			// Resend sign up code to the registered user
			const { destination, deliveryMedium } = await resendSignUpCode({
				username,
			});
			console.log(`A confirmation code has been sent to ${destination}.`);
			console.log(`Please check your ${deliveryMedium} for the code.`);
			break;
		}
	}
}

async function handleConfirmSignUp(username: string, confirmationCode: string) {
	await confirmSignUp({
		username,
		confirmationCode,
	});
}

```

Once the sign up is confirmed, call `signIn` again to restart the sign-in flow.

## Done

The sign-in flow is complete when the next step is `DONE`, which means the user is successfully authenticated. 
As a convenience, the `SignInResult` also provides the `isSignedIn` property, which will be true if the next step is `DONE`.

```ts
import { type SignInOutput } from '@aws-amplify/auth';

async function handleSignInResult(result: SignInOutput) {
	switch (result.nextStep.signInStep) {
		case 'DONE': {
			// `result.isSignedIn` is `true`
			console.log(`Sign in is complete.`);
			break;
		}
	}
}

```
</InlineFilter>


<InlineFilter filters={['flutter']}>
After a user has finished signup, they can proceed to sign in. Amplify Auth signin flows can be multi step processes. The required steps are determined by the configuration you provided when you define your auth resources like described on [Manage MFA Settings](/[platform]/build-a-backend/auth/concepts/multi-factor-authentication/) page.

Depending on the configuration, you may need to call various APIs to finish authenticating a user's signin attempt. To identify the next step in a signin flow, inspect the `nextStep` parameter in the signin result.

<Callout warning>
*New enumeration values*

When Amplify adds a new enumeration value (e.g., a new enum class entry or sealed class subtype in Kotlin, or a new enum value in Swift/Dart/Kotlin), it will publish a new minor version of the Amplify Library. Plugins that switch over enumeration values should include default handlers (an else branch in Kotlin or a default statement in Swift/Dart/Kotlin) to ensure that they are not impacted by new enumeration values.

</Callout>


The `Amplify.Auth.signIn` API returns a `SignInResult` object which indicates whether the sign-in flow is
complete or whether additional steps are required before the user is signed in.

To see if additional signin steps are required, inspect the sign in result's `nextStep.signInStep` property.
- If the sign-in step is `done`, the flow is complete and the user is signed in.
- If the sign-in step is not `done`, one or more additional steps are required. These are explained in detail below.


<Callout>

The `signInStep` property is an enum of type `AuthSignInStep`. Depending on its value, your code should take one of the actions mentioned on this page.

</Callout>

```dart
Future<SignInResult> signInWithCognito(
  String username,
  String password,
) async {
  final SignInResult result = await Amplify.Auth.signIn(
    username: username, 
    password: password,
  );
  return _handleSignInResult(result);
}

Future<void> _handleSignInResult(SignInResult result) async {
  switch (result.nextStep.signInStep) {
    case AuthSignInStep.continueSignInWithMfaSelection:
      // Handle select from MFA methods case
    case AuthSignInStep.continueSignInWithMfaSetupSelection:
      // Handle select from MFA methods available to setup
    case AuthSignInStep.continueSignInWithEmailMfaSetup:
      // Handle email setup case
    case AuthSignInStep.confirmSignInWithOtpCode:
      // Handle email MFA case
    case AuthSignInStep.continueSignInWithTotpSetup:
      // Handle TOTP setup case
    case AuthSignInStep.confirmSignInWithTotpMfaCode:
      // Handle TOTP MFA case
    case AuthSignInStep.confirmSignInWithSmsMfaCode:
      // Handle SMS MFA case
    case AuthSignInStep.confirmSignInWithNewPassword:
      // Handle new password case
    case AuthSignInStep.confirmSignInWithCustomChallenge:
      // Handle custom challenge case
    case AuthSignInStep.resetPassword:
      // Handle reset password case
    case AuthSignInStep.confirmSignUp:
      // Handle confirm sign up case
    case AuthSignInStep.done:
      safePrint('Sign in is complete');
  }
}
```
## Confirm sign-in with SMS MFA

If the next step is `confirmSignInWithSmsMfaCode`, Amplify Auth has sent the user a random code over SMS and is waiting for the user to verify that code. To handle this step, your app's UI must prompt the user to enter the code. After the user enters the code, pass the value to the `confirmSignIn` API.

<Callout>

The result includes an `AuthCodeDeliveryDetails` member. It includes additional information about the code delivery, such as the partial phone number of 
the SMS recipient, which can be used to prompt the user on where to look for the code.

</Callout>

```dart
Future<void> _handleSignInResult(SignInResult result) async {
  switch (result.nextStep.signInStep) {
    case AuthSignInStep.confirmSignInWithSmsMfaCode:
      final codeDeliveryDetails = result.nextStep.codeDeliveryDetails!;
      _handleCodeDelivery(codeDeliveryDetails);
    // ...
  }
}

void _handleCodeDelivery(AuthCodeDeliveryDetails codeDeliveryDetails) {
  safePrint(
    'A confirmation code has been sent to ${codeDeliveryDetails.destination}. '
    'Please check your ${codeDeliveryDetails.deliveryMedium.name} for the code.',
  );
}
```

```dart
Future<void> confirmMfaUser(String mfaCode) async {
  try {
    final result = await Amplify.Auth.confirmSignIn(
      confirmationValue: mfaCode,
    );
    return _handleSignInResult(result);
  } on AuthException catch (e) {
    safePrint('Error confirming MFA code: ${e.message}');
  }
}
```

## Confirm sign-in with TOTP MFA

If the next step is `confirmSignInWithTOTPCode`, you should prompt the user to enter the TOTP code from their associated authenticator app during set up. The code is a six-digit number that changes every 30 seconds. The user must enter the code before the 30-second window expires.

After the user enters the code, your implementation must pass the value to Amplify Auth `confirmSignIn` API.


```dart
Future<void> _handleSignInResult(SignInResult result) async {
  switch (result.nextStep.signInStep) {
    // ···
    case AuthSignInStep.confirmSignInWithTotpMfaCode:
      safePrint('Enter a one-time code from your registered authenticator app');
    // ···
  }
}

// Then, pass the TOTP code to `confirmSignIn`

Future<void> confirmTotpUser(String totpCode) async {
  try {
    final result = await Amplify.Auth.confirmSignIn(
      confirmationValue: totpCode,
    );
    return _handleSignInResult(result);
  } on AuthException catch (e) {
    safePrint('Error confirming TOTP code: ${e.message}');
  }
}
```

## Confirm sign-in with Email MFA

If the next step is `confirmSignInWithOtpCode`, Amplify Auth has sent the user a random code to their email address and is waiting for the user to verify that code. To handle this step, your app's UI must prompt the user to enter the code. After the user enters the code, pass the value to the `confirmSignIn` API.

<Callout>

The result includes an `AuthCodeDeliveryDetails` member. It includes additional information about the code delivery, such as the partial email address of 
the recipient, which can be used to prompt the user on where to look for the code.

</Callout>

```dart
Future<void> _handleSignInResult(SignInResult result) async {
  switch (result.nextStep.signInStep) {
    case AuthSignInStep.confirmSignInWithOtpCode:
      final codeDeliveryDetails = result.nextStep.codeDeliveryDetails!;
      _handleCodeDelivery(codeDeliveryDetails);
    // ...
  }
}

void _handleCodeDelivery(AuthCodeDeliveryDetails codeDeliveryDetails) {
  safePrint(
    'A confirmation code has been sent to ${codeDeliveryDetails.destination}. '
    'Please check your ${codeDeliveryDetails.deliveryMedium.name} for the code.',
  );
}
```

```dart
Future<void> confirmMfaUser(String mfaCode) async {
  try {
    final result = await Amplify.Auth.confirmSignIn(
      confirmationValue: mfaCode,
    );
    return _handleSignInResult(result);
  } on AuthException catch (e) {
    safePrint('Error confirming MFA code: ${e.message}');
  }
}
```


## Continue sign-in with MFA Selection

If the next step is `continueSignInWithMFASelection`, the user must select the MFA method to use. Amplify Auth currently supports SMS, TOTP, and email as MFA methods. After the user selects an MFA method, your implementation must pass the selected MFA method to Amplify Auth using `confirmSignIn` API.

The MFA types which are currently supported by Amplify Auth are:

- `MfaType.sms`
- `MfaType.totp`
- `MfaType.email`

```dart
Future<void> _handleSignInResult(SignInResult result) async {
  switch (result.nextStep.signInStep) {
    // ···
    case AuthSignInStep.continueSignInWithMfaSelection:
      final allowedMfaTypes = result.nextStep.allowedMfaTypes!;
      final selection = await _promptUserPreference(allowedMfaTypes);
      return _handleMfaSelection(selection);
    // ···
  }
}

Future<MfaType> _promptUserPreference(Set<MfaType> allowedTypes) async {
  // ···
}

Future<void> _handleMfaSelection(MfaType selection) async {
  try {
    final result = await Amplify.Auth.confirmSignIn(
      confirmationValue: selection.confirmationValue,
    );
    return _handleSignInResult(result);
  } on AuthException catch (e) {
    safePrint('Error resending code: ${e.message}');
  }
}
```

## Continue sign-in with Email Setup

If the next step is `continueSignInWithEmailMfaSetup`, then the user must provide an email address to complete the sign in process. Once this value has been collected from the user, call the `confirmSignIn` API to continue.

```dart
Future<void> _handleSignInResult(SignInResult result) async {
  switch (result.nextStep.signInStep) {
    // ···
    case AuthSignInStep.continueSignInWithEmailMfaSetup:
    // Prompt user to enter an email address they would like to use for MFA
    // ···
  }
}

// Then, pass the email address to `confirmSignIn`

Future<void> confirmEmailUser(String emailAddress) async {
  try {
    final result = await Amplify.Auth.confirmSignIn(
      confirmationValue: emailAddress,
    );
    return _handleSignInResult(result);
  } on AuthException catch (e) {
    safePrint('Error confirming email address: ${e.message}');
  }
}
```

## Continue sign-in with TOTP Setup

If the next step is `continueSignInWithTOTPSetup`, then the user must provide a TOTP code to complete the sign in process. The step returns an associated value of type `TOTPSetupDetails` which would be used for generating TOTP. `TOTPSetupDetails` provides a helper method called `getSetupURI` that can be used to generate a URI, which can be used by native password managers for TOTP association. For example. if the URI is used on Apple platforms, it will trigger the platform's native password manager to associate TOTP with the account. For more advanced use cases, `TOTPSetupDetails` also contains the `sharedSecret` that will be used to either generate a QR code or can be manually entered into an authenticator app.

Once the authenticator app is set up, the user can generate a TOTP code and provide it to the library to complete the sign in process.


```dart
Future<void> _handleSignInResult(SignInResult result) async {
  switch (result.nextStep.signInStep) {
    // ···
    case AuthSignInStep.continueSignInWithTotpSetup:
      final totpSetupDetails = result.nextStep.totpSetupDetails!;
      final setupUri = totpSetupDetails.getSetupUri(appName: 'MyApp');
      safePrint('Open URI to complete setup: $setupUri');
    // ···
  }
}

// Then, pass the TOTP code to `confirmSignIn`

Future<void> confirmTotpUser(String totpCode) async {
  try {
    final result = await Amplify.Auth.confirmSignIn(
      confirmationValue: totpCode,
    );
    return _handleSignInResult(result);
  } on AuthException catch (e) {
    safePrint('Error confirming TOTP code: ${e.message}');
  }
}
```

## Continue sign-in with MFA Setup Selection
If the next step is `continueSignInWithMfaSetupSelection`, then the user must indicate which of the available MFA methods they would like to setup. After the user selects an MFA method to setup, your implementation must pass the selected MFA method to the `confirmSignIn` API.

The MFA types which are currently supported by Amplify Auth are:

- `MfaType.sms`
- `MfaType.totp`
- `MfaType.email`

```dart
Future<void> _handleSignInResult(SignInResult result) async {
  switch (result.nextStep.signInStep) {
    // ···
    case AuthSignInStep.continueSignInWithMfaSetupSelection:
      final allowedMfaTypes = result.nextStep.allowedMfaTypes!;
      final selection = await _promptUserPreference(allowedMfaTypes);
      return _handleMfaSelection(selection);
    // ···
  }
}

Future<MfaType> _promptUserPreference(Set<MfaType> allowedTypes) async {
  // ···
}

Future<void> _handleMfaSelection(MfaType selection) async {
  try {
    final result = await Amplify.Auth.confirmSignIn(
      confirmationValue: selection.confirmationValue,
    );
    return _handleSignInResult(result);
  } on AuthException catch (e) {
    safePrint('Error selecting MFA method: ${e.message}');
  }
}
```

## Confirm sign-in with custom challenge

If the next step is `confirmSignInWithCustomChallenge`, Amplify Auth is awaiting completion of a custom authentication challenge. The challenge is based on the AWS Lambda trigger you configured as part of a [custom sign in flow](/[platform]/build-a-backend/auth/customize-auth-lifecycle/custom-auth-flows/#sign-in-a-user).

For example, your custom challenge Lambda may pass a prompt to the frontend which requires the user to enter a secret code.

```dart
Future<void> _handleSignInResult(SignInResult result) async {
  switch (result.nextStep.signInStep) {
    // ...
    case AuthSignInStep.confirmSignInWithCustomChallenge:
      final parameters = result.nextStep.additionalInfo;
      final hint = parameters['hint']!;
      safePrint(hint); // "Enter the secret code"
    // ...
  }
}
```

To complete this step, you should prompt the user for the custom challenge answer, and pass the answer to the `confirmSignIn` API.

```dart
Future<void> confirmCustomChallenge(String answer) async {
  try {
    final result = await Amplify.Auth.confirmSignIn(
      confirmationValue: answer,
    );
    return _handleSignInResult(result);
  } on AuthException catch (e) {
    safePrint('Error confirming custom challenge: ${e.message}');
  }
}
```

<Callout warning>

**Special Handling on `confirmSignIn`**

If `failAuthentication=true` is returned by the Lambda, Cognito will invalidate the session of the request. This is represented by a `NotAuthorizedException` and requires restarting the sign-in flow by calling `Amplify.Auth.signIn` again.

</Callout>

## Confirm sign-in with new password
If the next step is `confirmSignInWithNewPassword`, Amplify Auth requires the user choose a new password they proceeding with the sign in. 

Prompt the user for a new password and pass it to the `confirmSignIn` API.

```dart
Future<void> _handleSignInResult(SignInResult result) async {
  switch (result.nextStep.signInStep) {
    // ...
    case AuthSignInStep.confirmSignInWithNewPassword:
      safePrint('Please enter a new password');
    // ...
  }
}
```

```dart
Future<void> confirmNewPassword(String newPassword) async {
  try {
    final result = await Amplify.Auth.confirmSignIn(
      confirmationValue: newPassword,
    );
    return _handleSignInResult(result);
  } on AuthException catch (e) {
    safePrint('Error confirming new password: ${e.message}');
  }
}
```

## Reset password
If the next step is `resetPassword`, Amplify Auth requires that the user reset their password before proceeding.
Use the `resetPassword` API to guide the user through resetting their password, then call `Amplify.Auth.signIn`
when that's complete to restart the sign-in flow.

See the [reset password](/[platform]/build-a-backend/auth/manage-users/manage-passwords/) docs for more information.

```dart
Future<void> _handleSignInResult(SignInResult result) async {
  switch (result.nextStep.signInStep) {
    // ...
    case AuthSignInStep.resetPassword:
      final resetResult = await Amplify.Auth.resetPassword(
        username: username,
      );
      await _handleResetPasswordResult(resetResult);
    // ...
  }
}

Future<void> _handleResetPasswordResult(ResetPasswordResult result) async {
  switch (result.nextStep.updateStep) {
    case AuthResetPasswordStep.confirmResetPasswordWithCode:
      final codeDeliveryDetails = result.nextStep.codeDeliveryDetails!;
      _handleCodeDelivery(codeDeliveryDetails);
    case AuthResetPasswordStep.done:
      safePrint('Successfully reset password');
  }
}

void _handleCodeDelivery(AuthCodeDeliveryDetails codeDeliveryDetails) {
  safePrint(
    'A confirmation code has been sent to ${codeDeliveryDetails.destination}. '
    'Please check your ${codeDeliveryDetails.deliveryMedium.name} for the code.',
  );
}
```
## Confirm Signup
If the next step is `resetPassword`, Amplify Auth requires that the user confirm their email or phone number before proceeding.
Use the `resendSignUpCode` API to send a new sign up code to the registered email or phone number, followed by `confirmSignUp` 
to complete the sign up.

See the [confirm sign up](/[platform]/build-a-backend/auth/connect-your-frontend/sign-up/#confirm-sign-up) docs for more information.

<Callout>

The result includes an `AuthCodeDeliveryDetails` member. It includes additional information about the code delivery, such as the partial phone number of 
the SMS recipient, which can be used to prompt the user on where to look for the code.

</Callout>

```dart
Future<void> _handleSignInResult(SignInResult result) async {
  switch (result.nextStep.signInStep) {
    // ...
    case AuthSignInStep.confirmSignUp:
      // Resend the sign up code to the registered device.
      final resendResult = await Amplify.Auth.resendSignUpCode(
        username: username,
      );
      _handleCodeDelivery(resendResult.codeDeliveryDetails);
    // ...
  }
}

void _handleCodeDelivery(AuthCodeDeliveryDetails codeDeliveryDetails) {
  safePrint(
    'A confirmation code has been sent to ${codeDeliveryDetails.destination}. '
    'Please check your ${codeDeliveryDetails.deliveryMedium.name} for the code.',
  );
}
```

```dart
Future<void> confirmSignUp({
  required String username,
  required String confirmationCode,
}) async {
  try {
    await Amplify.Auth.confirmSignUp(
      username: username,
      confirmationCode: confirmationCode,
    );
  } on AuthException catch (e) {
    safePrint('Error confirming sign up: ${e.message}');
  }
}
```

Once the sign up is confirmed, call `Amplify.Auth.signIn` again to restart the sign-in flow.

## Done

The sign-in flow is complete when the next step is `done`, which means the user is successfully authenticated. 
As a convenience, the `SignInResult` also provides the `isSignedIn` property, which will be true if the next step is `done`.

```dart
Future<void> _handleSignInResult(SignInResult result) async {
  switch (result.nextStep.signInStep) {
    // ...
    case AuthSignInStep.done:
      // Could also check that `result.isSignedIn` is `true`
      safePrint('Sign in is complete');
  }
}
```
</InlineFilter>

<InlineFilter  filters={['android']}>
After a user has finished signup, they can proceed to sign in. Amplify Auth signin flows can be multi step processes. The required steps are determined by the configuration you provided when you define your auth resources like described on [Manage MFA Settings](/[platform]/build-a-backend/auth/concepts/multi-factor-authentication/) page. 

Depending on the configuration, you may need to call various APIs to finish authenticating a user's signin attempt. To identify the next step in a signin flow, inspect the `nextStep` parameter in the signin result.

<Callout warning>
*New enumeration values*

When Amplify adds a new enumeration value (e.g., a new enum class entry or sealed class subtype in Kotlin, or a new enum value in Swift/Dart/Kotlin), it will publish a new minor version of the Amplify Library. Plugins that switch over enumeration values should include default handlers (an else branch in Kotlin or a default statement in Swift/Dart/Kotlin) to ensure that they are not impacted by new enumeration values.

</Callout>


When called successfully, the signin APIs will return an `AuthSignInResult`. Inspect the `nextStep` property in the result to see if additional signin steps are required.
The `nextStep` property is of enum type `AuthSignInStep`. Depending on its value, your code should take one of the following actions:

<BlockSwitcher>

<Block name="Java">

```java
try {
    Amplify.Auth.signIn(
        "hello@example.com",
        "password",
        result ->
        {
            AuthNextSignInStep nextStep = result.getNextStep();
            switch (nextStep.getSignInStep()) {
                case CONFIRM_SIGN_IN_WITH_TOTP_CODE: {
                    Log.i("AuthQuickstart", "Received next step as confirm sign in with TOTP code");
                    // Prompt the user to enter the TOTP code generated in their authenticator app
                    // Then invoke `confirmSignIn` api with the code
                    break;
                }
                case CONTINUE_SIGN_IN_WITH_MFA_SETUP_SELECTION: {
                    Log.i("AuthQuickstart", "Received next step as continue sign in by selecting an MFA method to setup");
                    Log.i("AuthQuickstart", "Allowed MFA types for setup" + nextStep.getAllowedMFATypes());
                    // Prompt the user to select the MFA type they want to setup
                    // Then invoke `confirmSignIn` api with the MFA type
                    break;
                }
                case CONTINUE_SIGN_IN_WITH_EMAIL_MFA_SETUP: {
                    Log.i("AuthQuickstart", "Received next step as continue sign in by setting up email MFA");
                    // Prompt the user to enter the email address they would like to use to receive OTPs
                    // Then invoke `confirmSignIn` api with the email address
                    break;
                }
                case CONTINUE_SIGN_IN_WITH_TOTP_SETUP: {
                    Log.i("AuthQuickstart", "Received next step as continue sign in by setting up TOTP");
                    Log.i("AuthQuickstart", "Shared secret that will be used to set up TOTP in the authenticator app" + nextStep.getTotpSetupDetails().getSharedSecret());
                    // Prompt the user to enter the TOTP code generated in their authenticator app
                    // Then invoke `confirmSignIn` api with the code
                    break;
                }
                case CONTINUE_SIGN_IN_WITH_MFA_SELECTION: {
                    Log.i("AuthQuickstart", "Received next step as continue sign in by selecting MFA type");
                    Log.i("AuthQuickstart", "Allowed MFA type" + nextStep.getAllowedMFATypes());
                    // Prompt the user to select the MFA type they want to use
                    // Then invoke `confirmSignIn` api with the MFA type
                    break;
                }
                case CONTINUE_SIGN_IN_WITH_FIRST_FACTOR_SELECTION: {
                    Log.i("AuthQuickstart", "Available authentication factors for this user: " + result.getNextStep().getAvailableFactors());
                    // Prompt the user to select which authentication factor they want to use to sign-in
                    // Then invoke `confirmSignIn` api with that selection
                    break;
                }
                case CONFIRM_SIGN_IN_WITH_SMS_MFA_CODE: {
                    Log.i("AuthQuickstart", "SMS code sent to " + nextStep.getCodeDeliveryDetails().getDestination());
                    Log.i("AuthQuickstart", "Additional Info :" + nextStep.getAdditionalInfo());
                    // Prompt the user to enter the SMS MFA code they received
                    // Then invoke `confirmSignIn` api with the code
                    break;
                }
                case CONFIRM_SIGN_IN_WITH_OTP: {
                    Log.i("AuthQuickstart", "OTP code sent to " + nextStep.getCodeDeliveryDetails().getDestination());
                    Log.i("AuthQuickstart", "Additional Info :" + nextStep.getAdditionalInfo());
                    // Prompt the user to enter the OTP MFA code they received
                    // Then invoke `confirmSignIn` api with the code
                    break;
                }
              	case CONFIRM_SIGN_IN_WITH_PASSWORD: {
                		Log.i("AuthQuickstart", "Received next step as confirm sign in with password");
                		// Prompt the user to enter their password
                		// Then invoke `confirmSignIn` api with that password
                		break;
                }
                case CONFIRM_SIGN_IN_WITH_CUSTOM_CHALLENGE: {
                    Log.i("AuthQuickstart", "Custom challenge, additional info: " + nextStep.getAdditionalInfo());
                    // Prompt the user to enter custom challenge answer
                    // Then invoke `confirmSignIn` api with the answer
                    break;
                }
                case CONFIRM_SIGN_IN_WITH_NEW_PASSWORD: {
                    Log.i("AuthQuickstart", "Sign in with new password, additional info: " + nextStep.getAdditionalInfo());
                    // Prompt the user to enter a new password
                    // Then invoke `confirmSignIn` api with new password
                    break;
                }
                case DONE: {
                    Log.i("AuthQuickstart", "SignIn complete");
                    // User has successfully signed in to the app
                    break;
                }
            }
        },
        error -> {
            if (error instanceof UserNotConfirmedException) {
                // User was not confirmed during the signup process.
                // Invoke `confirmSignUp` api to confirm the user if
                // they have the confirmation code. If they do not have the
                // confirmation code, invoke `resendSignUpCode` to send the
                // code again.
                // After the user is confirmed, invoke the `signIn` api again.
                Log.i("AuthQuickstart", "Signup confirmation required" + error);
            } else if (error instanceof PasswordResetRequiredException) {
                // User needs to reset their password.
                // Invoke `resetPassword` api to start the reset password
                // flow, and once reset password flow completes, invoke
                // `signIn` api to trigger signIn flow again.
                Log.i("AuthQuickstart", "Password reset required" + error);
            } else {
                Log.e("AuthQuickstart", "SignIn failed: " + error);
            }
        }
    );
} catch (Exception error) {
    Log.e("AuthQuickstart", "Unexpected error occurred: " + error);
}
```

</Block>

<Block name="Kotlin - Callbacks">

```kotlin
try {
    Amplify.Auth.signIn(
        "hello@example.com",
        "password",
        { result ->
            val nextStep  = result.nextStep
            when(nextStep.signInStep){
                AuthSignInStep.CONFIRM_SIGN_IN_WITH_TOTP_CODE -> {
                    Log.i("AuthQuickstart", "Received next step as confirm sign in with TOTP code")
                    // Prompt the user to enter the TOTP code generated in their authenticator app
                    // Then invoke `confirmSignIn` api with the code
                }
                AuthSignInStep.CONTINUE_SIGN_IN_WITH_MFA_SETUP_SELECTION -> {
                    Log.i("AuthQuickstart", "Received next step as continue sign in by selecting an MFA method to setup")
                    Log.i("AuthQuickstart", "Allowed MFA types for setup ${nextStep.allowedMFATypes}")
                    // Prompt the user to select the MFA type they want to setup
                    // Then invoke `confirmSignIn` api with the MFA type
                }
                AuthSignInStep.CONTINUE_SIGN_IN_WITH_EMAIL_MFA_SETUP -> {
                    Log.i("AuthQuickstart", "Received next step as continue sign in by setting up email MFA")
                    // Prompt the user to enter the email address they would like to use to receive OTPs
                    // Then invoke `confirmSignIn` api with the email address
                }
                AuthSignInStep.CONTINUE_SIGN_IN_WITH_TOTP_SETUP -> {
                    Log.i("AuthQuickstart", "Received next step as continue sign in by setting up TOTP")
                    Log.i("AuthQuickstart", "Shared secret that will be used to set up TOTP in the authenticator app ${nextStep.totpSetupDetails?.sharedSecret}")
                    // Prompt the user to enter the TOTP code generated in their authenticator app
                    // Then invoke `confirmSignIn` api with the code
                }
                AuthSignInStep.CONTINUE_SIGN_IN_WITH_MFA_SELECTION -> {
                    Log.i("AuthQuickstart", "Received next step as continue sign in by selecting MFA type")
                    Log.i("AuthQuickstart", "Allowed MFA types ${nextStep.allowedMFATypes}")
                    // Prompt the user to select the MFA type they want to use
                    // Then invoke `confirmSignIn` api with the MFA type
                }
                AuthSignInStep.CONTINUE_SIGN_IN_WITH_FIRST_FACTOR_SELECTION -> {
                    Log.i("AuthQuickstart", "Available authentication factors for this user:  ${result.nextStep.availableFactors}")
                    // Prompt the user to select which authentication factor they want to use to sign-in
                    // Then invoke `confirmSignIn` api with that selection
                }
                AuthSignInStep.CONFIRM_SIGN_IN_WITH_SMS_MFA_CODE -> {
                    Log.i("AuthQuickstart", "SMS code sent to ${nextStep.codeDeliveryDetails?.destination}")
                    Log.i("AuthQuickstart", "Additional Info ${nextStep.additionalInfo}")
                    // Prompt the user to enter the SMS MFA code they received
                    // Then invoke `confirmSignIn` api with the code
                }
                AuthSignInStep.CONFIRM_SIGN_IN_WITH_OTP -> {
                    Log.i("AuthQuickstart", "OTP code sent to ${nextStep.codeDeliveryDetails?.destination}")
                    Log.i("AuthQuickstart", "Additional Info ${nextStep.additionalInfo}")
                    // Prompt the user to enter the OTP MFA code they received
                    // Then invoke `confirmSignIn` api with the code
                }
                AuthSignInStep.CONFIRM_SIGN_IN_WITH_PASSWORD -> {
                    Log.i("AuthQuickstart", "Received next step as confirm sign in with password")
                    // Prompt the user to enter their password
                    // Then invoke `confirmSignIn` api with that password
                }
                AuthSignInStep.CONFIRM_SIGN_IN_WITH_CUSTOM_CHALLENGE -> {
                    Log.i("AuthQuickstart","Custom challenge, additional info: ${nextStep.additionalInfo}")
                    // Prompt the user to enter custom challenge answer
                    // Then invoke `confirmSignIn` api with the answer
                }
                AuthSignInStep.CONFIRM_SIGN_IN_WITH_NEW_PASSWORD -> {
                    Log.i("AuthQuickstart", "Sign in with new password, additional info: ${nextStep.additionalInfo}")
                    // Prompt the user to enter a new password
                    // Then invoke `confirmSignIn` api with new password
                }
                AuthSignInStep.DONE -> {
                    Log.i("AuthQuickstart", "SignIn complete")
                    // User has successfully signed in to the app
                }
            }

        }
    ) { error ->
        when (error) {
            is UserNotConfirmedException -> {
                // User was not confirmed during the signup process.
                // Invoke `confirmSignUp` api to confirm the user if
                // they have the confirmation code. If they do not have the
                // confirmation code, invoke `resendSignUpCode` to send the
                // code again.
                // After the user is confirmed, invoke the `signIn` api again.
                Log.e("AuthQuickstart", "Signup confirmation required", error)
            }
            is PasswordResetRequiredException -> {
                // User needs to reset their password.
                // Invoke `resetPassword` api to start the reset password
                // flow, and once reset password flow completes, invoke
                // `signIn` api to trigger signIn flow again.
                Log.e("AuthQuickstart", "Password reset required", error)
            }
            else -> {
                Log.e("AuthQuickstart", "Unexpected error occurred: $error")
            }
        }
    }
} catch (error: Exception) {
    Log.e("AuthQuickstart", "Unexpected error occurred: $error")
}
```

</Block>

<Block name="Kotlin - Coroutines">

```kotlin
try {
    val result = Amplify.Auth.signIn(
        "hello@example.com",
        "password"
    )
    val nextStep = result.nextStep
    when (nextStep.signInStep) {
        AuthSignInStep.CONFIRM_SIGN_IN_WITH_TOTP_CODE -> {
            Log.i("AuthQuickstart", "Received next step as confirm sign in with TOTP code")
            // Prompt the user to enter the TOTP code generated in their authenticator app
            // Then invoke `confirmSignIn` api with the code
        }
        AuthSignInStep.CONTINUE_SIGN_IN_WITH_MFA_SETUP_SELECTION -> {
            Log.i("AuthQuickstart", "Received next step as continue sign in by selecting an MFA method to setup")
            Log.i("AuthQuickstart", "Allowed MFA types for setup ${nextStep.allowedMFATypes}")
            // Prompt the user to select the MFA type they want to setup
            // Then invoke `confirmSignIn` api with the MFA type
        }
        AuthSignInStep.CONTINUE_SIGN_IN_WITH_EMAIL_MFA_SETUP -> {
            Log.i("AuthQuickstart", "Received next step as continue sign in by setting up email MFA")
            // Prompt the user to enter the email address they would like to use to receive OTPs
            // Then invoke `confirmSignIn` api with the email address
        }
        AuthSignInStep.CONTINUE_SIGN_IN_WITH_TOTP_SETUP -> {
            Log.i("AuthQuickstart", "Received next step as continue sign in by setting up TOTP")
            Log.i("AuthQuickstart", "Shared secret that will be used to set up TOTP in the authenticator app ${nextStep.totpSetupDetails?.sharedSecret}")
            // Prompt the user to enter the TOTP code generated in their authenticator app
            // Then invoke `confirmSignIn` api with the code
        }
        AuthSignInStep.CONTINUE_SIGN_IN_WITH_MFA_SELECTION -> {
            Log.i("AuthQuickstart", "Received next step as continue sign in by selecting MFA type")
            Log.i("AuthQuickstart", "Allowed MFA types ${nextStep.allowedMFATypes}")
            // Prompt the user to select the MFA type they want to use
            // Then invoke `confirmSignIn` api with the MFA type
        }
        AuthSignInStep.CONTINUE_SIGN_IN_WITH_FIRST_FACTOR_SELECTION -> {
            Log.i("AuthQuickstart", "Available authentication factors for this user:  ${result.nextStep.availableFactors}")
            // Prompt the user to select which authentication factor they want to use to sign-in
            // Then invoke `confirmSignIn` api with that selection
        }
        AuthSignInStep.CONFIRM_SIGN_IN_WITH_SMS_MFA_CODE -> {
            Log.i("AuthQuickstart", "SMS code sent to ${nextStep.codeDeliveryDetails?.destination}")
            Log.i("AuthQuickstart", "Additional Info ${nextStep.additionalInfo}")
            // Prompt the user to enter the SMS MFA code they received
            // Then invoke `confirmSignIn` api with the code
        }
        AuthSignInStep.CONFIRM_SIGN_IN_WITH_OTP -> {
            Log.i("AuthQuickstart", "OTP code sent to ${nextStep.codeDeliveryDetails?.destination}")
            Log.i("AuthQuickstart", "Additional Info ${nextStep.additionalInfo}")
            // Prompt the user to enter the OTP MFA code they received
            // Then invoke `confirmSignIn` api with the code
        }
        AuthSignInStep.CONFIRM_SIGN_IN_WITH_PASSWORD -> {
            Log.i("AuthQuickstart", "Received next step as confirm sign in with password")
            // Prompt the user to enter their password
            // Then invoke `confirmSignIn` api with that password
        }
        AuthSignInStep.CONFIRM_SIGN_IN_WITH_CUSTOM_CHALLENGE -> {
            Log.i("AuthQuickstart","Custom challenge, additional info: ${nextStep.additionalInfo}")
            // Prompt the user to enter custom challenge answer
            // Then invoke `confirmSignIn` api with the answer
        }
        AuthSignInStep.CONFIRM_SIGN_IN_WITH_NEW_PASSWORD -> {
            Log.i("AuthQuickstart", "Sign in with new password, additional info: ${nextStep.additionalInfo}")
            // Prompt the user to enter a new password
            // Then invoke `confirmSignIn` api with new password
        }
        AuthSignInStep.DONE -> {
            Log.i("AuthQuickstart", "SignIn complete")
            // User has successfully signed in to the app
        }
    }
} catch (error: Exception) {
    when (error) {
        is UserNotConfirmedException -> {
            // User was not confirmed during the signup process.
            // Invoke `confirmSignUp` api to confirm the user if
            // they have the confirmation code. If they do not have the
            // confirmation code, invoke `resendSignUpCode` to send the
            // code again.
            // After the user is confirmed, invoke the `signIn` api again.
            Log.e("AuthQuickstart", "Signup confirmation required", error)
        }
        is PasswordResetRequiredException -> {
            // User needs to reset their password.
            // Invoke `resetPassword` api to start the reset password
            // flow, and once reset password flow completes, invoke
            // `signIn` api to trigger signIn flow again.
            Log.e("AuthQuickstart", "Password reset required", error)
        }
        else -> {
            Log.e("AuthQuickstart", "Unexpected error occurred: $error")
        }
    }
}
```

</Block>

<Block name="RxJava">

```java
RxAmplify.Auth.signIn("hello@example.com", "password").subscribe(
    result ->
    {
        AuthNextSignInStep nextStep = result.getNextStep();
        switch (nextStep.getSignInStep()) {
            case CONFIRM_SIGN_IN_WITH_TOTP_CODE: {
                Log.i("AuthQuickstart", "Received next step as confirm sign in with TOTP code");
                // Prompt the user to enter the TOTP code generated in their authenticator app
                // Then invoke `confirmSignIn` api with the code
                break;
            }
            case CONTINUE_SIGN_IN_WITH_MFA_SETUP_SELECTION: {
                Log.i("AuthQuickstart", "Received next step as continue sign in by selecting an MFA method to setup");
                Log.i("AuthQuickstart", "Allowed MFA types for setup" + nextStep.getAllowedMFATypes());
                // Prompt the user to select the MFA type they want to setup
                // Then invoke `confirmSignIn` api with the MFA type
                break;
            }
            case CONTINUE_SIGN_IN_WITH_EMAIL_MFA_SETUP: {
                Log.i("AuthQuickstart", "Received next step as continue sign in by setting up email MFA");
                // Prompt the user to enter the email address they would like to use to receive OTPs
                // Then invoke `confirmSignIn` api with the email address
                break;
            }
            case CONTINUE_SIGN_IN_WITH_TOTP_SETUP: {
                Log.i("AuthQuickstart", "Received next step as continue sign in by setting up TOTP");
                Log.i("AuthQuickstart", "Shared secret that will be used to set up TOTP in the authenticator app" + nextStep.getTotpSetupDetails().getSharedSecret());
                // Prompt the user to enter the TOTP code generated in their authenticator app
                // Then invoke `confirmSignIn` api with the code
                break;
            }
            case CONTINUE_SIGN_IN_WITH_MFA_SELECTION: {
                Log.i("AuthQuickstart", "Received next step as continue sign in by selecting MFA type");
                Log.i("AuthQuickstart", "Allowed MFA type" + nextStep.getAllowedMFATypes());
                // Prompt the user to select the MFA type they want to use
                // Then invoke `confirmSignIn` api with the MFA type
                break;
            }
            case CONTINUE_SIGN_IN_WITH_FIRST_FACTOR_SELECTION: {
                Log.i("AuthQuickstart", "Available authentication factors for this user: " + result.getNextStep().getAvailableFactors());
                // Prompt the user to select which authentication factor they want to use to sign-in
                // Then invoke `confirmSignIn` api with that selection
                break;
            }
            case CONFIRM_SIGN_IN_WITH_SMS_MFA_CODE: {
                Log.i("AuthQuickstart", "SMS code sent to " + nextStep.getCodeDeliveryDetails().getDestination());
                Log.i("AuthQuickstart", "Additional Info :" + nextStep.getAdditionalInfo());
                // Prompt the user to enter the SMS MFA code they received
                // Then invoke `confirmSignIn` api with the code
                break;
            }
            case CONFIRM_SIGN_IN_WITH_OTP: {
                Log.i("AuthQuickstart", "OTP code sent to " + nextStep.getCodeDeliveryDetails().getDestination());
                Log.i("AuthQuickstart", "Additional Info :" + nextStep.getAdditionalInfo());
                // Prompt the user to enter the OTP MFA code they received
                // Then invoke `confirmSignIn` api with the code
                break;
            }
            case CONFIRM_SIGN_IN_WITH_PASSWORD: {
                Log.i("AuthQuickstart", "Received next step as confirm sign in with password");
                // Prompt the user to enter their password
                // Then invoke `confirmSignIn` api with that password
                break;
            }
            case CONFIRM_SIGN_IN_WITH_CUSTOM_CHALLENGE: {
                Log.i("AuthQuickstart", "Custom challenge, additional info: " + nextStep.getAdditionalInfo());
                // Prompt the user to enter custom challenge answer
                // Then invoke `confirmSignIn` api with the answer
                break;
            }
            case CONFIRM_SIGN_IN_WITH_NEW_PASSWORD: {
                Log.i("AuthQuickstart", "Sign in with new password, additional info: " + nextStep.getAdditionalInfo());
                // Prompt the user to enter a new password
                // Then invoke `confirmSignIn` api with new password
                break;
            }
            case DONE: {
                Log.i("AuthQuickstart", "SignIn complete");
                // User has successfully signed in to the app
                break;
            }
        }
    },
    error -> {
        if (error instanceof UserNotConfirmedException) {
            // User was not confirmed during the signup process.
            // Invoke `confirmSignUp` api to confirm the user if
            // they have the confirmation code. If they do not have the
            // confirmation code, invoke `resendSignUpCode` to send the
            // code again.
            // After the user is confirmed, invoke the `signIn` api again.
            Log.i("AuthQuickstart", "Signup confirmation required" + error);
        } else if (error instanceof PasswordResetRequiredException) {
            // User needs to reset their password.
            // Invoke `resetPassword` api to start the reset password
            // flow, and once reset password flow completes, invoke
            // `signIn` api to trigger signIn flow again.
            Log.i("AuthQuickstart", "Password reset required" + error);
        } else {
            Log.e("AuthQuickstart", "SignIn failed: " + error);
        }
    }
);
```

</Block>

</BlockSwitcher>

## Confirm sign-in with SMS MFA

If the next step is `CONFIRM_SIGN_IN_WITH_SMS_MFA_CODE`, Amplify Auth has sent the user a random code over SMS, and is waiting to find out if the user successfully received it. To handle this step, your app's UI must prompt the user to enter the code. After the user enters the code, your implementation must pass the value to Amplify Auth `confirmSignIn` API.

<Callout>

**Note:** The result also includes an `AuthCodeDeliveryDetails` member. It includes additional information about the code delivery such as the partial phone number of the SMS recipient.

</Callout>

<BlockSwitcher>

<Block name="Java">

```java
try {
      Amplify.Auth.confirmSignIn(
            "confirmation code",
            result -> {
                if (result.isSignedIn()) {
                    Log.i("AuthQuickstart", "Confirm signIn succeeded");
                } else {
                    Log.i("AuthQuickstart", "Confirm sign in not complete. There might be additional steps: " + result.getNextStep());
                    // Switch on the next step to take appropriate actions.
                    // If `signInResult.isSignedIn` is true, the next step
                    // is 'done', and the user is now signed in.
                }
            },
            error -> Log.e("AuthQuickstart", "Confirm sign in failed: " + error)
    );
} catch (Exception error) {
    Log.e("AuthQuickstart", "Unexpected error: " + error);
}
```
</Block>

<Block name="Kotlin - Callbacks">

```kotlin
try {
    Amplify.Auth.confirmSignIn(
          "confirmation code",
          { result ->
              if (result.isSignedIn) {
                  Log.i("AuthQuickstart","Confirm signIn succeeded")
              } else {
                  Log.i("AuthQuickstart", "Confirm sign in not complete. There might be additional steps: ${result.nextStep}")
                  // Switch on the next step to take appropriate actions.
                  // If `signInResult.isSignedIn` is true, the next step
                  // is 'done', and the user is now signed in.
              }
          }
    ) { error -> Log.e("AuthQuickstart", "Confirm sign in failed: $error")}
} catch (error: Exception) {
    Log.e("AuthQuickstart", "Unexpected error: $error")
}
```
</Block>

<Block name="Kotlin - Coroutines">

```kotlin
try {
    val result = Amplify.Auth.confirmSignIn(
        "confirmation code"
    )
    if (result.isSignedIn) {
        Log.i("AuthQuickstart", "Confirm signIn succeeded")
    } else {
        Log.i("AuthQuickstart", "Confirm sign in not complete. There might be additional steps: ${result.nextStep}"
        )
        // Switch on the next step to take appropriate actions.
        // If `signInResult.isSignedIn` is true, the next step
        // is 'done', and the user is now signed in.
    }
} catch (error: Exception) {
    Log.e("AuthQuickstart", "Unexpected error: $error")
}
```
</Block>

<Block name="RxJava">

```java

RxAmplify.Auth.confirmSignIn(
                "confirmation code").subscribe(
                result -> {
                    if (result.isSignedIn()) {
                        Log.i("AuthQuickstart", "Confirm signIn succeeded");
                    } else {
                        Log.i("AuthQuickstart", "Confirm sign in not complete. There might be additional steps: " + result.getNextStep());
                        // Switch on the next step to take appropriate actions.
                        // If `signInResult.isSignedIn` is true, the next step
                        // is 'done', and the user is now signed in.
                    }
                },
                error -> Log.e("AuthQuickstart", "Confirm sign in failed: " + error)
        );
```
</Block>

</BlockSwitcher>

## Confirm sign-in with TOTP MFA

If the next step is `CONFIRM_SIGN_IN_WITH_TOTP_CODE`, you should prompt the user to enter the TOTP code from their associated authenticator app during set up. The code is a six-digit number that changes every 30 seconds. The user must enter the code before the 30-second window expires.

After the user enters the code, your implementation must pass the value to Amplify Auth `confirmSignIn` API.


## Confirm sign-in with Email MFA

If the next step is `CONFIRM_SIGN_IN_WITH_EMAIL_MFA_CODE`, Amplify Auth has sent the user a random code to their email address and is waiting to find out if the user successfully received it. To handle this step, your app's UI must prompt the user to enter the code. After the user enters the code, your implementation must pass the value to Amplify Auth `confirmSignIn` API.

<Callout>

**Note:** The result also includes an `AuthCodeDeliveryDetails` member. It includes additional information about the code delivery such as the partial email address of the recipient.

</Callout>

## Confirm sign-in with OTP

If the next step is `CONFIRM_SIGN_IN_WITH_OTP`, Amplify Auth has sent the user a random code to the medium of the user's choosing (e.g. SMS or email) and is waiting for the user to verify that code. To handle this step, your app's UI must prompt the user to enter the code. After the user enters the code, pass the value to the `confirmSignIn` API.

<Callout>

**Note:** The result includes an `AuthCodeDeliveryDetails` member. It includes additional information about the code delivery, such as the partial email address of the recipient, which can be used to prompt the user on where to look for the code.

</Callout>

## Continue sign-in with MFA Selection

If the next step is `CONTINUE_SIGN_IN_WITH_MFA_SELECTION`, the user must select the MFA method to use. Amplify Auth currently supports SMS, TOTP, and email as MFA methods. After the user selects an MFA method, your implementation must pass the selected MFA method to Amplify Auth using `confirmSignIn` API.

## Continue sign-in with Email Setup

If the next step is `CONTINUE_SIGN_IN_WITH_EMAIL_MFA_SETUP`, then the user must provide an email address to complete the sign in process. Once this value has been collected from the user, call the `confirmSignIn` API to continue.

## Continue sign-in with TOTP Setup

If the next step is `CONTINUE_SIGN_IN_WITH_TOTP_SETUP`, then the user must provide a TOTP code to complete the sign in process. The step returns an associated value of type `TOTPSetupDetails` which would be used for generating TOTP. `TOTPSetupDetails` provides a helper method called `getSetupURI` that can be used to generate a URI, which can be used by native password managers for TOTP association. For example. if the URI is used on Apple platforms, it will trigger the platform's native password manager to associate TOTP with the account. For more advanced use cases, `TOTPSetupDetails` also contains the `sharedSecret` that will be used to either generate a QR code or can be manually entered into an authenticator app.

Once the authenticator app is set up, the user can generate a TOTP code and provide it to the library to complete the sign in process.

## Continue sign-in with MFA Setup Selection

If the next step is `CONTINUE_SIGN_IN_WITH_MFA_SETUP_SELECTION`, the user must select the MFA method to setup. Amplify Auth currently supports SMS, TOTP, and email as MFA methods. After the user selects an MFA method, your implementation must pass the selected MFA method to Amplify Auth using `confirmSignIn` API.

## Continue sign-in with First Factor Selection

If the next step is `CONTINUE_SIGN_IN_WITH_FIRST_FACTOR_SELECTION`, the user must select an authentication factor to use either because they did not specify one or because the one they chose is not supported (e.g. selecting SMS when they don't have a phone number registered to their account). Amplify Auth currently supports SMS, email, password, and webauthn as authentication factors. After the user selects an authentication method, your implementation must pass the selected authentication method to Amplify Auth using `confirmSignIn` API.

Visit the [sign-in documentation](/[platform]/build-a-backend/auth/connect-your-frontend/sign-in/#sign-in-with-passwordless-methods) to see examples on how to call the `confirmSignIn` API.

## Confirm sign-in with custom challenge

If the next step is `CONFIRM_SIGN_IN_WITH_CUSTOM_CHALLENGE`, Amplify Auth is awaiting completion of a custom authentication challenge. The challenge is based on the Lambda trigger you setup when you configured a [custom sign in flow](/[platform]/build-a-backend/auth/customize-auth-lifecycle/custom-auth-flows/#sign-in-a-user). To complete this step, you should prompt the user for the custom challenge answer, and pass the answer to the `confirmSignIn` API.

<BlockSwitcher>

<Block name="Java">

```java
try {
    Amplify.Auth.confirmSignIn(
        "challenge answer",
        result -> {
            if (result.isSignedIn()) {
                Log.i("AuthQuickstart", "Confirm signIn succeeded");
            } else {
                Log.i("AuthQuickstart", "Confirm sign in not complete. There might be additional steps: " + result.getNextStep());
                // Switch on the next step to take appropriate actions.
                // If `signInResult.isSignedIn` is true, the next step
                // is 'done', and the user is now signed in.
            }
        },
        error -> Log.e("AuthQuickstart", "Confirm sign in failed: " + error)
    );
} catch (Exception error) {
    Log.e("AuthQuickstart", "Unexpected error: " + error);
}
```

</Block>

<Block name="Kotlin - Callbacks">

```kotlin
try {
    Amplify.Auth.confirmSignIn(
        "challenge answer",
        { result ->
            if (result.isSignedIn) {
              Log.i("AuthQuickstart","Confirm signIn succeeded")
              } else {
                  Log.i("AuthQuickstart", "Confirm sign in not complete. There might be additional steps: ${result.nextStep}")
                  // Switch on the next step to take appropriate actions.
                  // If `signInResult.isSignedIn` is true, the next step
                  // is 'done', and the user is now signed in.
              }
        }
    ) { error ->
        Log.e("AuthQuickstart", "Confirm sign in failed: $error")
    }
} catch (error: Exception) {
    Log.e("AuthQuickstart", "Unexpected error: $error")
}
```

</Block>

<Block name="Kotlin - Coroutines">

```kotlin
try {
    val result = Amplify.Auth.confirmSignIn(
        "challenge answer"
    )
    if (result.isSignedIn) {
        Log.i("AuthQuickstart", "Confirm signIn succeeded")
    } else {
        Log.i("AuthQuickstart", "Confirm sign in not complete. There might be additional steps: ${result.nextStep}")
        // Switch on the next step to take appropriate actions.
        // If `signInResult.isSignedIn` is true, the next step
        // is 'done', and the user is now signed in.
    }
} catch (error: Exception) {
    Log.e("AuthQuickstart", "Unexpected error: $error")
}
```

</Block>

<Block name="RxJava">

```java

RxAmplify.Auth.confirmSignIn(
    "challenge answer").subscribe(
    result -> {
        if (result.isSignedIn()) {
            Log.i("AuthQuickstart", "Confirm signIn succeeded");
        } else {
            Log.i("AuthQuickstart", "Confirm sign in not complete. There might be additional steps: " + result.getNextStep());
            // Switch on the next step to take appropriate actions.
            // If `signInResult.isSignedIn` is true, the next step
            // is 'done', and the user is now signed in.
        }
    },
    error -> Log.e("AuthQuickstart", "Confirm sign in failed: " + error)
);
```

</Block>
</BlockSwitcher>

<Callout warning>

**Special Handling on `confirmSignIn`**

During a confirmSignIn call if `failAuthentication=true` is returned by the Lambda the session of the request gets invalidated by cognito, a NotAuthorizedException is returned and a new signIn call is expected via Amplify.Auth.signIn

```java
NotAuthorizedException{message=Failed since user is not authorized., cause=NotAuthorizedException(message=Invalid session for the user.), recoverySuggestion=Check whether the given values are correct and the user is authorized to perform the operation.}
```

</Callout>

## Confirm sign-in with new password
If you receive a `UserNotConfirmedException` while signing in, Amplify Auth requires a new password for the user before they can proceed. Prompt the user for a new password and pass it to the `confirmSignIn` API.

<BlockSwitcher>

<Block name="Java">

```java
try {
    Amplify.Auth.confirmSignIn(
            "confirmation code",
            result -> {
                if (result.isSignedIn()) {
                    Log.i("AuthQuickstart", "Confirm signIn succeeded");
                } else {
                    Log.i("AuthQuickstart", "Confirm sign in not complete. There might be additional steps: " + result.getNextStep());
                    // Switch on the next step to take appropriate actions.
                    // If `signInResult.isSignedIn` is true, the next step
                    // is 'done', and the user is now signed in.
                }
            },
            error -> Log.e("AuthQuickstart", "Confirm sign in failed: " + error)
    );
} catch (Exception error) {
    Log.e("AuthQuickstart", "Unexpected error: " + error);
}
```
</Block>

<Block name="Kotlin - Callbacks">

```kotlin
 try {
      Amplify.Auth.confirmSignIn(
          "confirmation code",
          { result ->
              if (result.isSignedIn) {
                Log.i("AuthQuickstart","Confirm signIn succeeded")
              } else {
                Log.i("AuthQuickstart", "Confirm sign in not complete. There might be additional steps: ${result.nextStep}")
              }
          }
      ) { error ->
          Log.e("AuthQuickstart", "Confirm sign in failed: $error")
      }
} catch (error: Exception) {
    Log.e("AuthQuickstart", "Unexpected error: $error")
}
}
```

</Block>

<Block name="Kotlin - Coroutines">

```kotlin
try {
    val result = Amplify.Auth.confirmSignIn(
        "confirmation code"
    )
    if (result.isSignedIn) {
        Log.i("AuthQuickstart", "Confirm signIn succeeded")
    } else {
        Log.i("AuthQuickstart", "Confirm sign in not complete. There might be additional steps: ${result.nextStep}")
    }
} catch (error: Exception) {
    Log.e("AuthQuickstart", "Unexpected error: $error")
}
```
</Block>

<Block name="RxJava">

```java

RxAmplify.Auth.confirmSignIn(
                "confirmation code").subscribe(
                result -> {
                    if (result.isSignedIn()) {
                        Log.i("AuthQuickstart", "Confirm signIn succeeded");
                    } else {
                        Log.i("AuthQuickstart", "Confirm sign in not complete. There might be additional steps: " + result.getNextStep());
                    }
                },
                error -> Log.e("AuthQuickstart", "Confirm sign in failed: " + error)
        );
```
</Block>

</BlockSwitcher>

## Reset password
If you receive `PasswordResetRequiredException`, authentication flow could not proceed without resetting the password. The next step is to invoke `resetPassword` api and follow the reset password flow.
<BlockSwitcher>

<Block name="Java">

```java
try {
    Amplify.Auth.resetPassword(
            "username",
            result -> Log.i("AuthQuickstart", "Reset password succeeded"),
            error -> Log.e("AuthQuickstart", "Reset password failed : " + error)
    );
} catch (Exception error) {
    Log.e("AuthQuickstart", "Unexpected error: " + error);
}
```
</Block>

<Block name="Kotlin - Callbacks">

```kotlin
try {
      Amplify.Auth.resetPassword(
          "username",
          {
              Log.i("AuthQuickstart", "Reset password succeeded")
          }
      ) { error ->
          Log.e("AuthQuickstart", "Reset password failed : $error")
      }
} catch (error: Exception) {
    Log.e("AuthQuickstart", "Unexpected error: $error")
}
```
</Block>

<Block name="Kotlin - Coroutines">

```kotlin
try {
    Amplify.Auth.resetPassword("username")
    Log.i("AuthQuickstart", "Reset password succeeded")
} catch (error: Exception) {
    Log.e("AuthQuickstart", "Unexpected error: $error")
}
```
</Block>

<Block name="RxJava">

```java
RxAmplify.Auth.resetPassword(
        "username").subscribe(
        result -> Log.i("AuthQuickstart", "Reset password succeeded"),
        error -> Log.e("AuthQuickstart", "Reset password failed : " + error)
);
```
</Block>

</BlockSwitcher>

## Confirm Signup

If you receive `CONFIRM_SIGN_UP` as a next step, sign up could not proceed without confirming user information such as email or phone number. The next step is to invoke the `confirmSignUp` API and follow the confirm signup flow.

<BlockSwitcher>

<Block name="Java">

```java
 try {
      Amplify.Auth.confirmSignUp(
             "username",
             "confirmation code",
             result -> Log.i("AuthQuickstart", "Confirm signUp result completed: " + result.isSignUpComplete()),
             error -> Log.e("AuthQuickstart", "An error occurred while confirming sign up: " + error)
      );
} catch (Exception error) {
   Log.e("AuthQuickstart", "unexpected error: " + error);
}
```
</Block>

<Block name="Kotlin - Callbacks">

```kotlin
 try {
      Amplify.Auth.confirmSignUp(
          "username",
          "confirmation code",
          { result ->
              Log.i("AuthQuickstart", "Confirm signUp result completed: ${result.isSignUpComplete}")
          }
      ) { error ->
          Log.e("AuthQuickstart", "An error occurred while confirming sign up: $error")
      }
} catch (error: Exception) {
    Log.e("AuthQuickstart", "unexpected error: $error")
}
```
</Block>

<Block name="Kotlin - Coroutines">

```kotlin
try {
     val result = Amplify.Auth.confirmSignUp(
         "username",
         "confirmation code"
     )
     Log.i("AuthQuickstart", "Confirm signUp result completed: ${result.isSignUpComplete}")
} catch (error: Exception) {
   Log.e("AuthQuickstart", "unexpected error: $error")
}
```
</Block>

<Block name="RxJava">

```java
RxAmplify.Auth.confirmSignUp(
        "username",
        "confirmation code").subscribe(
        result -> Log.i("AuthQuickstart", "Confirm signUp result completed: " + result.isSignUpComplete()),
        error -> Log.e("AuthQuickstart", "An error occurred while confirming sign up: " + error)
);
```
</Block>

</BlockSwitcher>

## Get Current User

This call fetches the current logged in user and should be used after a user has been successfully signed in.
If the user is signed in, it will return the current userId and username.

<Callout>
**Note:** An empty string will be assigned to userId and/or username, if the values are not present in the accessToken.
</Callout>

<BlockSwitcher>

<Block name="Java">

```java
 try {
    Amplify.Auth.getCurrentUser(
           result -> Log.i("AuthQuickstart", "Current user details are:" + result.toString(),
           error -> Log.e("AuthQuickstart", "getCurrentUser failed with an exception: " + error)
    );
 } catch (Exception error) {
    Log.e("AuthQuickstart", "unexpected error: " + error);
 }
```
</Block>

<Block name="Kotlin - Callbacks">

```kotlin
Amplify.Auth.getCurrentUser({
    Log.i("AuthQuickStart", "Current user details are: $it")},{
    Log.e("AuthQuickStart", "getCurrentUser failed with an exception: $it")
})
```
</Block>

<Block name="Kotlin - Coroutines">

```kotlin
try {
    val result = Amplify.Auth.getCurrentUser()
    Log.i("AuthQuickstart", "Current user details are: $result")
} catch (error: Exception) {
    Log.e("AuthQuickstart", "getCurrentUser failed with an exception: $error")
}
```
</Block>

<Block name="RxJava">

```java
  RxAmplify.Auth.getCurrentUser().subscribe(
        result -> Log.i("AuthQuickStart getCurrentUser: " + result.toString()),
        error -> Log.e("AuthQuickStart", error.toString())
 );
```
</Block>

</BlockSwitcher>

## Done

Sign In flow is complete when you get `done`. This means the user is successfully authenticated. As a convenience, the SignInResult also provides the `isSignedIn` property, which will be true if the next step is `done`.

</InlineFilter>

<InlineFilter filters={['swift']}>

After a user has finished signup, they can proceed to sign in. Amplify Auth signin flows can be multi step processes. The required steps are determined by the configuration you provided when you define your auth resources like described on [Manage MFA Settings](/[platform]/build-a-backend/auth/concepts/multi-factor-authentication/) page. 

Depending on the configuration, you may need to call various APIs to finish authenticating a user's signin attempt. To identify the next step in a signin flow, inspect the `nextStep` parameter in the signin result.

<Callout warning>
*New enumeration values*

When Amplify adds a new enumeration value (e.g., a new enum class entry or sealed class subtype in Kotlin, or a new enum value in Swift/Dart/Kotlin), it will publish a new minor version of the Amplify Library. Plugins that switch over enumeration values should include default handlers (an else branch in Kotlin or a default statement in Swift/Dart/Kotlin) to ensure that they are not impacted by new enumeration values.

</Callout>


When called successfully, the signin APIs will return an `AuthSignInResult`. Inspect the `nextStep` property in the result to see if additional signin steps are required.

```swift
func signIn(username: String, password: String) async {
    do {
        let signInResult = try await Amplify.Auth.signIn(username: username, password: password)
        switch signInResult.nextStep {
        case .confirmSignInWithSMSMFACode(let deliveryDetails, let info):
            print("SMS code sent to \(deliveryDetails.destination)")
            print("Additional info \(String(describing: info))")

            // Prompt the user to enter the SMSMFA code they received
            // Then invoke `confirmSignIn` api with the code

        case .confirmSignInWithTOTPCode:
            print("Received next step as confirm sign in with TOTP code")

            // Prompt the user to enter the TOTP code generated in their authenticator app
            // Then invoke `confirmSignIn` api with the code

        case .confirmSignInWithOTP(let deliveryDetails):
            print("Email code sent to \(deliveryDetails.destination)")

            // Prompt the user to enter the Email MFA code they received
            // Then invoke `confirmSignIn` api with the code

        case .continueSignInWithFirstFactorSelection(let allowedFactors):
            print("Received next step as continue sign in by selecting first factor")
            print("Allowed factors \(allowedFactors)")

            // Prompt the user to select the first factor they want to use
            // Then invoke `confirmSignIn` api with the factor

        case .confirmSignInWithPassword:
            print("Received next step as confirm sign in with password")

            // Prompt the user to enter the password
            // Then invoke `confirmSignIn` api with the password
        
        case .continueSignInWithTOTPSetup(let setUpDetails):
            print("Received next step as continue sign in by setting up TOTP")
            print("Shared secret that will be used to set up TOTP in the authenticator app \(setUpDetails.sharedSecret)")
            
            // Prompt the user to enter the TOTP code generated in their authenticator app
            // Then invoke `confirmSignIn` api with the code

        case .continueSignInWithEmailMFASetup:
             print("Received next step as continue sign in by setting up email MFA")
             
            // Prompt the user to enter the email address they wish to use for MFA
            // Then invoke `confirmSignIn` api with the email address

        case .continueSignInWithMFASetupSelection(let allowedMFATypes):
            print("Received next step as continue sign in by selecting MFA type to setup")
            print("Allowed MFA types \(allowedMFATypes)")

            // Prompt the user to select the MFA type they want to setup
            // Then invoke `confirmSignIn` api with the MFA type

        case .continueSignInWithMFASelection(let allowedMFATypes):
            print("Received next step as continue sign in by selecting MFA type")
            print("Allowed MFA types \(allowedMFATypes)")
            
            // Prompt the user to select the MFA type they want to use
            // Then invoke `confirmSignIn` api with the MFA type
        
        case .confirmSignInWithCustomChallenge(let info):
            print("Custom challenge, additional info \(String(describing: info))")
            
            // Prompt the user to enter custom challenge answer
            // Then invoke `confirmSignIn` api with the answer
        
        case .confirmSignInWithNewPassword(let info):
            print("New password additional info \(String(describing: info))")
            
            // Prompt the user to enter a new password
            // Then invoke `confirmSignIn` api with new password
        
        case .resetPassword(let info):
            print("Reset password additional info \(String(describing: info))")
            
            // User needs to reset their password.
            // Invoke `resetPassword` api to start the reset password
            // flow, and once reset password flow completes, invoke
            // `signIn` api to trigger signin flow again.
        
        case .confirmSignUp(let info):
            print("Confirm signup additional info \(String(describing: info))")
            
            // User was not confirmed during the signup process.
            // Invoke `confirmSignUp` api to confirm the user if
            // they have the confirmation code. If they do not have the
            // confirmation code, invoke `resendSignUpCode` to send the
            // code again.
            // After the user is confirmed, invoke the `signIn` api again.
        case .done:
            
            // Use has successfully signed in to the app
            print("Signin complete")
        }
    } catch let error as AuthError{
        print ("Sign in failed \(error)")
    } catch {
        print("Unexpected error: \(error)")
    }
}
```

The `nextStep` property is of enum type `AuthSignInStep`. Depending on its value, your code should take one of the following actions:

## Confirm sign-in with SMS MFA
If the next step is `confirmSignInWithSMSMFACode`, Amplify Auth has sent the user a random code over SMS, and is waiting to find out if the user successfully received it. To handle this step, your app's UI must prompt the user to enter the code. After the user enters the code, your implementation must pass the value to Amplify Auth `confirmSignIn` API.

Note: the signin result also includes an `AuthCodeDeliveryDetails` member. It includes additional information about the code delivery such as the partial phone number of the SMS recipient.

<BlockSwitcher>

<Block name="Async/Await">

```swift
func confirmSignIn(confirmationCodeFromUser: String) async {
    do {
        let signInResult = try await Amplify.Auth.confirmSignIn(challengeResponse: confirmationCodeFromUser)
        if signInResult.isSignedIn {
            print("Confirm sign in succeeded. The user is signed in.")
        } else {
            print("Confirm sign in succeeded.")
            print("Next step: \(signInResult.nextStep)")
            // Switch on the next step to take appropriate actions. 
            // If `signInResult.isSignedIn` is true, the next step 
            // is 'done', and the user is now signed in.
        }
    } catch let error as AuthError {
        print("Confirm sign in failed \(error)")
    } catch {
        print("Unexpected error: \(error)")
    }
}
```

</Block>

<Block name="Combine">

```swift
func confirmSignIn(confirmationCodeFromUser: String) -> AnyCancellable {
    Amplify.Publisher.create {
        try await Amplify.Auth.confirmSignIn(challengeResponse: confirmationCodeFromUser)
        }.sink {
            if case let .failure(authError) = $0 {
                print("Confirm sign in failed \(authError)")
            }
        }
        receiveValue: { signInResult in
            if signInResult.isSignedIn {
                print("Confirm sign in succeeded. The user is signed in.")
            } else {
                print("Confirm sign in succeeded.")
                print("Next step: \(signInResult.nextStep)")
                // Switch on the next step to take appropriate actions. 
                // If `signInResult.isSignedIn` is true, the next step 
                // is 'done', and the user is now signed in.
            }
        }
}
```

</Block>

</BlockSwitcher>

## Confirm sign-in with TOTP MFA

If the next step is `confirmSignInWithTOTPCode`, you should prompt the user to enter the TOTP code from their associated authenticator app during set up. The code is a six-digit number that changes every 30 seconds. The user must enter the code before the 30-second window expires.

After the user enters the code, your implementation must pass the value to Amplify Auth `confirmSignIn` API.

<BlockSwitcher>

<Block name="Async/Await">

```swift
func confirmSignIn(totpCode: String) async {
    do {
        let signInResult = try await Amplify.Auth.confirmSignIn(challengeResponse: totpCode)
        if signInResult.isSignedIn {
            print("Confirm sign in succeeded. The user is signed in.")
        } else {
            print("Confirm sign in succeeded.")
            print("Next step: \(signInResult.nextStep)")
            // Switch on the next step to take appropriate actions. 
            // If `signInResult.isSignedIn` is true, the next step 
            // is 'done', and the user is now signed in.
        }
    } catch {
        print("Confirm sign in failed \(error)")
    }
}
```

</Block>

<Block name="Combine">

```swift
func confirmSignIn(totpCode: String) -> AnyCancellable {
    Amplify.Publisher.create {
        try await Amplify.Auth.confirmSignIn(challengeResponse: totpCode)
        }.sink {
            if case let .failure(authError) = $0 {
                print("Confirm sign in failed \(authError)")
            }
        }
        receiveValue: { signInResult in
            if signInResult.isSignedIn {
                print("Confirm sign in succeeded. The user is signed in.")
            } else {
                print("Confirm sign in succeeded.")
                print("Next step: \(signInResult.nextStep)")
                // Switch on the next step to take appropriate actions. 
                // If `signInResult.isSignedIn` is true, the next step 
                // is 'done', and the user is now signed in.
            }
        }
}
```

</Block>

</BlockSwitcher>


## Confirm sign-in with Email MFA
If the next step is `confirmSignInWithOTP`, Amplify Auth has sent a random code to the user's email address, and is waiting to find out if the user successfully received it. To handle this step, your app's UI must prompt the user to enter the code. After the user enters the code, your implementation must pass the value to Amplify Auth `confirmSignIn` API.

<Callout info>

**Note:** the sign-in result also includes an `AuthCodeDeliveryDetails` member. It includes additional information about the code delivery such as the partial email address of the recipient.

</Callout>

<BlockSwitcher>

<Block name="Async/Await">

```swift
func confirmSignIn(confirmationCodeFromUser: String) async {
    do {
        let signInResult = try await Amplify.Auth.confirmSignIn(challengeResponse: confirmationCodeFromUser)
        if signInResult.isSignedIn {
            print("Confirm sign in succeeded. The user is signed in.")
        } else {
            print("Confirm sign in succeeded.")
            print("Next step: \(signInResult.nextStep)")
            // Switch on the next step to take appropriate actions. 
            // If `signInResult.isSignedIn` is true, the next step 
            // is 'done', and the user is now signed in.
        }
    } catch let error as AuthError {
        print("Confirm sign in failed \(error)")
    } catch {
        print("Unexpected error: \(error)")
    }
}
```

</Block>

<Block name="Combine">

```swift
func confirmSignIn(confirmationCodeFromUser: String) -> AnyCancellable {
    Amplify.Publisher.create {
        try await Amplify.Auth.confirmSignIn(challengeResponse: confirmationCodeFromUser)
        }.sink {
            if case let .failure(authError) = $0 {
                print("Confirm sign in failed \(authError)")
            }
        }
        receiveValue: { signInResult in
            if signInResult.isSignedIn {
                print("Confirm sign in succeeded. The user is signed in.")
            } else {
                print("Confirm sign in succeeded.")
                print("Next step: \(signInResult.nextStep)")
                // Switch on the next step to take appropriate actions. 
                // If `signInResult.isSignedIn` is true, the next step 
                // is 'done', and the user is now signed in.
            }
        }
}
```

</Block>

</BlockSwitcher>


## Continue sign-in with MFA Selection

If the next step is `continueSignInWithMFASelection`, the user must select the MFA method to use. Amplify Auth currently supports SMS, TOTP, and email as MFA methods. After the user selects an MFA method, your implementation must pass the selected MFA method to Amplify Auth using `confirmSignIn` API.

<BlockSwitcher>

<Block name="Async/Await">

```swift
func confirmSignInWithTOTPAsMFASelection() async {
    do {
        let signInResult = try await Amplify.Auth.confirmSignIn(
            challengeResponse: MFAType.totp.challengeResponse)

        if case .confirmSignInWithTOTPCode = signInResult.nextStep {
            print("Received next step as confirm sign in with TOTP")
        }

    } catch {
        print("Confirm sign in failed \(error)")
    }
}
```

</Block>

<Block name="Combine">

```swift
func confirmSignInWithTOTPAsMFASelection() -> AnyCancellable {
    Amplify.Publisher.create {
        try await Amplify.Auth.confirmSignIn(
            challengeResponse: MFAType.totp.challengeResponse)
        }.sink {
            if case let .failure(authError) = $0 {
                print("Confirm sign in failed \(authError)")
            }
        }
        receiveValue: { signInResult in
        if case .confirmSignInWithTOTPCode = signInResult.nextStep {
            print("Received next step as confirm sign in with TOTP")
        }
    }
}
```

</Block>

</BlockSwitcher>

## Continue sign-in with Email Setup
If the next step is `continueSignInWithEmailMFASetup`, then the user must provide an email address to complete the sign in process. Once this value has been collected from the user, call the `confirmSignIn` API to continue.

```swift 
// Confirm sign in with Email Setup
case .continueSignInWithEmailMFASetup:
    print("Received next step as continue sign in by setting up email MFA")
        
    // Prompt the user to enter the email address they wish to use for MFA
    // Then invoke `confirmSignIn` api with the email address
```

## Continue sign-in with TOTP Setup

If the next step is `continueSignInWithTOTPSetup`, then the user must provide a TOTP code to complete the sign in process. The step returns an associated value of type `TOTPSetupDetails` which would be used for generating TOTP. `TOTPSetupDetails` provides a helper method called `getSetupURI` that can be used to generate a URI, which can be used by native password managers for TOTP association. For example. if the URI is used on Apple platforms, it will trigger the platform's native password manager to associate TOTP with the account. For more advanced use cases, `TOTPSetupDetails` also contains the `sharedSecret` that will be used to either generate a QR code or can be manually entered into an authenticator app.

Once the authenticator app is set up, the user can generate a TOTP code and provide it to the library to complete the sign in process.

```swift 
// Confirm sign in with TOTP setup
case .continueSignInWithTOTPSetup(let setUpDetails):
    
    /// appName parameter will help distinguish the account in the Authenticator app
    let setupURI = try setUpDetails.getSetupURI(appName: "<Your_App_Name>>") 
    
    print("TOTP Setup URI: \(setupURI)")
```

<BlockSwitcher>

<Block name="Async/Await">

```swift
func confirmSignInWithTOTPSetup(totpCodeFromAuthenticatorApp: String) async {
    do {
        let signInResult = try await Amplify.Auth.confirmSignIn(
            challengeResponse: totpCodeFromAuthenticatorApp)

         if signInResult.isSignedIn {
            print("Confirm sign in succeeded. The user is signed in.")
        } else {
            print("Confirm sign in succeeded.")
            print("Next step: \(signInResult.nextStep)")
            // Switch on the next step to take appropriate actions. 
            // If `signInResult.isSignedIn` is true, the next step 
            // is 'done', and the user is now signed in.
        }
    } catch {
        print("Confirm sign in failed \(error)")
    }
}
```

</Block>

<Block name="Combine">

```swift
func confirmSignInWithTOTPSetup(totpCodeFromAuthenticatorApp: String) -> AnyCancellable {
    Amplify.Publisher.create {
        try await Amplify.Auth.confirmSignIn(
            challengeResponse: totpCodeFromAuthenticatorApp)
        }.sink {
            if case let .failure(authError) = $0 {
                print("Confirm sign in failed \(authError)")
            }
        }
        receiveValue: { signInResult in
            if signInResult.isSignedIn {
                print("Confirm sign in succeeded. The user is signed in.")
            } else {
                print("Confirm sign in succeeded.")
                print("Next step: \(signInResult.nextStep)")
                // Switch on the next step to take appropriate actions. 
                // If `signInResult.isSignedIn` is true, the next step 
                // is 'done', and the user is now signed in.
            }
        }
}
```

</Block>

</BlockSwitcher>

## Continue sign-in with MFA Setup Selection

If the next step is `continueSignInWithMFASetupSelection`, the user must indicate which of the available MFA methods they would like to setup. After the user selects an MFA method to setup, your implementation must pass the selected MFA method to the `confirmSignIn` API.

<BlockSwitcher>

<Block name="Async/Await">

```swift
func continueSignInWithEmailMFASetupSelection() async {
    do {
        let signInResult = try await Amplify.Auth.confirmSignIn(
            challengeResponse: MFAType.email.challengeResponse)

        if case .confirmSignInWithTOTPCode = signInResult.nextStep {
            print("Received next step as confirm sign in with TOTP")
        }

    } catch {
        print("Confirm sign in failed \(error)")
    }
}
```

</Block>

<Block name="Combine">

```swift
func continueSignInWithEmailMFASetupSelection() -> AnyCancellable {
    Amplify.Publisher.create {
        try await Amplify.Auth.confirmSignIn(
            challengeResponse: MFAType.email.challengeResponse)
        }.sink {
            if case let .failure(authError) = $0 {
                print("Confirm sign in failed \(authError)")
            }
        }
        receiveValue: { signInResult in
        if case .confirmSignInWithTOTPCode = signInResult.nextStep {
            print("Received next step as confirm sign in with TOTP")
        }
    }
}
```

</Block>

</BlockSwitcher>

## Confirm sign-in with custom challenge

If the next step is `confirmSignInWithCustomChallenge`, Amplify Auth is awaiting completion of a custom authentication challenge. The challenge is based on the Lambda trigger you setup when you configured a [custom sign in flow](/[platform]/build-a-backend/auth/customize-auth-lifecycle/custom-auth-flows/#sign-in-a-user). To complete this step, you should prompt the user for the custom challenge answer, and pass the answer to the `confirmSignIn` API.

<BlockSwitcher>

<Block name="Async/Await">

```swift
func confirmSignIn(challengeAnswerFromUser: String) async {
    do {
        let signInResult = try await Amplify.Auth.confirmSignIn(challengeResponse: challengeAnswerFromUser)
        if signInResult.isSignedIn {
            print("Confirm sign in succeeded. The user is signed in.")
        } else {
            print("Confirm sign in succeeded.")
            print("Next step: \(signInResult.nextStep)")
            // Switch on the next step to take appropriate actions.
            // If `signInResult.isSignedIn` is true, the next step
            // is 'done', and the user is now signed in.
        }
    } catch let error as AuthError {
        print("Confirm sign in failed \(error)")
    } catch {
        print("Unexpected error: \(error)")
    }
}
```

</Block>

<Block name="Combine">

```swift
func confirmSignIn(challengeAnswerFromUser: String) -> AnyCancellable {
    Amplify.Publisher.create {
        try await Amplify.Auth.confirmSignIn(challengeResponse: challengeAnswerFromUser)
        }.sink {
            if case let .failure(authError) = $0 {
                print("Confirm sign in failed \(authError)")
            }
        }
        receiveValue: { signInResult in
            if signInResult.isSignedIn {
                print("Confirm sign in succeeded. The user is signed in.")
            } else {
                print("Confirm sign in succeeded.")
                print("Next step: \(signInResult.nextStep)")
                // Switch on the next step to take appropriate actions.
                // If `signInResult.isSignedIn` is true, the next step
                // is 'done', and the user is now signed in.
            }
        }
}
```

</Block>
</BlockSwitcher>

<Callout warning>

**Special Handling on `confirmSignIn`**

During a confirmSignIn call if `failAuthentication=true` is returned by the Lambda function the session of the request gets invalidated by cognito, a NotAuthorizedException is returned and a new signIn call is expected via Amplify.Auth.signIn

```swift
Exception:  notAuthorized{message=Failed since user is not authorized., cause=NotAuthorizedException(message=Invalid session for the user.), recoverySuggestion=Check whether the given values are correct and the user is authorized to perform the operation.}
```

</Callout>

## Confirm sign-in with new password

If the next step is `confirmSignInWithNewPassword`, Amplify Auth requires a new password for the user before they can proceed. Prompt the user for a new password and pass it to the `confirmSignIn` API.

<BlockSwitcher>

<Block name="Async/Await">

```swift
func confirmSignIn(newPasswordFromUser: String) async {
    do {
        let signInResult = try await Amplify.Auth.confirmSignIn(challengeResponse: newPasswordFromUser)
        if signInResult.isSignedIn {
            print("Confirm sign in succeeded. The user is signed in.")
        } else {
            print("Confirm sign in succeeded.")
            print("Next step: \(signInResult.nextStep)")
            // Switch on the next step to take appropriate actions. 
            // If `signInResult.isSignedIn` is true, the next step 
            // is 'done', and the user is now signed in.
        }
    } catch let error as AuthError {
        print("Confirm sign in failed \(error)")
    } catch {
        print("Unexpected error: \(error)")
    }
}
```

</Block>

<Block name="Combine">

```swift
func confirmSignIn(newPasswordFromUser: String) -> AnyCancellable {
    Amplify.Publisher.create {
        try await Amplify.Auth.confirmSignIn(challengeResponse: newPasswordFromUser)
        }.sink {
            if case let .failure(authError) = $0 {
                print("Confirm sign in failed \(authError)")
            }
        }
        receiveValue: { signInResult in
            if signInResult.isSignedIn {
                print("Confirm sign in succeeded. The user is signed in.")
            } else {
                print("Confirm sign in succeeded.")
                print("Next step: \(signInResult.nextStep)")
                // Switch on the next step to take appropriate actions. 
                // If `signInResult.isSignedIn` is true, the next step 
                // is 'done', and the user is now signed in.
            }
        }
}
```

</Block>

</BlockSwitcher>

## Reset password

If you receive `resetPassword`, authentication flow could not proceed without resetting the password. The next step is to invoke `resetPassword` api and follow the reset password flow.

<BlockSwitcher>

<Block name="Async/Await">

```swift
func resetPassword(username: String) async {
    do {
        let resetPasswordResult = try await Amplify.Auth.resetPassword(for: username)
        print("Reset password succeeded.")
        print("Next step: \(resetPasswordResult.nextStep)")
    } catch let error as AuthError {
        print("Reset password  failed \(error)")
    } catch {
        print("Unexpected error: \(error)")
    }
}
```

</Block>

<Block name="Combine">

```swift
func resetPassword(username: String) -> AnyCancellable {
    Amplify.Publisher.create {
        try await Amplify.Auth.resetPassword(for: username)
        }.sink {
            if case let .failure(authError) = $0 {
                print("Reset password  failed \(authError)")
            }
        }
        receiveValue: { resetPasswordResult in
            print("Reset password succeeded.")
            print("Next step: \(resetPasswordResult.nextStep)")
        }
}
```

</Block>

</BlockSwitcher>

## Confirm Signup

If you receive `confirmSignUp` as a next step, sign up could not proceed without confirming user information such as email or phone number. The next step is to invoke the `confirmSignUp` API and follow the confirm signup flow.

<BlockSwitcher>

<Block name="Async/Await">

```swift
func confirmSignUp(for username: String, with confirmationCode: String) async {
    do {
        let confirmSignUpResult = try await Amplify.Auth.confirmSignUp(
            for: username,
            confirmationCode: confirmationCode
        )
        print("Confirm sign up result completed: \(confirmSignUpResult.isSignUpComplete)")
    } catch let error as AuthError {
        print("An error occurred while confirming sign up \(error)")
    } catch {
        print("Unexpected error: \(error)")
    }
}
```

</Block>

<Block name="Combine">

```swift
func confirmSignUp(for username: String, with confirmationCode: String) -> AnyCancellable {
    Amplify.Publisher.create {
        try await Amplify.Auth.confirmSignUp(for: username, confirmationCode: confirmationCode)
        }.sink {
            if case let .failure(authError) = $0 {
                print("An error occurred while confirming sign up \(authError)")
            }
        }
        receiveValue: { _ in
            print("Confirm signUp succeeded")
        }
}
```

</Block>

</BlockSwitcher>

## Done

Signin flow is complete when you get `done`. This means the user is successfully authenticated. As a convenience, the SignInResult also provides the `isSignedIn` property, which will be true if the next step is `done`.
</InlineFilter>


Contents of build-a-backend_auth_connect-your-frontend_sign-in_index.txt:
import { getCustomStaticPath } from '@/utils/getCustomStaticPath';

export const meta = {
  title: 'Sign-in',
  description: 'Learn how to sign in',
  platforms: [
    'android',
    'angular',
    'flutter',
    'javascript',
    'nextjs',
    'react',
    'react-native',
    'swift',
    'vue'
  ]
};

export function getStaticPaths() {
  return getCustomStaticPath(meta.platforms);
}

export function getStaticProps() {
  return {
    props: {
      meta
    }
  };
}

Amplify provides a client library that enables you to interact with backend resources such as Amplify Auth.

<InlineFilter filters={["react"]}>
<Callout info>

The quickest way to get started with Amplify Auth in your frontend application is with the [Authenticator component](https://ui.docs.amplify.aws/react/connected-components/authenticator), which provides a customizable UI and complete authentication flows.

</Callout>
</InlineFilter>

<InlineFilter filters={["swift"]}>
<Callout info>

The quickest way to get started with Amplify Auth in your frontend application is with the [Authenticator component](https://ui.docs.amplify.aws/swift/connected-components/authenticator), which provides a customizable UI and complete authentication flows.

</Callout>
</InlineFilter>

<InlineFilter filters={["flutter"]}>
<Callout info>

The quickest way to get started with Amplify Auth in your frontend application is with the [Authenticator component](https://ui.docs.amplify.aws/flutter/connected-components/authenticator), which provides a customizable UI and complete authentication flows.

</Callout>
</InlineFilter>

<InlineFilter filters={["android"]}>
<Callout info>

The quickest way to get started with Amplify Auth in your frontend application is with the [Authenticator component](https://ui.docs.amplify.aws/android/connected-components/authenticator), which provides a customizable UI and complete authentication flows.

</Callout>
</InlineFilter>

## Using the signIn API

{/* signIn api definition */}

<InlineFilter filters={["angular", "javascript", "nextjs", "react", "react-native", "vue"]}>

```ts
import { signIn } from 'aws-amplify/auth'

await signIn({
  username: "hello@mycompany.com",
  password: "hunter2",
})
```

</InlineFilter>
<InlineFilter filters={["flutter"]}>

```dart
Future<void> signInUser(String username, String password) async {
  try {
    final result = await Amplify.Auth.signIn(
      username: username,
      password: password,
    );
    await _handleSignInResult(result);
  } on AuthException catch (e) {
    safePrint('Error signing in: ${e.message}');
  }
}
```

Depending on your configuration and how the user signed up, one or more confirmations will be necessary. Use the `SignInResult` returned from `Amplify.Auth.signIn` to check the next step for signing in. When the value is `done`, the user has successfully signed in.

```dart
Future<void> _handleSignInResult(SignInResult result) async {
  switch (result.nextStep.signInStep) {
    case AuthSignInStep.confirmSignInWithSmsMfaCode:
      final codeDeliveryDetails = result.nextStep.codeDeliveryDetails!;
      _handleCodeDelivery(codeDeliveryDetails);
      break;
    case AuthSignInStep.confirmSignInWithNewPassword:
      safePrint('Enter a new password to continue signing in');
      break;
    case AuthSignInStep.confirmSignInWithCustomChallenge:
      final parameters = result.nextStep.additionalInfo;
      final prompt = parameters['prompt']!;
      safePrint(prompt);
      break;
    case AuthSignInStep.resetPassword:
      final resetResult = await Amplify.Auth.resetPassword(
        username: username,
      );
      await _handleResetPasswordResult(resetResult);
      break;
    case AuthSignInStep.confirmSignUp:
      // Resend the sign up code to the registered device.
      final resendResult = await Amplify.Auth.resendSignUpCode(
        username: username,
      );
      _handleCodeDelivery(resendResult.codeDeliveryDetails);
      break;
    case AuthSignInStep.done:
      safePrint('Sign in is complete');
      break;
  }
}

void _handleCodeDelivery(AuthCodeDeliveryDetails codeDeliveryDetails) {
  safePrint(
    'A confirmation code has been sent to ${codeDeliveryDetails.destination}. '
    'Please check your ${codeDeliveryDetails.deliveryMedium.name} for the code.',
  );
}
```

</InlineFilter>
<InlineFilter filters={["android"]}>

<BlockSwitcher>
<Block name="Java">

```java
Amplify.Auth.signIn(
    "username",
    "password",
    result -> Log.i("AuthQuickstart", result.isSignedIn() ? "Sign in succeeded" : "Sign in not complete"),
    error -> Log.e("AuthQuickstart", error.toString())
);
```

</Block>
<Block name="Kotlin - Callbacks">

```kotlin
Amplify.Auth.signIn("username", "password",
    { result ->
        if (result.isSignedIn) {
            Log.i("AuthQuickstart", "Sign in succeeded")
        } else {
            Log.i("AuthQuickstart", "Sign in not complete")
        }
    },
    { Log.e("AuthQuickstart", "Failed to sign in", it) }
)
```

</Block>
<Block name="Kotlin - Coroutines">

```kotlin
try {
    val result = Amplify.Auth.signIn("username", "password")
    if (result.isSignedIn) {
        Log.i("AuthQuickstart", "Sign in succeeded")
    } else {
        Log.e("AuthQuickstart", "Sign in not complete")
    }
} catch (error: AuthException) {
    Log.e("AuthQuickstart", "Sign in failed", error)
}
```

</Block>
<Block name="RxJava">

```java
RxAmplify.Auth.signIn("username", "password")
    .subscribe(
        result -> Log.i("AuthQuickstart", result.isSignedIn() ? "Sign in succeeded" : "Sign in not complete"),
        error -> Log.e("AuthQuickstart", error.toString())
    );
```

</Block>
</BlockSwitcher>

</InlineFilter>
<InlineFilter filters={["swift"]}>

<BlockSwitcher>
<Block name="Async/Await">

```swift
func signIn(username: String, password: String) async {
    do {
        let signInResult = try await Amplify.Auth.signIn(
            username: username,
            password: password
        )
        if signInResult.isSignedIn {
            print("Sign in succeeded")
        }
    } catch let error as AuthError {
        print("Sign in failed \(error)")
    } catch {
        print("Unexpected error: \(error)")
    }
}
```

</Block>
<Block name="Combine">

```swift
func signIn(username: String, password: String) -> AnyCancellable {
    Amplify.Publisher.create {
        try await Amplify.Auth.signIn(
            username: username,
            password: password
        )
    }.sink {
        if case let .failure(authError) = $0 {
            print("Sign in failed \(authError)")
        }
    }
    receiveValue: { signInResult in
        if signInResult.isSignedIn {
            print("Sign in succeeded")
        }
    }
}
```

</Block>
</BlockSwitcher>

</InlineFilter>

The `signIn` API response will include a `nextStep` property, which can be used to determine if further action is required. It may return the following next steps:

<InlineFilter filters={["angular", "javascript", "react", "react-native", "nextjs", "vue"]}>
| Next Step | Description |
| --------- | ----------- |
| `CONFIRM_SIGN_IN_WITH_NEW_PASSWORD_REQUIRED` | The user was created with a temporary password and must set a new one. Complete the process with `confirmSignIn`. |
| `CONFIRM_SIGN_IN_WITH_CUSTOM_CHALLENGE` | The sign-in must be confirmed with a custom challenge response. Complete the process with `confirmSignIn`. |
| `CONFIRM_SIGN_IN_WITH_TOTP_CODE` | The sign-in must be confirmed with a TOTP code from the user. Complete the process with `confirmSignIn`. |
| `CONFIRM_SIGN_IN_WITH_SMS_CODE` | The sign-in must be confirmed with an SMS code from the user. Complete the process with `confirmSignIn`. |
| `CONFIRM_SIGN_IN_WITH_EMAIL_CODE` | The sign-in must be confirmed with an EMAIL code from the user. Complete the process with `confirmSignIn`. |
| `CONFIRM_SIGN_IN_WITH_PASSWORD` | The sign-in must be confirmed with the password from the user. Complete the process with `confirmSignIn`. |
| `CONTINUE_SIGN_IN_WITH_FIRST_FACTOR_SELECTION` | The user must select their mode of first factor authentication. Complete the process by passing the desired mode to the `challengeResponse` field of `confirmSignIn`. |
| `CONTINUE_SIGN_IN_WITH_MFA_SELECTION` | The user must select their mode of MFA verification before signing in. Complete the process with `confirmSignIn`. |
| `CONTINUE_SIGN_IN_WITH_MFA_SETUP_SELECTION` | The user must select their mode of MFA verification to setup. Complete the process by passing either `"EMAIL"` or `"TOTP"` to `confirmSignIn`. |
| `CONTINUE_SIGN_IN_WITH_TOTP_SETUP` | The TOTP setup process must be continued. Complete the process with `confirmSignIn`. |
| `CONTINUE_SIGN_IN_WITH_EMAIL_SETUP` | The EMAIL setup process must be continued. Complete the process by passing a valid email address to `confirmSignIn`. |
| `RESET_PASSWORD` | The user must reset their password via `resetPassword`. |
| `CONFIRM_SIGN_UP` | The user hasn't completed the sign-up flow fully and must be confirmed via `confirmSignUp`. |
| `DONE` | The sign in process has been completed. |
</InlineFilter>

<InlineFilter filters={["android"]}>
| Next Step | Description |
| --------- | ----------- |
| `CONFIRM_SIGN_IN_WITH_NEW_PASSWORD` | The user was created with a temporary password and must set a new one. Complete the process with `confirmSignIn`. |
| `CONFIRM_SIGN_IN_WITH_CUSTOM_CHALLENGE` | The sign-in must be confirmed with a custom challenge response. Complete the process with `confirmSignIn`. |
| `CONFIRM_SIGN_IN_WITH_TOTP_CODE` | The sign-in must be confirmed with a TOTP code from the user. Complete the process with `confirmSignIn`. |
| `CONFIRM_SIGN_IN_WITH_SMS_MFA_CODE` | The sign-in must be confirmed with a SMS code from the user. Complete the process with `confirmSignIn`. |
| `CONFIRM_SIGN_IN_WITH_OTP` | The sign-in must be confirmed with a code from the user (sent via SMS or Email). Complete the process with `confirmSignIn`. |
| `CONFIRM_SIGN_IN_WITH_PASSWORD` | The sign-in must be confirmed with the password from the user. Complete the process with `confirmSignIn`. |
| `CONTINUE_SIGN_IN_WITH_MFA_SETUP_SELECTION` | The user must select their mode of MFA verification to setup. Complete the process by passing either `MFAType.EMAIL.challengeResponse` or `MFAType.TOTP.challengeResponse` to `confirmSignIn`. |
| `CONTINUE_SIGN_IN_WITH_MFA_SELECTION` | The user must select their mode of MFA verification before signing in. Complete the process with `confirmSignIn`. |
| `CONTINUE_SIGN_IN_WITH_TOTP_SETUP` | The TOTP setup process must be continued. Complete the process with `confirmSignIn`. |
| `CONTINUE_SIGN_IN_WITH_EMAIL_MFA_SETUP` | The EMAIL setup process must be continued. Complete the process by passing a valid email address to `confirmSignIn`. |
| `CONTINUE_SIGN_IN_WITH_FIRST_FACTOR_SELECTION` | The user must select their mode of first factor authentication. Complete the process by passing the desired mode to the `challengeResponse` field of `confirmSignIn`. |
| `RESET_PASSWORD` | The user must reset their password via `resetPassword`. |
| `CONFIRM_SIGN_UP` | The user hasn't completed the sign-up flow fully and must be confirmed via `confirmSignUp`. |
| `DONE` | The sign in process has been completed. |
</InlineFilter>

<InlineFilter filters={["swift"]}>
| Next Step | Description |
| --------- | ----------- |
| `confirmSignInWithNewPassword` | The user was created with a temporary password and must set a new one. Complete the process with `confirmSignIn`. |
| `confirmSignInWithCustomChallenge` | The sign-in must be confirmed with a custom challenge response. Complete the process with `confirmSignIn`. |
| `confirmSignInWithTOTPCode` | The sign-in must be confirmed with a TOTP code from the user. Complete the process with `confirmSignIn`. |
| `confirmSignInWithSMSMFACode` | The sign-in must be confirmed with a SMS code from the user. Complete the process with `confirmSignIn`. |
| `confirmSignInWithOTP` | The sign-in must be confirmed with a code from the user (sent via SMS or Email). Complete the process with `confirmSignIn`. |
| `confirmSignInWithPassword` | The user must set a new password. Complete the process with `confirmSignIn`. |
| `continueSignInWithFirstFactorSelection` | The user must select their preferred mode of First Factor authentication. Complete the process with `confirmSignIn`. |
| `continueSignInWithMFASelection` | The user must select their mode of MFA verification before signing in. Complete the process with `confirmSignIn`. |
| `continueSignInWithMFASetupSelection` | The user must select their mode of MFA verification to setup. Complete the process by passing either `MFAType.email.challengeResponse` or `MFAType.totp.challengeResponse ` to `confirmSignIn`. |
| `continueSignInWithTOTPSetup` | The TOTP setup process must be continued. Complete the process with `confirmSignIn`. |
| `continueSignInWithEmailMFASetup` | The EMAIL setup process must be continued. Complete the process by passing a valid email address to `confirmSignIn`. |
| `resetPassword` | The user must reset their password via `resetPassword`. |
| `confirmSignUp` | The user hasn't completed the sign-up flow fully and must be confirmed via `confirmSignUp`. |
| `done` | The sign in process has been completed. |
</InlineFilter>

<InlineFilter filters={["flutter"]}>
| Next Step | Description |
| --------- | ----------- |
| `confirmSignInWithNewPassword` | The user was created with a temporary password and must set a new one. Complete the process with `confirmSignIn`. |
| `confirmSignInWithCustomChallenge` | The sign-in must be confirmed with a custom challenge response. Complete the process with `confirmSignIn`. |
| `confirmSignInWithTotpMfaCode` | The sign-in must be confirmed with a TOTP code from the user. Complete the process with `confirmSignIn`. |
| `confirmSignInWithSmsMfaCode` | The sign-in must be confirmed with a SMS code from the user. Complete the process with `confirmSignIn`. |
| `confirmSignInWithOtpCode` | The sign-in must be confirmed with a code from the user (sent via SMS or Email). Complete the process with `confirmSignIn`. |
| `continueSignInWithMfaSelection` | The user must select their mode of MFA verification before signing in. Complete the process with `confirmSignIn`. |
| `continueSignInWithMfaSetupSelection` | The user must select their mode of MFA verification to setup. Complete the process by passing either `"EMAIL"` or `"TOTP"` to `confirmSignIn`. |
| `continueSignInWithTotpSetup` | The TOTP setup process must be continued. Complete the process with `confirmSignIn`. |
| `continueSignInWithEmailMfaSetup` | The EMAIL setup process must be continued. Complete the process by passing a valid email address to `confirmSignIn`. |
| `resetPassword` | The user must reset their password via `resetPassword`. |
| `confirmSignUp` | The user hasn't completed the sign-up flow fully and must be confirmed via `confirmSignUp`. |
| `done` | The sign in process has been completed. |
</InlineFilter>

For more information on handling the MFA steps that may be returned, see [multi-factor authentication](/[platform]/build-a-backend/auth/concepts/multi-factor-authentication/).

<InlineFilter filters={["android"]}>

{/* @todo */}

</InlineFilter>
<InlineFilter filters={["swift"]}>

<BlockSwitcher>
<Block name="Async/Await">

```swift
func confirmSignIn() async {
    do {
        let signInResult = try await Amplify.Auth.confirmSignIn(challengeResponse: "<confirmation code received via SMS>")
        print("Confirm sign in succeeded. Next step: \(signInResult.nextStep)")
    } catch let error as AuthError {
        print("Confirm sign in failed \(error)")
    } catch {
        print("Unexpected error: \(error)")
    }
}
```

</Block>

<Block name="Combine">

```swift
func confirmSignIn() -> AnyCancellable {
    Amplify.Publisher.create {
        try await Amplify.Auth.confirmSignIn(challengeResponse: "<confirmation code received via SMS>")
    }.sink {
            if case let .failure(authError) = $0 {
                print("Confirm sign in failed \(authError)")
            }
        }
        receiveValue: { signInResult in
            print("Confirm sign in succeeded. Next step: \(signInResult.nextStep)")
        }
}
```

</Block>
</BlockSwitcher>
</InlineFilter>
<InlineFilter filters={["flutter"]}>

{/* @todo */}

</InlineFilter>

{/* double-filter to conditionally display this section for only platforms that have examples */}
<InlineFilter filters={["javascript", "nextjs", "react"]}>

### Practical Example

<InlineFilter filters={["javascript", "nextjs", "react"]}>

```tsx title="src/App.tsx"
import type { FormEvent } from "react"
import { Amplify } from "aws-amplify"
// highlight-next-line
import { signIn } from "aws-amplify/auth"
import outputs from "../amplify_outputs.json"

Amplify.configure(outputs)

interface SignInFormElements extends HTMLFormControlsCollection {
  email: HTMLInputElement
  password: HTMLInputElement
}

interface SignInForm extends HTMLFormElement {
  readonly elements: SignInFormElements
}

export default function App() {
  async function handleSubmit(event: FormEvent<SignInForm>) {
    event.preventDefault()
    const form = event.currentTarget
    // ... validate inputs
    await signIn({
      username: form.elements.email.value,
      password: form.elements.password.value,
    })
  }

  return (
    <form onSubmit={handleSubmit}>
      <label htmlFor="email">Email:</label>
      <input type="text" id="email" name="email" />
      <label htmlFor="password">Password:</label>
      <input type="password" id="password" name="password" />
      <input type="submit" />
    </form>
  )
}
```

</InlineFilter>
</InlineFilter>

{/* with multi-factor auth */}
## With multi-factor auth enabled

When you have Email or SMS MFA enabled, Cognito will send messages to your users on your behalf. Email and SMS messages require that your users have email address and phone number attributes respectively. It is recommended to set these attributes as required in your user pool if you wish to use either Email MFA or SMS MFA. When these attributes are required, a user must provide these details before they can complete the sign up process.

If you have set MFA to be required and you have activated more than one authentication factor, Cognito will prompt new users to select an MFA factor they want to use. Users must have a phone number to select SMS and an email address to select email MFA.

If a user doesn't have the necessary attributes defined for any available message based MFA, Cognito will prompt them to set up TOTP.

Visit the [multi-factor authentication documentation](/[platform]/build-a-backend/auth/concepts/multi-factor-authentication/) to learn more about enabling MFA on your backend auth resource.

<InlineFilter filters={["android"]}>

<BlockSwitcher>
<Block name="Java">

```java
ArrayList<AuthUserAttribute> attributes = new ArrayList<>();
attributes.add(new AuthUserAttribute(AuthUserAttributeKey.email(), "my@email.com"));
attributes.add(new AuthUserAttribute(AuthUserAttributeKey.phoneNumber(), "+15551234567"));

Amplify.Auth.signUp(
    "username",
    "Password123",
    AuthSignUpOptions.builder().userAttributes(attributes).build(),
    result -> Log.i("AuthQuickstart", result.toString()),
    error -> Log.e("AuthQuickstart", error.toString())
);
```

</Block>
<Block name="Kotlin - Callbacks">

```kotlin
val attrs = mapOf(
    AuthUserAttributeKey.email() to "my@email.com",
    AuthUserAttributeKey.phoneNumber() to "+15551234567"
)
val options = AuthSignUpOptions.builder()
    .userAttributes(attrs.map { AuthUserAttribute(it.key, it.value) })
    .build()
Amplify.Auth.signUp("username", "Password123", options,
    { Log.i("AuthQuickstart", "Sign up result = $it") },
    { Log.e("AuthQuickstart", "Sign up failed", it) }
)
```

</Block>
<Block name="Kotlin - Coroutines">

```kotlin
val attrs = mapOf(
    AuthUserAttributeKey.email() to "my@email.com",
    AuthUserAttributeKey.phoneNumber() to "+15551234567"
)
val options = AuthSignUpOptions.builder()
    .userAttributes(attrs.map { AuthUserAttribute(it.key, it.value) })
    .build()
try {
    val result = Amplify.Auth.signUp("username", "Password123", options)
    Log.i("AuthQuickstart", "Sign up OK: $result")
} catch (error: AuthException) {
    Log.e("AuthQuickstart", "Sign up failed", error)
}
```

</Block>
<Block name="RxJava">

```java
ArrayList<AuthUserAttribute> attributes = new ArrayList<>();
attributes.add(new AuthUserAttribute(AuthUserAttributeKey.email(), "my@email.com"));
attributes.add(new AuthUserAttribute(AuthUserAttributeKey.phoneNumber(), "+15551234567"));

RxAmplify.Auth.signUp(
    "username",
    "Password123",
    AuthSignUpOptions.builder().userAttributes(attributes).build())
    .subscribe(
        result -> Log.i("AuthQuickstart", result.toString()),
        error -> Log.e("AuthQuickstart", error.toString())
    );
```

</Block>
</BlockSwitcher>

</InlineFilter>
<InlineFilter filters={["swift"]}>

<BlockSwitcher>
<Block name="Async/Await">

```swift
func signUp(username: String, password: String, email: String, phonenumber: String) async {
    let userAttributes = [AuthUserAttribute(.email, value: email), AuthUserAttribute(.phoneNumber, value: phonenumber)]
    let options = AuthSignUpRequest.Options(userAttributes: userAttributes)

    do {
        let signUpResult = try await Amplify.Auth.signUp(
            username: username,
            password: password,
            options: options
        )

        if case let .confirmUser(deliveryDetails, _, userId) = signUpResult.nextStep {
            print("Delivery details \(String(describing: deliveryDetails)) for userId: \(String(describing: userId)))")
        } else {
            print("SignUp Complete")
        }
    } catch let error as AuthError {
        print("An error occurred while registering a user \(error)")
    } catch {
        print("Unexpected error: \(error)")
    }
}
```

</Block>
<Block name="Combine">

```swift
func signUp(username: String, password: String, email: String, phonenumber: String) -> AnyCancellable {
    let userAttributes = [
        AuthUserAttribute(.email, value: email),
        AuthUserAttribute(.phoneNumber, value: phonenumber)
    ]
    let options = AuthSignUpRequest.Options(userAttributes: userAttributes)
    Amplify.Publisher.create {
        try await Amplify.Auth.signUp(
            username: username,
            password: password,
            options: options
        )
    }.sink {
        if case let .failure(authError) = $0 {
            print("An error occurred while registering a user \(authError)")
        }
    }
    receiveValue: { signUpResult in
        if case let .confirmUser(deliveryDetails, _, userId) = signUpResult.nextStep {
            print("Delivery details \(String(describing: deliveryDetails)) for userId: \(String(describing: userId)))")
        } else {
            print("SignUp Complete")
        }
    }
    return sink
}
```

</Block>
</BlockSwitcher>

</InlineFilter>

### Confirm sign-in

<InlineFilter filters={["angular", "javascript", "react", "react-native", "nextjs", "vue"]}>
Following sign in, you will receive a `nextStep` in the sign-in result of one of the following types. Collect the user response and then pass to the `confirmSignIn` API to complete the sign in flow.
| Next Step | Description |
| --------- | ----------- |
| `CONFIRM_SIGN_IN_WITH_TOTP_CODE` | The sign-in must be confirmed with a TOTP code from the user. Complete the process with `confirmSignIn`. |
| `CONFIRM_SIGN_IN_WITH_SMS_CODE` | The sign-in must be confirmed with a SMS code from the user. Complete the process with `confirmSignIn`. |
| `CONFIRM_SIGN_IN_WITH_EMAIL_CODE` | The sign-in must be confirmed with a EMAIL code from the user. Complete the process with `confirmSignIn`. |
| `CONFIRM_SIGN_IN_WITH_PASSWORD` | The sign-in must be confirmed with the password from the user. Complete the process with `confirmSignIn`. |
| `CONTINUE_SIGN_IN_WITH_FIRST_FACTOR_SELECTION` | The user must select their mode of first factor authentication. Complete the process by passing the desired mode to the `challengeResponse` field of `confirmSignIn`. |
| `CONTINUE_SIGN_IN_WITH_MFA_SELECTION` | The user must select their mode of MFA verification before signing in. Complete the process with `confirmSignIn`. |
| `CONTINUE_SIGN_IN_WITH_MFA_SETUP_SELECTION` | The user must select their mode of MFA verification to setup. Complete the process by passing either `"EMAIL"` or `"TOTP"` to `confirmSignIn`. |
| `CONTINUE_SIGN_IN_WITH_TOTP_SETUP` | The TOTP setup process must be continued. Complete the process with `confirmSignIn`. |
| `CONTINUE_SIGN_IN_WITH_EMAIL_SETUP` | The EMAIL setup process must be continued. Complete the process by passing a valid email address to `confirmSignIn`. |
</InlineFilter>

<InlineFilter filters={["android"]}>
Following sign in, you will receive a `nextStep` in the sign-in result of one of the following types. Collect the user response and then pass to the `confirmSignIn` API to complete the sign in flow.
| Next Step | Description |
| --------- | ----------- |
| `CONFIRM_SIGN_IN_WITH_TOTP_CODE` | The sign-in must be confirmed with a TOTP code from the user. Complete the process with `confirmSignIn`. |
| `CONFIRM_SIGN_IN_WITH_SMS_MFA_CODE` | The sign-in must be confirmed with a SMS code from the user. Complete the process with `confirmSignIn`. |
| `CONFIRM_SIGN_IN_WITH_OTP` | The sign-in must be confirmed with a code from the user (sent via SMS or Email). Complete the process with `confirmSignIn`. |
| `CONFIRM_SIGN_IN_WITH_PASSWORD` | The sign-in must be confirmed with the password from the user. Complete the process with `confirmSignIn`. |
| `CONTINUE_SIGN_IN_WITH_FIRST_FACTOR_SELECTION` | The user must select their mode of first factor authentication. Complete the process by passing the desired mode to the `challengeResponse` field of `confirmSignIn`. |
| `CONTINUE_SIGN_IN_WITH_MFA_SELECTION` | The user must select their mode of MFA verification before signing in. Complete the process with `confirmSignIn`. |
| `CONTINUE_SIGN_IN_WITH_MFA_SETUP_SELECTION` | The user must select their mode of MFA verification to setup. Complete the process by passing either `MFAType.EMAIL.challengeResponse` or `MFAType.TOTP.challengeResponse` to `confirmSignIn`. |
| `CONTINUE_SIGN_IN_WITH_TOTP_SETUP` | The TOTP setup process must be continued. Complete the process with `confirmSignIn`. |
| `CONTINUE_SIGN_IN_WITH_EMAIL_MFA_SETUP` | The EMAIL setup process must be continued. Complete the process by passing a valid email address to `confirmSignIn`. |
</InlineFilter>

<InlineFilter filters={["swift"]}>
Following sign in, you will receive a `nextStep` in the sign-in result of one of the following types. Collect the user response and then pass to the `confirmSignIn` API to complete the sign in flow.
| Next Step | Description |
| --------- | ----------- |
| `confirmSignInWithTOTPCode` | The sign-in must be confirmed with a TOTP code from the user. Complete the process with `confirmSignIn`. |
| `confirmSignInWithSMSMFACode` | The sign-in must be confirmed with a SMS code from the user. Complete the process with `confirmSignIn`. |
| `confirmSignInWithOTP` | The sign-in must be confirmed with a code from the user (sent via SMS or Email). Complete the process with `confirmSignIn`. |
| `confirmSignInWithPassword` | The user must set a new password. Complete the process with `confirmSignIn`. |
| `continueSignInWithFirstFactorSelection` | The user must select their preferred mode of First Factor authentication. Complete the process with `confirmSignIn`. |
| `continueSignInWithMFASelection` | The user must select their mode of MFA verification before signing in. Complete the process with `confirmSignIn`. |
| `continueSignInWithMFASetupSelection` | The user must select their mode of MFA verification to setup. Complete the process by passing either `MFAType.email.challengeResponse` or `MFAType.totp.challengeResponse ` to `confirmSignIn`. |
| `continueSignInWithTOTPSetup` | The TOTP setup process must be continued. Complete the process with `confirmSignIn`. |
| `continueSignInWithEmailMFASetup` | The EMAIL setup process must be continued. Complete the process by passing a valid email address to `confirmSignIn`. |
</InlineFilter>

<InlineFilter filters={["flutter"]}>
Following sign in, you will receive a `nextStep` in the sign-in result of one of the following types. Collect the user response and then pass to the `confirmSignIn` API to complete the sign in flow.
| Next Step | Description |
| --------- | ----------- |
| `confirmSignInWithTotpMfaCode` | The sign-in must be confirmed with a TOTP code from the user. Complete the process with `confirmSignIn`. |
| `confirmSignInWithSmsMfaCode` | The sign-in must be confirmed with a SMS code from the user. Complete the process with `confirmSignIn`. |
| `confirmSignInWithOtpCode` | The sign-in must be confirmed with a code from the user (sent via SMS or Email). Complete the process with `confirmSignIn`. |
| `continueSignInWithMfaSelection` | The user must select their mode of MFA verification before signing in. Complete the process with `confirmSignIn`. |
| `continueSignInWithMfaSetupSelection` | The user must select their mode of MFA verification to setup. Complete the process by passing either `MfaType.email.confirmationValue` or `MfaType.totp.confirmationValue` to `confirmSignIn`. |
| `continueSignInWithTotpSetup` | The TOTP setup process must be continued. Complete the process with `confirmSignIn`. |
| `continueSignInWithEmailMfaSetup` | The EMAIL setup process must be continued. Complete the process by passing a valid email address to `confirmSignIn`. |
</InlineFilter>

<InlineFilter filters={["android", "flutter", "react-native", "swift"]}>
<Callout info>

**Note:** you must call `confirmSignIn` in the same app session as you call `signIn`. If you close the app, you will need to call `signIn` again. As a result, for testing purposes, you'll at least need an input field where you can enter the code sent via SMS and pass it to `confirmSignIn`.

</Callout>
</InlineFilter>

<InlineFilter filters={["angular", "javascript", "nextjs", "react", "react-native", "vue"]}>

```ts title="src/main.ts"
import { confirmSignIn, signIn } from "aws-amplify/auth";

const { nextStep } = await signIn({
  username: "hello@mycompany.com",
  password: "hunter2",
});

if (
  nextStep.signInStep === "CONFIRM_SIGN_IN_WITH_SMS_CODE" ||
  nextStep.signInStep === "CONFIRM_SIGN_IN_WITH_EMAIL_CODE" ||
  nextStep.signInStep === "CONFIRM_SIGN_IN_WITH_TOTP_CODE"
) {
  // collect OTP from user
  await confirmSignIn({
    challengeResponse: "123456",
  });
}

if (nextStep.signInStep === "CONTINUE_SIGN_IN_WITH_MFA_SELECTION") {
  // present nextStep.allowedMFATypes to user
  // collect user selection
  await confirmSignIn({
    challengeResponse: "EMAIL", // 'EMAIL', 'SMS', or 'TOTP'
  });
}

if (nextStep.signInStep === "CONTINUE_SIGN_IN_WITH_MFA_SETUP_SELECTION") {
  // present nextStep.allowedMFATypes to user
  // collect user selection
  await confirmSignIn({
    challengeResponse: "EMAIL", // 'EMAIL' or 'TOTP'
  });
}

if (nextStep.signInStep === "CONTINUE_SIGN_IN_WITH_EMAIL_SETUP") {
  // collect email address from user
  await confirmSignIn({
    challengeResponse: "hello@mycompany.com",
  });
}

if (nextStep.signInStep === "CONTINUE_SIGN_IN_WITH_TOTP_SETUP") {
  // present nextStep.totpSetupDetails.getSetupUri() to user
  // collect OTP from user
  await confirmSignIn({
    challengeResponse: "123456",
  });
}

```
<Callout info>

**Note:** The Amplify authentication flow will persist relevant session data throughout the lifespan of a page session. This enables the `confirmSignIn` API to be leveraged even after a full page refresh in a multi-page application, such as when redirecting from a login page to a sign in confirmation page.

</Callout>

</InlineFilter>

<InlineFilter filters={["android"]}>

<BlockSwitcher>
<Block name="Java">

```java
Amplify.Auth.confirmSignIn(
    "confirmation code received via SMS",
    result -> Log.i("AuthQuickstart", result.toString()),
    error -> Log.e("AuthQuickstart", error.toString())
);
```

</Block>
<Block name="Kotlin - Callbacks">

```kotlin
Amplify.Auth.confirmSignIn("code received via SMS",
    { Log.i("AuthQuickstart", "Confirmed signin: $it") },
    { Log.e("AuthQuickstart", "Failed to confirm signin", it) }
)
```

</Block>
<Block name="Kotlin - Coroutines">

```kotlin
try {
    val result = Amplify.Auth.confirmSignIn("code received via SMS")
    Log.i("AuthQuickstart", "Confirmed signin: $result")
} catch (error: AuthException) {
    Log.e("AuthQuickstart", "Failed to confirm signin", error)
}
```

</Block>
<Block name="RxJava">

```java
RxAmplify.Auth.confirmSignIn("confirmation code received via SMS")
    .subscribe(
        result -> Log.i("AuthQuickstart", result.toString()),
        error -> Log.e("AuthQuickstart", error.toString())
    );
```

</Block>
</BlockSwitcher>

</InlineFilter>
<InlineFilter filters={["swift"]}>

<BlockSwitcher>
<Block name="Async/Await">

```swift
func confirmSignIn() async {
    do {
        let signInResult = try await Amplify.Auth.confirmSignIn(challengeResponse: "<confirmation code received via SMS>")
        print("Confirm sign in succeeded. Next step: \(signInResult.nextStep)")
    } catch let error as AuthError {
        print("Confirm sign in failed \(error)")
    } catch {
        print("Unexpected error: \(error)")
    }
}
```

</Block>
<Block name="Combine">

```swift
func confirmSignIn() -> AnyCancellable {
    Amplify.Publisher.create {
        try await Amplify.Auth.confirmSignIn(challengeResponse: "<confirmation code received via SMS>")
    }.sink {
            if case let .failure(authError) = $0 {
                print("Confirm sign in failed \(authError)")
            }
        }
        receiveValue: { signInResult in
            print("Confirm sign in succeeded. Next step: \(signInResult.nextStep)")
        }
}
```

</Block>
</BlockSwitcher>

</InlineFilter>

## Sign in with an external identity provider

<InlineFilter filters={["angular", "javascript", "nextjs", "react", "react-native", "vue"]}>

To sign in using an external identity provider such as Google, use the `signInWithRedirect` function.

<Callout info>

For guidance on configuring an external Identity Provider with Amplify see [External Identity Providers](/[platform]/build-a-backend/auth/concepts/external-identity-providers/)

</Callout>

```ts
import { signInWithRedirect } from "aws-amplify/auth"

signInWithRedirect({ provider: "Google" })
```

<Callout info>

**Note:** if you do not pass an argument to `signInWithRedirect` it will redirect your users to the [Cognito Hosted UI](https://docs.aws.amazon.com/cognito/latest/developerguide/cognito-user-pools-app-integration.html), which has limited support for customization.

</Callout>

Alternatively if you have configured OIDC or SAML-based identity providers in your auth resource, you can specify a "custom" provider in `signInWithRedirect`:


```ts
import { signInWithRedirect } from "aws-amplify/auth"

signInWithRedirect({ provider: {
  custom: "MyOidcProvider"
}})
```

## Auto sign-in

The `autoSignIn` API will automatically sign-in a user when it was previously enabled by the `signUp` API and after any of the following cases has completed:

- User confirmed their account with a verification code sent to their phone or email (default option).
- User confirmed their account with a verification link sent to their phone or email. In order to enable this option you need to go to the [Amazon Cognito console](https://aws.amazon.com/pm/cognito), look for your userpool, then go to the `Messaging` tab and enable `link` mode inside the `Verification message` option. Finally you need to define the `signUpVerificationMethod` to `link` inside the `Cognito` option of your `Auth` config.

```ts title="src/main.ts"
import { autoSignIn } from 'aws-amplify/auth';

await autoSignIn();
```
<Callout>
**Note**: When MFA is enabled, your users may be presented with multiple consecutive steps that require them to enter an OTP to proceed with the sign up and subsequent sign in flow. This requirement is not present when using the `USER_AUTH` flow.
</Callout>

</InlineFilter>
<InlineFilter filters={['react-native']}
>


### Install native module

`signInWithRedirect` displays the sign-in UI inside a platform-dependent webview. On iOS devices, an [ASWebAuthenticationSession](https://developer.apple.com/documentation/authenticationservices/aswebauthenticationsession) will be launched and, on Android, a [Custom Tab](https://developer.chrome.com/docs/android/custom-tabs/). After the sign-in process is complete, the sign-in UI will redirect back to your app.

To enable this capability, an additional dependency must be installed.

```bash title="Terminal" showLineNumbers={false}
npm add @aws-amplify/rtn-web-browser
```

### Platform Setup

On iOS, there are no additional setup steps.

#### Android

After a successful sign-in, the sign-in UI will attempt to redirect back to your application. To register the redirect URI scheme you configured above with the device, an `intent-filter` must be added to your application's `AndroidManifest.xml` file which should be located in your React Native app's `android/app/src/main` directory.

Add the `intent-filter` to your application's main activity, replacing `myapp` with your redirect URI scheme as necessary.

```xml title="android/app/src/main/AndroidManifest.xml"
<application ...>
    <activity android:name=".MainActivity" ...>
        ...
        <intent-filter>
            <action android:name="android.intent.action.VIEW" />
            <category android:name="android.intent.category.DEFAULT" />
            <category android:name="android.intent.category.BROWSABLE" />
            <data android:scheme="myapp" />
        </intent-filter>
        ...
    </activity>
</application>
```

</InlineFilter>
<InlineFilter filters={['flutter']}>
To sign in using an external identity provider such as Google, use the `signInWithWebUI` function.

### How It Works

Sign-in with web UI will display the sign-in UI inside a webview. After the sign-in process is complete, the sign-in UI will redirect back to your app.

### Platform Setup

#### Web

To use Hosted UI in your Flutter web application locally, you must run the app with the `--web-port=3000` argument (with the value being whichever port you assigned to localhost host when configuring your redirect URIs).

#### Android

Add the following `queries` element to the `AndroidManifest.xml` file in your app's `android/app/src/main` directory, as well as the following `intent-filter` to the `MainActivity` in the same file.

Replace `myapp` with your redirect URI scheme as necessary:

```xml
<queries>
    <intent>
        <action android:name=
            "android.support.customtabs.action.CustomTabsService" />
    </intent>
</queries>
<application>
  ...
  <activity
        android:name=".MainActivity" android:exported="true">
        <intent-filter>
            <action android:name="android.intent.action.VIEW" />
            <category android:name="android.intent.category.DEFAULT" />
            <category android:name="android.intent.category.BROWSABLE" />
            <data android:scheme="myapp" />
        </intent-filter>
  </activity>
  ...
</application>
```

#### macOS

Open XCode and enable the App Sandbox capability and then select "Incoming Connections (Server)" under "Network".

![Incoming Connections setting selected in the App Sandbox section of the runner signing and capabilities tab.](/images/project-setup/flutter/mac/xcode-entitlements.png)

#### iOS, Windows and Linux

No specific platform configuration is required.

### Launch Social Web UI Sign In

You're now ready to launch sign in with your external provider's web UI.

```dart
Future<void> socialSignIn() async {
  try {
    final result = await Amplify.Auth.signInWithWebUI(
      provider: AuthProvider.google,
    );
    safePrint('Sign in result: $result');
  } on AuthException catch (e) {
    safePrint('Error signing in: ${e.message}');
  }
}
```
</InlineFilter>
<InlineFilter filters={['android']}>

To sign in using an external identity provider such as Google, use the `signInWithSocialWebUI` function.

### Update AndroidManifest.xml

Add the following activity and queries tag to your app's `AndroidManifest.xml` file, replacing `myapp` with
your redirect URI prefix if necessary:

```xml
<application ...>
  ...
  <activity
      android:name="com.amplifyframework.auth.cognito.activities.HostedUIRedirectActivity"
      android:exported="true">
      <intent-filter>
          <action android:name="android.intent.action.VIEW" />
          <category android:name="android.intent.category.DEFAULT" />
          <category android:name="android.intent.category.BROWSABLE" />
          <data android:scheme="myapp" />
      </intent-filter>
  </activity>
  ...
</application>
```

### Launch Social Web UI Sign In

Sweet! You're now ready to launch sign in with your social provider's web UI.

For now, just add this method to the `onCreate` method of MainActivity with whatever provider you're using (shown with Facebook below):

<BlockSwitcher>
<Block name="Java">

```java
// Replace facebook with your chosen auth provider such as google, amazon, or apple
Amplify.Auth.signInWithSocialWebUI(
    AuthProvider.facebook(),
    this,
    result -> Log.i("AuthQuickstart", result.toString()),
    error -> Log.e("AuthQuickstart", error.toString())
);
```

</Block>
<Block name="Kotlin - Callbacks">

```kotlin
// Replace facebook with your chosen auth provider such as google, amazon, or apple
Amplify.Auth.signInWithSocialWebUI(
    AuthProvider.facebook(),
    this,
    { Log.i("AuthQuickstart", "Sign in OK: $it") },
    { Log.e("AuthQuickstart", "Sign in failed", it) }
)
```

</Block>
<Block name="Kotlin - Coroutines">

```kotlin
try {
    // Replace facebook with your chosen auth provider such as google, amazon, or apple
    val result = Amplify.Auth.signInWithSocialWebUI(AuthProvider.facebook(), this)
    Log.i("AuthQuickstart", "Sign in OK: $result")
} catch (error: AuthException) {
    Log.e("AuthQuickstart", "Sign in failed", error)
}
```

</Block>
<Block name="RxJava">

```java
// Replace facebook with your chosen auth provider such as google, amazon, or apple
RxAmplify.Auth.signInWithSocialWebUI(AuthProvider.facebook(), this)
    .subscribe(
        result -> Log.i("AuthQuickstart", result.toString()),
        error -> Log.e("AuthQuickstart", error.toString())
    );
```

</Block>
</BlockSwitcher>

</InlineFilter>

<InlineFilter filters={['swift']}>

To sign in using an external identity provider such as Google, use the `signInWithWebUI` function.

### Update Info.plist

Sign-in with web UI requires the Amplify plugin to show up the sign-in UI inside a webview. After the sign-in process is complete it will redirect back to your app.
You have to enable this in your app's `Info.plist`. Right click Info.plist and then choose Open As > Source Code. Add the following entry in the URL scheme:

```xml

 <plist version="1.0">

     <dict>
     <!-- YOUR OTHER PLIST ENTRIES HERE -->

     <!-- ADD AN ENTRY TO CFBundleURLTypes for Cognito Auth -->
     <!-- IF YOU DO NOT HAVE CFBundleURLTypes, YOU CAN COPY THE WHOLE BLOCK BELOW -->
     <key>CFBundleURLTypes</key>
     <array>
         <dict>
             <key>CFBundleURLSchemes</key>
             <array>
                 <string>myapp</string>
             </array>
         </dict>
     </array>

     <!-- ... -->
     </dict>
```

When creating a new SwiftUI app using Xcode 13 no longer require configuration files such as the Info.plist. If you are missing this file, click on the project target, under Info, Url Types, and click '+' to add a new URL Type. Add `myapp` to the URL Schemes. You should see the Info.plist file now with the entry for CFBundleURLSchemes.

### Launch Social Web UI Sign In

Invoke the following API with the provider you're using (shown with Facebook below):

<BlockSwitcher>
<Block name="Async/Await">

```swift
func socialSignInWithWebUI() async {
    do {
        let signInResult = try await Amplify.Auth.signInWithWebUI(for: .facebook, presentationAnchor: self.view.window!)
        if signInResult.isSignedIn {
            print("Sign in succeeded")
        }
    } catch let error as AuthError {
        print("Sign in failed \(error)")
    } catch {
        print("Unexpected error: \(error)")
    }
}
```

</Block>
<Block name="Combine">

```swift
func socialSignInWithWebUI() -> AnyCancellable {
    Amplify.Publisher.create {
        try await Amplify.Auth.signInWithWebUI(for: .facebook, presentationAnchor: self.view.window!)
        }.sink {
            if case let .failure(authError) = $0 {
                print("Sign in failed \(authError)")
            }
        }
        receiveValue: { signInResult in
            if signInResult.isSignedIn {
                print("Sign in succeeded")
            }
        }
}
```

</Block>
</BlockSwitcher>

</InlineFilter>

<InlineFilter filters={["angular", "javascript", "nextjs", "react", "react-native", "vue", "swift", "android"]}>


## Sign in with passwordless methods

Your application's users can also sign in using passwordless methods. To learn more, visit the [concepts page for passwordless](/[platform]/build-a-backend/auth/concepts/passwordless/).

### SMS OTP

{/* blurb with supplemental information about handling sign-in, events, etc. */}

<InlineFilter filters={["angular", "javascript", "nextjs", "react", "react-native", "vue"]}>

Pass `SMS_OTP` as the `preferredChallenge` when calling the `signIn` API in order to initiate a passwordless authentication flow with SMS OTP.


```ts
const { nextStep: signInNextStep } = await signIn({
	username: '+15551234567',
	options: {
		authFlowType: 'USER_AUTH',
		preferredChallenge: 'SMS_OTP',
	},
});

if (signInNextStep.signInStep === 'CONFIRM_SIGN_IN_WITH_SMS_CODE') {
	// prompt user for otp code delivered via SMS
	const { nextStep: confirmSignInNextStep } = await confirmSignIn({
		challengeResponse: '123456',
	});

	if (confirmSignInNextStep.signInStep === 'DONE') {
		console.log('Sign in successful!');
	}
}
```

</InlineFilter>
<InlineFilter filters={["android"]}>

To request an OTP code via SMS for authentication, you pass the `challengeResponse` for `AuthFactorType.SMS_OTP` to the `confirmSignIn` API.

Amplify will respond appropriately to Cognito and return the challenge as the sign in next step: `CONFIRM_SIGN_IN_WITH_OTP_CODE`. You will call `confirmSignIn` again, this time with the OTP that your user provides.

<BlockSwitcher>
<Block name="Java">

```java
// First confirm the challenge type
Amplify.Auth.confirmSignIn(
    AuthFactorType.SMS_OTP.getChallengeResponse(),
    result -> {
        if (result.getNextStep().getSignInStep() == AuthSignInStep.CONFIRM_SIGN_IN_WITH_OTP) {
            // Show UI to collect OTP
        }
    },
    error -> Log.e("AuthQuickstart", error.toString())
);

// Then pass that OTP into the confirmSignIn API
Amplify.Auth.confirmSignIn(
    "123456",
    result -> {
        // result.getNextStep().getSignInStep() should be "DONE" now
    },
    error -> Log.e("AuthQuickstart", error.toString())
);
```

</Block>
<Block name="Kotlin - Callbacks">

```kotlin
// First confirm the challenge type
Amplify.Auth.confirmSignIn(
    AuthFactorType.SMS_OTP.challengeResponse,
    { result ->
        if (result.nextStep.signInStep == AuthSignInStep.CONFIRM_SIGN_IN_WITH_OTP) {
            // Show UI to collect OTP
        }
    },
    { error ->
        Log.e("AuthQuickstart", "Failed to sign in", error)
    }
)

// Then pass that OTP into the confirmSignIn API
Amplify.Auth.confirmSignIn(
    "123456",
    { result ->
        // result.nextStep.signInStep should be "DONE" now
    },
    { error ->
        Log.e("AuthQuickstart", "Failed to sign in", error)
    }
)
```

</Block>
<Block name="Kotlin - Coroutines">

```kotlin
// First confirm the challenge type
var result = Amplify.Auth.confirmSignIn(AuthFactorType.SMS_OTP.challengeResponse)
if (result.nextStep.signInStep == AuthSignInStep.CONFIRM_SIGN_IN_WITH_OTP) {
    // Show UI to collect OTP
}

// Then pass that OTP into the confirmSignIn API
result = Amplify.Auth.confirmSignIn("123456")

// result.nextStep.signInStep should be "DONE" now
```

</Block>
<Block name="RxJava">

```java
// First confirm the challenge type
RxAmplify.Auth.confirmSignIn(AuthFactorType.SMS_OTP.getChallengeResponse())
    .subscribe(
        result -> {
            if (result.getNextStep().getSignInStep() == AuthSignInStep.CONFIRM_SIGN_IN_WITH_OTP) {
                // Show UI to collect OTP
            }
        },
        error -> Log.e("AuthQuickstart", error.toString())
    );

// Then pass that OTP into the confirmSignIn API
RxAmplify.Auth.confirmSignIn("123456")
    .subscribe(
        result -> {
            // result.getNextStep().getSignInStep() should be "DONE" now
        },
        error -> Log.e("AuthQuickstart", error.toString())
    );
```

</Block>
</BlockSwitcher>


</InlineFilter>
<InlineFilter filters={["swift"]}>

<BlockSwitcher>
<Block name="Async/Await">

```swift
// sign in with `smsOTP` as preferred factor
func signIn(username: String) async {
    do {
        let pluginOptions = AWSAuthSignInOptions(
                authFlowType: .userAuth(preferredFirstFactor: .smsOTP))
        let signInResult = try await Amplify.Auth.signIn(
            username: username,
            options: .init(pluginOptions: pluginOptions))
        print("Sign in succeeded. Next step: \(signInResult.nextStep)")
    } catch let error as AuthError {
        print("Sign in failed \(error)")
    } catch {
        print("Unexpected error: \(error)")
    }
}

// confirm sign in with the code received
func confirmSignIn() async {
    do {
        let signInResult = try await Amplify.Auth.confirmSignIn(challengeResponse: "<confirmation code received via SMS>")
        print("Confirm sign in succeeded. Next step: \(signInResult.nextStep)")
    } catch let error as AuthError {
        print("Confirm sign in failed \(error)")
    } catch {
        print("Unexpected error: \(error)")
    }
}

```

</Block>
<Block name="Combine">

```swift
// sign in with `smsOTP` as preferred factor
func signIn(username: String) -> AnyCancellable {
    Amplify.Publisher.create {
        let pluginOptions = AWSAuthSignInOptions(
                authFlowType: .userAuth(preferredFirstFactor: .smsOTP))
        try await Amplify.Auth.signIn(
            username: username,
            options: .init(pluginOptions: pluginOptions))
    }.sink {
        if case let .failure(authError) = $0 {
            print("Sign in failed \(authError)")
        }
    }
    receiveValue: { signInResult in
        print("Sign in succeeded. Next step: \(signInResult.nextStep)")
    }
}

// confirm sign in with the code received
func confirmSignIn() -> AnyCancellable {
    Amplify.Publisher.create {
        try await Amplify.Auth.confirmSignIn(challengeResponse: "<confirmation code received via SMS>")
    }.sink {
        if case let .failure(authError) = $0 {
            print("Confirm sign in failed \(authError)")
        }
    }
    receiveValue: { signInResult in
        print("Confirm sign in succeeded. Next step: \(signInResult.nextStep)")
    }
}
```

</Block>
</BlockSwitcher>

</InlineFilter>

### Email OTP

{/* blurb with supplemental information about handling sign-in, events, etc. */}

<InlineFilter filters={["angular", "javascript", "nextjs", "react", "react-native", "vue"]}>

Pass `EMAIL_OTP` as the `preferredChallenge` when calling the `signIn` API in order to initiate a passwordless authentication flow using email OTP.

```ts
const { nextStep: signInNextStep } = await signIn({
	username: 'hello@example.com',
	options: {
		authFlowType: 'USER_AUTH',
		preferredChallenge: 'EMAIL_OTP',
	},
});

if (signInNextStep.signInStep === 'CONFIRM_SIGN_IN_WITH_EMAIL_CODE') {
	// prompt user for otp code delivered via email
	const { nextStep: confirmSignInNextStep } = await confirmSignIn({
		challengeResponse: '123456',
	});

	if (confirmSignInNextStep.signInStep === 'DONE') {
		console.log('Sign in successful!');
	}
}
```

</InlineFilter>
<InlineFilter filters={["android"]}>

To request an OTP code via email for authentication, you pass the `challengeResponse` for `AuthFactorType.EMAIL_OTP` to the `confirmSignIn` API.

Amplify will respond appropriately to Cognito and return the challenge as the sign in next step: `CONFIRM_SIGN_IN_WITH_OTP_CODE`. You will call `confirmSignIn` again, this time with the OTP that your user provides.

<BlockSwitcher>
<Block name="Java">

```java
// First confirm the challenge type
Amplify.Auth.confirmSignIn(
    AuthFactorType.EMAIL_OTP.getChallengeResponse(),
    result -> {
        if (result.getNextStep().getSignInStep() == AuthSignInStep.CONFIRM_SIGN_IN_WITH_OTP) {
            // Show UI to collect OTP
        }
    },
    error -> Log.e("AuthQuickstart", error.toString())
);

// Then pass that OTP into the confirmSignIn API
Amplify.Auth.confirmSignIn(
    "123456",
    result -> {
        // result.getNextStep().getSignInStep() should be "DONE" now
    },
    error -> Log.e("AuthQuickstart", error.toString())
);
```

</Block>
<Block name="Kotlin - Callbacks">

```kotlin
// First confirm the challenge type
Amplify.Auth.confirmSignIn(
    AuthFactorType.EMAIL_OTP.challengeResponse,
    { result ->
        if (result.nextStep.signInStep == AuthSignInStep.CONFIRM_SIGN_IN_WITH_OTP) {
            // Show UI to collect OTP
        }
    },
    { error ->
        Log.e("AuthQuickstart", "Failed to sign in", error)
    }
)

// Then pass that OTP into the confirmSignIn API
Amplify.Auth.confirmSignIn(
    "123456",
    { result ->
        // result.nextStep.signInStep should be "DONE" now
    },
    { error ->
        Log.e("AuthQuickstart", "Failed to sign in", error)
    }
)
```

</Block>
<Block name="Kotlin - Coroutines">

```kotlin
// First confirm the challenge type
var result = Amplify.Auth.confirmSignIn(AuthFactorType.EMAIL_OTP.challengeResponse)
if (result.nextStep.signInStep == AuthSignInStep.CONFIRM_SIGN_IN_WITH_OTP) {
    // Show UI to collect OTP
}

// Then pass that OTP into the confirmSignIn API
result = Amplify.Auth.confirmSignIn("123456")

// result.nextStep.signInStep should be "DONE" now
```

</Block>
<Block name="RxJava">

```java
// First confirm the challenge type
RxAmplify.Auth.confirmSignIn(AuthFactorType.EMAIL_OTP.getChallengeResponse())
    .subscribe(
        result -> {
            if (result.getNextStep().getSignInStep() == AuthSignInStep.CONFIRM_SIGN_IN_WITH_OTP) {
                // Show UI to collect OTP
            }
        },
        error -> Log.e("AuthQuickstart", error.toString())
    );

// Then pass that OTP into the confirmSignIn API
RxAmplify.Auth.confirmSignIn("123456")
    .subscribe(
        result -> {
            // result.getNextStep().getSignInStep() should be "DONE" now
        },
        error -> Log.e("AuthQuickstart", error.toString())
    );
```

</Block>
</BlockSwitcher>



</InlineFilter>
<InlineFilter filters={["swift"]}>

<BlockSwitcher>
<Block name="Async/Await">

```swift
// sign in with `emailOTP` as preferred factor
func signIn(username: String) async {
    do {
        let pluginOptions = AWSAuthSignInOptions(
                authFlowType: .userAuth(preferredFirstFactor: .emailOTP))
        let signInResult = try await Amplify.Auth.signIn(
            username: username,
            options: .init(pluginOptions: pluginOptions))
        print("Sign in succeeded. Next step: \(signInResult.nextStep)")
    } catch let error as AuthError {
        print("Sign in failed \(error)")
    } catch {
        print("Unexpected error: \(error)")
    }
}

// confirm sign in with the code received
func confirmSignIn() async {
    do {
        let signInResult = try await Amplify.Auth.confirmSignIn(challengeResponse: "<confirmation code received via SMS>")
        print("Confirm sign in succeeded. Next step: \(signInResult.nextStep)")
    } catch let error as AuthError {
        print("Confirm sign in failed \(error)")
    } catch {
        print("Unexpected error: \(error)")
    }
}

```

</Block>
<Block name="Combine">

```swift
// sign in with `emailOTP` as preferred factor
func signIn(username: String) -> AnyCancellable {
    Amplify.Publisher.create {
        let pluginOptions = AWSAuthSignInOptions(
                authFlowType: .userAuth(preferredFirstFactor: .emailOTP))
        try await Amplify.Auth.signIn(
            username: username,
            options: .init(pluginOptions: pluginOptions))
    }.sink {
        if case let .failure(authError) = $0 {
            print("Sign in failed \(authError)")
        }
    }
    receiveValue: { signInResult in
        print("Sign in succeeded. Next step: \(signInResult.nextStep)")
    }
}

// confirm sign in with the code received
func confirmSignIn() -> AnyCancellable {
    Amplify.Publisher.create {
        try await Amplify.Auth.confirmSignIn(challengeResponse: "<confirmation code received via SMS>")
    }.sink {
        if case let .failure(authError) = $0 {
            print("Confirm sign in failed \(authError)")
        }
    }
    receiveValue: { signInResult in
        print("Confirm sign in succeeded. Next step: \(signInResult.nextStep)")
    }
}
```

</Block>
</BlockSwitcher>

</InlineFilter>

### WebAuthn Passkeys

{/* blurb with supplemental information about handling sign-in, events, etc. */}

<InlineFilter filters={["angular", "javascript", "nextjs", "react", "react-native", "vue"]}>

Pass `WEB_AUTHN` as the `preferredChallenge` in order to initiate the passwordless authentication flow using a WebAuthn credential.

```ts
const { nextStep: signInNextStep } = await signIn({
	username: 'hello@example.com',
	options: {
		authFlowType: 'USER_AUTH',
		preferredChallenge: 'WEB_AUTHN',
	},
});

if (signInNextStep.signInStep === 'DONE') {
	console.log('Sign in successful!');
}
```

</InlineFilter>
<InlineFilter filters={["android"]}>

To sign in with WebAuthn, you pass the `challengeResponse` for `AuthFactorType.WEB_AUTHN` to the `confirmSignIn` API. Amplify will invoke Android's Credential Manager to retrieve a PassKey, and the user will be shown a system UI to authorize the PassKey access. This flow
completes without any additional interaction from your application, so there is only one `confirmSignIn` call needed for WebAuthn.

<Callout>
Amplify requires an `Activity` reference to attach the PassKey UI to your Application's [Task](https://developer.android.com/guide/components/activities/tasks-and-back-stack) when using WebAuthn - if an `Activity` is not supplied then the UI will appear in a separate Task. For this reason, we strongly recommend passing the `callingActivity` option to both the `signIn` and `confirmSignIn` APIs if your application uses the `USER_AUTH` flow.
</Callout>

<BlockSwitcher>
<Block name="Java">

```java
// Pass the calling activity
AuthSignInOptions options = AWSCognitoAuthConfirmSignInOptions.builder()
    .callingActivity(activity)
    .build();

// Confirm WebAuthn as the challenge type
Amplify.Auth.confirmSignIn(
    AuthFactorType.WEB_AUTHN.getChallengeResponse(),
    options,
    result -> Log.i("AuthQuickStart", "Next sign in step: " + result.getNextStep()),
    error -> Log.e("AuthQuickstart", "Failed to sign in", error)
);
```

</Block>
<Block name="Kotlin - Callbacks">

```kotlin
// Pass the calling activity
val options = AWSCognitoAuthConfirmSignInOptions.builder()
    .callingActivity(activity)
    .build()

// Confirm WebAuthn as the challenge type
Amplify.Auth.confirmSignIn(
    AuthFactorType.WEB_AUTHN.name,
    options,
    { result -> Log.i("AuthQuickStart", "Next sign in step: ${result.nextStep}") },
    { error -> Log.e("AuthQuickstart", "Failed to sign in", error) }
)
```

</Block>
<Block name="Kotlin - Coroutines">

```kotlin
// Pass the calling activity
val options = AWSCognitoAuthConfirmSignInOptions.builder()
    .callingActivity(activity)
    .build()

try {
    // Confirm WebAuthn as the challenge type
    var result = Amplify.Auth.confirmSignIn(
        challengeResponse = AuthFactorType.WEB_AUTHN.challengeResponse,
        options = options
    )
    Log.i("AuthQuickStart", "Next sign in step: ${result.nextStep}")
} catch (error: AuthException) {
    Log.e("AuthQuickstart", "Failed to sign in", error)
}
```

</Block>
<Block name="RxJava">

```java
// Pass the calling activity
AuthSignInOptions options = AWSCognitoAuthConfirmSignInOptions.builder()
    .callingActivity(activity)
    .build();

// Confirm WebAuthn as the challenge type
RxAmplify.Auth.confirmSignIn(AuthFactorType.WEB_AUTHN.getChallengeResponse(), options)
    .subscribe(
        result -> Log.i("AuthQuickStart", "Next sign in step: " + result.getNextStep()),
        error -> Log.e("AuthQuickstart", "Failed to sign in", error)
    );
```

</Block>
</BlockSwitcher>

Using WebAuthn sign in may result in a number of possible exception types.

- `UserCancelledException` - If the user declines to authorize access to the PassKey in the system UI. You can retry the WebAuthn flow by invoking `confirmSignIn` again, or restart the `signIn` process to select a different `AuthFactorType`.
- `WebAuthnNotEnabledException` - This indicates WebAuthn is not enabled in your user pool.
- `WebAuthnNotSupportedException` - This indicates WebAuthn is not supported on the user's device.
- `WebAuthnRpMismatchException` - This indicates there is a problem with the `assetlinks.json` file deployed to your relying party.
- `WebAuthnFailedException` - This exception is used for other errors that may occur with WebAuthn. Inspect the `cause` to determine the best course of action.

</InlineFilter>
<InlineFilter filters={["flutter"]}>

{/*  */}

</InlineFilter>
<InlineFilter filters={["swift"]}>

{/*  */}

</InlineFilter>

<InlineFilter filters={["angular", "javascript", "nextjs", "react", "react-native", "vue", "android"]}>

### Password

Pass either `PASSWORD` or `PASSWORD_SRP` as the `preferredChallenge` in order to initiate a traditional password based authentication flow.

</InlineFilter>

<InlineFilter filters={["angular", "javascript", "nextjs", "react", "react-native", "vue"]}>
```ts
const { nextStep: signInNextStep } = await signIn({
	username: 'hello@example.com',
	password: 'example-password',
	options: {
		authFlowType: 'USER_AUTH',
		preferredChallenge: 'PASSWORD_SRP', // or 'PASSWORD'
	},
});

if (confirmSignInNextStep.signInStep === 'DONE') {
	console.log('Sign in successful!');
}
```
</InlineFilter>

<InlineFilter filters={["android"]}>

<BlockSwitcher>
<Block name="Java">

```java
// First confirm the challenge type
Amplify.Auth.confirmSignIn(
    AuthFactorType.PASSWORD.getChallengeResponse(), // or PASSWORD_SRP
    result -> {
        if (result.getNextStep().getSignInStep() == AuthSignInStep.CONFIRM_SIGN_IN_WITH_PASSWORD) {
            // Show UI to collect password
        }
    },
    error -> Log.e("AuthQuickstart", error.toString())
);

// Then pass that password into the confirmSignIn API
Amplify.Auth.confirmSignIn(
    "password",
    result -> {
        // result.getNextStep().getSignInStep() should be "DONE" now
    },
    error -> Log.e("AuthQuickstart", error.toString())
);
```

</Block>
<Block name="Kotlin - Callbacks">

```kotlin
// First confirm the challenge type
Amplify.Auth.confirmSignIn(
    AuthFactorType.PASSWORD.challengeResponse, // or PASSWORD_SRP
    { result ->
        if (result.nextStep.signInStep == AuthSignInStep.CONFIRM_SIGN_IN_WITH_PASSWORD) {
            // Show UI to collect password
        }
    },
    { error ->
        Log.e("AuthQuickstart", "Failed to sign in", error)
    }
)

// Then pass that password into the confirmSignIn API
Amplify.Auth.confirmSignIn(
    "password",
    { result ->
        // result.nextStep.signInStep should be "DONE" now
    },
    { error ->
        Log.e("AuthQuickstart", "Failed to sign in", error)
    }
)
```

</Block>
<Block name="Kotlin - Coroutines">

```kotlin
// First confirm the challenge type
var result = Amplify.Auth.confirmSignIn(AuthFactorType.PASSWORD.challengeResponse) // or PASSWORD_SRP
if (result.nextStep.signInStep == AuthSignInStep.CONFIRM_SIGN_IN_WITH_PASSWORD) {
    // Show UI to collect password
}

// Then pass that password into the confirmSignIn API
result = Amplify.Auth.confirmSignIn("password")

// result.nextStep.signInStep should be "DONE" now
```

</Block>
<Block name="RxJava">

```java
// First confirm the challenge type
RxAmplify.Auth.confirmSignIn(AuthFactorType.PASSWORD.getChallengeResponse()) // or PASSWORD_SRP
    .subscribe(
        result -> {
            if (result.getNextStep().getSignInStep() == AuthSignInStep.CONFIRM_SIGN_IN_WITH_PASSWORD) {
                // Show UI to collect password
            }
        },
        error -> Log.e("AuthQuickstart", error.toString())
    );

// Then pass that password into the confirmSignIn API
RxAmplify.Auth.confirmSignIn("password")
    .subscribe(
        result -> {
            // result.getNextStep().getSignInStep() should be "DONE" now
        },
        error -> Log.e("AuthQuickstart", error.toString())
    );
```

</Block>
</BlockSwitcher>

</InlineFilter>

<InlineFilter filters={["angular", "javascript", "nextjs", "react", "react-native", "vue", "android"]}>
### First Factor Selection

Omit the `preferredChallenge` parameter to discover what first factors are available for a given user.

The `confirmSignIn` API can then be used to select a challenge and initiate the associated authentication flow.
</InlineFilter>

<InlineFilter filters={["angular", "javascript", "nextjs", "react", "react-native", "vue"]}>
```ts
const { nextStep: signInNextStep } = await signIn({
	username: '+15551234567',
	options: {
		authFlowType: 'USER_AUTH',
	},
});

if (
	signInNextStep.signInStep === 'CONTINUE_SIGN_IN_WITH_FIRST_FACTOR_SELECTION'
) {
	// present user with list of available challenges
	console.log(`Available Challenges: ${signInNextStep.availableChallenges}`);

	// respond with user selection using `confirmSignIn` API
	const { nextStep: nextConfirmSignInStep } = await confirmSignIn({
		challengeResponse: 'SMS_OTP', // or 'EMAIL_OTP', 'WEB_AUTHN', 'PASSWORD', 'PASSWORD_SRP'
	});
}

```
</InlineFilter>

<InlineFilter filters={["android"]}>
<BlockSwitcher>
<Block name="Java">

```java
// Retrieve the authentication factors by calling .availableFactors
AWSCognitoAuthSignInOptions options =
    AWSCognitoAuthSignInOptions
        .builder()
        .authFlowType(AuthFlowType.USER_AUTH)
        .callingActivity(callingActivity)
        .build();
Amplify.Auth.signIn(
    "hello@example.com",
    null,
    options,
    result -> {
        if (result.getNextStep().getSignInStep() == AuthSignInStep.CONTINUE_SIGN_IN_WITH_FIRST_FACTOR_SELECTION) {
            Log.i(
                "AuthQuickstart",
                "Available authentication factors for this user: " + result.getNextStep().getAvailableFactors()
            );
        }
    },
    error -> Log.e("AuthQuickstart", error.toString())
);
```

</Block>
<Block name="Kotlin - Callbacks">

```kotlin
// Retrieve the authentication factors by calling .availableFactors
val options = AWSCognitoAuthSignInOptions.builder()
    .authFlowType(AuthFlowType.USER_AUTH)
    .callingActivity(callingActivity)
    .build()
Amplify.Auth.signIn(
    "hello@example.com",
    null,
    options,
    { result ->
        if (result.nextStep.signInStep == AuthSignInStep.CONTINUE_SIGN_IN_WITH_FIRST_FACTOR_SELECTION) {
            Log.i(
                "AuthQuickstart",
                "Available factors for this user: ${result.nextStep.availableFactors}"
            )
        }
    },
    { error ->
        Log.e("AuthQuickstart", "Failed to sign in", error)
    }
)
```

</Block>
<Block name="Kotlin - Coroutines">

```kotlin
try {
    // Retrieve the authentication factors by calling .availableFactors
    val options = AWSCognitoAuthSignInOptions.builder()
        .authFlowType(AuthFlowType.USER_AUTH)
        .callingActivity(callingActivity)
        .build()
    val result = Amplify.Auth.signIn(
        username = "hello@example.com",
        password = null,
        options = options
    )
    if (result.nextStep.signInStep == AuthSignInStep.CONTINUE_SIGN_IN_WITH_FIRST_FACTOR_SELECTION) {
        Log.i(
            "AuthQuickstart",
            "Available factors for this user: ${result.nextStep.availableFactors}"
        )
    }
} catch (error: AuthException) {
    Log.e("AuthQuickstart", "Sign in failed", error)
}
```

</Block>
<Block name="RxJava">

```java
// Retrieve the authentication factors by calling .availableFactors
AWSCognitoAuthSignInOptions options =
    AWSCognitoAuthSignInOptions
        .builder()
        .authFlowType(AuthFlowType.USER_AUTH)
        .callingActivity(callingActivity)
        .build();
RxAmplify.Auth.signIn("hello@example.com", null, options)
    .subscribe(
        result -> {
            if (result.getNextStep().getSignInStep() == AuthSignInStep.CONTINUE_SIGN_IN_WITH_FIRST_FACTOR_SELECTION) {
                Log.i(
                    "AuthQuickstart",
                    "Available authentication factors for this user: " + result.getNextStep().getAvailableFactors()
                );
            }
        },
        error -> Log.e("AuthQuickstart", error.toString())
    );
```

</Block>
</BlockSwitcher>

</InlineFilter>



</InlineFilter>


Contents of build-a-backend_auth_connect-your-frontend_sign-out_index.txt:
import { getCustomStaticPath } from '@/utils/getCustomStaticPath';

export const meta = {
  title: 'Sign-out',
  description: 'Learn how to sign out',
  platforms: [
    'android',
    'angular',
    'flutter',
    'javascript',
    'nextjs',
    'react',
    'react-native',
    'swift',
    'vue'
  ]
};

export function getStaticPaths() {
  return getCustomStaticPath(meta.platforms);
}

export function getStaticProps() {
  return {
    props: {
      meta
    }
  };
}

Amplify provides a client library that enables you to interact with backend resources such as Amplify Auth.

<InlineFilter filters={["react"]}>
<Callout info>

The quickest way to get started with Amplify Auth in your frontend application is with the [Authenticator component](https://ui.docs.amplify.aws/react/connected-components/authenticator), which provides a customizable UI and complete authentication flows.

</Callout>
</InlineFilter>

<InlineFilter filters={["swift"]}>
<Callout info>

The quickest way to get started with Amplify Auth in your frontend application is with the [Authenticator component](https://ui.docs.amplify.aws/swift/connected-components/authenticator), which provides a customizable UI and complete authentication flows.

</Callout>
</InlineFilter>

<InlineFilter filters={["flutter"]}>
<Callout info>

The quickest way to get started with Amplify Auth in your frontend application is with the [Authenticator component](https://ui.docs.amplify.aws/flutter/connected-components/authenticator), which provides a customizable UI and complete authentication flows.

</Callout>
</InlineFilter>

<InlineFilter filters={["android"]}>
<Callout info>

The quickest way to get started with Amplify Auth in your frontend application is with the [Authenticator component](https://ui.docs.amplify.aws/android/connected-components/authenticator), which provides a customizable UI and complete authentication flows.

</Callout>
</InlineFilter>

{/* signOut api definition */}

To sign a user out of your application use the `signOut` API.

<InlineFilter filters={["angular", "javascript", "nextjs", "react", "react-native", "vue"]}>

```ts
import { signOut } from 'aws-amplify/auth';

await signOut();
```

</InlineFilter>
<InlineFilter filters={["flutter"]}>

```dart
Future<void> signOutCurrentUser() async {
  final result = await Amplify.Auth.signOut();
  if (result is CognitoCompleteSignOut) {
    safePrint('Sign out completed successfully');
  } else if (result is CognitoFailedSignOut) {
    safePrint('Error signing user out: ${result.exception.message}');
  }
}
```

</InlineFilter>
<InlineFilter filters={["android"]}>

<BlockSwitcher>
<Block name="Java">

```java
Amplify.Auth.signOut( signOutResult -> {
    if (signOutResult instanceof AWSCognitoAuthSignOutResult.CompleteSignOut) {
        // Sign Out completed fully and without errors.
        Log.i("AuthQuickStart", "Signed out successfully");
    } else if (signOutResult instanceof AWSCognitoAuthSignOutResult.PartialSignOut) {
        // Sign Out completed with some errors. User is signed out of the device.
        AWSCognitoAuthSignOutResult.PartialSignOut partialSignOutResult =
                (AWSCognitoAuthSignOutResult.PartialSignOut) signOutResult;

        HostedUIError hostedUIError = partialSignOutResult.getHostedUIError();
        if (hostedUIError != null) {
            Log.e("AuthQuickStart", "HostedUI Error", hostedUIError.getException());
            // Optional: Re-launch hostedUIError.getUrl() in a Custom tab to clear Cognito web session.
        }

        GlobalSignOutError globalSignOutError = partialSignOutResult.getGlobalSignOutError();
        if (globalSignOutError != null) {
            Log.e("AuthQuickStart", "GlobalSignOut Error", globalSignOutError.getException());
            // Optional: Use escape hatch to retry revocation of globalSignOutError.getAccessToken().
        }

        RevokeTokenError revokeTokenError = partialSignOutResult.getRevokeTokenError();
        if (revokeTokenError != null) {
            Log.e("AuthQuickStart", "RevokeToken Error", revokeTokenError.getException());
            // Optional: Use escape hatch to retry revocation of revokeTokenError.getRefreshToken().
        }
    } else if (signOutResult instanceof AWSCognitoAuthSignOutResult.FailedSignOut) {
        AWSCognitoAuthSignOutResult.FailedSignOut failedSignOutResult =
                (AWSCognitoAuthSignOutResult.FailedSignOut) signOutResult;
        // Sign Out failed with an exception, leaving the user signed in.
        Log.e("AuthQuickStart", "Sign out Failed", failedSignOutResult.getException());
    }
});
```

</Block>
<Block name="Kotlin - Callbacks">

```kotlin
Amplify.Auth.signOut { signOutResult ->
    when(signOutResult) {
        is AWSCognitoAuthSignOutResult.CompleteSignOut -> {
            // Sign Out completed fully and without errors.
            Log.i("AuthQuickStart", "Signed out successfully")
        }
        is AWSCognitoAuthSignOutResult.PartialSignOut -> {
            // Sign Out completed with some errors. User is signed out of the device.
            signOutResult.hostedUIError?.let {
                Log.e("AuthQuickStart", "HostedUI Error", it.exception)
                // Optional: Re-launch it.url in a Custom tab to clear Cognito web session.

            }
            signOutResult.globalSignOutError?.let {
                Log.e("AuthQuickStart", "GlobalSignOut Error", it.exception)
                // Optional: Use escape hatch to retry revocation of it.accessToken.
            }
            signOutResult.revokeTokenError?.let {
                Log.e("AuthQuickStart", "RevokeToken Error", it.exception)
                // Optional: Use escape hatch to retry revocation of it.refreshToken.
            }
        }
        is AWSCognitoAuthSignOutResult.FailedSignOut -> {
            // Sign Out failed with an exception, leaving the user signed in.
            Log.e("AuthQuickStart", "Sign out Failed", signOutResult.exception)
        }
    }
}
```

</Block>
<Block name="Kotlin - Coroutines">

```kotlin
val signOutResult = Amplify.Auth.signOut()
when(signOutResult) {
    is AWSCognitoAuthSignOutResult.CompleteSignOut -> {
        // Sign Out completed fully and without errors.
        Log.i("AuthQuickStart", "Signed out successfully")
    }
    is AWSCognitoAuthSignOutResult.PartialSignOut -> {
        // Sign Out completed with some errors. User is signed out of the device.
        signOutResult.hostedUIError?.let {
            Log.e("AuthQuickStart", "HostedUI Error", it.exception)
            // Optional: Re-launch it.url in a Custom tab to clear Cognito web session.

        }
        signOutResult.globalSignOutError?.let {
            Log.e("AuthQuickStart", "GlobalSignOut Error", it.exception)
            // Optional: Use escape hatch to retry revocation of it.accessToken.
        }
        signOutResult.revokeTokenError?.let {
            Log.e("AuthQuickStart", "RevokeToken Error", it.exception)
            // Optional: Use escape hatch to retry revocation of it.refreshToken.
        }
    }
    is AWSCognitoAuthSignOutResult.FailedSignOut -> {
        // Sign Out failed with an exception, leaving the user signed in.
        Log.e("AuthQuickStart", "Sign out Failed", signOutResult.exception)
    }
}
```

</Block>
<Block name="RxJava">

```java
RxAmplify.Auth.signOut()
    .subscribe(signOutResult -> {
        if (signOutResult instanceof AWSCognitoAuthSignOutResult.CompleteSignOut) {
            // Sign Out completed fully and without errors.
            Log.i("AuthQuickStart", "Signed out successfully");
        } else if (signOutResult instanceof AWSCognitoAuthSignOutResult.PartialSignOut) {
            // Sign Out completed with some errors. User is signed out of the device.
            AWSCognitoAuthSignOutResult.PartialSignOut partialSignOutResult =
                    (AWSCognitoAuthSignOutResult.PartialSignOut) signOutResult;

            HostedUIError hostedUIError = partialSignOutResult.getHostedUIError();
            if (hostedUIError != null) {
                Log.e("AuthQuickStart", "HostedUI Error", hostedUIError.getException());
                // Optional: Re-launch hostedUIError.getUrl() in a Custom tab to clear Cognito web session.
            }

            GlobalSignOutError globalSignOutError = partialSignOutResult.getGlobalSignOutError();
            if (globalSignOutError != null) {
                Log.e("AuthQuickStart", "GlobalSignOut Error", globalSignOutError.getException());
                // Optional: Use escape hatch to retry revocation of globalSignOutError.getAccessToken().
            }

            RevokeTokenError revokeTokenError = partialSignOutResult.getRevokeTokenError();
            if (revokeTokenError != null) {
                Log.e("AuthQuickStart", "RevokeToken Error", revokeTokenError.getException());
                // Optional: Use escape hatch to retry revocation of revokeTokenError.getRefreshToken().
            }
        } else if (signOutResult instanceof AWSCognitoAuthSignOutResult.FailedSignOut) {
            AWSCognitoAuthSignOutResult.FailedSignOut failedSignOutResult =
                    (AWSCognitoAuthSignOutResult.FailedSignOut) signOutResult;
            // Sign Out failed with an exception, leaving the user signed in.
            Log.e("AuthQuickStart", "Sign out Failed", failedSignOutResult.getException());
        }
    });
```

</Block>
</BlockSwitcher>

</InlineFilter>
<InlineFilter filters={["swift"]}>

<BlockSwitcher>
<Block name="Async/Await">

```swift
func signOutLocally() async {
    let result = await Amplify.Auth.signOut()
    guard let signOutResult = result as? AWSCognitoSignOutResult
    else {
        print("Signout failed")
        return
    }

    print("Local signout successful: \(signOutResult.signedOutLocally)")
    switch signOutResult {
    case .complete:
        // Sign Out completed fully and without errors.
        print("Signed out successfully")

    case let .partial(revokeTokenError, globalSignOutError, hostedUIError):
        // Sign Out completed with some errors. User is signed out of the device.
        
        if let hostedUIError = hostedUIError {
            print("HostedUI error  \(String(describing: hostedUIError))")
        }

        if let globalSignOutError = globalSignOutError {
            // Optional: Use escape hatch to retry revocation of globalSignOutError.accessToken.
            print("GlobalSignOut error  \(String(describing: globalSignOutError))")
        }

        if let revokeTokenError = revokeTokenError {
            // Optional: Use escape hatch to retry revocation of revokeTokenError.accessToken.
            print("Revoke token error  \(String(describing: revokeTokenError))")
        }

    case .failed(let error):
        // Sign Out failed with an exception, leaving the user signed in.
        print("SignOut failed with \(error)")
    }
}
```

</Block>
<Block name="Combine">

```swift
func signOutLocally() -> AnyCancellable {
    Amplify.Publisher.create {
        await Amplify.Auth.signOut()
    }.sink(receiveValue: { result in
        guard let signOutResult = result as? AWSCognitoSignOutResult
        else {
            print("Signout failed")
            return
        }
        print("Local signout successful: \(signOutResult.signedOutLocally)")
        switch signOutResult {
        case .complete:
            // Sign Out completed fully and without errors.
            print("Signed out successfully")

        case let .partial(revokeTokenError, globalSignOutError, hostedUIError):
            // Sign Out completed with some errors. User is signed out of the device.
            if let hostedUIError = hostedUIError {
                print("HostedUI error  \(String(describing: hostedUIError))")
            }

            if let globalSignOutError = globalSignOutError {
                // Optional: Use escape hatch to retry revocation of globalSignOutError.accessToken.
                print("GlobalSignOut error  \(String(describing: globalSignOutError))")
            }

            if let revokeTokenError = revokeTokenError {
                // Optional: Use escape hatch to retry revocation of revokeTokenError.accessToken.
                print("Revoke token error  \(String(describing: revokeTokenError))")
            }

        case .failed(let error):
            // Sign Out failed with an exception, leaving the user signed in.
            print("SignOut failed with \(error)")
        }
    })
}
```

</Block>

</BlockSwitcher>

</InlineFilter>

You can also sign out users from all devices by performing a global sign-out. This will also invalidate all refresh tokens issued to a user. The user's current access and ID tokens will remain valid on other devices until the refresh token expires (access and ID tokens expire one hour after they are issued).

<InlineFilter filters={["angular", "javascript", "nextjs", "react", "react-native", "vue"]}>

```ts
import { signOut } from 'aws-amplify/auth';

await signOut({ global: true });
```

</InlineFilter>
<InlineFilter filters={["flutter"]}>

```dart
Future<void> signOutGlobally() async {
  final result = await Amplify.Auth.signOut(
    options: const SignOutOptions(globalSignOut: true),
  );
  if (result is CognitoCompleteSignOut) {
    safePrint('Sign out completed successfully');
  } else if (result is CognitoPartialSignOut) {
    final globalSignOutException = result.globalSignOutException!;
    final accessToken = globalSignOutException.accessToken;
    // Retry the global sign out using the access token, if desired
    // ...
    safePrint('Error signing user out: ${globalSignOutException.message}');
  } else if (result is CognitoFailedSignOut) {
    safePrint('Error signing user out: ${result.exception.message}');
  }
}
```

</InlineFilter>
<InlineFilter filters={["android"]}>

<BlockSwitcher>
<Block name="Java">

```java
AuthSignOutOptions options = AuthSignOutOptions.builder()
    .globalSignOut(true)
    .build();

Amplify.Auth.signOut(options, signOutResult -> {
    if (signOutResult instanceof AWSCognitoAuthSignOutResult.CompleteSignOut) {
        // handle successful sign out
    } else if (signOutResult instanceof AWSCognitoAuthSignOutResult.PartialSignOut) {
        // handle partial sign out
    } else if (signOutResult instanceof AWSCognitoAuthSignOutResult.FailedSignOut) {
        // handle failed sign out
    }
});
```

</Block>
<Block name="Kotlin - Callbacks">

```kotlin
val options = AuthSignOutOptions.builder()
    .globalSignOut(true)
    .build()

Amplify.Auth.signOut(options) { signOutResult ->
    when(signOutResult) {
        is AWSCognitoAuthSignOutResult.CompleteSignOut -> {
            // handle successful sign out
        }
        is AWSCognitoAuthSignOutResult.PartialSignOut -> {
            // handle partial sign out
        }
        is AWSCognitoAuthSignOutResult.FailedSignOut -> {
            // handle failed sign out
        }
    }
}
```

</Block>
<Block name="Kotlin - Coroutines">

```kotlin
val options = AuthSignOutOptions.builder()
    .globalSignOut(true)
    .build()

val signOutResult = Amplify.Auth.signOut(options)

when(signOutResult) {
    is AWSCognitoAuthSignOutResult.CompleteSignOut -> {
        // handle successful sign out
    }
    is AWSCognitoAuthSignOutResult.PartialSignOut -> {
        // handle partial sign out
    }
    is AWSCognitoAuthSignOutResult.FailedSignOut -> {
        // handle failed sign out
    }
}
```

</Block>
<Block name="RxJava">

```java
AuthSignOutOptions options = AuthSignOutOptions.builder()
    .globalSignOut(true)
    .build();
    
RxAmplify.Auth.signOut(options)
    .subscribe(signOutResult -> {
        if (signOutResult instanceof AWSCognitoAuthSignOutResult.CompleteSignOut) {
            // handle successful sign out
        } else if (signOutResult instanceof AWSCognitoAuthSignOutResult.PartialSignOut) {
            // handle partial sign out
        } else if (signOutResult instanceof AWSCognitoAuthSignOutResult.FailedSignOut) {
            // handle failed sign out
        }
    });
```

</Block>
</BlockSwitcher> 

</InlineFilter>
<InlineFilter filters={["swift"]}>

<BlockSwitcher>
<Block name="Async/Await">

```swift
import AWSCognitoAuthPlugin

func signOutGlobally() async {
    let result = await Amplify.Auth.signOut(options: .init(globalSignOut: true))
    guard let signOutResult = result as? AWSCognitoSignOutResult
    else {
        print("Signout failed")
        return
    }

    print("Local signout successful: \(signOutResult.signedOutLocally)")
    switch signOutResult {
    case .complete:
        // handle successful sign out
    case .failed(let error):
        // handle failed sign out
    case let .partial(revokeTokenError, globalSignOutError, hostedUIError):
        // handle partial sign out
    }
}
```

</Block>
<Block name="Combine">

```swift
func signOutGlobally() -> AnyCancellable {
    Amplify.Publisher.create {
        await Amplify.Auth.signOut(options: .init(globalSignOut: true))
    }.sink(receiveValue: { result in
        guard let signOutResult = result as? AWSCognitoSignOutResult
        else {
            print("Signout failed")
            return
        }
        print("Local signout successful: \(signOutResult.signedOutLocally)")
        switch signOutResult {
        case .complete:
            // handle successful sign out
        case .failed(let error):
            // handle failed sign out
        case let .partial(revokeTokenError, globalSignOutError, hostedUIError):
            // handle partial sign out
        }
    })
}
```

</Block>
</BlockSwitcher>

</InlineFilter>

{/* double-filter to conditionally display this section for only platforms that have examples */}
<InlineFilter filters={["javascript", "nextjs", "react"]}>

## Practical Example

<InlineFilter filters={["javascript", "nextjs", "react"]}>

```tsx title="src/App.tsx"
import { Amplify } from "aws-amplify"
// highlight-next-line
import { signOut } from "aws-amplify/auth"
import outputs from "../amplify_outputs.json"

Amplify.configure(outputs)

export default function App() {
  async function handleSignOut() {
    // highlight-next-line
    await signOut()
  }

  return (
    <button type="button" onClick={handleSignOut}>
      Sign out
    </button>
  )
}
```

</InlineFilter>
</InlineFilter>


Contents of build-a-backend_auth_connect-your-frontend_sign-up_index.txt:
import { getCustomStaticPath } from '@/utils/getCustomStaticPath';

export const meta = {
  title: 'Sign-up',
  description: 'Learn how to sign up',
  platforms: [
    'android',
    'angular',
    'flutter',
    'javascript',
    'nextjs',
    'react',
    'react-native',
    'swift',
    'vue'
  ]
};

export function getStaticPaths() {
  return getCustomStaticPath(meta.platforms);
}

export function getStaticProps() {
  return {
    props: {
      meta,
    }
  };
}

Amplify provides a client library that enables you to interact with backend resources such as Amplify Auth.

{/* signUp api definition */}

<InlineFilter filters={["react"]}>
<Callout info>

The quickest way to get started with Amplify Auth in your frontend application is with the [Authenticator component](https://ui.docs.amplify.aws/react/connected-components/authenticator), which provides a customizable UI and complete authentication flows.

</Callout>
</InlineFilter>

<InlineFilter filters={["swift"]}>
<Callout info>

The quickest way to get started with Amplify Auth in your frontend application is with the [Authenticator component](https://ui.docs.amplify.aws/swift/connected-components/authenticator), which provides a customizable UI and complete authentication flows.

</Callout>
</InlineFilter>

<InlineFilter filters={["flutter"]}>
<Callout info>

The quickest way to get started with Amplify Auth in your frontend application is with the [Authenticator component](https://ui.docs.amplify.aws/flutter/connected-components/authenticator), which provides a customizable UI and complete authentication flows.

</Callout>
</InlineFilter>

<InlineFilter filters={["android"]}>
<Callout info>

The quickest way to get started with Amplify Auth in your frontend application is with the [Authenticator component](https://ui.docs.amplify.aws/android/connected-components/authenticator), which provides a customizable UI and complete authentication flows.

</Callout>
</InlineFilter>

To get started, you can use the `signUp()` API to create a new user in your backend:

<InlineFilter filters={["javascript", "react", "nextjs", "angular", "vue"]}>

```ts
import { signUp } from "aws-amplify/auth"

const { isSignUpComplete, userId, nextStep } = await signUp({
  username: "hello@mycompany.com",
  password: "hunter2",
  options: {
    userAttributes: {
      email: "hello@mycompany.com",
      phone_number: "+15555555555" // E.164 number convention
    },
  }
});
```

</InlineFilter>
<InlineFilter filters={["flutter"]}>

 ```dart
/// Signs a user up with a username, password, and email. The required
/// attributes may be different depending on your app's configuration.
Future<void> signUpUser({
  required String username,
  required String password,
  required String email,
  String? phoneNumber,
}) async {
  try {
    final userAttributes = {
      AuthUserAttributeKey.email: email,
      if (phoneNumber != null) AuthUserAttributeKey.phoneNumber: phoneNumber,
      // additional attributes as needed
    };
    final result = await Amplify.Auth.signUp(
      username: username,
      password: password,
      options: SignUpOptions(
        userAttributes: userAttributes,
      ),
    );
    await _handleSignUpResult(result);
  } on AuthException catch (e) {
    safePrint('Error signing up user: ${e.message}');
  }
}
```

```dart
Future<void> _handleSignUpResult(SignUpResult result) async {
  switch (result.nextStep.signUpStep) {
    case AuthSignUpStep.confirmSignUp:
      final codeDeliveryDetails = result.nextStep.codeDeliveryDetails!;
      _handleCodeDelivery(codeDeliveryDetails);
      break;
    case AuthSignUpStep.done:
      safePrint('Sign up is complete');
      break;
  }
}

void _handleCodeDelivery(AuthCodeDeliveryDetails codeDeliveryDetails) {
  safePrint(
    'A confirmation code has been sent to ${codeDeliveryDetails.destination}. '
    'Please check your ${codeDeliveryDetails.deliveryMedium.name} for the code.',
  );
}
```

</InlineFilter>
<InlineFilter filters={["android"]}>

<BlockSwitcher>
<Block name="Java">

```java
ArrayList<AuthUserAttribute> attributes = new ArrayList<>();
attributes.add(new AuthUserAttribute(AuthUserAttributeKey.email(), "my@email.com"));
attributes.add(new AuthUserAttribute(AuthUserAttributeKey.phoneNumber(), "+15551234567"));

Amplify.Auth.signUp(
    "username",
    "Password123",
    AuthSignUpOptions.builder().userAttributes(attributes).build(),
    result -> Log.i("AuthQuickstart", result.toString()),
    error -> Log.e("AuthQuickstart", error.toString())
);
```

</Block>
<Block name="Kotlin - Callbacks">

```kotlin
val attrs = mapOf(
    AuthUserAttributeKey.email() to "my@email.com",
    AuthUserAttributeKey.phoneNumber() to "+15551234567"
)
val options = AuthSignUpOptions.builder()
    .userAttributes(attrs.map { AuthUserAttribute(it.key, it.value) })
    .build()
Amplify.Auth.signUp("username", "Password123", options,
    { Log.i("AuthQuickstart", "Sign up result = $it") },
    { Log.e("AuthQuickstart", "Sign up failed", it) }
)
```

</Block>
<Block name="Kotlin - Coroutines">

```kotlin
val attrs = mapOf(
    AuthUserAttributeKey.email() to "my@email.com",
    AuthUserAttributeKey.phoneNumber() to "+15551234567"
)
val options = AuthSignUpOptions.builder()
    .userAttributes(attrs.map { AuthUserAttribute(it.key, it.value) })
    .build()
try {
    val result = Amplify.Auth.signUp("username", "Password123", options)
    Log.i("AuthQuickstart", "Sign up OK: $result")
} catch (error: AuthException) {
    Log.e("AuthQuickstart", "Sign up failed", error)
}
```

</Block>
<Block name="RxJava">

```java
ArrayList<AuthUserAttribute> attributes = new ArrayList<>();
attributes.add(new AuthUserAttribute(AuthUserAttributeKey.email(), "my@email.com"));
attributes.add(new AuthUserAttribute(AuthUserAttributeKey.phoneNumber(), "+15551234567"));

RxAmplify.Auth.signUp(
    "username",
    "Password123",
    AuthSignUpOptions.builder().userAttributes(attributes).build())
    .subscribe(
        result -> Log.i("AuthQuickstart", result.toString()),
        error -> Log.e("AuthQuickstart", error.toString())
    );
```

</Block>
</BlockSwitcher>

</InlineFilter>
<InlineFilter filters={["swift"]}>

<BlockSwitcher>

<Block name="Async/Await">

```swift
func signUp(username: String, password: String, email: String, phonenumber: String) async {
    let userAttributes = [AuthUserAttribute(.email, value: email), AuthUserAttribute(.phoneNumber, value: phonenumber)]
    let options = AuthSignUpRequest.Options(userAttributes: userAttributes)

    do {
        let signUpResult = try await Amplify.Auth.signUp(
            username: username,
            password: password,
            options: options
        )

        if case let .confirmUser(deliveryDetails, _, userId) = signUpResult.nextStep {
            print("Delivery details \(String(describing: deliveryDetails)) for userId: \(String(describing: userId)))")
        } else {
            print("SignUp Complete")
        }
    } catch let error as AuthError {
        print("An error occurred while registering a user \(error)")
    } catch {
        print("Unexpected error: \(error)")
    }
}
```

</Block>

<Block name="Combine">

```swift
func signUp(username: String, password: String, email: String, phonenumber: String) -> AnyCancellable {
    let userAttributes = [
        AuthUserAttribute(.email, value: email),
        AuthUserAttribute(.phoneNumber, value: phonenumber)
    ]
    let options = AuthSignUpRequest.Options(userAttributes: userAttributes)
    Amplify.Publisher.create {
        try await Amplify.Auth.signUp(
            username: username,
            password: password,
            options: options
        )
    }.sink {
        if case let .failure(authError) = $0 {
            print("An error occurred while registering a user \(authError)")
        }
    }
    receiveValue: { signUpResult in
        if case let .confirmUser(deliveryDetails, _, userId) = signUpResult.nextStep {
            print("Delivery details \(String(describing: deliveryDetails)) for userId: \(String(describing: userId)))")
        } else {
            print("SignUp Complete")
        }
    }
    return sink
}
```

</Block>
</BlockSwitcher>

</InlineFilter>

The `signUp` API response will include a `nextStep` property, which can be used to determine if further action is required. It may return the following next steps:

<InlineFilter filters={["angular", "javascript", "react", "react-native", "nextjs", "vue"]}>
| Next Step | Description |
| --------- | ----------- |
| `CONFIRM_SIGN_UP` | The sign up needs to be confirmed by collecting a code from the user and calling `confirmSignUp`. |
| `DONE` | The sign up process has been fully completed. |
| `COMPLETE_AUTO_SIGN_IN` | The sign up process needs to complete by invoking the `autoSignIn` API. |
</InlineFilter>

<InlineFilter filters={["android"]}>
| Next Step | Description |
| --------- | ----------- |
| `CONFIRM_SIGN_UP_STEP` | The sign up needs to be confirmed by collecting a code from the user and calling `confirmSignUp`. |
| `DONE` | The sign up process has been fully completed. |
</InlineFilter>

<InlineFilter filters={["swift", "flutter"]}>
| Next Step | Description |
| --------- | ----------- |
| `confirmSignUp` | The sign up needs to be confirmed by collecting a code from the user and calling `confirmSignUp`. |
| `done` | The sign up process has been fully completed. |
</InlineFilter>

## Confirm sign-up

By default, each user that signs up remains in the unconfirmed status until they verify with a confirmation code that was sent to their email or phone number. The following are the default verification methods used when either `phone` or `email` are used as `loginWith` options.

| Login option        | User account verification channel |
| ------------------- | --------------------------------- |
| `phone`             | Phone Number                      |
| `email`             | Email                             |
| `email` and `phone` | Email                             |

You can confirm the sign-up after receiving a confirmation code from the user:

<InlineFilter filters={["angular", "javascript", "react", "react-native", "nextjs", "vue"]}>

```ts
import { confirmSignUp } from 'aws-amplify/auth';

const { isSignUpComplete, nextStep } = await confirmSignUp({
  username: "hello@mycompany.com",
  confirmationCode: "123456"
});
```

</InlineFilter>
<InlineFilter filters={["flutter"]}>

```dart
Future<void> confirmUser({
  required String username,
  required String confirmationCode,
}) async {
  try {
    final result = await Amplify.Auth.confirmSignUp(
      username: username,
      confirmationCode: confirmationCode,
    );
    // Check if further confirmations are needed or if
    // the sign up is complete.
    await _handleSignUpResult(result);
  } on AuthException catch (e) {
    safePrint('Error confirming user: ${e.message}');
  }
}
```

</InlineFilter>
<InlineFilter filters={["android"]}>

<BlockSwitcher>
<Block name="Java">

```java
Amplify.Auth.confirmSignUp(
    "username",
    "the code you received via email",
    result -> Log.i("AuthQuickstart", result.isSignUpComplete() ? "Confirm signUp succeeded" : "Confirm sign up not complete"),
    error -> Log.e("AuthQuickstart", error.toString())
);
```

</Block>
<Block name="Kotlin - Callbacks">

```kotlin
Amplify.Auth.confirmSignUp(
    "username", "the code you received via email",
    { result ->
        if (result.isSignUpComplete) {
            Log.i("AuthQuickstart", "Confirm signUp succeeded")
        } else {
            Log.i("AuthQuickstart","Confirm sign up not complete")
        }
    },
    { Log.e("AuthQuickstart", "Failed to confirm sign up", it) }
)
```

</Block>
<Block name="Kotlin - Coroutines">

```kotlin
try {
    val code = "code you received via email"
    val result = Amplify.Auth.confirmSignUp("username", code)
    if (result.isSignUpComplete) {
        Log.i("AuthQuickstart", "Signup confirmed")
    } else {
        Log.i("AuthQuickstart", "Signup confirmation not yet complete")
    }
} catch (error: AuthException) {
    Log.e("AuthQuickstart", "Failed to confirm signup", error)
}
```

</Block>
<Block name="RxJava">

```java
RxAmplify.Auth.confirmSignUp("username", "the code you received via email")
    .subscribe(
        result -> Log.i("AuthQuickstart", result.isSignUpComplete() ? "Confirm signUp succeeded" : "Confirm sign up not complete"),
        error -> Log.e("AuthQuickstart", error.toString())
    );
```

</Block>
</BlockSwitcher>

</InlineFilter>
<InlineFilter filters={["swift"]}>

<BlockSwitcher>

<Block name="Async/Await">

```swift
func confirmSignUp(for username: String, with confirmationCode: String) async {
    do {
        let confirmSignUpResult = try await Amplify.Auth.confirmSignUp(
            for: username,
            confirmationCode: confirmationCode
        )
        print("Confirm sign up result completed: \(confirmSignUpResult.isSignUpComplete)")
    } catch let error as AuthError {
        print("An error occurred while confirming sign up \(error)")
    } catch {
        print("Unexpected error: \(error)")
    }
}
```

</Block>

<Block name="Combine">

```swift
func confirmSignUp(for username: String, with confirmationCode: String) -> AnyCancellable {
    Amplify.Publisher.create {
        try await Amplify.Auth.confirmSignUp(
            for: username,
            confirmationCode: confirmationCode
        )
    }.sink {
        if case let .failure(authError) = $0 {
            print("An error occurred while confirming sign up \(authError)")
        }
    }
    receiveValue: { _ in
        print("Confirm signUp succeeded")
    }
}
```

</Block>

</BlockSwitcher>

</InlineFilter>

<InlineFilter filters={["angular", "nextjs", "javascript", "react", "vue"]}>

<Callout info>

**Note:** When specifying `email` or `phone` as a way for your users to sign-in, these are attributes that are used in place of the username. Visit the [concepts page to learn more about usernames](/[platform]/build-a-backend/auth/concepts/).

</Callout>

</InlineFilter>


{/* double-filter to conditionally display this section for only platforms that have examples */}
<InlineFilter filters={["javascript", "nextjs", "react"]}>

## Practical Example

<InlineFilter filters={["javascript", "nextjs", "react"]}>

```tsx title="src/App.tsx"
import type { FormEvent } from "react"
import { Amplify } from "aws-amplify"
// highlight-next-line
import { signUp } from "aws-amplify/auth"
import outputs from "../amplify_outputs.json"

Amplify.configure(outputs)

interface SignUpFormElements extends HTMLFormControlsCollection {
  email: HTMLInputElement
  password: HTMLInputElement
}

interface SignUpForm extends HTMLFormElement {
  readonly elements: SignUpFormElements
}

export default function App() {
  async function handleSubmit(event: FormEvent<SignUpForm>) {
    event.preventDefault()
    const form = event.currentTarget
    // ... validate inputs
    await signUp({
      username: form.elements.email.value,
      password: form.elements.password.value,
    })
  }

  return (
    <form onSubmit={handleSubmit}>
      <label htmlFor="email">Email:</label>
      <input type="text" id="email" name="email" />
      <label htmlFor="password">Password:</label>
      <input type="password" id="password" name="password" />
      <input type="submit" />
    </form>
  )
}
```

</InlineFilter>
</InlineFilter>

<InlineFilter filters={["angular", "javascript", "nextjs", "react", "react-native", "vue", "swift", "android"]}>

## Sign up with passwordless methods

Your application's users can also sign up using passwordless methods. To learn more, visit the [concepts page for passwordless](/[platform]/build-a-backend/auth/concepts/passwordless/).

### SMS OTP

{/* blurb with supplemental information about handling sign-up, events, etc. */}

<InlineFilter filters={["angular", "javascript", "nextjs", "react", "react-native", "vue"]}>

```typescript
// Sign up using a phone number
const { nextStep: signUpNextStep } = await signUp({
	username: 'hello',
	options: {
		userAttributes: {
			phone_number: '+15555551234',
		},
	},
});

if (signUpNextStep.signUpStep === 'DONE') {
	console.log(`SignUp Complete`);
}

if (signUpNextStep.signUpStep === 'CONFIRM_SIGN_UP') {
	console.log(
		`Code Delivery Medium: ${signUpNextStep.codeDeliveryDetails.deliveryMedium}`,
	);
	console.log(
		`Code Delivery Destination: ${signUpNextStep.codeDeliveryDetails.destination}`,
	);
}

// Confirm sign up with the OTP received
const { nextStep: confirmSignUpNextStep } = await confirmSignUp({
	username: 'hello',
	confirmationCode: '123456',
});

if (confirmSignUpNextStep.signUpStep === 'DONE') {
	console.log(`SignUp Complete`);
}
```

</InlineFilter>
<InlineFilter filters={["android"]}>

<BlockSwitcher>
<Block name="Java">

```java
// Sign up using a phone number
ArrayList<AuthUserAttribute> attributes = new ArrayList<>();
attributes.add(new AuthUserAttribute(AuthUserAttributeKey.phoneNumber(), "+15551234567"));

Amplify.Auth.signUp(
    "hello@example.com",
    null,
    AuthSignUpOptions.builder().userAttributes(attributes).build(),
    result -> {
        if (result.isSignUpComplete()) {
            Log.i("AuthQuickstart", "Sign up is complete");
        } else if (result.getNextStep().getSignUpStep() == AuthSignUpStep.CONFIRM_SIGN_UP_STEP) {
            Log.i("AuthQuickstart", "Code Deliver Medium: " +
                result.getNextStep().getCodeDeliveryDetails().getDeliveryMedium());
            Log.i("AuthQuickstart", "Code Deliver Destination: " +
                result.getNextStep().getCodeDeliveryDetails().getDestination());
        }
    },
    error -> Log.e("AuthQuickstart", error.toString())
);

// Confirm sign up with the OTP received
Amplify.Auth.confirmSignUp(
    "hello@example.com",
    "123456",
    result -> {
        if (result.isSignUpComplete()) {
            Log.i("AuthQuickstart", "Sign up is complete");
        }
    },
    error -> Log.e("AuthQuickstart", error.toString())
);
```

</Block>
<Block name="Kotlin - Callbacks">

```kotlin
// Sign up using a phone number
val attributes = listOf(
    AuthUserAttribute(AuthUserAttributeKey.phoneNumber(), "+15555551234")
)
val options =
    AuthSignUpOptions
        .builder()
        .userAttributes(attributes)
        .build()

Amplify.Auth.signUp(
    "hello@example.com",
    null,
    options,
    { result ->
        if (result.isSignUpComplete) {
            Log.i("AuthQuickstart", "Sign up is complete")
        } else if (result.nextStep.signUpStep == AuthSignUpStep.CONFIRM_SIGN_UP_STEP) {
            Log.i("AuthQuickstart", "Code Deliver Medium: " +
                "${result.nextStep.codeDeliveryDetails?.deliveryMedium}")
            Log.i("AuthQuickstart", "Code Deliver Destination: " +
                "${result.nextStep.codeDeliveryDetails?.destination}")
        }
    },
    { Log.e("AuthQuickstart", "Failed to sign up", it) }
)

// Confirm sign up with the OTP received
Amplify.Auth.confirmSignUp(
    "hello@example.com",
    "123456",
    { result ->
        if (result.nextStep.signUpStep == AuthSignUpStep.DONE) {
            Log.i("AuthQuickstart", "Sign up is complete")
        }
    },
    { Log.e("AuthQuickstart", "Failed to sign up", it) }
)
```

</Block>
<Block name="Kotlin - Coroutines">

```kotlin
// Sign up using a phone number
val attributes = listOf(
    AuthUserAttribute(AuthUserAttributeKey.phoneNumber(), "+15555551234")
)
val options =
    AuthSignUpOptions
        .builder()
        .userAttributes(attributes)
        .build()
var result = Amplify.Auth.signUp("hello@example.com", null, options)

if (result.isSignUpComplete) {
    Log.i("AuthQuickstart", "Sign up is complete")
} else if (result.nextStep.signUpStep == AuthSignUpStep.CONFIRM_SIGN_UP_STEP) {
    Log.i("AuthQuickstart", "Code Deliver Medium: " +
        "${result.nextStep.codeDeliveryDetails?.deliveryMedium}")
    Log.i("AuthQuickstart", "Code Deliver Destination: " +
        "${result.nextStep.codeDeliveryDetails?.destination}")
}

// Confirm sign up with the OTP received
result = Amplify.Auth.confirmSignUp(
    "hello@example.com",
    "123456"
)

if (result.nextStep.signUpStep == AuthSignUpStep.DONE) {
    Log.i("AuthQuickstart", "Sign up is complete")
}
```

</Block>
<Block name="RxJava">

```java
// Sign up using a phone number
ArrayList<AuthUserAttribute> attributes = new ArrayList<>();
attributes.add(new AuthUserAttribute(AuthUserAttributeKey.phoneNumber(), "+15551234567"));

RxAmplify.Auth.signUp(
    "hello@example.com",
    null,
    AuthSignUpOptions.builder().userAttributes(attributes).build()
)
    .subscribe(
        result -> {
            if (result.isSignUpComplete()) {
                Log.i("AuthQuickstart", "Sign up is complete");
            } else if (result.getNextStep().getSignUpStep() == AuthSignUpStep.CONFIRM_SIGN_UP_STEP) {
                Log.i("AuthQuickstart", "Code Deliver Medium: " +
                    result.getNextStep().getCodeDeliveryDetails().getDeliveryMedium());
                Log.i("AuthQuickstart", "Code Deliver Destination: " +
                    result.getNextStep().getCodeDeliveryDetails().getDestination());
            }
        },
        error -> Log.e("AuthQuickstart", error.toString())
    );

// Confirm sign up with the OTP received
RxAmplify.Auth.confirmSignUp(
    "hello@example.com",
    "123456"
)
    .subscribe(
        result -> {
            if (result.isSignUpComplete()) {
                Log.i("AuthQuickstart", "Sign up is complete");
            }
        },
        error -> Log.e("AuthQuickstart", error.toString())
    );
```

</Block>
</BlockSwitcher>


</InlineFilter>
<InlineFilter filters={["swift"]}>

<BlockSwitcher>

<Block name="Async/Await">

```swift
// Sign up using an phone number
func signUp(username: String, phonenumber: String) async {
    let userAttributes = [
        AuthUserAttribute(.phoneNumber, value: phonenumber)
    ]
    let options = AuthSignUpRequest.Options(userAttributes: userAttributes)
    do {
        let signUpResult = try await Amplify.Auth.signUp(
            username: username,
            options: options
        )
        if case let .confirmUser(deliveryDetails, _, userId) = signUpResult.nextStep {
            print("Delivery details \(String(describing: deliveryDetails)) for userId: \(String(describing: userId)))")
        } else {
            print("SignUp Complete")
        }
    } catch let error as AuthError {
        print("An error occurred while registering a user \(error)")
    } catch {
        print("Unexpected error: \(error)")
    }
}

// Confirm sign up with the OTP received
func confirmSignUp(for username: String, with confirmationCode: String) async {
    do {
        let confirmSignUpResult = try await Amplify.Auth.confirmSignUp(
            for: username,
            confirmationCode: confirmationCode
        )
        print("Confirm sign up result completed: \(confirmSignUpResult.isSignUpComplete)")
    } catch let error as AuthError {
        print("An error occurred while confirming sign up \(error)")
    } catch {
        print("Unexpected error: \(error)")
    }
}
```

</Block>

<Block name="Combine">

```swift
// Sign up using a phone number
func signUp(username: String, phonenumber: String) -> AnyCancellable {
    let userAttributes = [
        AuthUserAttribute(.phoneNumber, value: phonenumber)
    ]
    let options = AuthSignUpRequest.Options(userAttributes: userAttributes)
    let sink = Amplify.Publisher.create {
        try await Amplify.Auth.signUp(
            username: username,
            options: options
        )
    }.sink {
        if case let .failure(authError) = $0 {
            print("An error occurred while registering a user \(authError)")
        }
    }
    receiveValue: { signUpResult in
        if case let .confirmUser(deliveryDetails, _, userId) = signUpResult.nextStep {
            print("Delivery details \(String(describing: deliveryDetails)) for userId: \(String(describing: userId)))")
        } else {
            print("SignUp Complete")
        }
    }
    return sink
}

// Confirm sign up with the OTP received
func confirmSignUp(for username: String, with confirmationCode: String) -> AnyCancellable {
    Amplify.Publisher.create {
        try await Amplify.Auth.confirmSignUp(
            for: username,
            confirmationCode: confirmationCode
        )
    }.sink {
        if case let .failure(authError) = $0 {
            print("An error occurred while confirming sign up \(authError)")
        }
    }
    receiveValue: { _ in
        print("Confirm signUp succeeded")
    }
}
```

</Block>

</BlockSwitcher>

</InlineFilter>

### Email OTP

{/* blurb with supplemental information about handling sign-up, events, etc. */}

<InlineFilter filters={["angular", "javascript", "nextjs", "react", "react-native", "vue"]}>

```typescript
// Sign up using an email address
const { nextStep: signUpNextStep } = await signUp({
	username: 'hello',
	options: {
		userAttributes: {
			email: 'hello@example.com',
		},
	},
});

if (signUpNextStep.signUpStep === 'DONE') {
	console.log(`SignUp Complete`);
}

if (signUpNextStep.signUpStep === 'CONFIRM_SIGN_UP') {
	console.log(
		`Code Delivery Medium: ${signUpNextStep.codeDeliveryDetails.deliveryMedium}`,
	);
	console.log(
		`Code Delivery Destination: ${signUpNextStep.codeDeliveryDetails.destination}`,
	);
}

// Confirm sign up with the OTP received
const { nextStep: confirmSignUpNextStep } = await confirmSignUp({
	username: 'hello',
	confirmationCode: '123456',
});

if (confirmSignUpNextStep.signUpStep === 'DONE') {
	console.log(`SignUp Complete`);
}
```

</InlineFilter>
<InlineFilter filters={["android"]}>

<BlockSwitcher>
<Block name="Java">

```java
// Sign up using an email address
ArrayList<AuthUserAttribute> attributes = new ArrayList<>();
attributes.add(new AuthUserAttribute(AuthUserAttributeKey.email(), "hello@example.com"));

Amplify.Auth.signUp(
    "hello@example.com",
    null,
    AuthSignUpOptions.builder().userAttributes(attributes).build(),
    result -> {
        if (result.isSignUpComplete()) {
            Log.i("AuthQuickstart", "Sign up is complete");
        } else if (result.getNextStep().getSignUpStep() == AuthSignUpStep.CONFIRM_SIGN_UP_STEP) {
            Log.i("AuthQuickstart", "Code Deliver Medium: " +
                result.getNextStep().getCodeDeliveryDetails().getDeliveryMedium());
            Log.i("AuthQuickstart", "Code Deliver Destination: " +
                result.getNextStep().getCodeDeliveryDetails().getDestination());
        }
    },
    error -> Log.e("AuthQuickstart", error.toString())
);

// Confirm sign up with the OTP received
Amplify.Auth.confirmSignUp(
    "hello@example.com",
    "123456",
    result -> {
        if (result.isSignUpComplete()) {
            Log.i("AuthQuickstart", "Sign up is complete");
        }
    },
    error -> Log.e("AuthQuickstart", error.toString())
);
```

</Block>
<Block name="Kotlin - Callbacks">

```kotlin
// Sign up using an email address
val attributes = listOf(
    AuthUserAttribute(AuthUserAttributeKey.email(), "my@email.com")
)
val options =
    AuthSignUpOptions
        .builder()
        .userAttributes(attributes)
        .build()

Amplify.Auth.signUp(
    "hello@example.com",
    null,
    options,
    { result ->
        if (result.isSignUpComplete) {
            Log.i("AuthQuickstart", "Sign up is complete")
        } else if (result.nextStep.signUpStep == AuthSignUpStep.CONFIRM_SIGN_UP_STEP) {
            Log.i("AuthQuickstart", "Code Deliver Medium: " +
                "${result.nextStep.codeDeliveryDetails?.deliveryMedium}")
            Log.i("AuthQuickstart", "Code Deliver Destination: " +
                "${result.nextStep.codeDeliveryDetails?.destination}")
        }
    },
    { Log.e("AuthQuickstart", "Failed to sign up", it) }
)

// Confirm sign up with the OTP received
Amplify.Auth.confirmSignUp(
    "hello@example.com",
    "123456",
    { result ->
        if (result.nextStep.signUpStep == AuthSignUpStep.DONE) {
            Log.i("AuthQuickstart", "Sign up is complete")
        }
    },
    { Log.e("AuthQuickstart", "Failed to sign up", it) }
)
```

</Block>
<Block name="Kotlin - Coroutines">

```kotlin
// Sign up using an email address
val attributes = listOf(
    AuthUserAttribute(AuthUserAttributeKey.email(), "my@email.com")
)
val options =
    AuthSignUpOptions
        .builder()
        .userAttributes(attributes)
        .build()
var result = Amplify.Auth.signUp("hello@example.com", null, options)

if (result.isSignUpComplete) {
    Log.i("AuthQuickstart", "Sign up is complete")
} else if (result.nextStep.signUpStep == AuthSignUpStep.CONFIRM_SIGN_UP_STEP) {
    Log.i("AuthQuickstart", "Code Deliver Medium: " +
        "${result.nextStep.codeDeliveryDetails?.deliveryMedium}")
    Log.i("AuthQuickstart", "Code Deliver Destination: " +
        "${result.nextStep.codeDeliveryDetails?.destination}")
}

// Confirm sign up with the OTP received
result = Amplify.Auth.confirmSignUp(
    "hello@example.com",
    "123456"
)

if (result.nextStep.signUpStep == AuthSignUpStep.DONE) {
    Log.i("AuthQuickstart", "Sign up is complete")
}
```

</Block>
<Block name="RxJava">

```java
// Sign up using an email address
ArrayList<AuthUserAttribute> attributes = new ArrayList<>();
attributes.add(new AuthUserAttribute(AuthUserAttributeKey.email(), "my@email.com"));

RxAmplify.Auth.signUp(
    "hello@example.com",
    null,
    AuthSignUpOptions.builder().userAttributes(attributes).build()
)
    .subscribe(
        result -> {
            if (result.isSignUpComplete()) {
                Log.i("AuthQuickstart", "Sign up is complete");
            } else if (result.getNextStep().getSignUpStep() == AuthSignUpStep.CONFIRM_SIGN_UP_STEP) {
                Log.i("AuthQuickstart", "Code Deliver Medium: " +
                    result.getNextStep().getCodeDeliveryDetails().getDeliveryMedium());
                Log.i("AuthQuickstart", "Code Deliver Destination: " +
                    result.getNextStep().getCodeDeliveryDetails().getDestination());
            }
        },
        error -> Log.e("AuthQuickstart", error.toString())
    );

// Confirm sign up with the OTP received
RxAmplify.Auth.confirmSignUp(
    "hello@example.com",
    "123456"
)
    .subscribe(
        result -> {
            if (result.isSignUpComplete()) {
                Log.i("AuthQuickstart", "Sign up is complete");
            }
        },
        error -> Log.e("AuthQuickstart", error.toString())
    );
```

</Block>
</BlockSwitcher>

</InlineFilter>
<InlineFilter filters={["swift"]}>

<BlockSwitcher>

<Block name="Async/Await">

```swift
// Sign up using an email
func signUp(username: String, email: String) async {
    let userAttributes = [
        AuthUserAttribute(.email, value: email)
    ]
    let options = AuthSignUpRequest.Options(userAttributes: userAttributes)
    do {
        let signUpResult = try await Amplify.Auth.signUp(
            username: username,
            options: options
        )
        if case let .confirmUser(deliveryDetails, _, userId) = signUpResult.nextStep {
            print("Delivery details \(String(describing: deliveryDetails)) for userId: \(String(describing: userId)))")
        } else {
            print("SignUp Complete")
        }
    } catch let error as AuthError {
        print("An error occurred while registering a user \(error)")
    } catch {
        print("Unexpected error: \(error)")
    }
}

// Confirm sign up with the OTP received
func confirmSignUp(for username: String, with confirmationCode: String) async {
    do {
        let confirmSignUpResult = try await Amplify.Auth.confirmSignUp(
            for: username,
            confirmationCode: confirmationCode
        )
        print("Confirm sign up result completed: \(confirmSignUpResult.isSignUpComplete)")
    } catch let error as AuthError {
        print("An error occurred while confirming sign up \(error)")
    } catch {
        print("Unexpected error: \(error)")
    }
}
```

</Block>

<Block name="Combine">

```swift
// Sign up using an email
func signUp(username: String, email: String) -> AnyCancellable {
    let userAttributes = [
        AuthUserAttribute(.email, value: email)
    ]
    let options = AuthSignUpRequest.Options(userAttributes: userAttributes)
    let sink = Amplify.Publisher.create {
        try await Amplify.Auth.signUp(
            username: username,
            options: options
        )
    }.sink {
        if case let .failure(authError) = $0 {
            print("An error occurred while registering a user \(authError)")
        }
    }
    receiveValue: { signUpResult in
        if case let .confirmUser(deliveryDetails, _, userId) = signUpResult.nextStep {
            print("Delivery details \(String(describing: deliveryDetails)) for userId: \(String(describing: userId)))")
        } else {
            print("SignUp Complete")
        }
    }
    return sink
}

// Confirm sign up with the OTP received
func confirmSignUp(for username: String, with confirmationCode: String) -> AnyCancellable {
    Amplify.Publisher.create {
        try await Amplify.Auth.confirmSignUp(
            for: username,
            confirmationCode: confirmationCode
        )
    }.sink {
        if case let .failure(authError) = $0 {
            print("An error occurred while confirming sign up \(authError)")
        }
    }
    receiveValue: { _ in
        print("Confirm signUp succeeded")
    }
}
```

</Block>

</BlockSwitcher>

</InlineFilter>

### Auto Sign In

{/* blurb with supplemental information about auto sign in */}

<InlineFilter filters={["angular", "javascript", "nextjs", "react", "react-native", "vue"]}>

```typescript
// Call `signUp` API with `USER_AUTH` as the authentication flow type for `autoSignIn`
const { nextStep: signUpNextStep } = await signUp({
	username: 'hello',
	options: {
		userAttributes: {
			email: 'hello@example.com',
			phone_number: '+15555551234',
		},
		autoSignIn: {
			authFlowType: 'USER_AUTH',
		},
	},
});

if (signUpNextStep.signUpStep === 'CONFIRM_SIGN_UP') {
	console.log(
		`Code Delivery Medium: ${signUpNextStep.codeDeliveryDetails.deliveryMedium}`,
	);
	console.log(
		`Code Delivery Destination: ${signUpNextStep.codeDeliveryDetails.destination}`,
	);
}

// Call `confirmSignUp` API with the OTP received
const { nextStep: confirmSignUpNextStep } = await confirmSignUp({
	username: 'hello',
	confirmationCode: '123456',
});

if (confirmSignUpNextStep.signUpStep === 'COMPLETE_AUTO_SIGN_IN') {
	// Call `autoSignIn` API to complete the flow
	const { nextStep } = await autoSignIn();

	if (nextStep.signInStep === 'DONE') {
		console.log('Successfully signed in.');
	}
}

```
</InlineFilter>
<InlineFilter filters={["android"]}>

<BlockSwitcher>
<Block name="Java">

```java
private void confirmSignUp(String username, String confirmationCode) {
    // Confirm sign up with the OTP received then auto sign in
    Amplify.Auth.confirmSignUp(
        username,
        confirmationCode,
        result -> {
            if (result.getNextStep().getSignUpStep() == AuthSignUpStep.COMPLETE_AUTO_SIGN_IN) {
                Log.i("AuthQuickstart", "Sign up is complete, auto sign in");
                autoSignIn();
            }
        },
        error -> Log.e("AuthQuickstart", error.toString())
    );
}

private void autoSignIn() {
    Amplify.Auth.autoSignIn(
        result -> Log.i("AuthQuickstart", "Sign in is complete"),
        error -> Log.e("AuthQuickstart", error.toString())
    );
}
```

</Block>
<Block name="Kotlin - Callbacks">

```kotlin
fun confirmSignUp(username: String, confirmationCode: String) {
    // Confirm sign up with the OTP received
    Amplify.Auth.confirmSignUp(
        username,
        confirmationCode,
        { signUpResult ->
            if (signUpResult.nextStep.signUpStep == AuthSignUpStep.COMPLETE_AUTO_SIGN_IN) {
                Log.i("AuthQuickstart", "Sign up is complete, auto sign in")
                autoSignIn()
            }
        },
        { Log.e("AuthQuickstart", "Failed to sign up", it) }
    )
}
fun autoSignIn() {
    Amplify.Auth.autoSignIn(
        { signInResult ->
            Log.i("AuthQuickstart", "Sign in is complete")
        },
        { Log.e("AuthQuickstart", "Failed to sign in", it) }
    )
}
```

</Block>
<Block name="Kotlin - Coroutines">

```kotlin
suspend fun confirmSignUp(username: String, confirmationCode: String) {
    // Confirm sign up with the OTP received then auto sign in
    val result = Amplify.Auth.confirmSignUp(
        "hello@example.com",
        "123456"
    )

    if (result.nextStep.signUpStep == AuthSignUpStep.COMPLETE_AUTO_SIGN_IN) {
        Log.i("AuthQuickstart", "Sign up is complete, auto sign in")
        autoSignIn()
    }
}

suspend fun autoSignIn() {
    val result = Amplify.Auth.autoSignIn()
    if (result.isSignedIn) {
        Log.i("AuthQuickstart", "Sign in is complete")
    } else {
        Log.e("AuthQuickstart", "Sign in did not complete $result")
    }
}
```

</Block>
<Block name="RxJava">

```java
private void confirmSignUp(String username, String confirmationCode) {
    // Confirm sign up with the OTP received then auto sign in
    RxAmplify.Auth.confirmSignUp(
        username,
        confirmationCode
    )
        .subscribe(
            result -> {
                if (result.getNextStep().getSignUpStep() == AuthSignUpStep.COMPLETE_AUTO_SIGN_IN) {
                    Log.i("AuthQuickstart", "Sign up is complete, auto sign in");
                    autoSignIn();
                }
            },
            error -> Log.e("AuthQuickstart", error.toString())
        );
}

private void autoSignIn() {
    RxAmplify.Auth.autoSignIn()
        .subscribe(
            result -> Log.i("AuthQuickstart", "Sign in is complete" + result.toString()),
            error -> Log.e("AuthQuickstart", error.toString())
        );
}
```

</Block>
</BlockSwitcher>

</InlineFilter>
<InlineFilter filters={["swift"]}>

<BlockSwitcher>

<Block name="Async/Await">

```swift
// Confirm sign up with the OTP received and auto sign in
func confirmSignUp(for username: String, with confirmationCode: String) async {
    do {
        let confirmSignUpResult = try await Amplify.Auth.confirmSignUp(
            for: username,
            confirmationCode: confirmationCode
        )
        if case .completeAutoSignIn(let session) = confirmSignUpResult.nextStep {
            let autoSignInResult = try await Amplify.Auth.autoSignIn()
            print("Auto sign in result: \(autoSignInResult.isSignedIn)")
        } else {
            print("Confirm sign up result completed: \(confirmSignUpResult.isSignUpComplete)")
        }
    } catch let error as AuthError {
        print("An error occurred while confirming sign up \(error)")
    } catch {
        print("Unexpected error: \(error)")
    }
}
```

</Block>

<Block name="Combine">

```swift
// Confirm sign up with the OTP received and auto sign in
func confirmSignUp(for username: String, with confirmationCode: String) -> AnyCancellable {
    Amplify.Publisher.create {
        try await Amplify.Auth.confirmSignUp(
            for: username,
            confirmationCode: confirmationCode
        )
    }.sink {
        if case let .failure(authError) = $0 {
            print("An error occurred while confirming sign up \(authError)")
        }
    }
    receiveValue: { confirmSignUpResult in
        if case let .completeAutoSignIn(session) = confirmSignUpResult.nextStep {
            print("Confirm Sign Up succeeded. Next step is auto sign in")
            // call `autoSignIn()` API to complete sign in
        } else {
            print("Confirm sign up result completed: \(confirmSignUpResult.isSignUpComplete)")
        }
    }
}

func autoSignIn() -> AnyCancellable {
    Amplify.Publisher.create {
        try await Amplify.Auth.autoSignIn()
    }.sink {
        if case let .failure(authError) = $0 {
            print("Auto Sign in failed \(authError)")
        }
    }
    receiveValue: { autoSignInResult in
        if autoSignInResult.isSignedIn {
            print("Auto Sign in succeeded")
        }
    }
}
```

</Block>

</BlockSwitcher>

</InlineFilter>

</InlineFilter>


Contents of build-a-backend_auth_connect-your-frontend_switching-authentication-flows_index.txt:
import { getCustomStaticPath } from '@/utils/getCustomStaticPath';

export const meta = {
  title: 'Switching authentication flows',
  description: 'Learn how to switch between different auth flows',
  platforms: [
    'angular',
    'javascript',
    'nextjs',
    'react',
    'react-native',
    'swift',
    'vue',
    'android'
  ]
};

export function getStaticPaths() {
  return getCustomStaticPath(meta.platforms);
}

export function getStaticProps() {
  return {
    props: {
      meta,
    }
  };
}

<InlineFilter filters={["swift"]}>

`AWSCognitoAuthPlugin` allows you to switch between different auth flows while initiating signIn. You can configure the flow in the `amplify_outputs.json` file or pass the `authFlowType` as a runtime parameter to the `signIn` api call.

For client side authentication there are four different flows that can be configured during runtime:

1. `userSRP`: The `userSRP` flow uses the [SRP protocol (Secure Remote Password)](https://en.wikipedia.org/wiki/Secure_Remote_Password_protocol) where the password never leaves the client and is unknown to the server. This is the recommended flow and is used by default.

2. `userPassword`: The `userPassword` flow will send user credentials unencrypted to the back-end. If you want to migrate users to Cognito using the "Migration" trigger and avoid forcing users to reset their passwords, you will need to use this authentication type because the Lambda function invoked by the trigger needs to verify the supplied credentials.

3. `customWithSRP`: The `customWithSRP` flow is used to start with SRP authentication and then switch to custom authentication. This is useful if you want to use SRP for the initial authentication and then use custom authentication for subsequent authentication attempts.

4. `customWithoutSRP`: The `customWithoutSRP` flow is used to start authentication flow **WITHOUT** SRP and then use a series of challenge and response cycles that can be customized to meet different requirements.

5. `userAuth`: The `userAuth` flow is a choice-based authentication flow that allows the user to choose from the list of available authentication methods. This flow is useful when you want to provide the user with the option to choose the authentication method. The choices that may be available to the user are `emailOTP`, `smsOTP`, `webAuthn`, `password` or `passwordSRP`.

`Auth` can be configured to use the different flows at runtime by calling `signIn` with `AuthSignInOptions`'s `authFlowType` as `AuthFlowType.userPassword`, `AuthFlowType.customAuthWithoutSrp` or `AuthFlowType.customAuthWithSrp`. If you do not specify the `AuthFlowType` in `AuthSignInOptions`, the default flow (`AuthFlowType.userSRP`) will be used.

<Callout>

Runtime configuration will take precedence and will override any auth flow type configuration present in amplify_outputs.json

</Callout>

> For more information about authentication flows, please visit [Amazon Cognito developer documentation](https://docs.aws.amazon.com/cognito/latest/developerguide/amazon-cognito-user-pools-authentication-flow.html#amazon-cognito-user-pools-custom-authentication-flow)

## USER_AUTH (Choice-based authentication) flow

A use case for the `USER_AUTH` authentication flow is to provide the user with the option to choose the authentication method. The choices that may be available to the user are `emailOTP`, `smsOTP`, `webAuthn`, `password` or `passwordSRP`.

```swift
let pluginOptions = AWSAuthSignInOptions(
    authFlowType: .userAuth)
let signInResult = try await Amplify.Auth.signIn(
    username: username,
    password: password,
    options: .init(pluginOptions: pluginOptions))
guard case .continueSignInWithFirstFactorSelection(let availableFactors) = signInResult.nextStep else {
    return
}
print("Available factors: \(availableFactors)")
```

The selection of the authentication method is done by the user. The user can choose from the available factors and proceed with the selected factor. You should call the `confirmSignIn` API with the selected factor to continue the sign-in process. Following is an example if you want to proceed with the `emailOTP` factor selection:

```swift
// Select emailOTP as the factor
var confirmSignInResult = try await Amplify.Auth.confirmSignIn(
    challengeResponse: AuthFactorType.emailOTP.challengeResponse)
```

## USER_PASSWORD_AUTH flow

A use case for the `USER_PASSWORD_AUTH` authentication flow is migrating users into Amazon Cognito

A user migration Lambda trigger helps migrate users from a legacy user management system into your user pool. If you choose the USER_PASSWORD_AUTH authentication flow, users don't have to reset their passwords during user migration. This flow sends your user's password to the service over an encrypted SSL connection during authentication.

When you have migrated all your users, switch flows to the more secure SRP flow. The SRP flow doesn't send any passwords over the network.

```swift
func signIn(username: String, password: String) async throws {

    let option = AWSAuthSignInOptions(authFlowType: .userPassword)
    do {
        let result = try await Amplify.Auth.signIn(
            username: username,
            password: password,
            options: AuthSignInRequest.Options(pluginOptions: option))
        print("Sign in succeeded with result: \(result)")
    } catch {
        print("Failed to sign in with error: \(error)")
    }
}
```

### Migrate users with Amazon Cognito

Amazon Cognito provides a trigger to migrate users from your existing user directory seamlessly into Cognito. You achieve this by configuring your User Pool's "Migration" trigger which invokes a Lambda function whenever a user that does not already exist in the user pool authenticates, or resets their password.

In short, the Lambda function will validate the user credentials against your existing user directory and return a response object containing the user attributes and status on success. An error message will be returned if an error occurs. There's documentation around [how to set up this migration flow](https://docs.aws.amazon.com/cognito/latest/developerguide/cognito-user-pools-import-using-lambda.html) and more detailed instructions on [how the lambda should handle request and response objects](https://docs.aws.amazon.com/cognito/latest/developerguide/user-pool-lambda-migrate-user.html#cognito-user-pools-lambda-trigger-syntax-user-migration).

## CUSTOM_AUTH flow

Amazon Cognito User Pools supports customizing the authentication flow to enable custom challenge types, in addition to a password in order to verify the identity of users. The custom authentication flow is a series of challenge and response cycles that can be customized to meet different requirements. These challenge types may include CAPTCHAs or dynamic challenge questions.

To define your challenges for custom authentication flow, you need to implement three Lambda triggers for Amazon Cognito.

The flow is initiated by calling `signIn` with `AuthSignInOptions` configured with `AuthFlowType.customAuthWithSrp` OR `AuthFlowType.customAuthWithoutSrp`.

Follow the instructions in [Custom Auth Sign In](/gen1/[platform]/build-a-backend/auth/sign-in-custom-flow/) to learn about how to integrate custom authentication flow in your application with the Auth APIs.

</InlineFilter>

<InlineFilter filters={["angular", "javascript", "nextjs", "react", "react-native", "vue"]}>

For client side authentication there are four different flows:

1. `USER_SRP_AUTH`: The `USER_SRP_AUTH` flow uses the [SRP protocol (Secure Remote Password)](https://en.wikipedia.org/wiki/Secure_Remote_Password_protocol) where the password never leaves the client and is unknown to the server. This is the recommended flow and is used by default.

2. `USER_PASSWORD_AUTH`: The `USER_PASSWORD_AUTH` flow will send user credentials to the backend without applying SRP encryption. If you want to migrate users to Cognito using the "Migration" trigger and avoid forcing users to reset their passwords, you will need to use this authentication type because the Lambda function invoked by the trigger needs to verify the supplied credentials.

3. `CUSTOM_WITH_SRP` & `CUSTOM_WITHOUT_SRP`: Allows for a series of challenge and response cycles that can be customized to meet different requirements.

4. `USER_AUTH`: The `USER_AUTH` flow is a choice-based authentication flow that allows the user to choose from the list of available authentication methods. This flow is useful when you want to provide the user with the option to choose the authentication method. The choices that may be available to the user are `EMAIL_OTP`, `SMS_OTP`, `WEB_AUTHN`, `PASSWORD` or `PASSWORD_SRP`.

The Auth flow can be customized when calling `signIn`, for example:

```ts title="src/main.ts"
await signIn({
  username: "hello@mycompany.com",
  password: "hunter2",
  options: {
      authFlowType: 'USER_AUTH'
  }
})
```

> For more information about authentication flows, please visit [AWS Cognito developer documentation](https://docs.aws.amazon.com/cognito/latest/developerguide/amazon-cognito-user-pools-authentication-flow.html#amazon-cognito-user-pools-custom-authentication-flow)

## USER_AUTH flow

The `USER_AUTH` sign in flow supports the following methods as first factors for authentication: `WEB_AUTHN`, `EMAIL_OTP`, `SMS_OTP`, `PASSWORD`, and `PASSWORD_SRP`.

If the desired first factor is known when authentication is initiated, it can be passed to the `signIn` API as the `preferredChallenge` to initiate the corresponding authentication flow.

```ts
// PASSWORD_SRP / PASSWORD
// sign in with preferred challenge as password
// note password must be provided in same step
const { nextStep } = await signIn({
    username: "hello@mycompany.com",
    password: "hunter2",
    options: {
        authFlowType: "USER_AUTH",
        preferredChallenge: "PASSWORD_SRP" // or "PASSWORD"
    },
});

// WEB_AUTHN / EMAIL_OTP / SMS_OTP
// sign in with preferred passwordless challenge
// no additional user input required at this step 
const { nextStep } = await signIn({
    username: "hello@example.com",
    options: {
        authFlowType: "USER_AUTH",
        preferredChallenge: "WEB_AUTHN" // or "EMAIL_OTP" or "SMS_OTP"
    },
});
```

If the desired first factor is not known or you would like to provide users with the available options, `preferredChallenge` can be omitted from the initial `signIn` API call. 

This allows you to discover which authentication first factors are available for a user via the `CONTINUE_SIGN_IN_WITH_FIRST_FACTOR_SELECTION` step. You can then present the available options to the user and use the `confirmSignIn` API to respond with the user's selection.

```ts
const { nextStep: signInNextStep } = await signIn({
	username: '+15551234567',
	options: {
		authFlowType: 'USER_AUTH',
	},
});

if (
	signInNextStep.signInStep === 'CONTINUE_SIGN_IN_WITH_FIRST_FACTOR_SELECTION'
) {
	// present user with list of available challenges
	console.log(`Available Challenges: ${signInNextStep.availableChallenges}`);

	// respond with user selection using `confirmSignIn` API
	const { nextStep: nextConfirmSignInStep } = await confirmSignIn({
		challengeResponse: 'SMS_OTP', // or 'EMAIL_OTP', 'WEB_AUTHN', 'PASSWORD', 'PASSWORD_SRP'
	});
}

```
Also, note that if the `preferredChallenge` passed to the initial `signIn` API call is unavailable for the user, Amplify will also respond with the `CONTINUE_SIGN_IN_WITH_FIRST_FACTOR_SELECTION` next step.


<Callout>
For more information about determining a first factor, and signing in with passwordless authentication factors, please visit the [Passwordless](/[platform]/build-a-backend/auth/concepts/passwordless/) concepts page.
</Callout>

## USER_PASSWORD_AUTH flow

A use case for the `USER_PASSWORD_AUTH` authentication flow is migrating users into Amazon Cognito

### Set up auth backend

In order to use the authentication flow `USER_PASSWORD_AUTH`, your Cognito app client has to be configured to allow it. In the AWS Console, this is done by ticking the checkbox at General settings > App clients > Show Details (for the affected client) > Enable username-password (non-SRP) flow. If you're using the AWS CLI or CloudFormation, update your app client by adding `USER_PASSWORD_AUTH` to the list of "Explicit Auth Flows".

### Migrate users with Amazon Cognito

Amazon Cognito provides a trigger to migrate users from your existing user directory seamlessly into Cognito. You achieve this by configuring your User Pool's "Migration" trigger which invokes a Lambda function whenever a user that does not already exist in the user pool authenticates, or resets their password.

In short, the Lambda function will validate the user credentials against your existing user directory and return a response object containing the user attributes and status on success. An error message will be returned if an error occurs. Visit [Amazon Cognito user pools import guide](https://docs.aws.amazon.com/cognito/latest/developerguide/cognito-user-pools-import-using-lambda.html) for migration flow and more detailed instruction, and [Amazon Cognito Lambda trigger guide](https://docs.aws.amazon.com/cognito/latest/developerguide/user-pool-lambda-migrate-user.html#cognito-user-pools-lambda-trigger-syntax-user-migration) on how to set up lambda to handle request and response objects.

## `CUSTOM_WITH_SRP` & `CUSTOM_WITHOUT_SRP` flows

Amazon Cognito user pools supports customizing the authentication flow to enable custom challenge types, 
in addition to a password in order to verify the identity of users. These challenge types may include CAPTCHAs
or dynamic challenge questions. The `CUSTOM_WITH_SRP` flow requires a password when calling `signIn`. Both of 
these flows map to the `CUSTOM_AUTH` flow in Cognito.

<Callout>

To define your challenges for custom authentication flow, you need to implement three Lambda triggers for Amazon Cognito. Please visit [AWS Amplify Custom Auth Challenge example](/[platform]/build-a-backend/functions/examples/custom-auth-flows/) for set up instructions. 

</Callout>

<Callout>

For more information about working with Lambda Triggers for custom authentication challenges, please visit [Amazon Cognito Developer Documentation](https://docs.aws.amazon.com/cognito/latest/developerguide/user-pool-lambda-challenge.html).

</Callout>

### Custom authentication flow

To initiate a custom authentication flow in your app, call `signIn` without a password. A custom challenge needs to be answered using the `confirmSignIn` API:

```ts title="src/main.ts"
import { signIn, confirmSignIn } from 'aws-amplify/auth';

const challengeResponse = 'the answer for the challenge';

const { nextStep } = await signIn({
  username,
  options: {
    authFlowType: 'CUSTOM_WITHOUT_SRP',
  },
});

if (nextStep.signInStep === 'CONFIRM_SIGN_IN_WITH_CUSTOM_CHALLENGE') {
  // to send the answer of the custom challenge
  await confirmSignIn({ challengeResponse });
}
```

### CAPTCHA authentication

To create a CAPTCHA challenge with a Lambda Trigger, please visit [AWS Amplify Google reCAPTCHA challenge example](/[platform]/build-a-backend/functions/examples/google-recaptcha-challenge/) for detailed examples. 

</InlineFilter>

<InlineFilter filters={["android"]}>

`AWSCognitoAuthPlugin` allows you to switch between different auth flows while initiating signIn. You can configure the flow in the `amplify_outputs.json` file or pass the `authFlowType` as a option to the `signIn` api call.

For client side authentication there are four different flows that can be configured during runtime:

1. `USER_SRP_AUTH`: The `USER_SRP_AUTH` flow uses the [SRP protocol (Secure Remote Password)](https://en.wikipedia.org/wiki/Secure_Remote_Password_protocol) where the password never leaves the client and is unknown to the server. This is the recommended flow and is used by default.

2. `USER_PASSWORD_AUTH`: The `USER_PASSWORD_AUTH` flow will send user credentials unencrypted to the back-end. If you want to migrate users to Cognito using the "Migration" trigger and avoid forcing users to reset their passwords, you will need to use this authentication type because the Lambda function invoked by the trigger needs to verify the supplied credentials.

3. `CUSTOM_AUTH_WITH_SRP`: The `CUSTOM_AUTH_WITH_SRP` flow is used to start with SRP authentication and then switch to custom authentication. This is useful if you want to use SRP for the initial authentication and then use custom authentication for subsequent authentication attempts.

4. `CUSTOM_AUTH_WITHOUT_SRP`: The `CUSTOM_AUTH_WITHOUT_SRP` flow is used to start authentication flow **WITHOUT** SRP and then use a series of challenge and response cycles that can be customized to meet different requirements.

5. `USER_AUTH`: The `USER_AUTH` flow is a choice-based authentication flow that allows the user to choose from the list of available authentication methods. This flow is useful when you want to provide the user with the option to choose the authentication method. The choices that may be available to the user are `EMAIL_OTP`, `SMS_OTP`, `WEB_AUTHN`, `PASSWORD` or `PASSWORD_SRP`.

`Auth` can be configured to use the different flows at runtime by calling `signIn` with `AWSCognitoAuthSignInOptions`'s `authFlowType` as `AuthFlowType.USER_PASSWORD_AUTH`, `AuthFlowType.CUSTOM_AUTH_WITHOUT_SRP`, `AuthFlowType.CUSTOM_AUTH_WITH_SRP`, or `AuthFlowType.USER_AUTH`. If you do not specify the `AuthFlowType` in `AWSCognitoAuthSignInOptions`, the default flow specified in `amplify_outputs.json` will be used.

<Callout>

Runtime configuration will take precedence and will override any auth flow type configuration present in `amplify_outputs.json`.

</Callout>

For more information about authentication flows, please visit [Amazon Cognito developer documentation](https://docs.aws.amazon.com/cognito/latest/developerguide/amazon-cognito-user-pools-authentication-flow.html#amazon-cognito-user-pools-custom-authentication-flow)

## USER_AUTH (Choice-based authentication) flow

A use case for the `USER_AUTH` authentication flow is to provide the user with the option to choose the authentication method. The choices that may be available to the user are `EMAIL_OTP`, `SMS_OTP`, `WEB_AUTHN`, `PASSWORD` or `PASSWORD_SRP`.

<Callout>
Amplify requires an `Activity` reference to attach the PassKey UI to your Application's [Task](https://developer.android.com/guide/components/activities/tasks-and-back-stack) when using WebAuthn - if an `Activity` is not supplied then the UI will appear in a separate Task. For this reason, we strongly recommend passing the `callingActivity` option to both the `signIn` and `confirmSignIn` APIs if your application uses the `USER_AUTH` flow.
</Callout>

If the desired first factor is known before the sign in flow is initiated it can be passed to the initial sign in call.

<BlockSwitcher>
<Block name="Java">

```java
// PASSWORD_SRP / PASSWORD
// Sign in with preferred challenge as password
// NOTE: Password must be provided in the same step
AuthSignInOptions options = AWSCognitoAuthSignInOptions.builder()
    .callingActivity(activity)
    .authFlowType(AuthFlowType.USER_AUTH)
    .preferredFirstFactor(AuthFactorType.PASSWORD_SRP) // or "PASSWORD"
    .build();
Amplify.Auth.signIn(
    username,
    password,
    options,
    result -> Log.i("AuthQuickStart", "Next step for sign in is " + result.getNextStep()),
    error -> Log.e("AuthQuickStart", "Failed to confirm sign in", error)
);

// WEB_AUTHN / EMAIL_OTP / SMS_OTP
// Sign in with preferred passwordless challenge
// No user input is required at this step
AuthSignInOptions options = AWSCognitoAuthSignInOptions.builder()
    .callingActivity(activity)
    .authFlowType(AuthFlowType.USER_AUTH)
    .preferredFirstFactor(AuthFactorType.WEB_AUTHN) // or "EMAIL_OTP" or "SMS_OTP"
    .build();
Amplify.Auth.signIn(
    username,
    null,
    options,
    result -> Log.i("AuthQuickStart", "Next step for sign in is " + result.getNextStep()),
    error -> Log.e("AuthQuickStart", "Failed to confirm sign in", error)
);
```

</Block>
<Block name="Kotlin - Callbacks">

```kotlin
// PASSWORD_SRP / PASSWORD
// Sign in with preferred challenge as password
// NOTE: Password must be provided in the same step
val options = AWSCognitoAuthSignInOptions.builder()
    .callingActivity(activity)
    .authFlowType(AuthFlowType.USER_AUTH)
    .preferredFirstFactor(AuthFactorType.PASSWORD_SRP) // or "PASSWORD"
    .build()
Amplify.Auth.signIn(
    username,
    password,
    options,
    { result -> Log.i("AuthQuickStart", "Next step for sign in is ${result.nextStep}") },
    { error -> Log.e("AuthQuickStart", "Failed to confirm sign in", error) }
)

// WEB_AUTHN / EMAIL_OTP / SMS_OTP
// Sign in with preferred passwordless challenge
// No user input is required at this step
val options = AWSCognitoAuthSignInOptions.builder()
    .callingActivity(activity)
    .authFlowType(AuthFlowType.USER_AUTH)
    .preferredFirstFactor(AuthFactorType.WEB_AUTHN) // or "EMAIL_OTP" or "SMS_OTP"
    .build()
Amplify.Auth.signIn(
    username,
    null,
    options,
    { result -> Log.i("AuthQuickStart", "Next step for sign in is ${result.nextStep}") },
    { error -> Log.e("AuthQuickStart", "Failed to confirm sign in", error) }
)
```

</Block>
<Block name="Kotlin - Coroutines">

```kotlin
// PASSWORD_SRP / PASSWORD
// Sign in with preferred challenge as password
// NOTE: Password must be provided in the same step
try {
    val options = AWSCognitoAuthSignInOptions.builder()
        .callingActivity(activity)
        .authFlowType(AuthFlowType.USER_AUTH)
        .preferredFirstFactor(AuthFactorType.PASSWORD_SRP) // or "PASSWORD"
        .build()
    val result = Amplify.Auth.signIn(
        username = "hello@example.com",
        password = "password",
        options = options
    )
    Log.i("AuthQuickstart", "Next step for sign in is ${result.nextStep}")
} catch (error: AuthException) {
    Log.e("AuthQuickstart", "Sign in failed", error)
}

// WEB_AUTHN / EMAIL_OTP / SMS_OTP
// Sign in with preferred passwordless challenge
// No user input is required at this step
try {
    val options = AWSCognitoAuthSignInOptions.builder()
        .callingActivity(activity)
        .authFlowType(AuthFlowType.USER_AUTH)
        .preferredFirstFactor(AuthFactorType.WEB_AUTHN) // or "EMAIL_OTP" or "SMS_OTP"
        .build()
    val result = Amplify.Auth.signIn(
        username = "hello@example.com",
        password = null,
        options = options
    )
    Log.i("AuthQuickstart", "Next step for sign in is ${result.nextStep}")
} catch (error: AuthException) {
    Log.e("AuthQuickstart", "Sign in failed", error)
}
```

</Block>
<Block name="RxJava">

```java
// PASSWORD_SRP / PASSWORD
// Sign in with preferred challenge as password
// NOTE: Password must be provided in the same step
AuthSignInOptions options = AWSCognitoAuthSignInOptions.builder()
    .callingActivity(activity)
    .authFlowType(AuthFlowType.USER_AUTH)
    .preferredFirstFactor(AuthFactorType.PASSWORD_SRP) // or "PASSWORD"
    .build();
RxAmplify.Auth.signIn(username, password, options)
    .subscribe(
        result -> Log.i("AuthQuickstart", "Next step for sign in is " + result.getNextStep()),
        error -> Log.e("AuthQuickstart", "Failed to confirm sign in", error))
    );

// WEB_AUTHN / EMAIL_OTP / SMS_OTP
// Sign in with preferred passwordless challenge
// No user input is required at this step
AuthSignInOptions options = AWSCognitoAuthSignInOptions.builder()
    .callingActivity(activity)
    .authFlowType(AuthFlowType.USER_AUTH)
    .preferredFirstFactor(AuthFactorType.WEB_AUTHN) // or "EMAIL_OTP" or "SMS_OTP"
    .build();
RxAmplify.Auth.signIn(username, null, options)
    .subscribe(
        result -> Log.i("AuthQuickstart", "Next step for sign in is " + result.getNextStep()),
        error -> Log.e("AuthQuickstart", "Failed to confirm sign in", error))
    );
```

</Block>
</BlockSwitcher>

If the preferred first factor is not supplied or is unavailable, and the user has multiple factors available, the flow will continue to select an available first factor by returning an `AuthNextSignInStep.signInStep` value of `CONTINUE_SIGN_IN_WITH_FIRST_FACTOR_SELECTION`, and a list of `AuthNextSignInStep.availableFactors`.

The selection of the authentication method is done by the user. The user can choose from the available factors and proceed with the selected factor. You should call the `confirmSignIn` API with the selected factor to continue the sign-in process. Following is an example if you want to proceed with the `WEB_AUTHN` factor selection:

<BlockSwitcher>
<Block name="Java">

```java
AuthConfirmSignInOptions options = AWSCognitoAuthConfirmSignInOptions.builder()
    .callingActivity(activity)
    .build();
Amplify.Auth.confirmSignIn(
    AuthFactorType.WEB_AUTHN.getChallengeResponse(),
    options,
    result -> Log.i("AuthQuickStart", "Next step for sign in is " + result.getNextStep()),
    error -> Log.e("AuthQuickStart", "Failed to confirm sign in", error)
);
```

</Block>
<Block name="Kotlin - Callbacks">

```kotlin
val options = AWSCognitoAuthConfirmSignInOptions.builder()
    .callingActivity(activity)
    .build()
Amplify.Auth.confirmSignIn(
    AuthFactorType.WEB_AUTHN.challengeResponse,
    options,
    { result -> Log.i("AuthQuickStart", "Next step for sign in is ${result.nextStep}") },
    { error -> Log.e("AuthQuickStart", "Failed to confirm sign in", error) }
)
```

</Block>
<Block name="Kotlin - Coroutines">

```kotlin
try {
    val options = AWSCognitoAuthConfirmSignInOptions.builder()
        .callingActivity(activity)
        .build()
    val result = Amplify.Auth.confirmSignIn(
        challengeResponse = AuthFactorType.WEB_AUTHN.challengeResponse,
        options = options
    )
    Log.i("AuthQuickstart", "Next step for sign in is ${result.nextStep}")
} catch (error: AuthException) {
    Log.e("AuthQuickstart", "Sign in failed", error)
}
```

</Block>
<Block name="RxJava">

```java
AuthConfirmSignInOptions options = AWSCognitoAuthConfirmSignInOptions.builder()
    .callingActivity(activity)
    .build();
RxAmplify.Auth.confirmSignIn(AuthFactorType.WEB_AUTHN.getChallengeResponse(), options)
    .subscribe(
        result -> Log.i("AuthQuickstart", "Next step for sign in is " + result.getNextStep()),
        error -> Log.e("AuthQuickstart", "Failed to confirm sign in", error))
    );
```

</Block>
</BlockSwitcher>

## USER_PASSWORD_AUTH flow

A use case for the `USER_PASSWORD_AUTH` authentication flow is migrating users into Amazon Cognito

A user migration Lambda trigger helps migrate users from a legacy user management system into your user pool. If you choose the USER_PASSWORD_AUTH authentication flow, users don't have to reset their passwords during user migration. This flow sends your user's password to the service over an encrypted SSL connection during authentication.

When you have migrated all your users, switch flows to the more secure SRP flow. The SRP flow doesn't send any passwords over the network.

<BlockSwitcher>
<Block name="Java">

```java
AuthSignInOptions options = AWSCognitoAuthSignInOptions.builder()
    .authFlowType(AuthFlowType.USER_PASSWORD_AUTH)
    .build();
Amplify.Auth.signIn(
    "hello@example.com",
    "password",
    options,
    result -> Log.i("AuthQuickStart", "Sign in succeeded with result " + result),
    error -> Log.e("AuthQuickStart", "Failed to sign in", error)
);
```

</Block>
<Block name="Kotlin - Callbacks">

```kotlin
val options = AWSCognitoAuthSignInOptions.builder()
    .authFlowType(AuthFlowType.USER_PASSWORD_AUTH)
    .build()
Amplify.Auth.signIn(
    "hello@example.com",
    "password",
    options,
    { result ->
        Log.i("AuthQuickstart", "Next step for sign in is ${result.nextStep}")
    },
    { error ->
        Log.e("AuthQuickstart", "Failed to sign in", error)
    }
)
```

</Block>
<Block name="Kotlin - Coroutines">

```kotlin
try {
    val options = AWSCognitoAuthSignInOptions.builder()
        .authFlowType(AuthFlowType.USER_PASSWORD_AUTH)
        .build()
    val result = Amplify.Auth.signIn(
        username = "hello@example.com",
        password = "password",
        options = options
    )
    Log.i("AuthQuickstart", "Next step for sign in is ${result.nextStep}")
} catch (error: AuthException) {
    Log.e("AuthQuickstart", "Sign in failed", error)
}
```

</Block>
<Block name="RxJava">

```java
AuthSignInOptions options = AWSCognitoAuthSignInOptions.builder()
    .authFlowType(AuthFlowType.USER_PASSWORD_AUTH)
    .build();
RxAmplify.Auth.signIn("hello@example.com", "password", options)
    .subscribe(
        result -> Log.i("AuthQuickstart", "Next step for sign in is " + result.getNextStep()),
        error -> Log.e("AuthQuickstart", error.toString())
    );
```

</Block>
</BlockSwitcher>

### Set up auth backend

In order to use the authentication flow `USER_PASSWORD_AUTH`, your Cognito app client has to be configured to allow it. Amplify Gen 2 enables SRP auth by default. To enable USER_PASSWORD_AUTH, you can update the `backend.ts` file with the following changes:

```ts title="amplify/backend.ts"
import { defineBackend } from '@aws-amplify/backend'
import { auth } from './auth/resource'
import { data } from './data/resource'

const backend = defineBackend({
  auth,
  data,
});

// highlight-start
backend.auth.resources.cfnResources.cfnUserPoolClient.explicitAuthFlows = [
  "ALLOW_USER_PASSWORD_AUTH",
  "ALLOW_USER_SRP_AUTH",
  "ALLOW_USER_AUTH",
  "ALLOW_REFRESH_TOKEN_AUTH"
];
// highlight-end
```

### Migrate users with Amazon Cognito

Amazon Cognito provides a trigger to migrate users from your existing user directory seamlessly into Cognito. You achieve this by configuring your User Pool's "Migration" trigger which invokes a Lambda function whenever a user that does not already exist in the user pool authenticates, or resets their password.

In short, the Lambda function will validate the user credentials against your existing user directory and return a response object containing the user attributes and status on success. An error message will be returned if an error occurs. There's documentation around [how to set up this migration flow](https://docs.aws.amazon.com/cognito/latest/developerguide/cognito-user-pools-import-using-lambda.html) and more detailed instructions on [how the lambda should handle request and response objects](https://docs.aws.amazon.com/cognito/latest/developerguide/user-pool-lambda-migrate-user.html#cognito-user-pools-lambda-trigger-syntax-user-migration).

## CUSTOM_AUTH flow

Amazon Cognito User Pools supports customizing the authentication flow to enable custom challenge types, in addition to a password in order to verify the identity of users. The custom authentication flow is a series of challenge and response cycles that can be customized to meet different requirements. These challenge types may include CAPTCHAs or dynamic challenge questions.

To define your challenges for custom authentication flow, you need to implement three Lambda triggers for Amazon Cognito.

The flow is initiated by calling `signIn` with `AWSCognitoAuthSignInOptions` configured with `AuthFlowType.CUSTOM_AUTH_WITH_SRP` OR `AuthFlowType.CUSTOM_AUTH_WITHOUT_SRP`.

Follow the instructions in [Custom Auth Sign In](/gen1/[platform]/build-a-backend/auth/sign-in-custom-flow/) to learn about how to integrate custom authentication flow in your application with the Auth APIs.

</InlineFilter>


<Callout>

For more information about working with Lambda Triggers for custom authentication challenges, please visit [Amazon Cognito Developer Documentation](https://docs.aws.amazon.com/cognito/latest/developerguide/user-pool-lambda-challenge.html).

</Callout>


Contents of build-a-backend_auth_connect-your-frontend_using-the-authenticator_index.txt:
import { getCustomStaticPath } from '@/utils/getCustomStaticPath';

export const meta = {
  title: 'Using the Authenticator',
  description: 'Learn how to use the Authenticator connected component from the Amplify UI library',
  platforms: [
    'android',
    'angular',
    'flutter',
    'javascript',
    'nextjs',
    'react',
    'react-native',
    'swift',
    'vue'
  ]
};

export function getStaticPaths() {
  return getCustomStaticPath(meta.platforms);
}

export function getStaticProps() {
  return {
    props: {
      meta,
    }
  };
}

<InlineFilter filters={["swift"]}>

The quickest way to get started with Amplify Auth in your frontend application is with the [Authenticator component](https://ui.docs.amplify.aws/swift/connected-components/authenticator), which provides a customizable UI and complete authentication flows.

```swift
import Amplify
import Authenticator
import AWSCognitoAuthPlugin
import SwiftUI

@main
struct MyApp: App {
    init() {
        do {
            try Amplify.add(plugin: AWSCognitoAuthPlugin())
            try Amplify.configure(with: .amplifyOutputs)
        } catch {
            print("Unable to configure Amplify \(error)")
        }
    }

    var body: some Scene {
        WindowGroup {
            Authenticator { state in
                VStack {
                    Text("Hello, \(state.user.username)")
                    Button("Sign out") {
                        Task {
                            await state.signOut()
                        }
                    }
                }
            }
        }
    }
}
```

</InlineFilter>

<InlineFilter filters={["flutter"]}>

The quickest way to get started with Amplify Auth in your frontend application is with the [Authenticator component](https://ui.docs.amplify.aws/flutter/connected-components/authenticator), which provides a customizable UI and complete authentication flows.

</InlineFilter>

<InlineFilter filters={["android"]}>

The quickest way to get started with Amplify Auth in your frontend application is with the [Authenticator component](https://ui.docs.amplify.aws/android/connected-components/authenticator), which provides a customizable UI and complete authentication flows.

</InlineFilter>

<InlineFilter filters={["javascript", "nextjs", "react"]}>

The quickest way to get started with Amplify Auth in your frontend application is with the [Authenticator component](https://ui.docs.amplify.aws/react/connected-components/authenticator), which provides a customizable UI and complete authentication flows.


```tsx title="src/App.tsx"
import { Authenticator } from '@aws-amplify/ui-react';
import { Amplify } from 'aws-amplify';
import '@aws-amplify/ui-react/styles.css';
import outputs from "../amplify_outputs.json";

Amplify.configure(outputs);

export default function App() {
  return (
    <Authenticator>
      {({ signOut, user }) => (
        <main>
          <h1>Hello {user?.username}</h1>
          <button onClick={signOut}>Sign out</button>
        </main>
      )}
    </Authenticator>
  );
}
```

</InlineFilter>

The Authenticator component is automatically configured based on the outputs generated from your backend. To learn more about the Authenticator and how to customize its appearance, visit the [Amplify UI documentation](https://ui.docs.amplify.aws/).

<InlineFilter filters={["javascript", "nextjs", "react"]}>
Conversely, you can bring your own UI and leverage the library from [`aws-amplify`](https://www.npmjs.com/package/aws-amplify) to handle authentication flows manually.
</InlineFilter>

{/* using the Authenticator Provider */}
{/* useAuthenticator */}
{/* ## Next Steps */}
{/* learn how to use the auth api's */}


Contents of build-a-backend_auth_customize-auth-lifecycle_custom-auth-flows_index.txt:
import { getCustomStaticPath } from '@/utils/getCustomStaticPath';

export const meta = {
  title: 'Custom auth flows',
  description:
    'Use Amazon Cognito Auth plugin to sign in a user into Amazon Cognito User Pool using user defined custom flow',
  platforms: [
    'android',
    'flutter',
    'swift',
  ], 
};

export const getStaticPaths = async () => {
  return getCustomStaticPath(meta.platforms);
};

export function getStaticProps(context) {
  return {
    props: {
      platform: context.params.platform,
      meta
    }
  };
}

<InlineFilter filters={['swift']}>
The Auth category can be configured to perform a [custom authentication flow](https://docs.aws.amazon.com/cognito/latest/developerguide/user-pool-lambda-challenge.html) defined by you. The following guide shows how to setup a simple passwordless authentication flow.

## Prerequisites
An application with Amplify libraries integrated and a minimum target of any of the following:
- **iOS 13.0**, using **Xcode 14.1** or later.
- **macOS 10.15**, using **Xcode 14.1** or later.
- **tvOS 13.0**, using **Xcode 14.3** or later.
- **watchOS 9.0**, using **Xcode 14.3** or later.
- **visionOS 1.0**, using **Xcode 15** or later. (Preview support - see below for more details.)

For a full example, please follow the [project setup walkthrough](/[platform]/start/quickstart/).

<Callout>

visionOS support is currently in **preview** and can be used by using the latest [Amplify Release](https://github.com/aws-amplify/amplify-swift/releases). 
As new Xcode and visionOS versions are released, the support will be updated with any necessary fixes on a best effort basis.

</Callout>

<Callout>

To use Auth in a macOS project, you'll need to enable the Keychain Sharing capability. In Xcode, navigate to **your application target** > **Signing & Capabilities** > **+ Capability**, then select **Keychain Sharing.**

This capability is required because Auth uses the Data Protection Keychain on macOS as a platform best practice. See [TN3137: macOS keychain APIs and implementations](https://developer.apple.com/documentation/technotes/tn3137-on-mac-keychains) for more information on how Keychain works on macOS and the Keychain Sharing entitlement.

For more information on adding capabilities to your application, see [Xcode Capabilities](https://developer.apple.com/documentation/xcode/capabilities).

</Callout>

## Configure Auth

The custom auth flow can be [configured manually](https://docs.aws.amazon.com/cognito/latest/developerguide/user-pool-lambda-challenge.html).

## Sign in a user

Implement a UI to get the username from the user. After the user enters the username you can start the sign in flow by calling the following method:
<BlockSwitcher>

<Block name="Async/Await">

```swift
func signIn(username: String) async {
    do {
        let options = AWSAuthSignInOptions(authFlowType: .customWithoutSRP)
        let signInResult = try await Amplify.Auth.signIn(username: username,
                                                        options: .init(pluginOptions: options))
        if case .confirmSignInWithCustomChallenge(_) = signInResult.nextStep {
            // Ask the user to enter the custom challenge.
        } else {
            print("Sign in succeeded")
        }
    } catch let error as AuthError {
        print("Sign in failed \(error)")
    } catch {
        print("Unexpected error: \(error)")
    }
}
```

</Block>

<Block name="Combine">

```swift
func signIn(username: String) -> AnyCancellable {
    Amplify.Publisher.create {
        let options = AWSAuthSignInOptions(authFlowType: .customWithoutSRP)
        try await Amplify.Auth.signIn(username: username,
                                    options: .init(pluginOptions: options))
    }.sink {
        if case let .failure(authError) = $0 {
            print("Sign in failed \(authError)")
        }
    }
    receiveValue: { result in
        if case .confirmSignInWithCustomChallenge(_) = result.nextStep {
            // Ask the user to enter the custom challenge.
        } else {
            print("Sign in succeeded")
        }
    }
}
```

</Block>

</BlockSwitcher>

Since this is a custom authentication flow with a challenge, the result of the signin process has a next step `.confirmSignInWithCustomChallenge`. Implement a UI to allow the user to enter the custom challenge.

## Confirm sign in with custom challenge

To get a custom challenge from the user, create an appropriate UI for the user to submit the required value, and pass that value into the `confirmSignin()` API.

<BlockSwitcher>

<Block name="Async/Await">

```swift
func customChallenge(response: String) async {
    do {
      _ = try await Amplify.Auth.confirmSignIn(challengeResponse: response)
      print("Confirm sign in succeeded") 
    } catch let error as AuthError {
      print("Confirm sign in failed \(error)")
    } catch {
      print("Unexpected error: \(error)")
    }
}
```

</Block>

<Block name="Combine">

```swift
func customChallenge(response: String) -> AnyCancellable {
    Amplify.Publisher.create {
        try await Amplify.Auth.confirmSignIn(challengeResponse: response)
        }.sink {
            if case let .failure(authError) = $0 {
                print("Confirm sign in failed \(authError)")
            }
        }
        receiveValue: { _ in
            print("Confirm sign in succeeded")
        }
}
```

</Block>

</BlockSwitcher>

You will know the sign in flow is complete if you see the following in your console window:

```console
Confirm sign in succeeded
```

### Lambda Trigger Setup

AWS Amplify now supports creating functions as part of its new backend experience. For more information on the Functions and how to start with them check out [Functions documentation](/[platform]/build-a-backend/functions/). In addition, more information on available triggers can be found in the [Cognito documentation](https://docs.aws.amazon.com/cognito/latest/developerguide/cognito-user-identity-pools-working-with-aws-lambda-triggers.html).

### Custom Auth Flow with Secure Remote Password (SRP)

Cognito User Pool allows to start the custom authentication flow with SRP as the first step. If you would like to use this flow, setup Define Auth Lambda trigger to handle SRP_A as the first challenge as shown below:

```javascript
exports.handler = (event, context) => {
  if (event.request.session.length == 1 && 
      event.request.session[0].challengeName == 'SRP_A') {
        event.response.issueTokens = false;
        event.response.failAuthentication = false;
        event.response.challengeName = 'PASSWORD_VERIFIER';
  } else if (event.request.session.length == 2 && 
      event.request.session[1].challengeName == 'PASSWORD_VERIFIER' && 
      event.request.session[1].challengeResult == true) {
        event.response.issueTokens = false;
        event.response.failAuthentication = false;
        event.response.challengeName = 'CUSTOM_CHALLENGE';
  } else if (event.request.session.length == 3 && 
      event.request.session[2].challengeName == 'CUSTOM_CHALLENGE' && 
      event.request.session[2].challengeResult == true) {
        event.response.issueTokens = true;
        event.response.failAuthentication = false;
  } else {
      event.response.issueTokens = false;
      event.response.failAuthentication = true;
  }
  context.done(null, event);
};
```

If your lambda is setup to start with `SRP` as the first step, make sure to initiate the signIn process with `customWithSRP` as the authentication flow:

```swift
let options = AWSAuthSignInOptions(
    authFlowType: .customWithSRP)
let signInResult = try await Amplify.Auth.signIn(
    username: username,
    password: password,
    options: .init(pluginOptions: options))
```

</InlineFilter>
<InlineFilter filters={['android']}>
The Auth category can be configured to perform a [custom authentication flow](https://docs.aws.amazon.com/cognito/latest/developerguide/user-pool-lambda-challenge.html) defined by you. The following guide shows how to setup a simple passwordless authentication flow.

## Prerequisites

* An Android application targeting at least Android SDK API level 24 with Amplify libraries integrated
    * For a full example of creating Android project, please follow the [project setup walkthrough](/[platform]/start/quickstart/)

## Configure Auth

The custom auth flow can be [configured manually](https://docs.aws.amazon.com/cognito/latest/developerguide/user-pool-lambda-challenge.html).

## Register a user

The flow as mentioned above requires a username and a valid email id as parameters to register a user. Invoke the following api to initiate a sign up flow.

<BlockSwitcher>
<Block name="Java">

```java
AuthSignUpOptions options = AuthSignUpOptions.builder()
    .userAttribute(AuthUserAttributeKey.email(), "my@email.com")
    .build();
Amplify.Auth.signUp("username", "Password123", options,
    result -> Log.i("AuthQuickStart", "Result: " + result.toString()),
    error -> Log.e("AuthQuickStart", "Sign up failed", error)
);
```

</Block>
<Block name="Kotlin - Callbacks">

```kotlin
val options = AuthSignUpOptions.builder()
    .userAttribute(AuthUserAttributeKey.email(), "my@email.com")
    .build()
Amplify.Auth.signUp("username", "Password123", options,
    { Log.i("AuthQuickStart", "Sign up succeeded: $it") },
    { Log.e ("AuthQuickStart", "Sign up failed", it) }
)
```

</Block>
<Block name="Kotlin - Coroutines">

```kotlin
val options = AuthSignUpOptions.builder()
    .userAttribute(AuthUserAttributeKey.email(), "my@email.com")
    .build()
try {
    val result = Amplify.Auth.signUp("username", "Password123", options)
    Log.i("AuthQuickStart", "Result: $result") 
} catch (error: AuthException) {
    Log.e("AuthQuickStart", "Sign up failed", error)
}
```

</Block>
<Block name="RxJava">

 ```java
RxAmplify.Auth.signUp(
    "username",
    "Password123",
    AuthSignUpOptions.builder().userAttribute(AuthUserAttributeKey.email(), "my@email.com").build())
    .subscribe(
        result -> Log.i("AuthQuickStart", "Result: " + result.toString()),
        error -> Log.e("AuthQuickStart", "Sign up failed", error)
    );
```

</Block>
</BlockSwitcher>

The next step in the sign up flow is to confirm the user. A confirmation code will be sent to the email id provided during sign up. Enter the confirmation code received via email in the `confirmSignUp` call.

<BlockSwitcher>
<Block name="Java">

```java
Amplify.Auth.confirmSignUp(
    "username",
    "the code you received via email",
    result -> Log.i("AuthQuickstart", result.isSignUpComplete() ? "Confirm signUp succeeded" : "Confirm sign up not complete"),
    error -> Log.e("AuthQuickstart", error.toString())
);
```

</Block>
<Block name="Kotlin - Callbacks">

```kotlin
Amplify.Auth.confirmSignUp(
    "username", "the code you received via email",
    { result ->
        if (result.isSignUpComplete) {
            Log.i("AuthQuickstart", "Confirm signUp succeeded")
        } else {
            Log.i("AuthQuickstart","Confirm sign up not complete")
        }
    },
    { Log.e("AuthQuickstart", "Failed to confirm sign up", it) }
)
```

</Block>
<Block name="Kotlin - Coroutines">

```kotlin
try {
    val code = "code you received via email"
    val result = Amplify.Auth.confirmSignUp("username", code)
    if (result.isSignUpComplete) {
        Log.i("AuthQuickstart", "Signup confirmed")
    } else {
        Log.i("AuthQuickstart", "Signup confirmation not yet complete")
    }
} catch (error: AuthException) {
    Log.e("AuthQuickstart", "Failed to confirm signup", error)
}
```

</Block>
<Block name="RxJava">

```java
RxAmplify.Auth.confirmSignUp("username", "the code you received via email")
    .subscribe(
        result -> Log.i("AuthQuickstart", result.isSignUpComplete() ? "Confirm signUp succeeded" : "Confirm sign up not complete"),
        error -> Log.e("AuthQuickstart", error.toString())
    );
```

</Block>
</BlockSwitcher>

You will know the sign up flow is complete if you see the following in your console window:

```console
Confirm signUp succeeded
```

## Sign in a user

Implement a UI to get the username from the user. After the user enters the username you can start the sign in flow by calling the following method:

<BlockSwitcher>

<Block name="Java">

```java
AWSCognitoAuthSignInOptions options = AWSCognitoAuthSignInOptions.builder()
    .authFlowType(AuthFlowType.CUSTOM_AUTH_WITHOUT_SRP)
    .build();
Amplify.Auth.signIn(
    "username",
    "password",
    options,
    result -> Log.i("AuthQuickstart", result.isSignedIn() ? "Sign in succeeded" : "Sign in not complete"),
    error -> Log.e("AuthQuickstart", error.toString())
);
```

</Block>

<Block name="Kotlin - Callbacks">

```kotlin
val options = AWSCognitoAuthSignInOptions.builder()
    .authFlowType(AuthFlowType.CUSTOM_AUTH_WITHOUT_SRP)
    .build()
Amplify.Auth.signIn(
    "username", 
    "password", 
    options,
    { result ->
        if (result.isSignedIn) {
            Log.i("AuthQuickstart", "Sign in succeeded")
        } else {
            Log.i("AuthQuickstart", "Sign in not complete")
        }
    },
    { Log.e("AuthQuickstart", "Failed to sign in", it) }
)
```

</Block>
<Block name="Kotlin - Coroutines">

```kotlin
val options = AWSCognitoAuthSignInOptions.builder()
    .authFlowType(AuthFlowType.CUSTOM_AUTH_WITHOUT_SRP)
    .build()
try {
    val result = Amplify.Auth.signIn("username", "password", options)
    if (result.isSignedIn) {
        Log.i("AuthQuickstart", "Sign in succeeded")
    } else {
        Log.e("AuthQuickstart", "Sign in not complete")
    }
} catch (error: AuthException) {
    Log.e("AuthQuickstart", "Sign in failed", error)
}
```

</Block>
<Block name="RxJava">

```java
AWSCognitoAuthSignInOptions options = AWSCognitoAuthSignInOptions.builder()
    .authFlowType(AuthFlowType.CUSTOM_AUTH_WITHOUT_SRP)
    .build();
RxAmplify.Auth.signIn("username", "password", options)
    .subscribe(
        result -> Log.i("AuthQuickstart", result.isSignedIn() ? "Sign in succeeded" : "Sign in not complete"),
        error -> Log.e("AuthQuickstart", error.toString())
    );
```

</Block>
</BlockSwitcher>

Since this is a custom authentication flow with a challenge, the result of the signin process has a next step `.confirmSignInWithCustomChallenge`. Implement a UI to allow the user to enter the custom challenge.

## Confirm sign in with custom challenge

Get the custom challenge (`1234` in this case) from the user and pass it to the `confirmSignin()` api.

<BlockSwitcher>

<Block name="Java">

```java
Amplify.Auth.confirmSignIn(
    "confirmation",
    result -> Log.i("AuthQuickstart", "Confirm sign in succeeded: " + result.toString()),
    error -> Log.e("AuthQuickstart", "Failed to confirm sign in", error)
);
```

</Block>
<Block name="Kotlin - Callbacks">

```kotlin
Amplify.Auth.confirmSignIn("confirmation",
    { Log.i("AuthQuickstart", "Confirm sign in succeeded: $it") },
    { Log.e("AuthQuickstart", "Failed to confirm sign in", it) }
)
```

</Block>
<Block name="Kotlin - Coroutines">

```kotlin
try {
    val result = Amplify.Auth.confirmSignIn("confirmation")
    Log.i("AuthQuickstart", "Confirm sign in succeeded: $result") 
} catch (error: AuthException) {
    Log.e("AuthQuickstart", "Failed to confirm signin", error)
}
```

</Block>
<Block name="RxJava">

```java
RxAmplify.Auth.confirmSignIn("confirmation")
    .subscribe(
        result -> Log.i("AuthQuickstart", result.toString()),
        error -> Log.e("AuthQuickstart", error.toString())
    );
```

</Block>

</BlockSwitcher>

You will know the sign in flow is complete if you see the following in your console window:

```console
Confirm sign in succeeded
```

### Lambda Trigger Setup

AWS Amplify now supports creating functions as part of the AWS Amplify. For more information on the Functions and how to start with them check out [Functions documentation](/[platform]/build-a-backend/functions/). In addition, more information on available triggers can be found in the [Cognito documentation](https://docs.aws.amazon.com/cognito/latest/developerguide/cognito-user-identity-pools-working-with-aws-lambda-triggers.html).

### Custom Auth Flow with Secure Remote Password (SRP)

Cognito User Pool allows to start the custom authentication flow with SRP as the first step. If you would like to use this flow, setup Define Auth Lambda trigger to handle SRP_A as the first challenge as shown below:

```javascript
exports.handler = (event, context) => {
  if (event.request.session.length == 1 &&
      event.request.session[0].challengeName == 'SRP_A') {
        event.response.issueTokens = false;
        event.response.failAuthentication = false;
        event.response.challengeName = 'PASSWORD_VERIFIER';
  } else if (event.request.session.length == 2 &&
      event.request.session[1].challengeName == 'PASSWORD_VERIFIER' &&
      event.request.session[1].challengeResult == true) {
        event.response.issueTokens = false;
        event.response.failAuthentication = false;
        event.response.challengeName = 'CUSTOM_CHALLENGE';
  } else if (event.request.session.length == 3 &&
      event.request.session[2].challengeName == 'CUSTOM_CHALLENGE' &&
      event.request.session[2].challengeResult == true) {
        event.response.issueTokens = true;
        event.response.failAuthentication = false;
  } else {
      event.response.issueTokens = false;
      event.response.failAuthentication = true;
  }
  context.done(null, event);
};
```

If your lambda is setup to start with `SRP` as the first step, make sure to initiate the signIn process with `customWithSRP` as the authentication flow:

<BlockSwitcher>

<Block name="Java">

```java
AWSCognitoAuthSignInOptions options = AWSCognitoAuthSignInOptions.builder()
    .authFlowType(AuthFlowType.CUSTOM_AUTH_WITH_SRP)
    .build();
Amplify.Auth.signIn(
    "username",
    "password",
    options,
    result -> Log.i("AuthQuickstart", result.isSignedIn() ? "Sign in succeeded" : "Sign in not complete"),
    error -> Log.e("AuthQuickstart", error.toString())
);
```

</Block>

<Block name="Kotlin - Callbacks">

```kotlin
val options = AWSCognitoAuthSignInOptions.builder()
    .authFlowType(AuthFlowType.CUSTOM_AUTH_WITH_SRP)
    .build()
Amplify.Auth.signIn(
    "username", 
    "password", 
    options,
    { result ->
        if (result.isSignedIn) {
            Log.i("AuthQuickstart", "Sign in succeeded")
        } else {
            Log.i("AuthQuickstart", "Sign in not complete")
        }
    },
    { Log.e("AuthQuickstart", "Failed to sign in", it) }
)
```

</Block>
<Block name="Kotlin - Coroutines">

```kotlin
val options = AWSCognitoAuthSignInOptions.builder()
    .authFlowType(AuthFlowType.CUSTOM_AUTH_WITH_SRP)
    .build()
try {
    val result = Amplify.Auth.signIn("username", "password", options)
    if (result.isSignedIn) {
        Log.i("AuthQuickstart", "Sign in succeeded")
    } else {
        Log.e("AuthQuickstart", "Sign in not complete")
    }
} catch (error: AuthException) {
    Log.e("AuthQuickstart", "Sign in failed", error)
}
```

</Block>
<Block name="RxJava">

```java
AWSCognitoAuthSignInOptions options = AWSCognitoAuthSignInOptions.builder()
    .authFlowType(AuthFlowType.CUSTOM_AUTH_WITH_SRP)
    .build();
RxAmplify.Auth.signIn("username", "password", options)
    .subscribe(
        result -> Log.i("AuthQuickstart", result.isSignedIn() ? "Sign in succeeded" : "Sign in not complete"),
        error -> Log.e("AuthQuickstart", error.toString())
    );
```

</Block>
</BlockSwitcher>

</InlineFilter>

<InlineFilter filters={['flutter']}>
The Auth category can be configured to perform a [custom authentication flow](https://docs.aws.amazon.com/cognito/latest/developerguide/user-pool-lambda-challenge.html) defined by you. The following guide shows how to setup a simple passwordless authentication flow.

## Prerequisites

Amplify requires a minimum target platform for iOS (13.0), Android (API level 24), and macOS (10.15). Refer to [Flutter's supported deployment platforms](https://docs.flutter.dev/reference/supported-platforms) when targeting Web, Windows, or Linux. Additional setup is required for some target platforms. Please see the [platform setup](/[platform]/build-a-backend/auth/connect-your-frontend/sign-in/#platform-setup) for more details on platform specific setup.

## Configure Auth

The custom auth flow can be [configured manually](https://docs.aws.amazon.com/cognito/latest/developerguide/user-pool-lambda-challenge.html).

## Register a user

The flow as mentioned above requires a username and a valid email id as parameters to register a user. Invoke the following api to initiate a sign up flow.

Because authentication flows in Cognito can be switched via your configuration, it is still required that users register with a password.

```dart
Future<void> signUpCustomFlow() async {
  try {
    final userAttributes = <AuthUserAttributeKey, String>{
      AuthUserAttributeKey.email: 'email@domain.com',
      AuthUserAttributeKey.phoneNumber: '+15559101234',
      // additional attributes as needed
    };
    final result = await Amplify.Auth.signUp(
      username: 'myusername',
      password: 'mysupersecurepassword',
      options: SignUpOptions(userAttributes: userAttributes),
    );
    safePrint('Sign up result: $result');
  } on AuthException catch (e) {
    safePrint('Error signing up: ${e.message}');
  }
}
```

The next step in the sign up flow is to confirm the user. A confirmation code will be sent to the email id provided during sign up. Enter the confirmation code received via email in the `confirmSignUp` call.

```dart
Future<void> confirmUser({
  required String username,
  required String confirmationCode,
}) async {
  try {
    final result = await Amplify.Auth.confirmSignUp(
      username: username,
      confirmationCode: confirmationCode,
    );
    // Check if further confirmations are needed or if
    // the sign up is complete.
    await _handleSignUpResult(result);
  } on AuthException catch (e) {
    safePrint('Error confirming user: ${e.message}');
  }
}
```

## Sign in a user

Implement a UI to get the username from the user. After the user enters the username you can start the sign in flow by calling the following method:

```dart
// Create state variables for the sign in status
var isSignedIn = false;
String? challengeHint;

Future<void> signInCustomFlow(String username) async {
  try {
    final result = await Amplify.Auth.signIn(username: username);
    setState(() {
      isSignedIn = result.isSignedIn;
      // Get the publicChallengeParameters from your Create Auth Challenge Lambda
      challengeHint = result.nextStep.additionalInfo['hint'];
    });
  } on AuthException catch (e) {
    safePrint('Error signing in: ${e.message}');
  }
}
```

<Callout>

Please note that you will be prevented from successfully calling `signIn` if a
user has already signed in and a valid session is active. You must first call
`signOut` to remove the original session.

</Callout>
## Confirm sign in with custom challenge

To get a custom challenge from the user, create an appropriate UI for the user to submit the required value, and pass that value into the `confirmSignin()` API.

```dart
Future<void> confirmSignIn(String generatedNumber) async {
  try {
    final result = await Amplify.Auth.confirmSignIn(
      /// Enter the random number generated by your Create Auth Challenge trigger
      confirmationValue: generatedNumber,
    );
    safePrint('Sign in result: $result');
  } on AuthException catch (e) {
    safePrint('Error signing in: ${e.message}');
  }
}
```

Once the user provides the correct response, they should be authenticated in your application.

<Callout warning>

<b>Special Handling on ConfirmSignIn</b>

During a `confirmSignIn` call, if `failAuthentication: true` is returned by the Lambda, the session of the request gets invalidated by Cognito, and a `NotAuthorizedException` is thrown. To recover, the user must initiate a new sign in by calling `Amplify.Auth.signIn`.

Exception: `NotAuthorizedException` with a message `Invalid session for the user.`
</Callout>

## Custom authentication flow with password verification

The example in this documentation demonstrates the passwordless custom authentication flow. However, it is also possible to require that users supply a valid password as part of the custom authentication flow.

To require a valid password, you can alter the [DefineAuthChallenge](https://docs.aws.amazon.com/cognito/latest/developerguide/user-pool-lambda-define-auth-challenge.html) code to handle a `PASSWORD_VERIFIER` step:

```js
exports.handler = async (event) => {
  if (
    event.request.session.length === 1 &&
    event.request.session[0].challengeName === 'SRP_A'
  ) {
    event.response.issueTokens = false;
    event.response.failAuthentication = false;
    event.response.challengeName = 'PASSWORD_VERIFIER';
  } else if (
    event.request.session.length === 2 &&
    event.request.session[1].challengeName === 'PASSWORD_VERIFIER' &&
    event.request.session[1].challengeResult === true
  ) {
    event.response.issueTokens = false;
    event.response.failAuthentication = false;
    event.response.challengeName = 'CUSTOM_CHALLENGE';
  } else if (
    event.request.session.length === 3 &&
    event.request.session[2].challengeName === 'CUSTOM_CHALLENGE' &&
    event.request.session[2].challengeResult === true
  ) {
    event.response.issueTokens = true;
    event.response.failAuthentication = false;
  } else {
    event.response.issueTokens = false;
    event.response.failAuthentication = true;
  }

  return event;
};
```

</InlineFilter>


Contents of build-a-backend_auth_customize-auth-lifecycle_email-customization_index.txt:
import { getCustomStaticPath } from '@/utils/getCustomStaticPath';

export const meta = {
  title: 'Email customization',
  description: 'Learn how to customize emails your users receive when signing up',
  platforms: [
    'android',
    'angular',
    'flutter',
    'javascript',
    'nextjs',
    'react',
    'react-native',
    'swift',
    'vue'
  ]
};

export function getStaticPaths() {
  return getCustomStaticPath(meta.platforms);
}

export function getStaticProps() {
  return {
    props: {
      meta,
    }
  };
}

{/* verification email (basic) */}
{/* verification email with react.email/jsx.email */}

## Customize the Verification Email

By default, Amplify Auth resources are scaffolded with email as the default method for your users to sign in. When you users sign up they receive a verification email to confirm their ownership of the email they specified during sign-up. Emails such as the verification email can be customized with your app's brand identity.

To get started, change the `email` attribute of `loginWith` from `true` to an object to begin customizing its default behavior:

```diff title="amplify/auth/resource.ts"
import { defineAuth } from "@aws-amplify/backend"

export const auth = defineAuth({
  loginWith: {
-   email: true, 
+   email: {
+     verificationEmailStyle: "CODE",
+     verificationEmailSubject: "Welcome to my app!",
+     verificationEmailBody: (createCode) => `Use this code to confirm your account: ${createCode()}`,
+   },
  },
})
```

## Customize the Invitation Email 

In some cases, you may [set up a user account on behalf of a user in the Amplify console](/[platform]/build-a-backend/auth/manage-users/with-amplify-console/). In this case, Amplify Auth will send an invitation email to the user welcoming them to your application. This email includes a brief welcome message, along with the email address they can log in with and the temporary password you've set up for them. 

If you'd like to customize that email, you can override the `userInvitation` attribute of the `email` object:

```diff title="amplify/auth/resource.ts"
import { defineAuth } from "@aws-amplify/backend"

export const auth = defineAuth({
  loginWith: {
-   email: true, 
+   email: {
+     // can be used in conjunction with a customized welcome email as well
+     verificationEmailStyle: "CODE",
+     verificationEmailSubject: "Welcome to my app!",
+     verificationEmailBody: (createCode) => `Use this code to confirm your account: ${createCode()}`,
+     userInvitation: {
+       emailSubject: "Welcome to my app!",
+       emailBody: (user, code) =>
+         `We're happy to have you! You can now login with username ${user()} and temporary password ${code()}`, 
+     },
+   },
  },
})
```

Note that when using the `user` and `code` arguments of the `emailBody` function, `user` and `code` are **functions** which must be called. Failure to call them will result in an error when your sandbox deploys.

{/* ## With react.email */}

{/* ## With jsx.email */}

{/* ## i18n */}


Contents of build-a-backend_auth_customize-auth-lifecycle_index.txt:
import { getChildPageNodes } from '@/utils/getChildPageNodes';
import { getCustomStaticPath } from '@/utils/getCustomStaticPath';

export const meta = {
  title: 'Customize auth lifecycle',
  description:
    'Learn how to customize the auth lifecycle',
  route: '/[platform]/build-a-backend/auth/customize-auth-lifecycle',
  platforms: [
    'android',
    'angular',
    'flutter',
    'javascript',
    'nextjs',
    'react',
    'react-native',
    'swift',
    'vue'
  ]
};

export function getStaticPaths() {
  return getCustomStaticPath(meta.platforms);
}

export function getStaticProps() {
  const childPageNodes = getChildPageNodes(meta.route);
  return {
    props: {
      meta,
      childPageNodes
    }
  };
}

<Overview childPageNodes={props.childPageNodes} />


Contents of build-a-backend_auth_customize-auth-lifecycle_triggers_index.txt:
import { getCustomStaticPath } from '@/utils/getCustomStaticPath';

export const meta = {
  title: 'Triggers',
  description: 'Learn how to use Cognito Lambda triggers to customize the authentication lifecycle',
  platforms: [
    'android',
    'angular',
    'flutter',
    'javascript',
    'nextjs',
    'react',
    'react-native',
    'swift',
    'vue'
  ]
};

export function getStaticPaths() {
  return getCustomStaticPath(meta.platforms);
}

export function getStaticProps() {
  return {
    props: {
      meta,
    }
  };
}

Amplify Auth's behavior can be customized through the use of triggers. A trigger is defined as a Function, and is a mechanism to slot some logic to execute during the authentication flow. For example, you can use triggers to [validate whether emails include an allowlisted domain](/[platform]/build-a-backend/functions/examples/email-domain-filtering), [add a user to a group upon confirmation](/[platform]/build-a-backend/functions/examples/add-user-to-group), or [create a "UserProfile" model upon account confirmation](/[platform]/build-a-backend/functions/examples/create-user-profile-record).

Triggers translate to [Cognito user pool Lambda triggers](https://docs.aws.amazon.com/cognito/latest/developerguide/cognito-user-identity-pools-working-with-aws-lambda-triggers.html).

> When you have a Lambda trigger assigned to your user pool, Amazon Cognito interrupts its default flow to request information from your function. Amazon Cognito generates a JSON event and passes it to your function. The event contains information about your user's request to create a user account, sign in, reset a password, or update an attribute. Your function then has an opportunity to take action, or to send the event back unmodified.

To get started, define a function and specify the `triggers` property on your auth resource:

```ts title="amplify/auth/resource.ts"
import { defineAuth } from "@aws-amplify/backend"

export const auth = defineAuth({
  loginWith: {
    email: true,
  },
  // highlight-next-line
  triggers: {}
})
```

To learn more about use cases for triggers, visit the [Functions examples](/[platform]/build-a-backend/functions/examples/).


Contents of build-a-backend_auth_data-usage-policy_index.txt:
import { getCustomStaticPath } from '@/utils/getCustomStaticPath';

export const meta = {
  title: 'Data usage policy information',
  description: "Review the data types gathered by the Amplify library that Apple requires you to disclose in your app's data usage policy when submitting the app to the App Store.",
  platforms: ['swift'],
};

export const getStaticPaths = async () => {
  return getCustomStaticPath(meta.platforms);
};

export function getStaticProps(context) {
  return {
    props: {
      platform: context.params.platform,
      meta
    }
  };
}

<InlineFilter filters={['swift']}>
Apple requires app developers to provide the data usage policy of the app when they submit their app to the App Store. See Apple's [User privacy and data use](https://developer.apple.com/app-store/user-privacy-and-data-use/) for more details. The Amplify Library is used to interact with AWS resources under the developer’s ownership and management. The library cannot predict the usage of its APIs and it is up to the developer to provide the privacy manifest that accurately reflects the data collected by the app. Below are the different categories identified by Apple and the corresponding data type used by the Amplify Library.

By utilizing the library, Amplify gathers API usage metrics from the AWS services accessed. This process involves adding a user agent to the request made to your AWS service. The user-agent header is included with information about the Amplify Library version, operating system name, and version. AWS collects this data to generate metrics related to our library usage. This information is not linked to the user’s identity and not used for tracking purposes as described in Apple's privacy and data use guidelines.

Should you have any specific concerns or require additional information for the enhancement of your privacy manifest, please don't hesitate to reach out.

## Contact info

| Data Type                        | Amplify Category   | Purpose             | Linked To Identity   | Tracking   | Provided by developer   |
| ------------------------------   | ------------------ | ------------------- | :------------------: | :--------: | :---------------------: |
| **Name**                         |                    |                     |                      |            |                         |
|                                  | Auth               | App Functionality   | ✅                   | ❌        | ✅                      |
| **Email Address**                |                    |                     |                      |            |                         |
|                                  | Auth               | App Functionality   | ✅                   | ❌        | ✅                      |
| **Phone Number**                 |                    |                     |                      |            |                         |
|                                  | Auth               | App Functionality   | ✅                   | ❌        | ✅                      |

## User Content

| Data Type                        | Amplify Category   | Purpose             | Linked To Identity   | Tracking   | Provided by developer   |
| ------------------------------   | ------------------ | ------------------- | :------------------: | :--------: | :---------------------: |
| **Photos or Videos**             |                    |                     |                      |            |                         |
|                                  | Storage            | App Functionality   | ❌                   | ❌        | ✅                      |
|                                  | Predictions        | App Functionality   | ❌                   | ❌        | ✅                      |
| **Audio Data**                   |                    |                     |                      |            |                         |
|                                  | Predictions        | App Functionality   | ❌                   | ❌        | ✅                      |

## Identifiers

| Data Type                        | Amplify Category   | Purpose             | Linked To Identity   | Tracking   | Provided by developer   |
| ------------------------------   | ------------------ | ------------------- | :------------------: | :--------: | :---------------------: |
| **User ID**                      |                    |                     |                      |            |                         |
|                                  | Auth               | App Functionality   | ✅                   | ❌        | ❌                      |
|                                  | Analytics          | Analytics           | ✅                   | ❌        | ❌                      |
| **Device ID**                    |                    |                     |                      |            |                         |
|                                  | Auth               | App Functionality   | ✅                   | ❌        | ❌                      |
|                                  | Analytics          | Analytics           | ✅                   | ❌        | ❌                      |

## Other Data

| Data Type                        | Amplify Category   | Purpose             | Linked To Identity   | Tracking   | Provided by developer   |
| ------------------------------   | ------------------ | ------------------- | :------------------: | :--------: | :---------------------: |
| **OS Version**                   |                    |                     |                      |            |                         |
|                                  | All categories     | Analytics           | ❌                   | ❌        | ❌                      |
| **OS Name**                      |                    |                     |                      |            |                         |
|                                  | All categories     | Analytics           | ❌                   | ❌        | ❌                      |
| **Locale Info**                  |                    |                     |                      |            |                         |
|                                  | All categories     | Analytics           | ❌                   | ❌        | ❌                      |
| **App Version**                  |                    |                     |                      |            |                         |
|                                  | Auth               | App Functionality   | ✅                   | ❌        | ❌                      |
| **Min OS target of the app**     |                    |                     |                      |            |                         |
|                                  | Auth               | App Functionality   | ✅                   | ❌        | ❌                      |
| **Timezone information**         |                    |                     |                      |            |                         |
|                                  | Auth               | App Functionality   | ✅                   | ❌        | ❌                      |
| **Network information**          |                    |                     |                      |            |                         |
|                                  | Auth               | App Functionality   | ✅                   | ❌        | ❌                      |
| **Has SIM card**                 |                    |                     |                      |            |                         |
|                                  | Auth               | App Functionality   | ✅                   | ❌        | ❌                      |
| **Cellular Carrier Name**        |                    |                     |                      |            |                         |
|                                  | Auth               | App Functionality   | ✅                   | ❌        | ❌                      |
| **Device Model**                 |                    |                     |                      |            |                         |
|                                  | Auth               | App Functionality   | ✅                   | ❌        | ❌                      |
| **Device Name**                  |                    |                     |                      |            |                         |
|                                  | Auth               | App Functionality   | ✅                   | ❌        | ❌                      |
| **Device OS Version**            |                    |                     |                      |            |                         |
|                                  | Auth               | App Functionality   | ✅                   | ❌        | ❌                      |
| **Device Height and Width**      |                    |                     |                      |            |                         |
|                                  | Auth               | App Functionality   | ✅                   | ❌        | ❌                      |
| **Device Language**              |                    |                     |                      |            |                         |
|                                  | Auth               | App Functionality   | ✅                   | ❌        | ❌                      |
| **identifierForVendor**          |                    |                     |                      |            |                         |
|                                  | Auth               | App Functionality   | ✅                   | ❌        | ❌                      |


## Health and Fitness	
No data is collected

## Financial Info
No data is collected

## Location							
No data is collected

## Sensitive Info							
No data is collected

## Contacts							
No data is collected

## Browsing History
No data is collected

## Search History
No data is collected

## Diagnostics
No data is collected
</InlineFilter>

Some Amplify categories such as Analytics and Auth persist data to the local device. Some of that data is automatically removed when a user uninstalls the app from the device.

Amplify stores Auth information in the local [system keychain](https://developer.apple.com/documentation/security/keychain_services), which does not guarantee any particular behavior around whether data is removed when an app is uninstalled.

Deciding on when to clear this auth information is not something that the SDK can do in a generic way, so App developers should decide when to clear the data by signing out. One strategy for accomplishing this would be to use [UserDefaults](https://developer.apple.com/documentation/foundation/userdefaults) to detect whether or not the app is launching for the first time, and invoking [`Auth.signOut()`](/[platform]/build-a-backend/auth/connect-your-frontend/sign-out/) if the app has not been launched before.


Contents of build-a-backend_auth_examples_index.txt:
import { getChildPageNodes } from '@/utils/getChildPageNodes';
import { getCustomStaticPath } from '@/utils/getCustomStaticPath';

export const meta = {
  title: 'Examples',
  description:
    'Learn how to address different business use cases with Amplify Auth',
  route: '/[platform]/build-a-backend/auth/examples',
  platforms: [
    'android',
    'angular',
    'flutter',
    'javascript',
    'nextjs',
    'react',
    'react-native',
    'swift',
    'vue'
  ]
};

export function getStaticPaths() {
  return getCustomStaticPath(meta.platforms);
}

export function getStaticProps() {
  const childPageNodes = getChildPageNodes(meta.route);
  return {
    props: {
      meta,
      childPageNodes
    }
  };
}

<Overview childPageNodes={props.childPageNodes} />


Contents of build-a-backend_auth_examples_microsoft-entra-id-saml_index.txt:
import { getCustomStaticPath } from '@/utils/getCustomStaticPath';

export const meta = {
  title: 'Microsoft Entra ID (SAML)',
  description: 'Learn how to connect a Microsoft Entra ID provider with SAML',
  platforms: [
    'android',
    'angular',
    'flutter',
    'javascript',
    'nextjs',
    'react',
    'react-native',
    'swift',
    'vue'
  ]
};

export function getStaticPaths() {
  return getCustomStaticPath(meta.platforms);
}

export function getStaticProps() {
  return {
    props: {
      meta,
    }
  };
}

Microsoft Entra ID can be configured as a SAML provider for use with Amazon Cognito. Integrating Entra ID enables you to sign in with your existing enterprise users, and maintain profiles unique to the Amplify Auth resource for use within your Amplify app. To learn more, visit the [Azure documentation for SAML authentication with Microsoft Entra ID](https://learn.microsoft.com/en-us/entra/architecture/auth-saml).

<Callout info>

**Note:** the following guidance showcases configuration with your [personal cloud sandbox](/[platform]/deploy-and-host/sandbox-environments/setup/). You will need to repeat the configuration steps for branch deployments after confirming functionality against your sandbox.

</Callout>

## Start your personal cloud sandbox

To get started, define your auth resource with the appropriate redirect URIs:

```ts title="amplify/auth/resource.ts"
import { defineAuth } from "@aws-amplify/backend"

/**
 * Define and configure your auth resource
 * @see https://docs.amplify.aws/gen2/build-a-backend/auth
 */
export const auth = defineAuth({
  loginWith: {
    email: true,
    externalProviders: {
      logoutUrls: ["http://localhost:3000/come-back-soon"],
      callbackUrls: ["http://localhost:3000/profile"],
    },
  },
})
```

Deploy to your personal cloud sandbox with `npx ampx sandbox`. This will generate a domain you can use to configure your new Entra ID App. After deploying your changes successfully, copy the generated `domain` value from `amplify_outputs.json`

```json title="amplify_outputs.json"
{
  "auth": {
    "aws_region": "us-east-1",
    "user_pool_id": "<your-cognito-user-pool-id>",
    "user_pool_client_id": "<your-cognito-user-pool-client-id>",
    "identity_pool_id": "<your-cognito-identity-pool-id>",
    "mfa_methods": [],
    "standard_required_attributes": [
      "email"
    ],
    "username_attributes": [
      "email"
    ],
    "user_verification_types": [
      "email"
    ],
    "mfa_configuration": "OFF",
    "password_policy": {
      "min_length": 8,
      "require_numbers": true,
      "require_lowercase": true,
      "require_uppercase": true,
      "require_symbols": true
    },
    "oauth": {
      "identity_providers": [],
      "redirect_sign_in_uri": [
        "http://localhost:3000/profile"
      ],
      "redirect_sign_out_uri": [
        "http://localhost:3000/come-back-soon"
      ],
      "response_type": "code",
      "scopes": [
        "phone",
        "email",
        "openid",
        "profile",
        "aws.cognito.signin.user.admin"
      ],
      // highlight-next-line
      "domain": "<some-hash>.auth.us-east-1.amazoncognito.com"
    },
  },
  "version": "1"
}
```

## Set up Microsoft Entra ID

Next, navigate to [portal.amazon.com](https://portal.azure.com/), select **Entra ID**. In your default directory, or company's existing directory, under **Manage**, select **Enterprise Applications**

![Entra ID default directory page highlighting Enterprise Applications](/images/auth/examples/microsoft-entra-id-saml/entra-id-select-enterprise-applications.png)

Afterwards, select **New application**, then select **Create your own application**. Specify a name for the application and choose **Integrate any other application you don't find in the gallery (Non-gallery)**

![Azure portal creating a new enterprise application for Entra ID](/images/auth/examples/microsoft-entra-id-saml/entra-id-new-enterprise-application.png)

Now that you have created the new enterprise application you can begin to configure Single Sign-on with SAML. Select **Single sign-on**

![Entra ID enterprise application highlighting "single sign-on"](/images/auth/examples/microsoft-entra-id-saml/entra-id-select-single-sign-on.png)

Then select **SAML**

![Entra ID enterprise application single sign-on setup highlighting "SAML"](/images/auth/examples/microsoft-entra-id-saml/entra-id-select-saml.png)

You will be directed to a page to set up single sign-on with SAML, which needs a few pieces of information from your Amplify Auth resource.

![Entra ID set up single sign-on page with a form requiring an entity ID and reply URL](/images/auth/examples/microsoft-entra-id-saml/entra-id-set-up-saml.png)

In the **Basic SAML Configuration** step, select **Edit** and populate with the appropriate values.

| Label | Value |
|-------|-------|
| Identifier (Entity ID) | `urn:amazon:cognito:sp:<your-cognito-user-pool-id>` |
| Reply URL (Assertion Consumer Service URL) | `https://<your-cognito-domain>/saml2/idpresponse` |
| Logout Url (Optional) | `https://<your-cognito-domain>/saml2/logout` |

<Callout info>

**Note:** Amazon Cognito redirect URIs for SAML providers follow the convention:

```text showLineNumbers={false}
https://<some-hash>.auth.<aws-region>.amazoncognito.com/saml2/<action>
```

If you are using a custom domain the route remains the same: `/saml2/<action>`. [Learn more about configuring Amazon Cognito with SAML identity providers](https://docs.aws.amazon.com/cognito/latest/developerguide/cognito-user-pools-saml-idp.html)

</Callout>

<Callout warning>

**Warning:** there is a known limitation where upstream sign-out functionality successfully signs out of Entra ID, but fails to redirect back to the user app. This behavior is disabled by default with SAML integrations in Amplify Auth.

</Callout>

Save the configuration and proceed to Step 3's **SAML Certificates** section. Copy the **App Federation Metadata Url**

![Entra ID set up single sign-on page highlighting the app federation metadata URL](/images/auth/examples/microsoft-entra-id-saml/entra-id-copy-federation-url.png)

## Configure your backend with Entra ID

Now that you've configured your SAML provider with Microsoft Entra ID and copied the **App Federation Metadata Url**, configure your auth resource with the new SAML provider and paste the URL value into the `metadataContent` property:

```ts title="amplify/auth/resource.ts"
import { defineAuth } from "@aws-amplify/backend"

/**
 * Define and configure your auth resource
 * @see https://docs.amplify.aws/gen2/build-a-backend/auth
 */
export const auth = defineAuth({
  loginWith: {
    email: true,
    externalProviders: {
      saml: {
        name: "MicrosoftEntraIDSAML",
        metadata: {
          metadataType: "URL",
          metadataContent: "<your-metadata-content-url>",
        },
        attributeMapping: {
          email: "http://schemas.xmlsoap.org/ws/2005/05/identity/claims/emailaddress",
        },
      },
      logoutUrls: ["http://localhost:3000/come-back-soon"],
      callbackUrls: ["http://localhost:3000/profile"],
    },
  },
})
```

User attributes can be found in Step 2's **Attributes & Claims** section, and are prefixed with a namespace by default. The example above shows mapping the default claim for the SAML user's email address, however additional attributes can be mapped.

## Optionally upload the Cognito Signing Certificate

In the AWS Console, navigate to your Cognito User Pool. Select the identity provider, **MicrosoftEntraIDSAML**, created after configuring Amplify Auth with the Entra ID SAML provider. Select **View signing certificate** and **download as .crt**

![Amazon Cognito console highlighting "view signing certificate" for SAML provider](/images/auth/examples/microsoft-entra-id-saml/cognito-view-signing-certificate.png)

Rename the file extension to `.cer` in order to upload to Azure. On the **Single sign-on** page, scroll down to **Step 3** (**SAML Certificates**), and under **Verification Certificates (optional)**, select **Edit**.

![Entra ID single sign-on page highlighting "edit" for verification certificates](/images/auth/examples/microsoft-entra-id-saml/entra-id-edit-verification-certificate.png)

Select **Require verification certificates** and upload the certificate.

![Entra ID verification certificate upload pane](/images/auth/examples/microsoft-entra-id-saml/entra-id-upload-verification-certificate.png)

Save your changes, and now requests to Entra ID from your Cognito User Pool will be verified.

## Connect your frontend

Now your users are ready to sign in with Microsoft Entra ID. To sign in with this custom provider, specify the provider name as the name specified in your auth resource definition: `MicrosoftEntraIDSAML`

<InlineFilter filters={["angular", "javascript", "nextjs", "react", "react-native", "vue"]}>

```ts title="main.ts"
import { signInWithRedirect } from "aws-amplify/auth"

signInWithRedirect({
  provider: { custom: "MicrosoftEntraIDSAML" }
})
```

</InlineFilter>
<InlineFilter filters={["android"]}>

<BlockSwitcher>
<Block name="Java">

```java
Amplify.Auth.signInWithSocialWebUI(
    AuthProvider.custom("MicrosoftEntraIDSAML")
    this,
    result -> Log.i("AuthQuickStart", result.toString()),
    error -> Log.e("AuthQuickStart", error.toString())
);
```

</Block>
<Block name="Kotlin - Callbacks">

```kotlin
Amplify.Auth.signInWithSocialWebUI(
    AuthProvider.custom("MicrosoftEntraIDSAML"),
    this,
    { Log.i("AuthQuickstart", "Sign in OK: $it") },
    { Log.e("AuthQuickstart", "Sign in failed", it) }
)
```

</Block>
<Block name="Kotlin - Coroutines">

```kotlin
try {
    val result = Amplify.Auth.signInWithSocialWebUI(AuthProvider.custom("MicrosoftEntraIDSAML"), this)
    Log.i("AuthQuickstart", "Sign in OK: $result")
} catch (error: AuthException) {
    Log.e("AuthQuickstart", "Sign in failed", error)
}
```

</Block>
<Block name="RxJava">

```java
RxAmplify.Auth.signInWithSocialWebUI(AuthProvider.custom("MicrosoftEntraIDSAML"), this)
    .subscribe(
        result -> Log.i("AuthQuickstart", result.toString()),
        error -> Log.e("AuthQuickstart", error.toString())
    );
```

</Block>
</BlockSwitcher>

</InlineFilter>
<InlineFilter filters={["flutter"]}>

```dart
Future<void> signInWithMicrosoftEntraID() async {
  try {
    final result = await Amplify.Auth.signInWithWebUI(
      provider: AuthProvider.custom("MicrosoftEntraIDSAML"),
    );
    safePrint('Sign in result: $result');
  } on AuthException catch (e) {
    safePrint('Error signing in: ${e.message}');
  }
}
```

</InlineFilter>
<InlineFilter filters={["swift"]}>

<BlockSwitcher>
<Block name="Async/Await">

```swift
func signInWithMicrosoftEntraID() async {
    do {
        let signInResult = try await Amplify.Auth.signInWithWebUI(
            for: AuthProvider.custom("MicrosoftEntraIDSAML"),
            presentationAnchor: self.view.window!
        )
        if signInResult.isSignedIn {
            print("Sign in succeeded")
        }
    } catch let error as AuthError {
        print("Sign in failed \(error)")
    } catch {
        print("Unexpected error: \(error)")
    }
}
```

</Block>
<Block name="Combine">

```swift
func signInWithMicrosoftEntraID() -> AnyCancellable {
    Amplify.Publisher.create {
        try await Amplify.Auth.signInWithWebUI(
            for: AuthProvider.custom("MicrosoftEntraIDSAML"),
            presentationAnchor: self.view.window!
        )
    }
    .sink { completion in
        if case let .failure(authError) = completion {
            print("Sign in failed \(authError)")
        }
    } receiveValue: { signInResult in
        if signInResult.isSignedIn {
            print("Sign in succeeded")
        }
    }
}
```

</Block>
</BlockSwitcher>

</InlineFilter>


Contents of build-a-backend_auth_grant-access-to-auth-resources_index.txt:
import { getCustomStaticPath } from '@/utils/getCustomStaticPath';

export const meta = {
  title: 'Grant access to auth resources',
  description: 'Learn how to grant access to auth resources',
  platforms: [
    'android',
    'angular',
    'flutter',
    'javascript',
    'nextjs',
    'react',
    'react-native',
    'swift',
    'vue'
  ]
};

export function getStaticPaths() {
  return getCustomStaticPath(meta.platforms);
}

export function getStaticProps() {
  return {
    props: {
      meta
    }
  };
}

Amplify Auth can be defined with an `access` property, which allows other resources to interact with auth by specifying actions.

```ts title="amplify/auth/resource.ts"
import { defineAuth } from "@aws-amplify/backend"
import { addUserToGroup } from "../functions/add-user-to-group/resource"

/**
 * Define and configure your auth resource
 * @see https://docs.amplify.aws/gen2/build-a-backend/auth
 */
export const auth = defineAuth({
  loginWith: {
    email: true,
  },
  access: (allow) => [
    allow.resource(addUserToGroup).to(["addUserToGroup"])
  ],
})
```

<Callout>

When you grant a function access to another resource in your Amplify backend it will configure environment variables for that function to make SDK calls to the AWS services it has access to. Those environment variables are typed and available as part of the `env` object.

</Callout>

## List of actions

|Action Name|Description|Cognito IAM Actions|
|-|-|-|
|manageUsers | Grants CRUD access to users in the UserPool | <ul><li>cognito-idp:AdminConfirmSignUp</li><li>cognito-idp:AdminCreateUser</li><li>cognito-idp:AdminDeleteUser</li><li>cognito-idp:AdminDeleteUserAttributes</li><li>cognito-idp:AdminDisableUser</li><li>cognito-idp:AdminEnableUser</li><li>cognito-idp:AdminGetUser</li><li>cognito-idp:AdminListGroupsForUser</li><li>cognito-idp:AdminRespondToAuthChallenge</li><li>cognito-idp:AdminSetUserMFAPreference</li><li>cognito-idp:AdminSetUserSettings</li><li>cognito-idp:AdminUpdateUserAttributes</li><li>cognito-idp:AdminUserGlobalSignOut</li></ul>|
|manageGroupMembership | Grants permission to add and remove users from groups | <ul><li>cognito-idp:AdminAddUserToGroup</li><li>cognito-idp:AdminRemoveUserFromGroup</li></ul>|
|manageGroups | Grants CRUD access to groups in the UserPool | <ul><li>cognito-idp:GetGroup</li><li>cognito-idp:ListGroups</li><li>cognito-idp:CreateGroup</li><li>cognito-idp:DeleteGroup</li><li>cognito-idp:UpdateGroup</li></ul>|
|manageUserDevices | Manages devices registered to users| <ul><li>cognito-idp:AdminForgetDevice</li><li>cognito-idp:AdminGetDevice</li><li>cognito-idp:AdminListDevices</li><li>cognito-idp:AdminUpdateDeviceStatus</li></ul>|
|managePasswordRecovery | Grants permission to reset user passwords | <ul><li>cognito-idp:AdminResetUserPassword</li><li>cognito-idp:AdminSetUserPassword</li></ul>| 
|addUserToGroup | Grants permission to add any user to any group. | <ul><li>cognito-idp:AdminAddUserToGroup</li></ul>
|createUser | Grants permission to create new users and send welcome messages via email or SMS. | <ul><li>cognito-idp:AdminCreateUser</li></ul>
|deleteUser | Grants permission to delete any user | <ul><li>cognito-idp:AdminDeleteUser</li></ul>
|deleteUserAttributes | Grants permission to delete attributes from any user | <ul><li>cognito-idp:AdminDeleteUserAttributes</li></ul>
|disableUser | Grants permission to deactivate any user | <ul><li>cognito-idp:AdminDisableUser</li></ul>
|enableUser | Grants permission to activate any user | <ul><li>cognito-idp:AdminEnableUser</li></ul>
|forgetDevice | Grants permission to deregister any user's devices | <ul><li>cognito-idp:AdminForgetDevice</li></ul>
|getDevice | Grants permission to get information about any user's devices | <ul><li>cognito-idp:AdminGetDevice</li></ul>
|getUser | Grants permission to look up any user by user name | <ul><li>cognito-idp:AdminGetUser</li></ul>
|listUsers | Grants permission to list users and their basic details in the UserPool | <ul><li>cognito-idp:ListUsers</li></ul>
|listDevices | Grants permission to list any user's remembered devices | <ul><li>cognito-idp:AdminListDevices</li></ul>
|listGroupsForUser | Grants permission to list the groups that any user belongs to | <ul><li>cognito-idp:AdminListGroupsForUser</li></ul>
|listUsersInGroup | Grants permission to list users in the specified group | <ul><li>cognito-idp:ListUsersInGroup</li></ul>
|removeUserFromGroup | Grants permission to remove any user from any group | <ul><li>cognito-idp:AdminRemoveUserFromGroup</li></ul>
|resetUserPassword | Grants permission to reset any user's password | <ul><li>cognito-idp:AdminResetUserPassword</li></ul>
|setUserMfaPreference | Grants permission to set any user's preferred MFA method | <ul><li>cognito-idp:AdminSetUserMFAPreference</li></ul>
|setUserPassword | Grants permission to set any user's password | <ul><li>cognito-idp:AdminSetUserPassword</li></ul>
|setUserSettings | Grants permission to set user settings for any user | <ul><li>cognito-idp:AdminSetUserSettings</li></ul>
|updateDeviceStatus | Grants permission to update the status of any user's remembered devices | <ul><li>cognito-idp:AdminUpdateDeviceStatus</li></ul>
|updateUserAttributes | Grants permission to updates any user's standard or custom attributes | <ul><li>cognito-idp:AdminUpdateUserAttributes</li></ul>


Contents of build-a-backend_auth_index.txt:
import { getChildPageNodes } from '@/utils/getChildPageNodes';
import { getCustomStaticPath } from '@/utils/getCustomStaticPath';

export const meta = {
  title: 'Authentication',
  description: 'Learn about the authentication capabilities of AWS Amplify.',
  route: '/[platform]/build-a-backend/auth',
  platforms: [
    'android',
    'angular',
    'flutter',
    'javascript',
    'nextjs',
    'react',
    'react-native',
    'swift',
    'vue'
  ]
};

export async function getStaticPaths() {
  return getCustomStaticPath(meta.platforms);
}

export function getStaticProps() {
  const childPageNodes = getChildPageNodes(meta.route);
  return {
    props: {
      meta,
      childPageNodes
    }
  };
}

<Overview childPageNodes={props.childPageNodes} />


Contents of build-a-backend_auth_manage-users_index.txt:
import { getChildPageNodes } from '@/utils/getChildPageNodes';
import { getCustomStaticPath } from '@/utils/getCustomStaticPath';

export const meta = {
  title: 'Manage users',
  description: 'Learn how to manage users',
  route: '/[platform]/build-a-backend/auth/manage-users',
  platforms: [
    'android',
    'angular',
    'flutter',
    'javascript',
    'nextjs',
    'react',
    'react-native',
    'swift',
    'vue'
  ]
};

export function getStaticPaths() {
  return getCustomStaticPath(meta.platforms);
}

export function getStaticProps() {
  const childPageNodes = getChildPageNodes(meta.route);
  return {
    props: {
      meta,
      childPageNodes
    }
  };
}

{/* console experience */}
{/* admin queries/actions */}
{/* user devices/device management */}

<Overview childPageNodes={props.childPageNodes} />


Contents of build-a-backend_auth_manage-users_manage-devices_index.txt:
import { getCustomStaticPath } from '@/utils/getCustomStaticPath';

export const meta = {
  title: 'Manage devices',
  description: 'Learn how to manage user devices',
  platforms: [
    'android',
    'angular',
    'flutter',
    'javascript',
    'nextjs',
    'react',
    'react-native',
    'swift',
    'vue'
  ]
};

export function getStaticPaths() {
  return getCustomStaticPath(meta.platforms);
}

export function getStaticProps() {
  return {
    props: {
      meta,
    }
  };
}

Amplify Auth enables you to track devices your users use for auditing, MFA, and more. Before you begin it is important to understand the terminology for device statuses:

- **Tracked:** Every time the user signs in with a new device, the client is given the device key at the end of a successful authentication event. We use this device key to generate a salt and password verifier which is used to call the ConfirmDevice API. At this point, the device is considered to be _tracked_. Once the device is in a tracked state, you can use the Amazon Cognito console to see the time it started to be tracked, last authentication time, and other information about that device.
- **Remembered:** Remembered devices are also tracked. During user authentication, the device key and secret pair assigned to a remembered device is used to authenticate the device to verify that it is the same device that the user previously used to sign in.
- **Not Remembered:** A not-remembered device is a tracked device where Cognito has been configured to require users to "Opt-in" to remember a device, but the user has not opt-ed in to having the device remembered. This use case is used for users signing into their application from a device that they don't own.
- **Forgotten:** a forgotten device is one removed from being remembered

<Callout info>

**Note:** [device tracking and remembering](https://aws.amazon.com/blogs/mobile/tracking-and-remembering-devices-using-amazon-cognito-your-user-pools/) features are not available when using federating sign-in with external providers as devices are tracked on the upstream identity provider. These features are also not available when using Cognito's Hosted UI.

</Callout>

## Remember devices

You can remember devices using the following:

<InlineFilter filters={["angular", "javascript", "nextjs", "react", "react-native", "vue"]}>

```ts
import { rememberDevice } from 'aws-amplify/auth';

await rememberDevice();
```

</InlineFilter>
<InlineFilter filters={["flutter"]}>

```dart
Future<void> rememberCurrentDevice() async {
  try {
    await Amplify.Auth.rememberDevice();
    safePrint('Remember device succeeded');
  } on AuthException catch (e) {
    safePrint('Remember device failed with error: $e');
  }
}
```

</InlineFilter>
<InlineFilter filters={["android"]}>

<BlockSwitcher>
<Block name="Java">

```java
Amplify.Auth.rememberDevice(
    () -> Log.i("AuthQuickStart", "Remember device succeeded"),
    error -> Log.e("AuthQuickStart", "Remember device failed with error " + error.toString())
);
```

</Block>
<Block name="Kotlin - Callbacks">

```kotlin
Amplify.Auth.rememberDevice(
    { Log.i("AuthQuickStart", "Remember device succeeded") },
    { Log.e("AuthQuickStart", "Remember device failed with error", it) }
)
```

</Block>
<Block name="Kotlin - Coroutines">

```kotlin
try {
    Amplify.Auth.rememberDevice()
    Log.i("AuthQuickStart", "Remember device succeeded")
} catch (error: AuthException) {
    Log.e("AuthQuickStart", "Remember device failed with error", error)
}
```

</Block>
<Block name="RxJava">

```java
RxAmplify.Auth.rememberDevice()
    .subscribe(
      () -> Log.i("AuthQuickStart", "Remember device succeeded"),
      error -> Log.e("AuthQuickStart", "Remember device failed with error " + error.toString())
    );
```

</Block>
</BlockSwitcher>

</InlineFilter>
<InlineFilter filters={["swift"]}>

<BlockSwitcher>
<Block name="Async/Await">

```swift
func rememberDevice() async {
    do {
        try await Amplify.Auth.rememberDevice()
        print("Remember device succeeded")
    } catch let error as AuthError {
        print("Remember device failed with error \(error)")
    } catch {
        print("Unexpected error: \(error)")
    }
}
```

</Block>
<Block name="Combine">

```swift
func rememberDevice() -> AnyCancellable {
    Amplify.Publisher.create {
        try await Amplify.Auth.rememberDevice()
    }.sink {
            if case let .failure(authError) = $0 {
                print("Remember device failed with error \(authError)")
            }
        }
        receiveValue: {
            print("Remember device succeeded")
        }
}
```

</Block>
</BlockSwitcher>

</InlineFilter>

## Forget devices

You can also forget devices but note that forgotten devices are neither remembered nor tracked.

<InlineFilter filters={["angular", "javascript", "nextjs", "react", "react-native", "vue"]}>

```ts
import { forgetDevice } from 'aws-amplify/auth';

await forgetDevice();
```

</InlineFilter>
<InlineFilter filters={["flutter"]}>

<BlockSwitcher>
<Block name="Current Device">

```dart
Future<void> forgetCurrentDevice() async {
  try {
    await Amplify.Auth.forgetDevice();
    safePrint('Forget device succeeded');
  } on AuthException catch (e) {
    safePrint('Forget device failed with error: $e');
  }
}
```

</Block>
<Block name="Specific Device">

```dart
// A device that was fetched via Amplify.Auth.fetchDevices()
Future<void> forgetSpecificDevice(AuthDevice myDevice) async {
  try {
    await Amplify.Auth.forgetDevice(myDevice);
    safePrint('Forget device succeeded');
  } on AuthException catch (e) {
    safePrint('Forget device failed with error: $e');
  }
}
```

</Block>
</BlockSwitcher>

</InlineFilter>
<InlineFilter filters={["android"]}>

<BlockSwitcher>
<Block name="Java">

```java
Amplify.Auth.forgetDevice(
    () -> Log.i("AuthQuickStart", "Forget device succeeded"),
    error -> Log.e("AuthQuickStart", "Forget device failed with error " + error.toString())
);
```

</Block>
<Block name="Kotlin - Callbacks">

```kotlin
Amplify.Auth.forgetDevice(
    { Log.i("AuthQuickStart", "Forget device succeeded") },
    { Log.e("AuthQuickStart", "Forget device failed with error", it) }
)
```

</Block>
<Block name="Kotlin - Coroutines">

```kotlin
try {
    Amplify.Auth.forgetDevice()
    Log.i("AuthQuickStart", "Forget device succeeded")
} catch (error: AuthException) {
    Log.e("AuthQuickStart", "Forget device failed with error", error)
}
```

</Block>
<Block name="RxJava">

```java
RxAmplify.Auth.forgetDevice()
    .subscribe(
      () -> Log.i("AuthQuickStart", "Forget device succeeded"),
      error -> Log.e("AuthQuickStart", "Forget device failed with error " + error.toString())
    );
```

</Block>
</BlockSwitcher>

</InlineFilter>
<InlineFilter filters={["swift"]}>

<BlockSwitcher>

<Block name="Async/Await">

```swift
func forgetDevice() async {
    do {
        try await Amplify.Auth.forgetDevice()
        print("Forget device succeeded")
    } catch let error as AuthError {
        print("Forget device failed with error \(error)")
    } catch {
        print("Unexpected error: \(error)")
    }
}
```

</Block>
<Block name="Combine">

```swift
func forgetDevice() -> AnyCancellable {
    Amplify.Publisher.create {
        try await Amplify.Auth.forgetDevice()
    }.sink {
        if case let .failure(authError) = $0 {
            print("Forget device failed with error \(authError)")
        }
    }
    receiveValue: {
        print("Forget device succeeded")
    }
}
```

</Block>
</BlockSwitcher>

</InlineFilter>

## Fetch devices

You can fetch a list of remembered devices by using the following:

<InlineFilter filters={["angular", "javascript", "nextjs", "react", "react-native", "vue"]}>

```ts
import { fetchDevices } from 'aws-amplify/auth';

const output = await fetchDevices();
```

</InlineFilter>
<InlineFilter filters={["flutter"]}>

```dart
Future<void> fetchAllDevices() async {
  try {
    final devices = await Amplify.Auth.fetchDevices();
    for (final device in devices) {
      safePrint('Device: $device');
    }
  } on AuthException catch (e) {
    safePrint('Fetch devices failed with error: $e');
  }
}
```

</InlineFilter>


<InlineFilter filters={["android"]}>

<BlockSwitcher>
<Block name="Java">

```java
Amplify.Auth.fetchDevices(
    devices -> {
        for (AuthDevice device : devices) {
            Log.i("AuthQuickStart", "Device: " + device);
        }
    },
    error -> Log.e("AuthQuickStart", "Fetch devices failed with error: " + error.toString()));
```

</Block>
<Block name="Kotlin - Callbacks">

```kotlin
Amplify.Auth.fetchDevices(
    { devices ->
        devices.forEach { Log.i("AuthQuickStart", "Device: " + it) }
    },
    { Log.e("AuthQuickStart", "Fetch devices failed with error", it) }
)
```

</Block>
<Block name="Kotlin - Coroutines">

```kotlin
try {
    Amplify.Auth.fetchDevices().forEach { device ->
        Log.i("AuthQuickStart", "Device: $device")
    }
} catch (error: AuthException) {
    Log.e("AuthQuickStart",  "Fetch devices failed with error", error)
}
```

</Block>
<Block name="RxJava">

```java
RxAmplify.Auth.fetchDevices()
    .subscribe(
        device -> Log.i("AuthQuickStart", "Device: " + device);
        error -> Log.e("AuthQuickStart", "Fetch devices failed with error: " + error.toString())
    );
```

</Block>
</BlockSwitcher>

</InlineFilter>
<InlineFilter filters={["swift"]}>

<BlockSwitcher>
<Block name="Async/Await">

```swift
func fetchDevices() async {
    do {
        let fetchDeviceResult = try await Amplify.Auth.fetchDevices()
        for device in fetchDeviceResult {
            print(device.id)
        }
    } catch let error as AuthError {
        print("Fetch devices failed with error \(error)")
    } catch {
        print("Unexpected error: \(error)")
    }
}
```

</Block>
<Block name="Combine">

```swift
func fetchDevices() -> AnyCancellable {
    Amplify.Publisher.create {
        try await Amplify.Auth.fetchDevices()
    }.sink {
        if case let .failure(authError) = $0 {
            print("Fetch devices failed with error \(authError)")
        }
    }
    receiveValue: { fetchDeviceResult in
        for device in fetchDeviceResult {
            print(device.id)
        }
    }
}
```

</Block>
</BlockSwitcher>

</InlineFilter>

<InlineFilter filters={["flutter"]}>

## Fetch the current device

You can fetch the current device by using the following:

```dart
Future<void> fetchCurrentUserDevice() async {
  try {
    final device = await Amplify.Auth.fetchCurrentDevice();
    safePrint('Device: $device');
  } on AuthException catch (e) {
    safePrint('Get current device failed with error: $e');
  }
}
```

</InlineFilter>

You can now set up devices to be remembered, forgotten, and fetched.

{/* user agents */}


Contents of build-a-backend_auth_manage-users_manage-passwords_index.txt:
import { getCustomStaticPath } from '@/utils/getCustomStaticPath';

export const meta = {
  title: 'Manage passwords',
  description: 'Learn how to manage user passwords',
  platforms: [
    'android',
    'angular',
    'flutter',
    'javascript',
    'nextjs',
    'react',
    'react-native',
    'swift',
    'vue'
  ]
};

export function getStaticPaths() {
  return getCustomStaticPath(meta.platforms);
}

export function getStaticProps() {
  return {
    props: {
      meta,
    }
  };
}

Amplify Auth provides a secure way for your users to change their password or recover a forgotten password.

## Understand password default settings

By default, your users can retrieve access to their accounts if they forgot their password by using either their phone or email. The following are the default account recovery methods used when either `phone` or `email` are used as login options.

| Login option        | User account verification channel |
| ------------------- | --------------------------------- |
| `phone`             | Phone Number                      |
| `email`             | Email                             |
| `email` and `phone` | Email                             |

{/* ## Reset password */}
## Reset Password

To reset a user's password, use the `resetPassword` API which will send a reset code to the destination (e.g. email or SMS) based on the user's settings.

<InlineFilter filters={["angular", "javascript", "nextjs", "react", "react-native", "vue"]}>

```ts
import { resetPassword } from 'aws-amplify/auth';

const output = await resetPassword({
  username: "hello@mycompany.com"
});

const { nextStep } = output;
switch (nextStep.resetPasswordStep) {
  case 'CONFIRM_RESET_PASSWORD_WITH_CODE':
    const codeDeliveryDetails = nextStep.codeDeliveryDetails;
    console.log(
      `Confirmation code was sent to ${codeDeliveryDetails.deliveryMedium}`
    );
    // Collect the confirmation code from the user and pass to confirmResetPassword.
    break;
  case 'DONE':
    console.log('Successfully reset password.');
    break;
}
```

</InlineFilter>
<InlineFilter filters={["flutter"]}>

```dart
Future<void> resetPassword(String username) async {
  try {
    final result = await Amplify.Auth.resetPassword(
      username: username,
    );
    await _handleResetPasswordResult(result);
  } on AuthException catch (e) {
    safePrint('Error resetting password: ${e.message}');
  }
}
```

```dart
Future<void> _handleResetPasswordResult(ResetPasswordResult result) async {
  switch (result.nextStep.updateStep) {
    case AuthResetPasswordStep.confirmResetPasswordWithCode:
      final codeDeliveryDetails = result.nextStep.codeDeliveryDetails!;
      _handleCodeDelivery(codeDeliveryDetails);
      break;
    case AuthResetPasswordStep.done:
      safePrint('Successfully reset password');
      break;
  }
}
```

</InlineFilter>
<InlineFilter filters={["android"]}>

<BlockSwitcher>
<Block name="Java">

```java
Amplify.Auth.resetPassword(
   "username",
   result -> Log.i("AuthQuickstart", result.toString()),
   error -> Log.e("AuthQuickstart", error.toString())
);
```

</Block>
<Block name="Kotlin - Callbacks">

```kotlin
Amplify.Auth.resetPassword("username",
    { Log.i("AuthQuickstart", "Password reset OK: $it") },
    { Log.e("AuthQuickstart", "Password reset failed", it) }
)
```

</Block>
<Block name="Kotlin - Coroutines">

```kotlin
try {
    val result = Amplify.Auth.resetPassword("username")
    Log.i("AuthQuickstart", "Password reset OK: $result")
} catch (error: AuthException) {
    Log.e("AuthQuickstart", "Password reset failed", error)
}
```

</Block>
<Block name="RxJava">

```java
RxAmplify.Auth.resetPassword("username")
    .subscribe(
        result -> Log.i("AuthQuickstart", result.toString()),
        error -> Log.e("AuthQuickstart", error.toString())
    );
```

</Block>
</BlockSwitcher>

</InlineFilter>
<InlineFilter filters={["swift"]}>

<BlockSwitcher>
<Block name="Async/Await">

```swift
func resetPassword(username: String) async {
    do {
        let resetResult = try await Amplify.Auth.resetPassword(for: username)
        switch resetResult.nextStep {
            case .confirmResetPasswordWithCode(let deliveryDetails, let info):
                print("Confirm reset password with code send to - \(deliveryDetails) \(String(describing: info))")
            case .done:
                print("Reset completed")
        }
    } catch let error as AuthError {
        print("Reset password failed with error \(error)")
    } catch {
        print("Unexpected error: \(error)")
    }
}
```

</Block>
<Block name="Combine">

```swift
func resetPassword(username: String) -> AnyCancellable {
    Amplify.Publisher.create {
            try await Amplify.Auth.resetPassword(for: username)
        }.sink {
            if case let .failure(authError) = $0 {
                print("Reset password failed with error \(authError)")
            }
        }
        receiveValue: { resetResult in
            switch resetResult.nextStep {
            case .confirmResetPasswordWithCode(let deliveryDetails, let info):
                print("Confirm reset password with code send to - \(deliveryDetails) \(String(describing: info))")
            case .done:
                print("Reset completed")
            }
        }
}
```

</Block>
</BlockSwitcher>

Usually, resetting the password require you to verify that it is the actual user that tried to reset the password. The next step above will be `.confirmResetPasswordWithCode`.

If you would like to display a more specific view or messaging to your users based the error that occurred, you can handle this by downcasting the `underlyingError` to `AWSCognitoAuthError`.

```swift
if let authError = error as? AuthError,
    let cognitoAuthError = authError.underlyingError as? AWSCognitoAuthError {
    switch cognitoAuthError {
    case .userNotFound:
        print("User not found")
    case .invalidParameter:
        print("Invalid Parameter)
    default:
        break
    }
}
```

</InlineFilter>


To complete the password reset process, invoke the `confirmResetPassword` API with the code your user received and the new password they want to set.

<InlineFilter filters={["angular", "javascript", "nextjs", "react", "react-native", "vue"]}>

```ts
import { confirmResetPassword } from 'aws-amplify/auth';

await confirmResetPassword({
  username: "hello@mycompany.com",
  confirmationCode: "123456",
  newPassword: "hunter3",
});
```

</InlineFilter>
<InlineFilter filters={["flutter"]}>

```dart
Future<void> confirmResetPassword({
  required String username,
  required String newPassword,
  required String confirmationCode,
}) async {
  try {
    final result = await Amplify.Auth.confirmResetPassword(
      username: username,
      newPassword: newPassword,
      confirmationCode: confirmationCode,
    );
    safePrint('Password reset complete: ${result.isPasswordReset}');
  } on AuthException catch (e) {
    safePrint('Error resetting password: ${e.message}');
  }
}
```

</InlineFilter>
<InlineFilter filters={["android"]}>

<BlockSwitcher>
<Block name="Java">

```java
Amplify.Auth.confirmResetPassword(
   "Username",
   "NewPassword123",
   "confirmation code you received",
   () -> Log.i("AuthQuickstart", "New password confirmed"),
   error -> Log.e("AuthQuickstart", error.toString())
);
```

</Block>
<Block name="Kotlin - Callbacks">

```kotlin
Amplify.Auth.confirmResetPassword("Username", "NewPassword123", "confirmation code",
   { Log.i("AuthQuickstart", "New password confirmed") },
   { Log.e("AuthQuickstart", "Failed to confirm password reset", it) }
)
```

</Block>
<Block name="Kotlin - Coroutines">

```kotlin
try {
    Amplify.Auth.confirmResetPassword("Username", "NewPassword123", "code you received")
    Log.i("AuthQuickstart", "New password confirmed")
} catch (error: AuthException) {
    Log.e("AuthQuickstart", "Failed to confirm password reset", error)
}
```
</Block>
<Block name="RxJava">

```java
RxAmplify.Auth.confirmResetPassword("Username","NewPassword123", "confirmation code")
    .subscribe(
        () -> Log.i("AuthQuickstart", "New password confirmed"),
        error -> Log.e("AuthQuickstart", error.toString())
    );
```

</Block>
</BlockSwitcher>

</InlineFilter>
<InlineFilter filters={["swift"]}>

<BlockSwitcher>
<Block name="Async/Await">

```swift
func confirmResetPassword(
    username: String,
    newPassword: String,
    confirmationCode: String
) async {
    do {
        try await Amplify.Auth.confirmResetPassword(
            for: username,
            with: newPassword,
            confirmationCode: confirmationCode
        )
        print("Password reset confirmed")
    } catch let error as AuthError {
        print("Reset password failed with error \(error)")
    } catch {
        print("Unexpected error: \(error)")
    }
}
```

</Block>
<Block name="Combine">

```swift
func confirmResetPassword(
    username: String,
    newPassword: String,
    confirmationCode: String
) -> AnyCancellable {
    Amplify.Publisher.create {
        try await Amplify.Auth.confirmResetPassword(
            for: username,
            with: newPassword,
            confirmationCode: confirmationCode
        )
    }.sink {
        if case let .failure(authError) = $0 {
            print("Reset password failed with error \(authError)")
        }
    }
    receiveValue: {
        print("Password reset confirmed")
    }
}
```

</Block>
</BlockSwitcher>

</InlineFilter>


## Update password

You can update a signed in user's password using the `updatePassword` API.

<InlineFilter filters={["angular", "javascript", "nextjs", "react", "react-native", "vue"]}>

```ts
import { updatePassword } from 'aws-amplify/auth';

await updatePassword({
  oldPassword: "hunter2",
  newPassword: "hunter3",
});
```

</InlineFilter>
<InlineFilter filters={["flutter"]}>

```dart
Future<void> updatePassword({
  required String oldPassword,
  required String newPassword,
}) async {
  try {
    await Amplify.Auth.updatePassword(
      oldPassword: oldPassword,
      newPassword: newPassword,
    );
  } on AuthException catch (e) {
    safePrint('Error updating password: ${e.message}');
  }
}
```

</InlineFilter>
<InlineFilter filters={["android"]}>

<BlockSwitcher>
<Block name="Java">

```java
Amplify.Auth.updatePassword(
    "existingPassword",
    "newPassword",
    () -> Log.i("AuthQuickstart", "Updated password successfully"),
    error -> Log.e("AuthQuickstart", error.toString())
);
```

</Block>
<Block name="Kotlin - Callbacks">

```kotlin
Amplify.Auth.updatePassword("existingPassword", "newPassword",
    { Log.i("AuthQuickstart", "Updated password successfully") },
    { Log.e("AuthQuickstart", "Password update failed", it) }
)
```

</Block>
<Block name="Kotlin - Coroutines">

```kotlin
try {
    Amplify.Auth.updatePassword("existingPassword", "newPassword")
    Log.i("AuthQuickstart", "Updated password successfully")
} catch (error: AuthException) {
    Log.e("AuthQuickstart", "Password update failed", error)
}
```

</Block>
<Block name="RxJava">

```java
RxAmplify.Auth.updatePassword("existingPassword", "newPassword")
    .subscribe(
        () -> Log.i("AuthQuickstart", "Updated password successfully"),
        error -> Log.e("AuthQuickstart", error.toString())
    );
```

</Block>
</BlockSwitcher>

</InlineFilter>
<InlineFilter filters={["swift"]}>

<BlockSwitcher>
<Block name="Async/Await">

```swift
func changePassword(oldPassword: String, newPassword: String) async {
    do {
        try await Amplify.Auth.update(oldPassword: oldPassword, to: newPassword)
        print("Change password succeeded")
    } catch let error as AuthError {
        print("Change password failed with error \(error)")
    } catch {
        print("Unexpected error: \(error)")
    }
}
```

</Block>
<Block name="Combine">

```swift
func changePassword(oldPassword: String, newPassword: String) -> AnyCancellable {
    Amplify.Publisher.create {
            try await Amplify.Auth.update(oldPassword: oldPassword, to: newPassword)
        }.sink {
            if case let .failure(authError) = $0 {
                print("Change password failed with error \(authError)")
            }
        }
        receiveValue: {
            print("Change password succeeded")
        }
}
```

</Block>
</BlockSwitcher>

</InlineFilter>

### Override default user account verification channel

You can always change the channel used by your authentication resources by overriding the following setting.

```ts title="amplify/auth/resource.ts"
import { defineAuth } from '@aws-amplify/backend';

export const auth = defineAuth({
  loginWith: {
    email: true
  },
// highlight-start
  accountRecovery: 'EMAIL_ONLY'
// highlight-end
});
```

## Override default password policy

By default your password policy is set to the following:

- `MinLength`: 8 characters
- `requireLowercase`: true
- `requireUppercase`: true
- `requireNumbers`: true
- `requireSymbols`: true
- `tempPasswordValidity`: 3 days

You can customize the password format acceptable by your auth resource by modifying the underlying `cfnUserPool` resource:

```ts title="amplify/backend.ts"
import { defineBackend } from '@aws-amplify/backend';
import { auth } from './auth/resource';

const backend = defineBackend({
  auth,
});
// extract L1 CfnUserPool resources
const { cfnUserPool } = backend.auth.resources.cfnResources;
// modify cfnUserPool policies directly
cfnUserPool.policies = {
  passwordPolicy: {
    minimumLength: 32,
    requireLowercase: true,
    requireNumbers: true,
    requireSymbols: true,
    requireUppercase: true,
    temporaryPasswordValidityDays: 20,
  },
};
```


Contents of build-a-backend_auth_manage-users_manage-webauthn-credentials_index.txt:
import { getCustomStaticPath } from '@/utils/getCustomStaticPath';

export const meta = {
  title: 'Manage WebAuthn credentials',
  description: 'Learn how to manage WebAuthn credentials',
  platforms: [
    'android',
    'angular',
    'javascript',
    'nextjs',
    'react',
    'react-native',
    'swift',
    'vue'
  ]
};

export function getStaticPaths() {
  return getCustomStaticPath(meta.platforms);
}

export function getStaticProps() {
  return {
    props: {
      meta,
    }
  };
}

<InlineFilter filters={["react-native"]}>
<Callout warning>

WebAuthn registration and authentication are not currently supported on React Native, other passwordless features are fully supported.

</Callout>
</InlineFilter>

Amplify Auth enables your users to associate, keep track of, and delete passkeys.

## Associate WebAuthN credentials
  
Note that users must be authenticated to register a passkey. That also means users cannot create a passkey during sign up; consequently, they must have at least one other first factor authentication mechanism associated with their account to use WebAuthn.

You can associate a passkey using the following API:

<InlineFilter filters={["angular", "javascript", "nextjs", "react", "react-native", "vue"]}>

```ts
import { associateWebAuthnCredential} from 'aws-amplify/auth';

await associateWebAuthnCredential();

```

</InlineFilter>
<InlineFilter filters={["android"]}>

<BlockSwitcher>
<Block name="Java">

```java
Amplify.Auth.associateWebAuthnCredential(
    activity,
    () -> Log.i("AuthQuickstart", "Associated credential"),
    error -> Log.e("AuthQuickstart", "Failed to register credential", error)
);
```

</Block>
<Block name="Kotlin - Callbacks">

```kotlin
Amplify.Auth.associateWebAuthnCredential(
    activity,
    { Log.i("AuthQuickstart", "Associated credential") },
    { Log.e("AuthQuickstart", "Failed to register credential", error) }
)
```

</Block>
<Block name="Kotlin - Coroutines">

```kotlin
try {
    val result = Amplify.Auth.associateWebAuthnCredential(activity)
    Log.i("AuthQuickstart", "Associated credential")
} catch (error: AuthException) {
    Log.e("AuthQuickstart", "Failed to associate credential", error)
}
```

</Block>
<Block name="RxJava">

```java
RxAmplify.Auth.associateWebAuthnCredential(activity)
    .subscribe(
        result -> Log.i("AuthQuickstart", "Associated credential"), 
        error -> Log.e("AuthQuickstart", "Failed to associate credential", error)
    );
```

</Block>
</BlockSwitcher>

You must supply an `Activity` instance so that Amplify can display the PassKey UI in your Application's [Task](https://developer.android.com/guide/components/activities/tasks-and-back-stack).

</InlineFilter>
<InlineFilter filters={["swift"]}>

<BlockSwitcher>
<Block name="Async/Await">

```swift
func associateWebAuthNCredentials() async {
    do {
        try await Amplify.Auth.associateWebAuthnCredential()
        print("WebAuthn credential was associated")
    } catch {
        print("Associate WebAuthn Credential failed: \(error)")
    }
}
```

</Block>
<Block name="Combine">

```swift
func associateWebAuthNCredentials() -> AnyCancellable {
    Amplify.Publisher.create {
        try await Amplify.Auth.associateWebAuthnCredential()
    }.sink {
        print("Associate WebAuthn Credential failed: \($0)")
    }
    receiveValue: { _ in
        print("WebAuthn credential was associated")
    }
}
```

</Block>
</BlockSwitcher>

</InlineFilter>

The user will be prompted to register a passkey using their local authenticator. Amplify will then associate that passkey with Cognito.

## List WebAuthN credentials

You can list registered passkeys using the following API:

<InlineFilter filters={["angular", "javascript", "nextjs", "react", "react-native", "vue"]}>

```ts
import { listWebAuthnCredentials } from 'aws-amplify/auth';

const result = await listWebAuthnCredentials();

for (const credential of result.credentials) {
	console.log(`Credential ID: ${credential.credentialId}`);
	console.log(`Friendly Name: ${credential.friendlyCredentialName}`);
	console.log(`Relying Party ID: ${credential.relyingPartyId}`);
	console.log(`Created At: ${credential.createdAt}`);
}

```
</InlineFilter>
<InlineFilter filters={["swift"]}>

<BlockSwitcher>
<Block name="Async/Await">

```swift
func listWebAuthNCredentials() async {
    do {
        let result = try await Amplify.Auth.listWebAuthnCredentials(
          options: .init(pageSize: 5))
          
        for credential in result.credentials {  
          print("Credential ID: \(credential.credentialId)")  
          print("Created At: \(credential.createdAt)")  
          print("Relying Party Id: \(credential.relyingPartyId)")  
          if let friendlyName = credential.friendlyName {    
            print("Friendly name: \(friendlyName)")    
          }
        }
          
        // Fetch the next page
        if let nextToken = result.nextToken {  
          let nextResult = try await Amplify.Auth.listWebAuthnCredentials(
            options: .init(
              pageSize: 5,
              nextToken: nextToken))
        }
    } catch {
        print("Associate WebAuthn Credential failed: \(error)")
    }
}
```

</Block>
<Block name="Combine">

```swift
func listWebAuthNCredentials() -> AnyCancellable {
    Amplify.Publisher.create {
        try await Amplify.Auth.listWebAuthnCredentials(
          options: .init(pageSize: 5))
    }.sink {
        print("List WebAuthn Credential failed: \($0)")
    }
    receiveValue: { result in
        for credential in result.credentials {  
          print("Credential ID: \(credential.credentialId)")  
          print("Created At: \(credential.createdAt)")  
          print("Relying Party Id: \(credential.relyingPartyId)")  
          if let friendlyName = credential.friendlyName {    
            print("Friendly name: \(friendlyName)")    
          }
        }
          
        if let nextToken = result.nextToken {  
          // Fetch the next page
        }
    }
}
```

</Block>
</BlockSwitcher>

</InlineFilter>
<InlineFilter filters={["android"]}>

<BlockSwitcher>
<Block name="Java">

```java
Amplify.Auth.listWebAuthnCredentials(
    result -> result.getCredentials().forEach(credential -> {
        Log.i("AuthQuickstart", "Credential ID: " + credential.getCredentialId());
        Log.i("AuthQuickstart", "Friendly Name: " + credential.getFriendlyName());
        Log.i("AuthQuickstart", "Relying Party ID: " + credential.getRelyingPartyId());
        Log.i("AuthQuickstart", "Created At: " + credential.getCreatedAt());
    }),
    error -> Log.e("AuthQuickstart", "Failed to list credentials", error)
);
```

</Block>
<Block name="Kotlin - Callbacks">

```kotlin
Amplify.Auth.listWebAuthnCredentials(
    { result ->
        result.credentials.forEach { credential ->
            Log.i("AuthQuickstart", "Credential ID: ${credential.credentialId}")
            Log.i("AuthQuickstart", "Friendly Name: ${credential.friendlyName}")
            Log.i("AuthQuickstart", "Relying Party ID: ${credential.relyingPartyId}")
            Log.i("AuthQuickstart", "Created At: ${credential.createdAt}")
        }
    },
    { error -> Log.e("AuthQuickstart", "Failed to list credentials", error) }
)
```

</Block>
<Block name="Kotlin - Coroutines">

```kotlin
try {
    val result = Amplify.Auth.listWebAuthnCredentials()
    result.credentials.forEach { credential ->
        Log.i("AuthQuickstart", "Credential ID: ${credential.credentialId}")
        Log.i("AuthQuickstart", "Friendly Name: ${credential.friendlyName}")
        Log.i("AuthQuickstart", "Relying Party ID: ${credential.relyingPartyId}")
        Log.i("AuthQuickstart", "Created At: ${credential.createdAt}")
    }
} catch (error: AuthException) {
    Log.e("AuthQuickstart", "Failed to list credentials", error)
}
```

</Block>
<Block name="RxJava">

```java
RxAmplify.Auth.listWebAuthnCredentials()
    .subscribe(
        result -> result.getCredentials().forEach(credential -> {
            Log.i("AuthQuickstart", "Credential ID: " + credential.getCredentialId());
            Log.i("AuthQuickstart", "Friendly Name: " + credential.getFriendlyName());
            Log.i("AuthQuickstart", "Relying Party ID: " + credential.getRelyingPartyId());
            Log.i("AuthQuickstart", "Created At: " + credential.getCreatedAt());
        }), 
        error -> Log.e("AuthQuickstart", "Failed to list credentials", error)
    );
```

</Block>
</BlockSwitcher>
</InlineFilter>

## Delete WebAuthN credentials

You can delete a passkey with the following API:

<InlineFilter filters={["angular", "javascript", "nextjs", "react", "react-native", "vue"]}>

```ts
import { deleteWebAuthnCredential } from 'aws-amplify/auth';

const id = "credential-id-to-delete";

await deleteWebAuthnCredential({
  credentialId: id
});
```
</InlineFilter>
<InlineFilter filters={["swift"]}>

<BlockSwitcher>
<Block name="Async/Await">

```swift
func deleteWebAuthNCredentials(credentialId: String) async {
    do {
        try await Amplify.Auth.deleteWebAuthnCredential(credentialId: credentialId)
        print("WebAuthn credential was deleted")
    } catch {
        print("Delete WebAuthn Credential failed: \(error)")
    }
}
```

</Block>
<Block name="Combine">

```swift
func deleteWebAuthNCredentials(credentialId: String) -> AnyCancellable {
    Amplify.Publisher.create {
        try await Amplify.Auth.deleteWebAuthnCredential(credentialId: credentialId)
    }.sink {
        print("Delete WebAuthn Credential failed: \($0)")
    }
    receiveValue: { _ in
        print("WebAuthn credential was deleted")
    }
}
```

</Block>
</BlockSwitcher>
</InlineFilter>
<InlineFilter filters={["android"]}>

<BlockSwitcher>
<Block name="Java">

```java
Amplify.Auth.deleteWebAuthnCredential(
    credentialId,
    (result) -> Log.i("AuthQuickstart", "Deleted credential"),
    error -> Log.e("AuthQuickstart", "Failed to delete credential", error)
);
```

</Block>
<Block name="Kotlin - Callbacks">

```kotlin
Amplify.Auth.deleteWebAuthnCredential(
    credentialId,
    { Log.i("AuthQuickstart", "Deleted credential") },
    { Log.e("AuthQuickstart", "Failed to delete credential", error) }
)
```

</Block>
<Block name="Kotlin - Coroutines">

```kotlin
try {
    val result = Amplify.Auth.deleteWebAuthnCredential(credentialId)
    Log.i("AuthQuickstart", "Deleted credential")
} catch (error: AuthException) {
    Log.e("AuthQuickstart", "Failed to delete credential", error)
}
```

</Block>
<Block name="RxJava">

```java
RxAmplify.Auth.deleteWebAuthnCredential(credentialId)
    .subscribe(
        result -> Log.i("AuthQuickstart", "Deleted credential"), 
        error -> Log.e("AuthQuickstart", "Failed to delete credential", error)
    );
```

</Block>
</BlockSwitcher>

The delete passkey API has only the required `credentialId` as input, and it does not return a value.

</InlineFilter>


<InlineFilter filters={["angular", "javascript", "nextjs", "react", "react-native", "vue"]}>
## Practical example

Here is a code example that uses the list and delete APIs together. In this example, the user has 3 passkeys registered. They want to list all passkeys while using a `pageSize` of 2 as well as delete the first passkey in the list.

```ts
import { 
  listWebAuthnCredentials,
  deleteWebAuthnCredential
} from 'aws-amplify/auth';

let passkeys = [];

const result = await listWebAuthnCredentials({ pageSize: 2 });

passkeys.push(...result.credentials);

const nextPage = await listWebAuthnCredentials({
  pageSize: 2,
  nextToken: result.nextToken,
});

passkeys.push(...nextPage.credentials);

const id = passkeys[0].credentialId;

await deleteWebAuthnCredential({
  credentialId: id
});
```

</InlineFilter>


Contents of build-a-backend_auth_manage-users_with-admin-actions_index.txt:
import { getCustomStaticPath } from '@/utils/getCustomStaticPath';

export const meta = {
  title: 'With admin actions',
  description: 'Learn how to manage users with Admin Actions',
  platforms: [
    'android',
    'angular',
    'flutter',
    'javascript',
    'nextjs',
    'react',
    'react-native',
    'swift',
    'vue'
  ]
};

export function getStaticPaths() {
  return getCustomStaticPath(meta.platforms);
}

export function getStaticProps() {
  return {
    props: {
      meta,
    }
  };
}

Amplify Auth can be managed with the [AWS SDK's `@aws-sdk/client-cognito-identity-provider` package](https://docs.aws.amazon.com/AWSJavaScriptSDK/v3/latest/client/cognito-identity-provider/). This package is intended to use server-side, and can be used within a Function. This example focuses on the `addUserToGroup` action and will be defined as a [custom mutation](/[platform]/build-a-backend/data/custom-business-logic/#step-1---define-a-custom-query-or-mutation).

To get started, create an "ADMINS" group that will be used to authorize the mutation:

```ts title="amplify/auth/resource.ts"
import { defineAuth } from "@aws-amplify/backend"

export const auth = defineAuth({
  loginWith: {
    email: true,
  },
  // highlight-next-line
  groups: ["ADMINS"]
})
```

Next, create the Function resource:

```ts title="amplify/data/add-user-to-group/resource.ts"
import { defineFunction } from "@aws-amplify/backend"

export const addUserToGroup = defineFunction({
  name: "add-user-to-group",
})
```

Then, in your auth resources, grant access for the function to perform the `addUserToGroup` action. [Learn more about granting access to auth resources](/[platform]/build-a-backend/auth/grant-access-to-auth-resources).

```ts title="amplify/auth/resource.ts"
import { defineAuth } from "@aws-amplify/backend"
// highlight-next-line
import { addUserToGroup } from "../data/add-user-to-group/resource"

export const auth = defineAuth({
  loginWith: {
    email: true,
  },
  groups: ["ADMINS"],
  // highlight-start
  access: (allow) => [
    allow.resource(addUserToGroup).to(["addUserToGroup"])
  ],
  // highlight-end
})
```

You're now ready to define the custom mutation. Here you will use the newly-created `addUserToGroup` function resource to handle the `addUserToGroup` mutation. This mutation can only be called by a user in the "ADMINS" group.

```ts title="amplify/data/resource.ts"
import type { ClientSchema } from "@aws-amplify/backend"
import { a, defineData } from "@aws-amplify/backend"
import { addUserToGroup } from "./resource"

const schema = a.schema({
  addUserToGroup: a
    .mutation()
    .arguments({
      userId: a.string().required(),
      groupName: a.string().required(),
    })
    .authorization((allow) => [allow.group("ADMINS")])
    .handler(a.handler.function(addUserToGroup))
    .returns(a.json())
})

export type Schema = ClientSchema<typeof schema>

export const data = defineData({
  schema,
  authorizationModes: {
    defaultAuthorizationMode: "iam",
  },
})
```

Lastly, create the function's handler using the exported client schema to type the handler function, and the generated `env` to specify the user pool ID you'd like to interact with:

```ts title="amplify/data/add-user-to-group/handler.ts"
import type { Schema } from "../resource"
import { env } from "$amplify/env/add-user-to-group"
import {
  AdminAddUserToGroupCommand,
  CognitoIdentityProviderClient,
} from "@aws-sdk/client-cognito-identity-provider"

type Handler = Schema["addUserToGroup"]["functionHandler"]
const client = new CognitoIdentityProviderClient()

export const handler: Handler = async (event) => {
  const { userId, groupName } = event.arguments
  const command = new AdminAddUserToGroupCommand({
    Username: userId,
    GroupName: groupName,
    UserPoolId: env.AMPLIFY_AUTH_USERPOOL_ID,
  })
  const response = await client.send(command)
  return response
}
```

{/* double-up the filter for web platforms until mobile examples are written */}
<InlineFilter filters={["angular", "javascript", "nextjs", "react", "react-native", "vue"]}>

In your frontend, use the generated client to call your mutation using the group name and the user's ID.

<InlineFilter filters={["angular", "javascript", "nextjs", "react", "react-native", "vue"]}>

```ts title="src/client.ts"
import type { Schema } from "../amplify/data/resource"
import { generateClient } from "aws-amplify/data"

const client = generateClient<Schema>()

await client.mutations.addUserToGroup({
  groupName: "ADMINS",
  userId: "5468d468-4061-70ed-8870-45c766d26225",
})
```

</InlineFilter>
<InlineFilter filters={["flutter"]}>

{/* @todo */}

</InlineFilter>
<InlineFilter filters={["android"]}>

{/* @todo */}

</InlineFilter>
<InlineFilter filters={["swift"]}>

{/* @todo */}

</InlineFilter>
</InlineFilter>


Contents of build-a-backend_auth_manage-users_with-amplify-console_index.txt:
import { getCustomStaticPath } from '@/utils/getCustomStaticPath';

export const meta = {
  title: 'Manage users with Amplify console',
  description:
    'Manage applications Cognito users and groups with Amplify console',
  platforms: [
    'android',
    'angular',
    'flutter',
    'javascript',
    'nextjs',
    'react',
    'react-native',
    'swift',
    'vue'
  ]
};

export function getStaticPaths() {
  return getCustomStaticPath(meta.platforms);
}

export function getStaticProps(context) {
  return {
    props: {
      platform: context.params.platform,
      meta
    }
  };
}

The **User management** page in the Amplify console provides a user-friendly interface for managing your application's users. You can create and manage users and groups, edit user attributes, and suspend users. 

If you have not yet created an **auth** resource, visit the [Auth setup guide](/[platform]/build-a-backend/auth/set-up-auth/).

## Access User management

After you've deployed your auth resource, you can access the manager on Amplify Console.

1. Log in to the [Amplify console](https://console.aws.amazon.com/amplify/home) and choose your app.
2. Select the branch you would like to access.
3. Select **Authentication** from the left navigation bar.
4. Then, select **User management**.

<Video src="/images/gen2/manage/user-manager.mp4" description="Video - [Access user manager on Amplify console]"/>

### To create a user

1. On the **User management** page, select **Users** tab.
2. Select **Create user**.
3. In the **Create user** window, for Unique identifier enter a email address, username, or phone number. For Temporary password enter a password.
4. Choose Create user.

<Callout>

A user can be confirmed by using the [pre-built UI components](/[platform]/build-a-backend/auth/connect-your-frontend/using-the-authenticator/) and [Amplify libraries](/[platform]/build-a-backend/auth/connect-your-frontend/sign-up/).

</Callout>

## To create a group

1. On the **User management** page, choose the **Groups** tab and then choose **Create group**.
2. In the **Create group** window, for **Title** enter a name for the group.
3. Choose **Create group**.


## To add a users to a group

1. On the **User management** page, choose the **Groups** tab.
2. Select the name of the group to add users to.
3. Choose **Add users**.
4. In the **Add users to group** window, choose how you want to search for users to add from the **Search** menu. You can choose _Email_, _Phone number_, or _Username_.
5. Add one user or multiple users to add to the group and then choose **Add users**.

## To delete a group

1. On the **User management** page, choose the **Groups** tab.
2. In the **Groups** section, select the name of the group to delete.
3. Choose **Delete**.
4. A confirmation window is displayed. Enter _Delete_ and choose, **Confirm deletion**.


Contents of build-a-backend_auth_modify-resources-with-cdk_index.txt:
import { getCustomStaticPath } from '@/utils/getCustomStaticPath';

export const meta = {
  title: 'Modify Amplify-generated Cognito resources with CDK',
  description: 'Learn how to modify Amplify-generated Cognito resources.',
  platforms: [
    'android',
    'angular',
    'flutter',
    'javascript',
    'nextjs',
    'react',
    'react-native',
    'swift',
    'vue'
  ]
};

export function getStaticPaths() {
  return getCustomStaticPath(meta.platforms);
}

export function getStaticProps(context) {
  return {
    props: {
      platform: context.params.platform,
      meta
    }
  };
}

Amplify Auth provides sensible defaults for the underlying Amazon Cognito resource definitions. You can customize your authentication resource to enable it to behave exactly as needed for your use cases by modifying it directly using [AWS Cloud Development Kit (CDK)](https://aws.amazon.com/cdk/)

## Override Cognito UserPool password policies

You can override the password policy by using the L1 `cfnUserPool` construct and adding a `addPropertyOverride`.

```ts title="amplify/backend.ts"
import { defineBackend } from '@aws-amplify/backend';
import { auth } from './auth/resource';

const backend = defineBackend({
  auth,
});
// extract L1 CfnUserPool resources
const { cfnUserPool } = backend.auth.resources.cfnResources;
// modify cfnUserPool policies directly
cfnUserPool.policies = {
  passwordPolicy: {
    minimumLength: 10,
    requireLowercase: true,
    requireNumbers: true,
    requireSymbols: true,
    requireUppercase: true,
    temporaryPasswordValidityDays: 20,
  },
};
```

## Override Cognito UserPool multi-factor authentication options

While Email MFA is not yet supported with `defineAuth`, this feature can be enabled by modifying the underlying CDK construct.

Start by ensuring your `defineAuth` resource configuration includes a compatible account recovery option and a custom SES sender.

```ts title="amplify/auth/resource.ts"
import { defineAuth } from "@aws-amplify/backend"

/**
 * Define and configure your auth resource
 * @see https://docs.amplify.aws/gen2/build-a-backend/auth
 */
export const auth = defineAuth({
  loginWith: {
    email: true,
    phone: true,
  },
  multifactor: {
    mode: "OPTIONAL",
    sms: true,
    totp: false,
  },
  // Important! The logic to resolve this value cannot determine whether email mfa is enabled when overriding the resource. 
  // Be sure to pick a recovery option appropriate for your application.
  accountRecovery: "EMAIL_AND_PHONE_WITHOUT_MFA",
  senders: {
    email: {
      fromEmail: "registrations@example.com",
    },
  },
})
```

Next, extend the underlying CDK construct by activating [Amazon Cognito's Advanced Security Features (ASF)](https://docs.aws.amazon.com/cognito/latest/developerguide/cognito-user-pool-settings-advanced-security.html) and add `EMAIL_OTP` to the enabled MFA options.

```ts title="amplify/backend.ts"
import { defineBackend } from "@aws-amplify/backend"
import { auth } from "./auth/resource"

const backend = defineBackend({
  auth,
})

const { cfnUserPool } = backend.auth.resources.cfnResources

// enable ASF
cfnUserPool.userPoolAddOns = {
  advancedSecurityMode: "AUDIT",
}

// add email mfa
// https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-cognito-userpool.html#cfn-cognito-userpool-enabledmfas
cfnUserPool.enabledMfas = [...(cfnUserPool.enabledMfas || []), "EMAIL_OTP"]
```

{/* token validity */}
{/* BYO custom idp construct */}
{/* extend auth/unauth roles */}

<InlineFilter filters={["android","angular", "javascript", "nextjs", "react", "react-native", "swift", "vue"]}>

### Override Cognito UserPool to enable passwordless sign-in methods

You can modify the underlying Cognito user pool resource to enable sign in with passwordless methods. [Learn more about passwordless sign-in methods](/[platform]/build-a-backend/auth/concepts/passwordless/).

```ts title="amplify/backend.ts"
import { defineBackend } from "@aws-amplify/backend"
import { auth } from "./auth/resource"

const backend = defineBackend({
  auth,
})

const { cfnResources } = backend.auth.resources;
const { cfnUserPool, cfnUserPoolClient } = cfnResources;

cfnUserPool.addPropertyOverride(
	'Policies.SignInPolicy.AllowedFirstAuthFactors',
	['PASSWORD', 'WEB_AUTHN', 'EMAIL_OTP', 'SMS_OTP']
);

cfnUserPoolClient.explicitAuthFlows = [
	'ALLOW_REFRESH_TOKEN_AUTH',
	'ALLOW_USER_AUTH'
];

/* Needed for WebAuthn */
cfnUserPool.addPropertyOverride('WebAuthnRelyingPartyID', '<RELYING_PARTY>');
cfnUserPool.addPropertyOverride('WebAuthnUserVerification', 'preferred');
```
</InlineFilter>


Contents of build-a-backend_auth_moving-to-production_index.txt:
import { getCustomStaticPath } from '@/utils/getCustomStaticPath';

export const meta = {
  title: 'Moving to production',
  description: 'Learn how to configure your auth resources for production workloads',
  platforms: [
    'android',
    'angular',
    'flutter',
    'javascript',
    'nextjs',
    'react',
    'react-native',
    'swift',
    'vue'
  ]
};

export function getStaticPaths() {
  return getCustomStaticPath(meta.platforms);
}

export function getStaticProps() {
  return {
    props: {
      meta
    }
  };
}

Amplify Auth provisions [Amazon Cognito](https://aws.amazon.com/cognito/) resources that are provisioned with limited capabilities for sending email and SMS messages. In its default state, it is not intended to handle production workloads, but is sufficient for developing your application and associated business logic.

## Email

Cognito provides a [default email functionality](https://docs.aws.amazon.com/cognito/latest/developerguide/user-pool-email.html#user-pool-email-default) that limits how many emails can be sent in one day. When considering production workloads, Cognito can be configured to send emails using [Amazon Simple Email Service (Amazon SES)](https://aws.amazon.com/ses/).

<Callout warning>

All new AWS accounts default to a "sandbox" status with Amazon SES. This comes with the primary caveat that you can only send mail **to** verified email addresses and domains

</Callout>

To get started with Amazon SES in production, you must first [request production access](https://docs.aws.amazon.com/ses/latest/dg/request-production-access.html). Once you submit your request the submission cannot be modified, however you will receive a response from AWS within 24 hours.

After you have configured your account for production access and have verified your _sender_ email, you can configure your Cognito user pool to send emails using the verified sender:

```ts title="amplify/auth/resource.ts"
import { defineAuth } from "@aws-amplify/backend"

/**
 * Define and configure your auth resource
 * @see https://docs.amplify.aws/react/build-a-backend/auth
 */
export const auth = defineAuth({
  loginWith: {
    email: true,
  },
  senders: {
    email: {
      // configure using the email registered and verified in Amazon SES
      fromEmail: "registrations@example.com",
    },
  },
})
```

Now when emails are sent on new user sign-ups, password resets, etc., the sending account will be your verified email! To customize further, you can change the display name of the sender, or optionally apply a custom address for your users to reply.

```ts title="amplify/auth/resource.ts"
import { defineAuth } from "@aws-amplify/backend"

/**
 * Define and configure your auth resource
 * @see https://docs.amplify.aws/react/build-a-backend/auth
 */
export const auth = defineAuth({
  loginWith: {
    email: true,
  },
  senders: {
    email: {
      fromEmail: "registrations@example.com",
      // highlight-start
      fromName: "MyApp",
      replyTo: "inquiries@example.com"
      // highlight-end
    },
  },
})
```

## SMS

In order to send SMS authentication codes, you must [request an origination number](https://docs.aws.amazon.com/pinpoint/latest/userguide/settings-request-number.html). Authentication codes will be sent from the origination number. If your AWS account is in the SMS sandbox, you must also add a destination phone number, which can be done by going to the [Amazon Pinpoint Console](https://console.aws.amazon.com/pinpoint/), selecting SMS and voice in the navigation pane, and selecting Add phone number in the Destination phone numbers tab. To check if your AWS account is in the SMS sandbox, go to the [SNS console](https://console.aws.amazon.com/sns/), select the Text messaging (SMS) tab from the navigation pane, and check the status under the Account information section.

{/* backend example */}

{/* ## Custom domain */}
{/* ## Protect your auth domain */}
{/* waf */}


Contents of build-a-backend_auth_set-up-auth_index.txt:
import { getCustomStaticPath } from '@/utils/getCustomStaticPath';

export const meta = {
  title: 'Set up Amplify Auth',
  description:
    'Learn how to set up and connect your backend resources for authentication in Amplify.',
  platforms: [
    'android',
    'angular',
    'flutter',
    'javascript',
    'nextjs',
    'react',
    'react-native',
    'swift',
    'vue'
  ]
};

export function getStaticPaths() {
  return getCustomStaticPath(meta.platforms);
}

export function getStaticProps() {
  return {
    props: {
      meta
    }
  };
}

Amplify Auth is powered by [Amazon Cognito](https://aws.amazon.com/cognito/). Cognito is a robust user directory service that handles user registration, authentication, account recovery, and other operations. [Review the concepts to learn more](/[platform]/build-a-backend/auth/concepts/).

To get started with defining your authentication resource, open or create the auth resource file:

```ts title="amplify/auth/resource.ts"
import { defineAuth } from "@aws-amplify/backend"

/**
 * Define and configure your auth resource
 * @see https://docs.amplify.aws/gen2/build-a-backend/auth
 */
export const auth = defineAuth({
  loginWith: {
    email: true,
  },
})
```

By default, your auth resource is scaffolded using `email` as the default login mechanism. You can also configure your auth resource to allow signing in with phone numbers or an external provider such as Google, Facebook, Amazon, or Sign in with Apple.

<Callout info>

**Note:** At a minimum you will need to pass a `loginWith` value to set up how your users sign in to your app. Signing in with email and password is configured by default if you do not provide any value.

</Callout>

## Deploy auth resource

After you have chosen and defined your authentication resource, run the following command to create your resource in your personal cloud sandbox.

<InlineFilter filters={['angular', 'javascript', 'nextjs', 'react', 'react-native', 'vue']}>

```bash title="Terminal" showLineNumbers={false}
npx ampx sandbox
```

</InlineFilter>
<InlineFilter filters={['flutter']}>

```bash title="Terminal" showLineNumbers={false}
npx ampx sandbox --outputs-format dart --outputs-out-dir lib
```

</InlineFilter>
<InlineFilter filters={['android']}>

<Callout warning>
Be sure to add a "raw" folder under `app/src/main/res` directory if it does not exist.
</Callout>

```bash title="Terminal" showLineNumbers={false}
npx ampx sandbox --outputs-out-dir <path_to_app/src/main/res/raw>
```

</InlineFilter>
<InlineFilter filters={['swift']}>

```bash title="Terminal" showLineNumbers={false}
npx ampx sandbox
```

</InlineFilter>

After a successful deployment, this command also generates an outputs file (`amplify_outputs.json`) to enable your frontend app to connect to your backend resources. The values you configure in your backend authentication resource are set in the generated outputs file to automatically configure the frontend [`Authenticator connected component`](https://ui.docs.amplify.aws/react/connected-components/authenticator).

## Connect your application code to your auth resource

Creating and correctly implementing the sign-in flow can be challenging and time-consuming. Amplify's Authenticator UI component streamlines this by enabling you to rapidly build the entire authentication flow for your app. The component works seamlessly with configuration in `amplify/auth/resource.ts` to automatically connect with your backend resources.

Amplify has pre-built UI components for React, Vue, Angular, React Native, Swift, Android, and Flutter. In this guide, we are focusing on those for web applications.

<InlineFilter filters={["javascript", "react"]}>

First, install the `@aws-amplify/ui-react` library:

```bash title="Terminal" showLineNumbers={false}
npm add @aws-amplify/ui-react
```

Next, open **pages/\_app.tsx** and add the `Authenticator` component.

```ts title="pages/_app.tsx"
import type { AppProps } from 'next/app';
import { Authenticator } from '@aws-amplify/ui-react';
import { Amplify } from 'aws-amplify';
import outputs from '@/amplify_outputs.json';
import '@aws-amplify/ui-react/styles.css';

Amplify.configure(outputs);

export default function App({ Component, pageProps }: AppProps) {
  return (
    <Authenticator>
      {({ signOut, user }) => (
        <main>
          <h1>Hello {user?.username}</h1>
          <button onClick={signOut}>Sign out</button>
          <Component {...pageProps} />
        </main>
      )}
    </Authenticator>
  );
};
```

</InlineFilter>
<InlineFilter filters={["vue"]}>
<BlockSwitcher>
<Block name="Vue 3">

First, install the `@aws-amplify/ui-vue` library:

```bash title="Terminal" showLineNumbers={false}
npm add @aws-amplify/ui-vue
```

Next, open **src/App.vue** and add the `Authenticator` component.

**Authenticator**

The `Authenticator` component offers a simple way to add authentication flows into your app. This component encapsulates an authentication workflow in the framework of your choice and is backed by your backend Auth resources. `Authenticator` passes the `user` info and `signOut` function to the inner template.

```html
<script setup>
  import { Authenticator } from "@aws-amplify/ui-vue";
  import "@aws-amplify/ui-vue/styles.css";

  import { Amplify } from 'aws-amplify';
  import outputs from '../amplify_outputs.json';

  Amplify.configure(outputs);
</script>

<template>
  <authenticator>
    <template v-slot="{ user, signOut }">
      <h1>Hello {{ user.username }}!</h1>
      <button @click="signOut">Sign Out</button>
    </template>
  </authenticator>
</template>
```

</Block>
<Block name="Vue 2">

First, install the `@aws-amplify/ui-components` library:

```bash title="Terminal" showLineNumbers={false}
npm add @aws-amplify/ui-components
```

Now open **src/main.ts** and add the following below your last import:

```js title="src/main.ts"
import '@aws-amplify/ui-components';
import {
  applyPolyfills,
  defineCustomElements
} from '@aws-amplify/ui-components/loader';
import Vue from 'vue';

Vue.config.ignoredElements = [/amplify-\w*/];

applyPolyfills().then(() => {
  defineCustomElements(window);
});
```

Next, open **src/App.ts** and add the `amplify-authenticator` component.

**amplify-authenticator**

The `amplify-authenticator` component offers a simple way to add authentication flows into your app. This component encapsulates an authentication workflow in the framework of your choice and is backed by your backend Auth resources. The optional `amplify-sign-out` component is available if you would like to render a sign-out button.

```html title="src/App.ts"
<template>
  <amplify-authenticator>
    <div>
      My App
      <amplify-sign-out></amplify-sign-out>
    </div>
  </amplify-authenticator>
</template>
```

</Block>
</BlockSwitcher>

</InlineFilter>
<InlineFilter filters={["angular"]}>

First, install the `@aws-amplify/ui-angular` library:

```bash title="Terminal" showLineNumbers={false}
npm add @aws-amplify/ui-angular
```

Now open **app.module.ts** and add the Amplify imports and configuration:

```js title="app.module.ts"
import { NgModule } from '@angular/core';
import { BrowserModule } from '@angular/platform-browser';
import { AmplifyAuthenticatorModule } from '@aws-amplify/ui-angular';

import { AppComponent } from './app.component';
import outputs from './amplify_outputs.json';

Amplify.configure(outputs);

@NgModule({
  declarations: [AppComponent],
  imports: [BrowserModule, AmplifyAuthenticatorModule],
  providers: [],
  bootstrap: [AppComponent]
})
export class AppModule {}
```

Next, import the default theme inside **styles.css**:

```css title="styles.css"
@import '~@aws-amplify/ui-angular/theme.css';
```

Next, open **app.component.html** and add the `amplify-authenticator` component.

**amplify-authenticator**

The `Authenticator` component offers a simple way to add authentication flows into your app. This component encapsulates an authentication workflow in the framework of your choice and is backed by your backend Auth resources. `Authenticator` passes the `user` info and `signOut` function to the inner template.

The `amplify-authenticator` component offers a simple way to add authentication flows into your app. This component encapsulates an authentication workflow in the framework of your choice and is backed by your backend Auth resources. `amplify-authenticator` passes the `user` info and `signOut` function to the inner template.

```html title="app.component.html"
<amplify-authenticator>
  <ng-template
    amplifySlot="authenticated"
    let-user="user"
    let-signOut="signOut"
  >
    <h1>Welcome {{ user.username }}!</h1>
    <button (click)="signOut()">Sign Out</button>
  </ng-template>
</amplify-authenticator>
```

</InlineFilter>
<InlineFilter filters={['react-native']}>

First, install the `@aws-amplify/ui-react-native` library:

```bash title="Terminal" showLineNumbers={false}
npm add \
  @aws-amplify/react-native \
  @aws-amplify/ui-react-native \
  aws-amplify \
  @react-native-community/netinfo \
  @react-native-async-storage/async-storage \
  react-native-safe-area-context@^4.2.5 \
  react-native-get-random-values
```

<Callout info>
If your project will support Federated Sign In using the `React Native Authenticator` the `@aws-amplify/rtn-web-browser` package is also required:

```bash title="Terminal" showLineNumbers={false}
npm add @aws-amplify/rtn-web-browser
```
</Callout>

Then install the iOS cocoapods by running:

```bash title="Terminal" showLineNumbers={false}
npx pod-install
```

<Callout warning>
For calling native libraries and platform dependencies from Expo, you need to run the prebuild command for generating the folders for related platforms.

```bash title="Terminal" showLineNumbers={false}
npx expo prebuild
```
</Callout>
Next, update the `App.tsx` file with the following to set up the authentication flow:

```typescript
import React from "react";
import { Button, View, StyleSheet } from "react-native";
import { Amplify } from "aws-amplify";
import { Authenticator, useAuthenticator } from "@aws-amplify/ui-react-native";
import outputs from "./amplify_outputs.json";

Amplify.configure(outputs);

const SignOutButton = () => {
  const { signOut } = useAuthenticator();

  return (
    <View style={styles.signOutButton}>
      <Button title="Sign Out" onPress={signOut} />
    </View>
  );
};

const App = () => {
  return (
    <Authenticator.Provider>
      <Authenticator>
        <SignOutButton />
      </Authenticator>
    </Authenticator.Provider>
  );
};

const styles = StyleSheet.create({
  signOutButton: {
    alignSelf: "flex-end",
  },
});

export default App;
```

</InlineFilter>
<InlineFilter filters={['flutter']}>

First, install the `amplify_authenticator` library:

```bash title="Terminal" showLineNumbers={false}
flutter pub add amplify_flutter
flutter pub add amplify_auth_cognito
flutter pub add amplify_authenticator
```

or you can update your `pubspec.yaml` file with the following

```yaml
dependencies:
  amplify_flutter: ^2.0.0
  amplify_auth_cognito: ^2.0.0
  amplify_authenticator: ^2.0.0
```

and run the following command to download the libraries.

```bash title="Terminal" showLineNumbers={false}
flutter pub get
```

Next, update your `main.dart` file with the following:

```dart
import 'package:amplify_auth_cognito/amplify_auth_cognito.dart';
import 'package:amplify_authenticator/amplify_authenticator.dart';
import 'package:amplify_flutter/amplify_flutter.dart';
import 'package:flutter/material.dart';

import 'amplify_outputs.dart';

Future<void> main() async {
  try {
    WidgetsFlutterBinding.ensureInitialized();
    await _configureAmplify();
    runApp(const MyApp());
  } on AmplifyException catch (e) {
    runApp(Text("Error configuring Amplify: ${e.message}"));
  }
}

// highlight-start
Future<void> _configureAmplify() async {
  try {
    await Amplify.addPlugin(AmplifyAuthCognito());
    await Amplify.configure(amplifyConfig);
    safePrint('Successfully configured');
  } on Exception catch (e) {
    safePrint('Error configuring Amplify: $e');
  }
}
// highlight-end

class MyApp extends StatelessWidget {
  const MyApp({super.key});
  @override
  Widget build(BuildContext context) {
    // highlight-next-line
    return Authenticator(
      child: MaterialApp(
        // highlight-next-line
        builder: Authenticator.builder(),
        home: const Scaffold(
          body: Center(
            child: Column(
              mainAxisAlignment: MainAxisAlignment.center,
              children: [
                // highlight-next-line
                SignOutButton(),
              ],
            ),
          ),
        ),
      ),
    );
  }
}
```

</InlineFilter>
<InlineFilter filters={['android']}>

<Callout warning>

Be sure to have compileSdk version as 34 or higher.

</Callout>

The Authenticator component is built using [Jetpack Compose](https://developer.android.com/jetpack/compose). Enable Jetpack Compose by adding the following to the android section of your app's `build.gradle` file:

```kotlin title="app/build.gradle.kts" showLineNumbers={false}
compileOptions {
    // Support for Java 8 features
    isCoreLibraryDesugaringEnabled = true
    sourceCompatibility = JavaVersion.VERSION_1_8
    targetCompatibility = JavaVersion.VERSION_1_8
}
buildFeatures {
    compose = true
}
composeOptions {
  kotlinCompilerExtensionVersion = "1.2.0"
}
dependencies {
    coreLibraryDesugaring("com.android.tools:desugar_jdk_libs:2.0.3")
}
```

Add the following dependencies to your *app*'s `build.gradle.kts` file and click "Sync Now" when prompted:

```kotlin title="app/build.gradle.kts" 
dependencies {
    implementation("com.amplifyframework.ui:authenticator:ANDROID_AUTHENTICATOR_VERSION")
}
```

<Callout warning>
Before calling the `Amplify.configure` function, make sure to either download the `amplify_outputs.json` file from the console, or generate it with the following command: 

```bash title="Terminal" showLineNumbers={false}
npx ampx generate outputs --app-id <app-id> --branch main --out-dir app/src/main/res/raw
```

Next, be sure the file you generated or downloaded is in the appropriate resource directory for your application (for example, `app/src/main/res/raw`) in your Android project. Otherwise, you will not be able to compile your application.
</Callout>

```kotlin title="MyAmplifyApp.kt"
import android.app.Application
import android.util.Log
import com.amplifyframework.AmplifyException
import com.amplifyframework.auth.cognito.AWSCognitoAuthPlugin
import com.amplifyframework.core.Amplify
import com.amplifyframework.core.configuration.AmplifyOutputs

class MyAmplifyApp: Application() {
    override fun onCreate() {
        super.onCreate()

        try {
            // highlight-next-line
            Amplify.addPlugin(AWSCognitoAuthPlugin())
            Amplify.configure(AmplifyOutputs(R.raw.amplify_outputs), applicationContext)
            Log.i("MyAmplifyApp", "Initialized Amplify")
        } catch (error: AmplifyException) {
            Log.e("MyAmplifyApp", "Could not initialize Amplify", error)
        }
    }
}
```

Lastly, update your MainActivity.kt file to use the Amplify UI components:

```kotlin
import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.material3.Button
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.Surface
import androidx.compose.material3.Text
import androidx.compose.runtime.Composable
import androidx.compose.ui.Modifier
import androidx.compose.ui.tooling.preview.Preview
import com.amplifyframework.core.Amplify
import com.amplifyframework.ui.authenticator.ui.Authenticator
// highlight-next-line
import <your-package-name>.ui.theme.MyAmplifyAppTheme

class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            MyAmplifyAppTheme {
                // A surface container using the 'background' color from the theme
                Surface(
                    modifier = Modifier.fillMaxSize(),
                    color = MaterialTheme.colorScheme.background
                ) {
                    // highlight-next-line
                    Authenticator { state ->
                        Column {
                            Text(
                                text = "Hello ${state.user.username}!",
                            )
                            Button(onClick = {
                                // highlight-next-line
                                Amplify.Auth.signOut {  }
                            }) {
                                Text(text = "Sign Out")
                            }
                        }
                    }
                }
            }
        }
    }
}
```

</InlineFilter>
<InlineFilter filters={["swift"]}>

### Prerequisites

An application with Amplify libraries integrated and a minimum target of any of the following:

- **iOS 13.0**, using **Xcode 14.1** or later.
- **macOS 10.15**, using **Xcode 14.1** or later.
- **tvOS 13.0**, using **Xcode 14.3** or later.
- **watchOS 9.0**, using **Xcode 14.3** or later.
- **visionOS 1.0**, using **Xcode 15** or later. (Preview support - see below for more details.)

<Callout>

visionOS support is currently in **preview** and can be used by using the latest [Amplify Release](https://github.com/aws-amplify/amplify-swift/releases). 
As new Xcode and visionOS versions are released, the support will be updated with any necessary fixes on a best effort basis.

</Callout>
<Callout>

**Note:** To use Amplify Auth in a macOS project, you'll need to enable the Keychain Sharing capability. In Xcode, navigate to **your application target** > **Signing & Capabilities** > **+ Capability**, then select **Keychain Sharing.**

This capability is required because Auth uses the Data Protection Keychain on macOS as a platform best practice. See [TN3137: macOS keychain APIs and implementations](https://developer.apple.com/documentation/technotes/tn3137-on-mac-keychains) for more information on how Keychain works on macOS and the Keychain Sharing entitlement.

For more information on adding capabilities to your application, see [Xcode Capabilities](https://developer.apple.com/documentation/xcode/capabilities).

</Callout>

{/* @TODO bare-bones example */}
Move the generated files to your project. You can do this by dragging and dropping the files to your project.

![Dialog appears when users drag and drop the generated files into Xcode. It displays targets, added folders, and destination options. The default settings should be sufficient for drag and drop.](/images/lib/getting-started/ios/set-up-swift-8.png)

Open your project in Xcode and select File > Add Packages... and add the following dependencies:

- Amplify Library for Swift: Enter its GitHub URL (https://github.com/aws-amplify/amplify-swift), *select Up to Next Major Version* and click *Add Package*

  - Select the following libraries:
    - Amplify
    - AWSCognitoAuthPlugin

- Amplify UI Swift - Authenticator: Enter its GitHub URL (https://github.com/aws-amplify/amplify-ui-swift-authenticator), *select Up to Next Major Version* and click *Add Package*

  - Select the following library:
    - Authenticator

Next, update the `init` part of your `MyAmplifyAppApp.swift` file with the following code:

```swift title="MyAmplifyApp.swift"
import Amplify
import Authenticator
import AWSCognitoAuthPlugin
import SwiftUI

@main
struct MyApp: App {
    init() {
        do {
            try Amplify.add(plugin: AWSCognitoAuthPlugin())
            try Amplify.configure(with: .amplifyOutputs)
        } catch {
            print("Unable to configure Amplify \(error)")
        }
    }

    var body: some Scene {
        WindowGroup {
            Authenticator { state in
                VStack {
                    Text("Hello, \(state.user.username)")
                    Button("Sign out") {
                        Task {
                            await state.signOut()
                        }
                    }
                }
            }
        }
    }
}
```

</InlineFilter>

Once you add the Authenticator component to your app, you can test the sign-up, sign-in, and sign-out functionality. You can also [customize the Authenticator connected component](https://ui.docs.amplify.aws/react/connected-components/authenticator/customization) to adjust colors and styling as needed.

{/* ## Manage users in the Amplify console */}

## Next steps

Now that you have completed setting up authentication in your Amplify app with email and password, you may also want to add some additional features. We recommend you learn more about:

- [Learn more about authentication concepts](/[platform]/build-a-backend/auth/concepts/)
- [Moving to production](/[platform]/build-a-backend/auth/moving-to-production/)


Contents of build-a-backend_auth_sign-in-with-web-ui_index.txt:
import { getCustomStaticPath } from '@/utils/getCustomStaticPath';

export const meta = {
  title: 'Enable sign-in with web UI',
  description:
    'Use Amazon Cognito Auth plugin to register and authenticate a user with a prebuilt web UI',
  platforms: ['flutter', 'swift', 'android']
};

export const getStaticPaths = async () => {
  return getCustomStaticPath(meta.platforms);
};

export function getStaticProps(context) {
  return {
    props: {
      platform: context.params.platform,
      meta
    }
  };
}

<InlineFilter filters={['android']}>
## Prerequisites
* An app set up according to the [getting started walkthrough](/[platform]/build-a-backend/auth/set-up-auth/)

<Callout warning>
 When configuring social sign-in, it's important to exercise caution when designating attributes as "required." Different social identity providers have varied scopes in terms of the information they respond back to Cognito with.  User pool attributes that are initially set up as "required" cannot be changed later, and may require you to migrate the users or create a new user pool.  
</Callout>

## Configure Auth Category

<Callout>

This library's Cognito plugin currently supports the [Authorization Code Grant](https://docs.aws.amazon.com/cognito/latest/developerguide/authorization-endpoint.html) OAuth Flow.

</Callout>

In your `auth/resource.ts` file, update the 
```ts
export const auth = defineAuth({
  loginWith: {
    email: true,
    externalProviders: {
      callbackUrls: ["myapp://callback/"],
      logoutUrls: ["myapp://signout/"],
    },
  },
});
```

## Update AndroidManifest.xml

Add the following activity and queries tag to your app's `AndroidManifest.xml` file, replacing `myapp` with
your redirect URI prefix if necessary:

```xml
<application ...>
  ...
  <activity
      android:name="com.amplifyframework.auth.cognito.activities.HostedUIRedirectActivity"
      android:exported="true">
      <intent-filter>
          <action android:name="android.intent.action.VIEW" />
          <category android:name="android.intent.category.DEFAULT" />
          <category android:name="android.intent.category.BROWSABLE" />
          <data android:scheme="myapp" />
      </intent-filter>
  </activity>
  ...
</application>
```

## Launch Web UI Sign In

Sweet! You're now ready to launch sign in with web UI. For now, just add this method to the `onCreate` method of MainActivity:

<BlockSwitcher>
<Block name="Java">

```java
Amplify.Auth.signInWithWebUI(
    this,
    result -> Log.i("AuthQuickStart", result.toString()),
    error -> Log.e("AuthQuickStart", error.toString())
);
```

</Block>
<Block name="Kotlin - Callbacks">

```kotlin
Amplify.Auth.signInWithWebUI(
    this,
    { Log.i("AuthQuickStart", "Signin OK = $it") },
    { Log.e("AuthQuickStart", "Signin failed", it) }
)
```

</Block>
<Block name="Kotlin - Coroutines">

```kotlin
try {
    val result = Amplify.Auth.signInWithWebUI(this)
    Log.i("AuthQuickStart", "Signin OK: $result")
} catch (error: AuthException) {
    Log.e("AuthQuickStart", "Signin failed", error)
}
```

</Block>
<Block name="RxJava">

```java
RxAmplify.Auth.signInWithWebUI(this)
    .subscribe(
        result -> Log.i("AuthQuickStart", result.toString()),
        error -> Log.e("AuthQuickStart", error.toString())
    );
```

</Block>
</BlockSwitcher>


</InlineFilter>
<InlineFilter filters={['swift']}>
## Prerequisites

<Callout warning>

**Note:** Social sign-in (OAuth) functionality is only available in **iOS**, **macOS** and **visionOS**.

 When configuring social sign-in, it's important to exercise caution when designating attributes as "required." Different social identity providers have varied scopes in terms of the information they respond back to Cognito with.  User pool attributes that are initially set up as "required" cannot be changed later, and may require you to migrate the users or create a new user pool.  

</Callout>

For a full example, please follow the [project setup walkthrough](/[platform]/start/quickstart/).

<Callout>

To use Auth in a macOS project, you'll need to enable the Keychain Sharing capability. In Xcode, navigate to **your application target** > **Signing & Capabilities** > **+ Capability**, then select **Keychain Sharing.**

This capability is required because Auth uses the Data Protection Keychain on macOS as a platform best practice.
See [TN3137: macOS keychain APIs and implementations](https://developer.apple.com/documentation/technotes/tn3137-on-mac-keychains) for more information on how Keychain works on macOS and the Keychain Sharing entitlement.

For more information on adding capabilities to your application, see [Xcode Capabilities](https://developer.apple.com/documentation/xcode/capabilities).

</Callout>

## Configure Auth Category

<Callout>

This library's Cognito plugin currently supports the [Authorization Code Grant](https://docs.aws.amazon.com/cognito/latest/developerguide/authorization-endpoint.html) OAuth Flow.

</Callout>

Update the `auth/resource.ts` file like the following to enable the sign-in and sign-out capabilities with a web ui.

```ts
export const auth = defineAuth({
  loginWith: {
    email: true,
    externalProviders: {
      callbackUrls: ["myapp://callback/"],
      logoutUrls: ["myapp://signout/"],
    },
  },
});
```
## Update Info.plist

Signin with web UI require the Amplify plugin to show up the signin UI inside a webview. After the signin process is complete it will redirect back to your app. 
You have to enable this in your app's `Info.plist`. Right click Info.plist and then choose Open As > Source Code. Add the following entry in the URL scheme:

```xml

 <plist version="1.0">

     <dict>
     <!-- YOUR OTHER PLIST ENTRIES HERE -->

     <!-- ADD AN ENTRY TO CFBundleURLTypes for Cognito Auth -->
     <!-- IF YOU DO NOT HAVE CFBundleURLTypes, YOU CAN COPY THE WHOLE BLOCK BELOW -->
     <key>CFBundleURLTypes</key>
     <array>
         <dict>
             <key>CFBundleURLSchemes</key>
             <array>
                 <string>myapp</string>
             </array>
         </dict>
     </array>

     <!-- ... -->
     </dict>
```

When creating a new SwiftUI app using Xcode 13 no longer require configuration files such as the Info.plist. If you are missing this file, click on the project target, under Info, Url Types, and click '+' to add a new URL Type. Add `myapp` to the URL Schemes. You should see the Info.plist file now with the entry for CFBundleURLSchemes.

## Launch Web UI Sign In

You're now ready to launch sign in with web UI. The `signInWithWebUI` api require a presentationAnchor and for an iOS app it will be the main UIWindow of the app. The example code below assume that you are in a UIViewController where you can fetch the UIWindow instance by `self.view.window`.

<BlockSwitcher>

<Block name="Async/Await">

```swift
func signInWithWebUI() async {
    do {
        let signInResult = try await Amplify.Auth.signInWithWebUI(presentationAnchor: self.view.window!)
        if signInResult.isSignedIn {
            print("Sign in succeeded")
        }
    } catch let error as AuthError {
        print("Sign in failed \(error)")
    } catch {
        print("Unexpected error: \(error)")
    }
}
```

</Block>

<Block name="Combine">

```swift
func signInWithWebUI() -> AnyCancellable {
    Amplify.Publisher.create {
        try await Amplify.Auth.signInWithWebUI(presentationAnchor: self.view.window!)
        }.sink {
            if case let .failure(authError) = $0 {
                print("Sign in failed \(authError)")
            }
        }
        receiveValue: { signInResult in
            if signInResult.isSignedIn {
                print("Sign in succeeded")
            }
        }
}
```

</Block>

</BlockSwitcher>

### Prefer private session during signIn

Starting Amplify 1.6.0, `Amplify.Auth.signInWithWebUI` automatically uses [ASWebAuthenticationSession](https://developer.apple.com/documentation/authenticationservices/aswebauthenticationsession) internally for iOS 13.0+. For older iOS versions, it will fall back to [SFAuthenticationSession](https://developer.apple.com/documentation/safariservices/sfauthenticationsession).
This release also introduces a new `preferPrivateSession` flag to `AWSAuthWebUISignInOptions` during the sign in flow. If `preferPrivateSession` is set to `true` during sign in, the user will not see a web view displayed when they sign out. `preferPrivateSession` will set [ASWebAuthenticationSession.prefersEphemeralWebBrowserSession](https://developer.apple.com/documentation/authenticationservices/aswebauthenticationsession/3237231-prefersephemeralwebbrowsersessio) internally and the authentication session will be private if the user's preferred browser supports it.

```swift
try await Amplify.Auth.signInWithWebUI(
    presentationAnchor: self.view.window!,
    options: .preferPrivateSession()
) {
    ...
}
```

</InlineFilter>
<InlineFilter filters={['flutter']}>
## Prerequisites

* An app set up according to the [getting started walkthrough](/[platform]/build-a-backend/auth/set-up-auth/)

<Callout warning>
 When configuring Social sign-in, it's important to exercise caution when designating attributes as "required." Different social identity providers have varied scopes in terms of the information they respond back to Cognito with.  User pool attributes that are initially set up as "required" cannot be changed later, and may require you to migrate the users or create a new user pool.  
</Callout>

## Configure Auth Category

<Callout>

This library's Cognito plugin currently supports the [Authorization Code Grant](https://docs.aws.amazon.com/cognito/latest/developerguide/authorization-endpoint.html) OAuth Flow.

</Callout>

Update the `auth/resource.ts` file like the following to enable the sign-in and sign-out capabilities with a web ui.

```ts
export const auth = defineAuth({
  loginWith: {
    email: true,
    externalProviders: {
      callbackUrls: ["myapp://callback/"],
      logoutUrls: ["myapp://signout/"],
    },
  },
});
```

## How It Works

Sign-in with web UI will display the sign-in UI inside a webview. After the sign-in process is complete, the sign-in UI will redirect back to your app.

## Platform Setup

### Web

To use Hosted UI in your Flutter web application locally, you must run the app with the `--web-port=3000` argument (with the value being whichever port you assigned to localhost host when configuring your redirect URIs).

### Android

Add the following `queries` element to the `AndroidManifest.xml` file in your app's `android/app/src/main` directory, as well as the following `intent-filter` to the `MainActivity` in the same file.

Replace `myapp` with your redirect URI scheme as necessary:

```xml
<queries>
    <intent>
        <action android:name=
            "android.support.customtabs.action.CustomTabsService" />
    </intent>
</queries>
<application>
  ...
  <activity
        android:name=".MainActivity" android:exported="true">
        <intent-filter>
            <action android:name="android.intent.action.VIEW" />
            <category android:name="android.intent.category.DEFAULT" />
            <category android:name="android.intent.category.BROWSABLE" />
            <data android:scheme="myapp" />
        </intent-filter>
  </activity>
  ...
</application>
```

### macOS

Open XCode and enable the App Sandbox capability and then select "Incoming Connections (Server)" under "Network".

![Incoming Connections setting selected in the App Sandbox section of the runner signing and capabilities tab.](/images/project-setup/flutter/mac/xcode-entitlements.png)

### iOS, Windows and Linux

No specific platform configuration is required.

## Launch Web UI Sign In

You're now ready to launch sign in with web UI.

```dart
Future<void> signInWithWebUI() async {
  try {
    final result = await Amplify.Auth.signInWithWebUI();
    safePrint('Sign in result: $result');
  } on AuthException catch (e) {
    safePrint('Error signing in: ${e.message}');
  }
}
```

You can also specify a provider with the `provider` attribute:

```dart
Future<void> signInWithWebUIProvider() async {
  try {
    final result = await Amplify.Auth.signInWithWebUI(
      provider: AuthProvider.google,
    );
    safePrint('Result: $result');
  } on AuthException catch (e) {
    safePrint('Error signing in: ${e.message}');
  }
}
```

Amplify Flutter currently supports the following social sign-in providers:
  * Google
  * Facebook
  * Login With Amazon
  * Apple

### Prefer private session during signIn on iOS.

Amplify.Auth.signInWithWebUI uses [ASWebAuthenticationSession](https://developer.apple.com/documentation/authenticationservices/aswebauthenticationsession) internally for iOS. ASWebAuthenticationSession has a property, [prefersEphemeralWebBrowserSession](https://developer.apple.com/documentation/authenticationservices/aswebauthenticationsession/3237231-prefersephemeralwebbrowsersessio) which can be used to indicate whether the session should ask the browser for a private authentication session. To set this flag to true, set `preferPrivateSession` to true using `CognitoSignInWithWebUIPluginOptions`.

This will bypass the permissions dialog that is displayed to the end user during sign in and sign out. However, it will also prevent reuse of existing sessions from the user's browser. For example, if the user is logged into Google in their browser and try to sign in using Google in your app, they would now need to re-enter their credentials.

```dart
Future<void> signInWithWebUIAndPrivateSession() async {
  await Amplify.Auth.signInWithWebUI(
    options: const SignInWithWebUIOptions(
      pluginOptions: CognitoSignInWithWebUIPluginOptions(
        isPreferPrivateSession: true,
      ),
    ),
  );
}
```

</InlineFilter>


Contents of build-a-backend_auth_use-aws-sdk_index.txt:
import { getCustomStaticPath } from '@/utils/getCustomStaticPath';

export const meta = {
  title: 'Use AWS SDK',
  description: 'For advanced use cases where Amplify does not provide the functionality, you can retrieve the escape hatch to access the AWSCognito instance.',
  platforms: [
    'swift',
    'android'  
  ],
};

export const getStaticPaths = async () => {
  return getCustomStaticPath(meta.platforms);
};

export function getStaticProps(context) {
  return {
    props: {
      platform: context.params.platform,
      meta
    }
  };
}

For advanced use cases where Amplify does not provide the functionality, you can retrieve an escape hatch to access the underlying Amazon Cognito client.

<InlineFilter filters={['swift']}>

The escape hatch provides access to the underlying `AWSCognitoIdentityProvider` instance. Import the necessary types:

```swift
import AWSCognitoAuthPlugin
import AWSCognitoIdentityProvider
```

Then retrieve the escape hatch with this code:

```swift
func getEscapeHatch() {
    let client: CognitoIdentityProviderClient

    // Get the instance of AWSCognitoAuthPlugin
    let plugin = try? Amplify.Auth.getPlugin(for: "awsCognitoAuthPlugin") as? AWSCognitoAuthPlugin

    // Get the instance of CognitoIdentityProviderClient
    if case .userPoolAndIdentityPool(let userPoolClient, _) = plugin?.getEscapeHatch() {
        client = userPoolClient
    } else if case .userPool(let userPoolClient) = plugin?.getEscapeHatch() {
        client = userPoolClient
    } else {
        fatalError("No user pool configuration found")
    }
    print("Fetched escape hatch - \(String(describing: client))")
}
```
</InlineFilter>

<InlineFilter filters={["android"]}>
You can access the underlying `CognitoIdentityProviderClient` and `CognitoIdentityClient` as shown below

```kotlin
implementation "aws.sdk.kotlin:cognitoidentityprovider:1.0.44"
implementation "aws.sdk.kotlin:cognitoidentity:1.0.44"
```
<BlockSwitcher>
<Block name="Kotlin">

```kotlin
suspend fun resendCodeUsingEscapeHatch() {
    // Get the instance of AWSCognitoAuthPlugin
    val cognitoAuthPlugin = Amplify.Auth.getPlugin("awsCognitoAuthPlugin")
    val cognitoAuthService = cognitoAuthPlugin.escapeHatch as AWSCognitoAuthService

    // Get the instance of CognitoIdentityProviderClient
    val cognitoIdentityProviderClient = cognitoAuthService.cognitoIdentityProviderClient
    val request = ResendConfirmationCodeRequest {
        clientId = "xxxxxxxxxxxxxxxx"
        username = "user1"
    }
    val response = cognitoIdentityProviderClient?.resendConfirmationCode(request)
}
```

</Block>
<Block name="Java">

<Callout>

[Learn more about consuming Kotlin clients from Java using either a blocking interface or an equivalent async interface based on futures](https://github.com/awslabs/smithy-kotlin/blob/main/docs/design/kotlin-smithy-sdk.md#java-interop).

</Callout>

```java
// Get the instance of AWSCognitoAuthPlugin
AWSCognitoAuthPlugin cognitoAuthPlugin = (AWSCognitoAuthPlugin) Amplify.Auth.getPlugin("awsCognitoAuthPlugin");

// Get the instance of CognitoIdentityProviderClient
CognitoIdentityProviderClient client = cognitoAuthPlugin.getEscapeHatch().getCognitoIdentityProviderClient();
ResendConfirmationCodeRequest request = ResendConfirmationCodeRequest.Companion.invoke(dslBuilder -> {
    dslBuilder.setClientId("xxxxxxxxxxxxxxxx");
    dslBuilder.setUsername("user1");
    return null;
});

assert client != null;
client.resendConfirmationCode(request, new Continuation<ResendConfirmationCodeResponse>() {
    @NonNull
    @Override
    public CoroutineContext getContext() {
        return GlobalScope.INSTANCE.getCoroutineContext();
    }

    @Override
    public void resumeWith(@NonNull Object resultOrException) {
        Log.i(TAG, "Result: " + resultOrException);
    }
});
```

</Block>
</BlockSwitcher>
</InlineFilter>


Contents of build-a-backend_auth_use-existing-cognito-resources_index.txt:
import { getCustomStaticPath } from '@/utils/getCustomStaticPath';

export const meta = {
  title: 'Use existing Cognito resources',
  description: 'Learn how to use existing auth resources',
  platforms: [
    'android',
    'angular',
    'flutter',
    'javascript',
    'nextjs',
    'react',
    'react-native',
    'swift',
    'vue'
  ]
};

export function getStaticPaths() {
  return getCustomStaticPath(meta.platforms);
}

export function getStaticProps(context) {
  return {
    props: {
      platform: context.params.platform,
      meta
    }
  };
}

Amplify Auth can be configured to use an existing Amazon Cognito user pool and identity pool. If you are in a team setting or part of a company that has previously created auth resources, you can [configure the client library directly](#use-auth-resources-without-an-amplify-backend), or maintain references with [AWS Cloud Development Kit (AWS CDK)](https://aws.amazon.com/cdk/) in your Amplify backend.

<Callout info>

**Note:** when using existing auth resources, it may be necessary to add additional policies or permissions for your authenticated and unauthenticated IAM roles. These changes must be performed manually.

</Callout>

## Use auth resources without an Amplify backend

<InlineFilter filters={["angular", "javascript", "nextjs", "react", "react-native", "vue"]}>

You can use existing resources without an Amplify backend by configuring the client library directly.

```ts title="src/main.ts"
import { Amplify } from "aws-amplify"

Amplify.configure({
  Auth: {
    Cognito: {
      userPoolId: "<your-cognito-user-pool-id>",
      userPoolClientId: "<your-cognito-user-pool-client-id>",
      identityPoolId: "<your-cognito-identity-pool-id>",
      loginWith: {
        email: true,
      },
      signUpVerificationMethod: "code",
      userAttributes: {
        email: {
          required: true,
        },
      },
      allowGuestAccess: true,
      passwordFormat: {
        minLength: 8,
        requireLowercase: true,
        requireUppercase: true,
        requireNumbers: true,
        requireSpecialCharacters: true,
      },
    },
  },
})
```

</InlineFilter>
<InlineFilter filters={["android", "flutter", "swift"]}>

Configuring the mobile client libraries directly is not supported, however you can manually create `amplify_outputs.json` with the following schema:

<Callout info>

**Note:** it is strongly recommended to use backend outputs to generate this file for each sandbox or branch deployment

</Callout>

```json title="amplify_outputs.json"
{
  "version": "1",
  "auth": {
    "aws_region": "<your-cognito-aws-region>",
    "user_pool_id": "<your-cognito-user-pool-id>",
    "user_pool_client_id": "<your-cognito-user-pool-client-id>",
    "identity_pool_id": "<your-cognito-identity-pool-id>",
    "username_attributes": ["email"],
    "standard_required_attributes": ["email"],
    "user_verification_types": ["email"],
    "unauthenticated_identities_enabled": true,
    "password_policy": {
      "min_length": 8,
      "require_lowercase": true,
      "require_uppercase": true,
      "require_numbers": true,
      "require_symbols": true
    }
  }
}
```

</InlineFilter>

## Use auth resources with an Amplify backend

If you have created Amazon Cognito resources outside of the context of your Amplify app such as creating resources through the AWS Console or consuming resources created by a separate team, you can use `referenceAuth` to reference the existing resources. It requires a user pool, a user pool client, identity pool, and an authenticated & unauthenticated IAM role configured on your identity pool.

```ts title="amplify/auth/resource.ts"
import { referenceAuth } from '@aws-amplify/backend';

export const auth = referenceAuth({
  userPoolId: 'us-east-1_xxxx',
  identityPoolId: 'us-east-1:b57b7c3b-9c95-43e4-9266-xxxx',
  authRoleArn: 'arn:aws:iam::xxxx:role/amplify-xxxx-mai-amplifyAuthauthenticatedU-xxxx',
  unauthRoleArn: 'arn:aws:iam::xxxx:role/amplify-xxxx-mai-amplifyAuthunauthenticate-xxxx',
  userPoolClientId: 'xxxx',
});
```

<Callout info>

The configuration of your referenced resources cannot be modified. IAM policies specific to your Amplify application will be appended to your authenticated and unauthenticated roles, and applications using the referenced resource will be able to create users in the Cognito user pool and identities in the Cognito identity pool.

</Callout>

You can also use the [`access` property](/[platform]/build-a-backend/auth/grant-access-to-auth-resources/) to grant permissions to your auth resource from other Amplify backend resources. For example, if you have a function that needs to retrieve details about a user:

```ts title="amplify/auth/resource.ts"
import { referenceAuth } from '@aws-amplify/backend';
import { getUser } from "../functions/get-user/resource";

export const auth = referenceAuth({
  userPoolId: 'us-east-1_xxxx',
  identityPoolId: 'us-east-1:b57b7c3b-9c95-43e4-9266-xxxx',
  authRoleArn: 'arn:aws:iam::xxxx:role/amplify-xxxx-mai-amplifyAuthauthenticatedU-xxxx',
  unauthRoleArn: 'arn:aws:iam::xxxx:role/amplify-xxxx-mai-amplifyAuthunauthenticate-xxxx',
  userPoolClientId: 'xxxx',
  access: (allow) => [
    allow.resource(getUser).to(["getUser"]),
  ],
});
```

In a team setting you may want to reference a different set of auth resources depending on the deployment context. For instance if you have a `staging` branch that should reuse resources from a separate "staging" environment compared to a `production` branch that should reuse resources from the separate "production" environment. In this case we recommend using environment variables.

```ts title="amplify/auth/resource.ts"
import { referenceAuth } from '@aws-amplify/backend';

export const auth = referenceAuth({
  userPoolId: process.env.MY_USER_POOL_ID,
  identityPoolId: process.env.MY_IDENTITY_POOL_ID,
  authRoleArn: process.env.MY_AUTH_ROLE_ARN,
  unauthRoleArn: process.env.MY_UNAUTH_ROLE_ARN,
  userPoolClientId: process.env.MY_USER_POOL_CLIENT_ID,
});
```

Environment variables must be configured separately on your machine for sandbox deployments and Amplify console for branch deployments.

## Next steps

- [Learn how to connect your frontend](/[platform]/build-a-backend/auth/connect-your-frontend/)


Contents of build-a-backend_data_aws-appsync-apollo-extensions_index.txt:
import { getCustomStaticPath } from '@/utils/getCustomStaticPath';

export const meta = {
  title: 'AWS AppSync Apollo Extensions',
  description:
    'AWS AppSync Apollo Extensions',
  platforms: [
    'android',
    'swift',
  ]
};

export function getStaticPaths() {
  return getCustomStaticPath(meta.platforms);
}

export function getStaticProps(context) {
  return {
    props: {
      platform: context.params.platform,
      meta
    }
  };
}

AWS AppSync Apollo Extensions provide a seamless way to connect to your AWS AppSync backend using Apollo client, an open-source GraphQL client.
<InlineFilter filters={["swift"]}>

To learn more about Apollo, see https://www.apollographql.com/docs/ios/.

</InlineFilter>

<InlineFilter filters={["android"]}>

To learn more about Apollo, see https://www.apollographql.com/docs/kotlin.

</InlineFilter>

## Features

AWS AppSync Apollo Extensions provide AWS AppSync authorizers to be used with the Apollo client to make it simple to apply the correct authorization payloads to your GraphQL operations.

<InlineFilter filters={["android"]}>
Additionally, we publish an optional Amplify extension that allows Amplify to provide auth tokens and signing logic for the corresponding Authorizers.
</InlineFilter>

<InlineFilter filters={["swift"]}>
Additionally, the included Amplify components allow Amplify to provide auth tokens and signing logic for the corresponding Authorizers.
</InlineFilter>

## Install the AWS AppSync Apollo Extensions library

<InlineFilter filters={["android"]}>

<BlockSwitcher>

<Block name="With Amplify">

Add the `apollo-appsync-amplify` dependency to your app/build.gradle.kts file.

```kotlin title="app/build.gradle.kts"
dependencies {
    // highlight-start
    // Connect Apollo to AppSync, delegating some implementation details to Amplify
    implementation("com.amplifyframework:apollo-appsync-amplify:1.0.0")    
    // highlight-end
}
```

</Block>

<Block name="Without Amplify">

Add the `apollo-appsync` dependency to your app/build.gradle.kts file.

```kotlin title="app/build.gradle.kts"
dependencies {
    // highlight-start
    // Connect Apollo to AppSync without using Amplify
    implementation("com.amplifyframework:apollo-appsync:1.0.0")    
    // highlight-end
}
```
</Block>

</BlockSwitcher>

</InlineFilter>

<InlineFilter filters={["swift"]}>

Add AWS AppSync Apollo Extensions into your project using Swift Package Manager.

Enter its GitHub URL (`https://github.com/aws-amplify/aws-appsync-apollo-extensions-swift`), select **Up to Next Major Version** and click **Add Package**

* Select the following libraries:
    * **AWSAppSyncApolloExtensions**

</InlineFilter>

## Connecting to AWS AppSync with Apollo client

<InlineFilter filters={["android"]}>

### Creating the ApolloClient

<BlockSwitcher>

<Block name="With Amplify">
Before you begin, you will need an Amplify Data backend deploy. To get started, see [Set up Data](/[platform]/build-a-backend/data/set-up-data/). 

Once you have deployed your backend and created the `amplify_outputs.json` file, you can use Amplify library to read and retrieve your configuration values with the following steps:

```kotlin
// Use apiKey auth mode, reading configuration from AmplifyOutputs
val connector = ApolloAmplifyConnector(context, AmplifyOutputs(R.raw.amplify_outputs))
val apolloClient = ApolloClient.Builder()
    .appSync(connector.endpoint, connector.apiKeyAuthorizer())
    .build()
```
</Block>

<Block name="Without Amplify">
You can create your Apollo client by using our provided AWS AppSync endpoint and authorizer classes. 

```kotlin
val endpoint = AppSyncEndpoint("<your_appsync_endpoint>")
// Continue Reading to see more authorizer examples
val authorizer = ApiKeyAuthorizer("[API_KEY]") 
val apolloClient = ApolloClient.Builder()
    .appSync(endpoint, authorizer)
    .build()
```
</Block>

</BlockSwitcher>

### Providing AppSync Authorizers

<BlockSwitcher>

<Block name="With Amplify">

The AWS AppSync Apollo Extensions library provides a number of Authorizer classes to match the various authorization strategies that may be in use in your schema. You should choose the appropriate Authorizer type for your authorization strategy. To read more about the strategies and their corresponding auth modes, see [Available authorization strategies](/[platform]/build-a-backend/data/customize-authz/#available-authorization-strategies).

Some common ones are

*  `publicAPIkey` strategy, `apiKey` authMode, **APIKeyAuthorizer**
*  `guest` strategy, `identityPool` authMode, **IAMAuthorizer**
*  `owner` strategy, `userPool` authMode, **AuthTokenAuthorizer**

If you define multiple authorization strategies within your schema, you will have to create separate Apollo client instances for each Authorizer that you want to use in your app.

#### API_KEY

An `ApiKeyAuthorizer` can read the API key from `amplify_outputs.json`, provide a hardcoded API key, or fetch the API key from some source:

```kotlin
// highlight-start
// Using ApolloAmplifyConnector to read API key from amplify_outputs.json
val connector = ApolloAmplifyConnector(context, AmplifyOutputs(R.raw.amplify_outputs))
val authorizer = connector.apiKeyAuthorizer()
//highlight-end
// or
// highlight-start
// Use a hard-coded API key
val authorizer = ApiKeyAuthorizer("[API_KEY]")
//highlight-end
// or
// highlight-start
// Fetch the API key from some source. This function may be called many times,
// so it should implement appropriate caching internally.
val authorizer = ApiKeyAuthorizer { fetchApiKey() }
//highlight-end
```

#### AMAZON_COGNITO_USER_POOLS

You can use `AmplifyApolloConnector` to get an `AuthTokenAuthorizer` instance that supplies the token for the current logged-in Amplify user, or implement the token fetching yourself.

```kotlin
// highlight-start
// Using ApolloAmplifyConnector to get the authorizer that connects to your 
// Amplify instance
val connector = ApolloAmplifyConnector(context, AmplifyOutputs(R.raw.amplify_outputs))
val authorizer = connector.authTokenAuthorizer()
//highlight-end
// or
// highlight-start
// Using the ApolloAmplifyConnector companion function
val authorizer = AuthTokenAuthorizer { 
  ApolloAmplifyConnector.fetchLatestCognitoAuthToken() 
}
//highlight-end
// or
// highlight-start
// Use your own token fetching. This function may be called many times,
// so it should implement appropriate caching internally.
val authorizer = AuthTokenAuthorizer {
  fetchLatestAuthToken()
}
//highlight-end
```

You can provide your own custom `fetchLatestAuthToken` provider for **AWS_LAMBDA** and **OPENID_CONNECT** auth modes. 

#### AWS_IAM

You can use the `ApolloAmplifyConnector` to delegate token fetching and request 
signing to Amplify.

```kotlin
// highlight-start
// Using ApolloAmplifyConnector to get the authorizer that connects to your 
// Amplify instance
val connector = ApolloAmplifyConnector(context, AmplifyOutputs(R.raw.amplify_outputs))
val authorizer = connector.iamAuthorizer()
//highlight-end
// or
// highlight-start
// Using the ApolloAmplifyConnector companion function
val authorizer = IamAuthorizer { 
  ApolloAmplifyConnector.signAppSyncRequest(it, "us-east-1") 
}
//highlight-end
```

</Block>

<Block name="Without Amplify">

AWS AppSync supports the following [authorization modes](https://docs.aws.amazon.com/appsync/latest/devguide/security-authz.html). Use the corresponding Authorizer that matches the chosen authorization type. 

Some common ones are

*  API Key Authorization -> **APIKeyAuthorizer**
*  IAM Authorization -> **IAMAuthorizer**
*  Cognito User Pools -> **AuthTokenAuthorizer**

If you apply multiple authorization directives in your schema, you will have to create separate Apollo client instances for each Authorizer that you want to use in your app.

#### API_KEY

An `ApiKeyAuthorizer` can be used with a hardcoded API key or by fetching the key from some source.:

```kotlin
// highlight-start
// Use a hard-coded API key
val authorizer = ApiKeyAuthorizer("[API_KEY]")
//highlight-end
// or
// highlight-start
// Fetch the API key from some source. This function may be called many times,
// so it should implement appropriate caching internally.
val authorizer = ApiKeyAuthorizer { fetchApiKey() }
//highlight-end
```

#### AMAZON_COGNITO_USER_POOLS

When working directly with AppSync, you must implement the token fetching yourself.

```kotlin
// highlight-start
// Use your own token fetching. This function may be called many times,
// so it should implement appropriate caching internally.
val authorizer = AuthTokenAuthorizer {
  fetchLatestAuthToken()
}
//highlight-end
```

#### AWS_IAM

When working directly with AppSync, you must implement the request signing yourself.

```kotlin
// highlight-start
// Provide an implementation of the signing function. This function should implement the 
// AWS Sig-v4 signing logic and return the authorization headers containing the token and signature.
val authorizer = IamAuthorizer { signRequestAndReturnHeaders(it) }
// highlight-end
```
</Block>

</BlockSwitcher>

</InlineFilter>


<InlineFilter filters={["swift"]}>
AWS AppSync supports the following [authorization modes](https://docs.aws.amazon.com/appsync/latest/devguide/security-authz.html):

### API_KEY

```swift
import AWSAppSyncApolloExtensions

let authorizer = APIKeyAuthorizer(apiKey: "[API_KEY]")
let interceptor = AppSyncInterceptor(authorizer)
```

### AMAZON_COGNITO_USER_POOLS

If you are using Amplify Auth, you can create a method that retrieves the Cognito access token

```swift
import Amplify

func getUserPoolAccessToken() async throws -> String {
    let authSession = try await Amplify.Auth.fetchAuthSession()
    if let result = (authSession as? AuthCognitoTokensProvider)?.getCognitoTokens() {
        switch result {
        case .success(let tokens):
            return tokens.accessToken
        case .failure(let error):
            throw error
        }
    }
    throw AuthError.unknown("Did not receive a valid response from fetchAuthSession for get token.")
}
```

Then create the AuthTokenAuthorizer with this method.

```swift
import AWSAppSyncApolloExtensions

let authorizer = AuthTokenAuthorizer(fetchLatestAuthToken: getUserPoolAccessToken)
let interceptor = AppSyncInterceptor(authorizer)
```

### AWS_IAM

If you are using Amplify Auth, you can use the following method for AWS_IAM auth

```swift
import AWSCognitoAuthPlugin
import AWSAppSyncApolloExtensions

let authorizer = IAMAuthorizer(
    signRequest: AWSCognitoAuthPlugin.createAppSyncSigner(
        region: "[REGION]"))
```
</InlineFilter>

<InlineFilter filters={["swift"]}>
## Connecting Amplify Data to Apollo client

Before you begin, you will need an Amplify Data backend deploy. To get started, see [Set up Data](/[platform]/build-a-backend/data/set-up-data/). 

Once you have deployed your backend and created the `amplify_outputs.json` file, you can use Amplify library to read and retrieve your configuration values with the following steps:

1. Enter its GitHub URL (`https://github.com/aws-amplify/amplify-swift`), select **Up to Next Major Version** and click **Add Package**
2. Select the following libraries:
    1. **AWSPluginsCore**
3. Drag and drop the `amplify_outputs.json` file into your Xcode project. 
4. Initialize the configuration with `try AWSAppSyncConfiguration(with: .amplifyOutputs)`

The resulting configuration object will have the `endpoint`, `region`, and optional `apiKey.` The following example shows reading the `amplify_outputs.json` file from the main bundle to instantiate the configuration and uses it to configure the Apollo client for **API_Key** authorization.

```swift
import Apollo
import ApolloAPI
import AWSPluginsCore
import AWSAppSyncApolloExtensions

func createApolloClient() throws -> ApolloClient {
   let store = ApolloStore(cache: InMemoryNormalizedCache())
   
    // 1. Read AWS AppSync API configuration from `amplify_outputs.json`
    let configuration = try AWSAppSyncConfiguration(with: .amplifyOutputs)
    
   // 2. Use `configuration.apiKey` with APIKeyAuthorizer
    let authorizer = APIKeyAuthorizer(apiKey: configuration.apiKey ?? "")
    let interceptor = AppSyncInterceptor(authorizer)
    let interceptorProvider = DefaultPrependInterceptorProvider(interceptor: interceptor,
                                                                store: store)
   // 3. Use `configuration.endpoint` with RequestChainNetworkTransport
    let transport = RequestChainNetworkTransport(interceptorProvider: interceptorProvider,
                                                endpointURL: configuration.endpoint)

    return ApolloClient(networkTransport: transport, store: store)
}
```

The AWS AppSync Apollo Extensions library provides a number of Authorizer classes to match the various authorization strategies that may be in use in your schema. You should choose the appropriate Authorizer type for your authorization strategy. To read more about the strategies and their corresponding auth modes, see [Available authorization strategies](/[platform]/build-a-backend/data/customize-authz/#available-authorization-strategies).

Some common ones are

*  `publicAPIkey` strategy, `apiKey` authMode, **APIKeyAuthorizer**
*  `guest` strategy, `identityPool` authMode, **IAMAuthorizer**
*  `owner` strategy, `userPool` authMode, **AuthTokenAuthorizer**

If you define multiple authorization strategies within your schema, you will have to create separate Apollo client instances for each Authorizer that you want to use in your app.

</InlineFilter>

## Downloading the AWS AppSync schema

The schema is used by Apollo’s code generation tool to generate API code that helps you execute GraphQL operations. The following steps integrate your AppSync schema with Apollo's code generation process:

<InlineFilter filters={["swift"]}>
1. Navigate to your API on the [AWS AppSync console](https://console.aws.amazon.com/appsync/home)
2. On the left side, select Schema
3. Select the "Export schema" dropdown and download the `schema.json` file.
4. Add this file to your project as directed by [Apollo Code Generation documentation](https://www.apollographql.com/docs/ios/code-generation/introduction). 

You can alternatively download the introspection schema using the [`fetch-schema`](https://www.apollographql.com/docs/ios/code-generation/codegen-cli#fetch-schema) command with the `amplify-ios-cli` tool.

</InlineFilter>

<InlineFilter filters={["android"]}>

1. Navigate to your API on the [AWS AppSync console](https://console.aws.amazon.com/appsync/home)
2. On the left side, select Schema
3. Select the "Export schema" dropdown and download the `schema.json` file.
4. Add this file to your project as directed by [Apollo documentation](https://www.apollographql.com/docs/kotlin/advanced/plugin-recipes#specifying-the-schema-location) 

</InlineFilter>

## Generating Queries, Mutations, and Subscriptions for Apollo client

<InlineFilter filters={["android"]}>

<BlockSwitcher>

<Block name="With Amplify">
**Amplify provided .graphql files**
1. Within your Amplify Gen 2 backend, run: `npx ampx generate graphql-client-code --format graphql-codegen --statement-target graphql --out graphql`
2. Copy the generated files (`mutations.graphql`, `queries.graphql`, `subscriptions.graphql`) to your `{app}/src/main/graphql` folder as shown in the [Apollo documentation](https://www.apollographql.com/docs/kotlin#getting-started)

**Manual**
1. Navigate to the **Queries** tab in your API on the [AWS AppSync console](https://console.aws.amazon.com/appsync/home). Here, you can test queries, mutations, and subscriptions in the GraphQL playground.
2. Enter your GraphQL operation (query, mutation, or subscription) in the editor and select **Run** to execute it.
3. Observe the request and response structure in the results. This gives you insight into the exact call patterns and structure that Apollo will use.
4. Copy the GraphQL operation(s) from the playground and pass them to to your `{app}/src/main/graphql` folder as shown in the [Apollo documentation](https://www.apollographql.com/docs/kotlin#getting-started)

</Block>

<Block name="Without Amplify">

1. Navigate to the **Queries** tab in your API on the [AWS AppSync console](https://console.aws.amazon.com/appsync/home). Here, you can test queries, mutations, and subscriptions in the GraphQL playground.
2. Enter your GraphQL operation (query, mutation, or subscription) in the editor and click **Run** to execute it.
3. Observe the request and response structure in the results. This gives you insight into the exact call patterns and structure that Apollo will use.
4. Copy the GraphQL operation from the playground and pass it to Apollo's code generation tool to automatically generate the corresponding API code for your project.

</Block>

</BlockSwitcher>

</InlineFilter>

<InlineFilter filters={["swift"]}>

1. Navigate to the **Queries** tab in your API on the [AWS AppSync console](https://console.aws.amazon.com/appsync/home). Here, you can test queries, mutations, and subscriptions in the GraphQL playground.
2. Enter your GraphQL operation (query, mutation, or subscription) in the editor and click **Run** to execute it.
3. Observe the request and response structure in the results. This gives you insight into the exact call patterns and structure that Apollo will use.
4. Copy the GraphQL operation from the playground and pass it to Apollo's code generation tool to automatically generate the corresponding API code for your project.

</InlineFilter>

<InlineFilter filters={["android"]}>

## Type Mapping AppSync Scalars
By default, [AWS AppSync Scalars](https://docs.aws.amazon.com/appsync/latest/devguide/scalars.html#graph-ql-aws-appsync-scalars) will default to the `Any` type. You can map these scalars to more explicit types by editing the `apollo` block in your `app/build.gradle[.kts]` file. In the example below, we are now mapping a few of our AppSync scalar types to `String` instead of `Any`. Additional improvements could be made by writing [custom class adapters](https://www.apollographql.com/docs/kotlin/essentials/custom-scalars#define-class-mapping) to convert date/time scalars into Kotlin date/time class types.

```kotlin
apollo {
    service("{serviceName}") {
        packageName.set("{packageName}")
        mapScalarToKotlinString("AWSDateTime")
        mapScalarToKotlinString("AWSEmail")
    }
}
```
</InlineFilter>

<InlineFilter filters={["swift"]}>

## Connecting to AWS AppSync real-time endpoint

The following example shows how you can create an Apollo client that allows performing GraphQL subscription operations with AWS AppSync. 

```swift
import Apollo
import ApolloAPI
import ApolloWebSocket
import AWSPluginsCore
import AWSAppSyncApolloExtensions

func createApolloClient() throws -> ApolloClient {
    let store = ApolloStore(cache: InMemoryNormalizedCache())
    let configuration = try AWSAppSyncConfiguration(with: .amplifyOutputs)
   
    // 1. Create your authorizer
    let authorizer = /* your Authorizer */
    let interceptor = AppSyncInterceptor(authorizer)

    let interceptorProvider = DefaultPrependInterceptorProvider(interceptor: interceptor,
                                                                store: store)
    let transport = RequestChainNetworkTransport(interceptorProvider: interceptorProvider,
                                                    endpointURL: configuration.endpoint)

    // 2. Create the AWS AppSync compatible websocket client
    let websocket = AppSyncWebSocketClient(endpointURL: configuration.endpoint,
                                            authorizer: authorizer)
    // 3. Add it to the WebSocketTransport
    let webSocketTransport = WebSocketTransport(websocket: websocket)
    // 4. Create a SplitNetworkTransport
    let splitTransport = SplitNetworkTransport(
        uploadingNetworkTransport: transport,
        webSocketNetworkTransport: webSocketTransport
    )
    // 5. Pass the SplitNetworkTransport to the ApolloClient
    return ApolloClient(networkTransport: splitTransport, store: store)
}
```

</InlineFilter>


Contents of build-a-backend_data_connect-event-api_index.txt:
import { getCustomStaticPath } from '@/utils/getCustomStaticPath';

export const meta = {
  title: 'Connect to AWS AppSync Events',
  description:
    'Connect to AWS AppSync Events',
  platforms: [
    'angular',
    'javascript',
    'nextjs',
    'react',
    'react-native',
    'vue'
  ]
};

export const getStaticPaths = async () => {
  return getCustomStaticPath(meta.platforms);
};

export function getStaticProps(context) {
  return {
    props: {
      platform: context.params.platform,
      meta
    }
  };
}

This guide walks through how you can connect to AWS AppSync Events using the Amplify library.

AWS AppSync Events lets you create secure and performant serverless WebSocket APIs that can broadcast real-time event data to millions of subscribers, without you having to manage connections or resource scaling. With this feature, you can build multi-user features such as a collaborative document editors, chat apps, and live polling systems.

Learn more about AWS AppSync Events by visiting the [Developer Guide](https://docs.aws.amazon.com/appsync/latest/eventapi/event-api-welcome.html).

## Connect to an Event API without an existing Amplify backend

Before you begin, you will need:

- An Event API created via the AWS Console
- Take note of: HTTP endpoint, region, API Key

```tsx title="src/App.tsx"
import type { EventsChannel } from 'aws-amplify/data';
import { useState, useEffect } from 'react';
import { Amplify } from 'aws-amplify';
import { events } from 'aws-amplify/data';

Amplify.configure({
  API: {
    Events: {
      endpoint:
        'https://abcdefghijklmnopqrstuvwxyz.appsync-api.us-east-1.amazonaws.com/event',
      region: 'us-east-1',
      defaultAuthMode: 'apiKey',
      apiKey: 'da2-abcdefghijklmnopqrstuvwxyz'
    }
  }
});

export default function App() {
  const [myEvents, setMyEvents] = useState<unknown[]>([]);

  useEffect(() => {
    let channel: EventsChannel;

    const connectAndSubscribe = async () => {
      channel = await events.connect('default/channel');

      channel.subscribe({
        next: (data) => {
          console.log('received', data);
          setMyEvents((prev) => [data, ...prev]);
        },
        error: (err) => console.error('error', err)
      });
    };

    connectAndSubscribe();

    return () => channel && channel.close();
  }, []);

  async function publishEvent() {
    await events.post('default/channel', { some: 'data' });
  }

  return (
    <>
      <button onClick={publishEvent}>Publish Event</button>
      <ul>
        {myEvents.map((data) => (
          <li key={data.id}>{JSON.stringify(data.event)}</li>
        ))}
      </ul>
    </>
  );
}
```

## Add an Event API to an existing Amplify backend

This guide walks through how you can add an Event API to an existing Amplify backend. We'll be using Cognito User Pools for authenticating with Event API from our frontend application. Any signed in user will be able to subscribe to the Event API and publish events.

Before you begin, you will need:

- An existing Amplify backend (see [Quickstart](/[platform]/start/quickstart/))
- Latest versions of `@aws-amplify/backend` and `@aws-amplify/backend-cli` (`npm add @aws-amplify/backend@latest @aws-amplify/backend-cli@latest`)

### Update Backend Definition

First, we'll add a new Event API to our backend definition.

```ts title="amplify/backend.ts"
import { defineBackend } from '@aws-amplify/backend';
import { auth } from './auth/resource';
// highlight-start
// import CDK resources:
import {
  CfnApi,
  CfnChannelNamespace,
  AuthorizationType,
} from 'aws-cdk-lib/aws-appsync';
import { Policy, PolicyStatement } from 'aws-cdk-lib/aws-iam';
// highlight-end

const backend = defineBackend({
	auth,
});

// highlight-start
// create a new stack for our Event API resources:
const customResources = backend.createStack('custom-resources');

// add a new Event API to the stack:
const cfnEventAPI = new CfnApi(customResources, 'CfnEventAPI', {
  name: 'my-event-api',
  eventConfig: {
    authProviders: [
      {
        authType: AuthorizationType.USER_POOL,
        cognitoConfig: {
          awsRegion: customResources.region,
          // configure Event API to use the Cognito User Pool provisioned by Amplify:
          userPoolId: backend.auth.resources.userPool.userPoolId,
        },
      },
    ],
    // configure the User Pool as the auth provider for Connect, Publish, and Subscribe operations:
    connectionAuthModes: [{ authType: AuthorizationType.USER_POOL }],
    defaultPublishAuthModes: [{ authType: AuthorizationType.USER_POOL }],
    defaultSubscribeAuthModes: [{ authType: AuthorizationType.USER_POOL }],
  },
});

// create a default namespace for our Event API:
const namespace = new CfnChannelNamespace(
  customResources,
  'CfnEventAPINamespace',
  {
    apiId: cfnEventAPI.attrApiId,
    name: 'default',
  }
);

// attach a policy to the authenticated user role in our User Pool to grant access to the Event API:
backend.auth.resources.authenticatedUserIamRole.attachInlinePolicy(
  new Policy(customResources, 'AppSyncEventPolicy', {
    statements: [
      new PolicyStatement({
        actions: [
          'appsync:EventConnect',
          'appsync:EventSubscribe',
          'appsync:EventPublish',
        ],
        resources: [`${cfnEventAPI.attrApiArn}/*`, `${cfnEventAPI.attrApiArn}`],
      }),
    ],
  })
);

// finally, add the Event API configuration to amplify_outputs:
backend.addOutput({
  custom: {
    events: {
      url: `https://${cfnEventAPI.getAtt('Dns.Http').toString()}/event`,
      aws_region: customResources.region,
      default_authorization_type: AuthorizationType.USER_POOL,
    },
  },
});
// highlight-end
```

### Deploy Backend

To test your changes, deploy your Amplify Sandbox.

```bash title="Terminal" showLineNumbers={false}
npx ampx sandbox
```

### Connect your frontend application

After the sandbox deploys, connect your frontend application to the Event API. We'll be using the [Amplify Authenticator component](https://ui.docs.amplify.aws/react/connected-components/authenticator) to sign in to our Cognito User Pool.

If you don't already have the Authenticator installed, you can install it by running `npm add @aws-amplify/ui-react`.

```tsx title="src/App.tsx"
import { useEffect, useState } from 'react';
import { Amplify } from 'aws-amplify';
import { events, type EventsChannel } from 'aws-amplify/data';
import { Authenticator } from '@aws-amplify/ui-react';
import '@aws-amplify/ui-react/styles.css';
import outputs from '../amplify_outputs.json';

Amplify.configure(outputs);

export default function App() {
  const [myEvents, setMyEvents] = useState<Record<string, any>[]>([]);

  useEffect(() => {
    let channel: EventsChannel;

    const connectAndSubscribe = async () => {
      channel = await events.connect('default/channel');

      channel.subscribe({
        next: (data) => {
          console.log('received', data);
          setMyEvents((prev) => [data, ...prev]);
        },
        error: (err) => console.error('error', err),
      });
    };

    connectAndSubscribe();

    return () => channel && channel.close();
  }, []);

  async function publishEvent() {
    await events.post('default/channel', { some: 'data' });
  }

  return (
    <Authenticator>
      {({ signOut, user }) => (
        <>
          <div>
            <h1>Welcome, {user.username}</h1>
            <button onClick={signOut}>Sign Out</button>
          </div>
          <div>
            <button onClick={publishEvent}>Publish Event</button>
            <ul>
            {myEvents.map((data) => (
              <li key={data.id}>{JSON.stringify(data.event)}</li>
              ))}
            </ul>
          </div>
        </>
      )}
    </Authenticator>
  );
}
```


Contents of build-a-backend_data_connect-from-server-runtime_index.txt:
import { getChildPageNodes } from '@/utils/getChildPageNodes';
import { getCustomStaticPath } from '@/utils/getCustomStaticPath';

export const meta = {
  title: 'Connect to data from Server-side Runtimes',
  description:
    'Connect to Amplify Data from Next.js and Nuxt.js Server-side Runtimes (SSR).',
  route: '/[platform]/build-a-backend/data/connect-from-server-runtime',
  platforms: [
    'android',
    'angular',
    'javascript',
    'nextjs',
    'react',
    'react-native',
    'swift',
    'vue'
  ]
};

export const getStaticPaths = async () => {
  return getCustomStaticPath(meta.platforms);
};

export function getStaticProps(context) {
  const childPageNodes = getChildPageNodes(meta.route);
  return {
    props: {
      meta,
      childPageNodes
    }
  };
}

<Overview childPageNodes={props.childPageNodes} />


Contents of build-a-backend_data_connect-from-server-runtime_nextjs-server-runtime_index.txt:
import { getCustomStaticPath } from '@/utils/getCustomStaticPath';

export const meta = {
  title: 'Next.js server runtime',
  description:
    'Connect to Amplify Data from Next.js Server-side Runtime (SSR).',
  platforms: [
    'android',
    'angular',
    'javascript',
    'nextjs',
    'react',
    'react-native',
    'swift',
    'vue'
  ]
};

export const getStaticPaths = async () => {
  return getCustomStaticPath(meta.platforms);
};

export function getStaticProps(context) {
  return {
    props: {
      platform: context.params.platform,
      meta
    }
  };
}

This guide walks through how you can connect to Amplify Data from Next.js Server-side Runtimes (SSR). For Next.js applications, Amplify provides first-class support for the [App Router (React Server Components, Route Handlers, and Server Actions)](https://nextjs.org/docs/app), the [Pages Router (Components, API Routes)](https://nextjs.org/docs/pages), and [Middleware](https://nextjs.org/docs/app/building-your-application/routing/middleware).

Before you begin, you will need:

- [A Next.js application created](/[platform]/start/quickstart/)
- [Installed and configured Amplify libraries for Next.js](/nextjs/build-a-backend/server-side-rendering/)
- [Deployed Amplify Data resources](/[platform]/build-a-backend/data/set-up-data/), or directly using [AWS AppSync](https://aws.amazon.com/appsync/)

## Connect to Amplify Data from a Next.js server runtime

Connecting to Amplify Data will include choosing the correct data client for Next.js server runtimes, generating the data client, and then calling the API.

### Step 1 - Choose the correct Data client for Next.js server runtimes

Amplify offers two specialized data clients for Next.js server runtimes (from `@aws-amplify/adapter-nextjs/data`) that you should use depending whether you retrieve the user tokens using [`cookies`](https://nextjs.org/docs/app/api-reference/functions/cookies) or [`NextRequest`](https://nextjs.org/docs/app/api-reference/functions/next-request) and [`NextResponse`](https://nextjs.org/docs/app/api-reference/functions/next-response):

- `generateServerClientUsingCookies()` 🍪 generates a data client with the Next.js `cookies` function from `next/headers`. Each API request dynamically refetches the cookies at runtime.
- `generateServerClientUsingReqRes()` 🌐 generates a data client requiring `NextRequest` and `NextResponse` provided to an `runWithAmplifyServerContext` function to prevent token contamination.

Choose the correct data client based on your Next.js Router (App or Pages) and then the use case:

<BlockSwitcher>

<Block name="App Router">

| Use case               | Required Data client                 |
| ---------------------- | --------------------------------------- |
| React Server Component | `generateServerClientUsingCookies()` 🍪 |
| Server Actions         | `generateServerClientUsingCookies()` 🍪 |
| Route Handler          | `generateServerClientUsingCookies()` 🍪 |
| Middleware             | `generateServerClientUsingReqRes()` 🌐  |

</Block>

<Block name="Pages Router">

**Pages Router**

| Use case                   | Required Data client                |
| -------------------------- | -------------------------------------- |
| Server-side component code | `generateServerClientUsingReqRes()` 🌐 |
| API Route                  | `generateServerClientUsingReqRes()` 🌐 |
| Middleware                 | `generateServerClientUsingReqRes()` 🌐 |

</Block>

</BlockSwitcher>

### Step 2 - Generate the Data client for Next.js server runtimes

<BlockSwitcher>

<Block name="generateServerClientUsingCookies() 🍪">

To generate a Data client for the Next.js server runtime using cookies, you need to provide both your Amplify configuration and the cookies function from Next.js.

```ts
import { type Schema } from '@/amplify/data/resource';
import { generateServerClientUsingCookies } from '@aws-amplify/adapter-nextjs/data';
import outputs from '@/amplify_outputs.json';
import { cookies } from 'next/headers';

export const cookieBasedClient = generateServerClientUsingCookies<Schema>({
  config: outputs,
  cookies,
});
```

<Callout>

We recommend you generate Amplify Data's server client in a utility file. Then, import the generated client in your Next.js React Server Components, Server Actions, or Route Handlers.

</Callout>

</Block>

<Block name="generateServerClientUsingReqRes() 🌐">

To generate a data client for the Next.js server runtime using `NextRequest` and `NextResponse`, you only need to provide your Amplify configuration. When making the individual API requests, you will need to pass the config to the [`runWithAmplifyServerContext`](/[platform]/build-a-backend/server-side-rendering) function to pass in the cookies from request and response variables.

```ts
import { type Schema } from '@/amplify/data/resource';
import { createServerRunner } from '@aws-amplify/adapter-nextjs';
import { generateServerClientUsingReqRes } from '@aws-amplify/adapter-nextjs/data';
import outputs from '@/amplify_outputs.json';

export const { runWithAmplifyServerContext } = createServerRunner({
  config: outputs,
});

export const reqResBasedClient = generateServerClientUsingReqRes<Schema>({
  config: outputs,
});
```

<Callout>

We recommend you generate the server Data client in a utility file. Then, import the generated client in your Next.js Middleware, component's server runtime code, and API Routes.

</Callout>

</Block>

</BlockSwitcher>

### Step 3 - Call API using generated server Data clients

You can make any available query or mutation request with the generated server data clients; however, note that subscriptions are not available within server runtimes.

<BlockSwitcher>

<Block name="generateServerClientUsingCookies() 🍪">

Import the cookie-based server Data client in your Next.js React Server Component code and make your API requests.

```ts
import { type Schema } from '@/amplify/data/resource';
import { generateServerClientUsingCookies } from '@aws-amplify/adapter-nextjs/data';
import outputs from '@/amplify_outputs.json';
import { cookies } from 'next/headers';

export const cookieBasedClient = generateServerClientUsingCookies<Schema>({
  config: outputs,
  cookies,
});

const fetchTodos = async () => {
  const { data: todos, errors } = await cookieBasedClient.models.Todo.list();

  if (!errors) {
    return todos;
  }
};
```

</Block>

<Block name="generateServerClientUsingReqRes() 🌐">

Import the NextRequest/NextResponse-based server Data client in your Next.js server runtime code and make your API requests within the `runWithAmplifyServerContext` function. Review [Server-side Rendering](/[platform]/build-a-backend/server-side-rendering) to learn more about creating an Amplify server context.

For example, in a Next.js Pages Router API route, use the `req` and `res` parameters from the `handler` function with `runWithAmplifyServerContext`:

```ts
import { type Schema } from '@/amplify/data/resource';
import type { NextApiRequest, NextApiResponse } from 'next';
import {
  runWithAmplifyServerContext,
  reqResBasedClient,
} from '@/utils/amplifyServerUtils';

type ResponseData = {
  todos: Schema['Todo']['type'][];
};

export default async function handler(
  request: NextApiRequest,
  response: NextApiResponse<ResponseData>
) {
  const todos = await runWithAmplifyServerContext({
    nextServerContext: { request, response },
    operation: async (contextSpec) => {
      const { data: todos } = await reqResBasedClient.models.Todo.list(
        contextSpec
      );
      return todos;
    },
  });

  response.status(200).json({ todos });
}
```

</Block>

</BlockSwitcher>


Contents of build-a-backend_data_connect-from-server-runtime_nuxtjs-server-runtime_index.txt:
import { getCustomStaticPath } from '@/utils/getCustomStaticPath';

export const meta = {
  title: 'Nuxt.js server runtime',
  description:
    'Connect to Amplify Data from Nuxt.js Server-side Runtime (SSR).',
  platforms: [
    'angular',
    'javascript',
    'nextjs',
    'react',
    'react-native',
    'vue'
  ]
};

export const getStaticPaths = async () => {
  return getCustomStaticPath(meta.platforms);
};

export function getStaticProps(context) {
  return {
    props: {
      platform: context.params.platform,
      meta
    }
  };
}

This guide walks through how you can connect to Amplify Data from Nuxt.js Server-side Runtime (SSR). For Nuxt.js applications, Amplify provides first-class support for [Routing (Pages)](https://nuxt.com/docs/getting-started/routing) , [API Routes](https://nuxt.com/docs/guide/directory-structure/server#server-routes) , and [Middleware](https://nuxt.com/docs/guide/directory-structure/server#server-middleware).

Before you begin, you will need:

- [A Nuxt.js application created](https://nuxt.com/docs/getting-started/installation)
- [Deployed Amplify Data resources](/[platform]/build-a-backend/data/set-up-data/), or directly using [AWS AppSync](https://aws.amazon.com/appsync/)

## Connect to Amplify Data from a Nuxt.js server runtime

Connecting to Amplify Data will include setting up the AmplifyAPIs Plugin with the `runWithAmplifyServerContext` adapter,  using the `useNuxtApp()` composable, setting up the Amplify server context utility and then using the `runAmplifyApi` function to call the API in an isolated server context.

### Step 1 - Set up the AmplifyAPIs Plugin

Nuxt 3 offers universal rendering by default, where your data fetching logic may be executed on both the client and server sides. Amplify offers APIs that are capable of running within a server context to support use cases such as server-side rendering (SSR) and static site generation (SSG), though Amplify's client-side APIs and server-side APIs of Amplify are slightly different. You can set up an AmplifyAPIs plugin to make your data fetching logic run smoothly across the client and server. To learn more about how to use Amplify categories APIs in server side rendering, refer to this [documentation](/[platform]/build-a-backend/server-side-rendering/).

1. Create a `plugins` directory under the root of your Nuxt project. 
2. Create two files `01.amplify-apis.client.ts` and `01.amplify-apis.server.ts` under the `plugins` directory.

In these files, you will register both client-specific and server-specific Amplify APIs that you will use in your Nuxt project as a plugin. You can then access these APIs via the `useNuxtApp` composable.

<Callout>

**NOTE:** The leading number in the files name indicate the plugin loading order, for more details see https://nuxt.com/docs/guide/directory-structure/plugins#registration-order. The `.client` and `.server` indicate the runtime that the logic contained in the file will run on, client or server. For details see: https://nuxt.com/docs/guide/directory-structure/plugins

</Callout>

Modify the `01.amplify-apis.client.ts` file, with the following code:

<Accordion title='Expand to view the code implementation' headingLevel='4'>

```ts title="nuxt-amplify-gen2/plugins/01.amplify-apis.client.ts"
import {
  fetchAuthSession,
  fetchUserAttributes,
  signIn,
  signOut,
  getCurrentUser,
} from "aws-amplify/auth";
import { generateClient } from "aws-amplify/data";
import outputs from "../amplify_outputs.json";
import type { Schema } from "@/amplify/data/resource";
import { Amplify } from "aws-amplify";

// configure the Amplify client library
if (process.client) {
  Amplify.configure(outputs, { ssr: true });
}

// generate your data client using the Schema from your backend
const client = generateClient<Schema>();

export default defineNuxtPlugin({
  name: "AmplifyAPIs",
  enforce: "pre",
  setup() {
    return {
      provide: {
        // You can call the API by via the composable `useNuxtApp()`. For example:
        // `useNuxtApp().$Amplify.Auth.fetchAuthSession()`
        Amplify: {
          Auth: {
            fetchAuthSession,
            fetchUserAttributes,
            getCurrentUser,
            signIn,
            signOut,
          },
          GraphQL: {
            client,
          },
        },
      },
    };
  },
});
```
<Callout warning="true">

Make sure you call `Amplify.configure` as early as possible in your application’s life-cycle. A missing configuration or `NoCredentials` error is thrown if `Amplify.configure` has not been called before other Amplify JavaScript APIs. Review the [Library Not Configured Troubleshooting guide](/[platform]/build-a-backend/troubleshooting/library-not-configured/) for possible causes of this issue.

</Callout>

</Accordion>

Next, modify the `01.amplify-apis.server.ts` file, with the following code:

<Accordion title='Expand to view the code implementation' headingLevel='4'>

```ts title="nuxt-amplify-gen2/plugins/01.amplify-apis.server.ts"
import type { CookieRef } from "nuxt/app";
import {
  createKeyValueStorageFromCookieStorageAdapter,
  createUserPoolsTokenProvider,
  createAWSCredentialsAndIdentityIdProvider,
  runWithAmplifyServerContext,
} from "aws-amplify/adapter-core";
import { parseAmplifyConfig } from "aws-amplify/utils";
import {
  fetchAuthSession,
  fetchUserAttributes,
  getCurrentUser,
} from "aws-amplify/auth/server";
import { generateClient } from "aws-amplify/data/server";
import type {
  LibraryOptions,
  FetchAuthSessionOptions,
} from "@aws-amplify/core";
import type {
  GraphQLOptionsV6,
  GraphQLResponseV6,
} from "@aws-amplify/api-graphql";

import outputs from "../amplify_outputs.json";

// parse the content of `amplify_outputs.json` into the shape of ResourceConfig
const amplifyConfig = parseAmplifyConfig(outputs);

// create the Amplify used token cookies names array
const userPoolClientId = amplifyConfig.Auth!.Cognito.userPoolClientId;
const lastAuthUserCookieName = `CognitoIdentityServiceProvider.${userPoolClientId}.LastAuthUser`;

// create a GraphQL client that can be used in a server context
const gqlServerClient = generateClient({ config: amplifyConfig });

const getAmplifyAuthKeys = (lastAuthUser: string) =>
  ["idToken", "accessToken", "refreshToken", "clockDrift"]
    .map(
      (key) =>
        `CognitoIdentityServiceProvider.${userPoolClientId}.${lastAuthUser}.${key}`
    )
    .concat(lastAuthUserCookieName);

// define the plugin
export default defineNuxtPlugin({
  name: "AmplifyAPIs",
  enforce: "pre",
  setup() {
    // The Nuxt composable `useCookie` is capable of sending cookies to the
    // client via the `SetCookie` header. If the `expires` option is left empty,
    // it sets a cookie as a session cookie. If you need to persist the cookie
    // on the client side after your end user closes your Web app, you need to
    // specify an `expires` value.
    //
    // We use 30 days here as an example (the default Cognito refreshToken
    // expiration time).
    const expires = new Date();
    expires.setDate(expires.getDate() + 30);

    // Get the last auth user cookie value
    //
    // We use `sameSite: 'lax'` in this example, which allows the cookie to be
    // sent to your Nuxt server when your end user gets redirected to your Web
    // app from a different domain. You should choose an appropriate value for
    // your own use cases.
    const lastAuthUserCookie = useCookie(lastAuthUserCookieName, {
      sameSite: "lax",
      expires,
      secure: true,
    });

    // Get all Amplify auth token cookie names
    const authKeys = lastAuthUserCookie.value
      ? getAmplifyAuthKeys(lastAuthUserCookie.value)
      : [];

    // Create a key-value map of cookie name => cookie ref
    //
    // Using the composable `useCookie` here in the plugin setup prevents
    // cross-request pollution.
    const amplifyCookies = authKeys
      .map((name) => ({
        name,
        cookieRef: useCookie(name, { sameSite: "lax", expires, secure: true }),
      }))
      .reduce<Record<string, CookieRef<string | null | undefined>>>(
        (result, current) => ({
          ...result,
          [current.name]: current.cookieRef,
        }),
        {}
      );

    // Create a key value storage based on the cookies
    //
    // This key value storage is responsible for providing Amplify Auth tokens to
    // the APIs that you are calling.
    //
    // If you implement the `set` method, when Amplify needed to refresh the Auth
    // tokens on the server side, the new tokens would be sent back to the client
    // side via `SetCookie` header in the response. Otherwise the refresh tokens
    // would not be propagate to the client side, and Amplify would refresh
    // the tokens when needed on the client side.
    //
    // In addition, if you decide not to implement the `set` method, you don't
    // need to pass any `CookieOptions` to the `useCookie` composable.
    const keyValueStorage = createKeyValueStorageFromCookieStorageAdapter({
      get(name) {
        const cookieRef = amplifyCookies[name];

        if (cookieRef && cookieRef.value) {
          return { name, value: cookieRef.value };
        }

        return undefined;
      },
      getAll() {
        return Object.entries(amplifyCookies).map(([name, cookieRef]) => {
          return { name, value: cookieRef.value ?? undefined };
        });
      },
      set(name, value) {
        const cookieRef = amplifyCookies[name];
        if (cookieRef) {
          cookieRef.value = value;
        }
      },
      delete(name) {
        const cookieRef = amplifyCookies[name];

        if (cookieRef) {
          cookieRef.value = null;
        }
      },
    });

    // Create a token provider
    const tokenProvider = createUserPoolsTokenProvider(
      amplifyConfig.Auth!,
      keyValueStorage
    );

    // Create a credentials provider
    const credentialsProvider = createAWSCredentialsAndIdentityIdProvider(
      amplifyConfig.Auth!,
      keyValueStorage
    );

    // Create the libraryOptions object
    const libraryOptions: LibraryOptions = {
      Auth: {
        tokenProvider,
        credentialsProvider,
      },
    };

    return {
      provide: {
        // You can add the Amplify APIs that you will use on the server side of
        // your Nuxt app here. You must only use the APIs exported from the
        // `aws-amplify/<category>/server` subpaths.
        //
        // You can call the API by via the composable `useNuxtApp()`. For example:
        // `useNuxtApp().$Amplify.Auth.fetchAuthSession()`
        //
        // Recall that Amplify server APIs are required to be called in a isolated
        // server context that is created by the `runWithAmplifyServerContext`
        // function.
        Amplify: {
          Auth: {
            fetchAuthSession: (options: FetchAuthSessionOptions) =>
              runWithAmplifyServerContext(
                amplifyConfig,
                libraryOptions,
                (contextSpec) => fetchAuthSession(contextSpec, options)
              ),
            fetchUserAttributes: () =>
              runWithAmplifyServerContext(
                amplifyConfig,
                libraryOptions,
                (contextSpec) => fetchUserAttributes(contextSpec)
              ),
            getCurrentUser: () =>
              runWithAmplifyServerContext(
                amplifyConfig,
                libraryOptions,
                (contextSpec) => getCurrentUser(contextSpec)
              ),
          },
          GraphQL: {
            client: {
              // Follow this typing to ensure the`graphql` API return type can
              // be inferred correctly according to your queries and mutations
              graphql: <
                FALLBACK_TYPES = unknown,
                TYPED_GQL_STRING extends string = string
              >(
                options: GraphQLOptionsV6<FALLBACK_TYPES, TYPED_GQL_STRING>,
                additionalHeaders?: Record<string, string>
              ) =>
                runWithAmplifyServerContext<
                  GraphQLResponseV6<FALLBACK_TYPES, TYPED_GQL_STRING>
                >(amplifyConfig, libraryOptions, (contextSpec) =>
                  gqlServerClient.graphql(
                    contextSpec,
                    options,
                    additionalHeaders
                  )
                ),
            },
          },
        },
      },
    };
  },
});
```
</Accordion>

### Step 2 - Use the `useNuxtApp()` composable

Using the GraphQL API in `~/app.vue`:

```ts title="nuxt-amplify-gen2/app.vue"
<script setup lang="ts">
import { Authenticator } from '@aws-amplify/ui-vue';
import '@aws-amplify/ui-vue/styles.css';
import { onMounted, ref } from 'vue';
import type { Schema } from '@/amplify/data/resource';

// create a reactive reference to the array of todos
const todos = ref<Schema['Todo']['type'][]>([]);

async function listTodos() {
 try {
    // `$Amplify` is generated by Nuxt according to the `provide` key in the plugins
    // fetch all todos
    const { data } = await useNuxtApp().$Amplify.GraphQL.client.models.Todo.list();
    todos.value = data;

  } catch (error) {
     console.error('Error fetching todos', error);
  }
}

// fetch todos when the component is mounted
onMounted(() => {
  listTodos();
});
</script>


<template>
  <Authenticator>
    <template v-slot="{ user, signOut }">
      <h1>Hello, Amplify 👋</h1>
        <ul>
          <li v-for="todo in todos" :key="todo.id">{{ todo.content }}</li>
        </ul>
      <button @click="signOut">Sign Out</button>
    </template>
  </Authenticator>
</template>
```

The `app.vue` file can be rendered on both the client and server sides by default. The `useNuxtApp().$Amplify` composable will pick up the correct implementation of `01.amplify-apis.client.ts` and `01.amplify-apis.server.ts` to use, depending on the runtime.

<Callout warning>

Only a subset of Amplify APIs are usable on the server side, and as the libraries evolve, `amplify-apis.client` and `amplify-apis.server` may diverge further. You can guard your API calls to ensure an API is available in the context where you use it. E.g., you can use `if (process.client)` to ensure that a client-only API isn't executed on the server.

</Callout>

### Step 3 - Set up Amplify for API Routes

Following the specification of Nuxt, your API route handlers will live under `~/server`, which is a separate environment from other parts of your Nuxt app; hence, the plugins created in the previous step are not usable here, and extra work is required.

#### Setup Amplify Server Context Utility

1. Create a `utils` directory under the `server` directory of your Nuxt project. 
2. Create an `amplifyUtils.ts` file under the `utils` directory.

In this file, you will create a helper function to call Amplify APIs that are capable of running on the server side with context isolation. Modify the `amplifyUtils.ts` file, with the following code:

<Accordion title='Expand to view the code implementation' headingLevel='4'>

```ts title="nuxt-amplify-gen2/server/utils/amplifyUtils.ts"
import type { H3Event, EventHandlerRequest } from "h3";
import {
  createKeyValueStorageFromCookieStorageAdapter,
  createUserPoolsTokenProvider,
  createAWSCredentialsAndIdentityIdProvider,
  runWithAmplifyServerContext,
  AmplifyServer,
  CookieStorage,
} from "aws-amplify/adapter-core";
import { parseAmplifyConfig } from "aws-amplify/utils";

import type { LibraryOptions } from "@aws-amplify/core";
import outputs from "~/amplify_outputs.json";

const amplifyConfig = parseAmplifyConfig(outputs);

const createCookieStorageAdapter = (
  event: H3Event<EventHandlerRequest>
): CookieStorage.Adapter => {
  // `parseCookies`, `setCookie` and `deleteCookie` are Nuxt provided functions
  const readOnlyCookies = parseCookies(event);

  return {
    get(name) {
      if (readOnlyCookies[name]) {
        return { name, value: readOnlyCookies[name] };
      }
    },
    set(name, value, options) {
      setCookie(event, name, value, options);
    },
    delete(name) {
      deleteCookie(event, name);
    },
    getAll() {
      return Object.entries(readOnlyCookies).map(([name, value]) => {
        return { name, value };
      });
    },
  };
};

const createLibraryOptions = (
  event: H3Event<EventHandlerRequest>
): LibraryOptions => {
  const cookieStorage = createCookieStorageAdapter(event);
  const keyValueStorage =
    createKeyValueStorageFromCookieStorageAdapter(cookieStorage);
  const tokenProvider = createUserPoolsTokenProvider(
    amplifyConfig.Auth!,
    keyValueStorage
  );
  const credentialsProvider = createAWSCredentialsAndIdentityIdProvider(
    amplifyConfig.Auth!,
    keyValueStorage
  );

  return {
    Auth: {
      tokenProvider,
      credentialsProvider,
    },
  };
};

export const runAmplifyApi = <Result>(
  // we need the event object to create a context accordingly
  event: H3Event<EventHandlerRequest>,
  operation: (
    contextSpec: AmplifyServer.ContextSpec
  ) => Result | Promise<Result>
) => {
  return runWithAmplifyServerContext<Result>(
    amplifyConfig,
    createLibraryOptions(event),
    operation
  );
};
```

</Accordion>

Now, you can use the `runAmplifyApi` function to call Amplify APIs in an isolated server context. Create a new API route `/api/current-user` in the `server` directory and modify the `current-user.ts` file, with the following code:

```ts title="nuxt-amplify-gen2/server/api/current-user.ts"
import { getCurrentUser } from "aws-amplify/auth/server";
import { runAmplifyApi } from "~/server/utils/amplifyUtils";

export default defineEventHandler(async (event) => {
  const user = await runAmplifyApi(event, (contextSpec) =>
    getCurrentUser(contextSpec)
  );

  return user;
});
```

You can then fetch data from this API route, for example: `fetch('http://localhost:3000/api/current-user')`


Contents of build-a-backend_data_connect-to-API_index.txt:
import { getCustomStaticPath } from '@/utils/getCustomStaticPath';

export const meta = {
  title: 'Connect your app code to API',
  description: 'Learn how to connect your app code to an API.',
  platforms: [
    'android',
    'angular',
    'flutter',
    'javascript',
    'nextjs',
    'react',
    'react-native',
    'swift',
    'vue'
  ]
};

export const getStaticPaths = async () => {
  return getCustomStaticPath(meta.platforms);
};

export function getStaticProps(context) {
  return {
    props: {
      meta
    }
  };

}

In this guide, you will connect your application code to the backend API using the Amplify Libraries. Before you begin, you will need:

- Your cloud sandbox with an Amplify Data resource up and running (`npx ampx sandbox`)
- A frontend application set up with the Amplify library installed
- [npm installed](https://docs.npmjs.com/getting-started)

## Configure the Amplify Library

When you deploy you're iterating on your backend (`npx ampx sandbox`), an **amplify_outputs.json** file is generated for you. This file contains your API's endpoint information and auth configurations. Add the following code to your app's entrypoint to initialize and configure the Amplify client library:

<InlineFilter filters={["javascript", "angular", "react-native", "react", "nextjs", "vue"]}>

```ts
import { Amplify } from 'aws-amplify';
import outputs from '../amplify_outputs.json';

Amplify.configure(outputs);
```

## Generate the Amplify Data client

Once the Amplify library is configured, you can generate a "Data client" for your frontend code to make fully-typed API requests to your backend.

<Callout info>
**If you're using Amplify with a JavaScript-only frontend (i.e. not TypeScript), then you can still get a fully-typed data fetching experience by annotating the generated client with a JSDoc comment**. Select the **JavaScript** in the code block below to see how.
</Callout>

To generate a new Data client, use the following code:

<BlockSwitcher>
<Block name="TypeScript">
```ts
import { generateClient } from 'aws-amplify/data';
import type { Schema } from '../amplify/data/resource'; // Path to your backend resource definition

const client = generateClient<Schema>();

// Now you should be able to make CRUDL operations with the
// Data client
const fetchTodos = async () => {
  const { data: todos, errors } = await client.models.Todo.list();
};
```
</Block>
<Block name="JavaScript">
```js
import { generateClient } from 'aws-amplify/data';

/**
 * @type {import('aws-amplify/data').Client<import('../amplify/data/resource').Schema>}
 */
const client = generateClient();

// Now you should be able to make CRUDL operations with the
// Data client
const fetchTodos = async () => {
  const { data: todos, errors } = await client.models.Todo.list();
};
```
</Block>

</BlockSwitcher>

</InlineFilter>

## Configure authorization mode

The **Authorization Mode** determines how a request should be authorized with the backend. By default, Amplify Data uses the "userPool" authorization which uses the signed-in user credentials to sign an API request. If you use a `allow.publicApiKey()` authorization rules for your data models, you need to use "apiKey" as an authorization mode. Review [Customize your auth rules](/[platform]/build-a-backend/data/customize-authz) to learn more about which authorization modes to choose for which type of request. A **Default Authorization Mode** is provided as part of the **amplify_outputs.json** that is generated upon a successful deployment.

<InlineFilter filters={["javascript", "angular", "react-native", "react", "nextjs", "vue"]}>

You can generate different Data clients with different authorization modes or pass in the authorization mode at the request time.

### Set authorization mode on a per-client basis

To apply the same authorization mode on all requests from a Data client, specify the `authMode` parameter on the `generateClient` function.


<BlockSwitcher>

<Block name="API Key">

Use "API Key" as your authorization mode when if defined the `allow.publicApiKey()` authorization rule.

```ts
import { generateClient } from 'aws-amplify/data';
import type { Schema } from '../amplify/data/resource'; // Path to your backend resource definition

const client = generateClient<Schema>({
  authMode: 'apiKey',
});
```

</Block>
<Block name="Amazon Cognito user pool">

Use "userPool" as your authorization mode when using Amazon Cognito user pool-based authorization rules, such as `allow.authenticated()`, `allow.owner()`, `allow.ownerDefinedIn()`, `allow.groupsDefinedIn()`, or `allow.groups()`.

```ts
import { generateClient } from 'aws-amplify/data';
import type { Schema } from '../amplify/data/resource'; // Path to your backend resource definition

const client = generateClient<Schema>({
  authMode: 'userPool',
});
```

</Block>
<Block name="AWS IAM (including Amazon Cognito identity pool roles)">

Use "identityPool" as your authorization mode when using Amazon Cognito identity pool-based authorization rules, such as `allow.guest()` or `allow.authenticated('identityPool')`.

```ts
import { generateClient } from 'aws-amplify/data';
import type { Schema } from '../amplify/data/resource'; // Path to your backend resource definition

const client = generateClient<Schema>({
  authMode: 'identityPool',
});
```

</Block>
<Block name="OpenID Connect (OIDC)">
Use "oidc" as your authorization mode when connecting applications to a trusted identity provider. Private, owner, and group authorization can be configured with an OIDC authorization mode. Review the [OIDC authorization docs](/[platform]/build-a-backend/data/customize-authz/using-oidc-authorization-provider) to learn more.

```ts
import { generateClient } from 'aws-amplify/data';
import type { Schema } from '../amplify/data/resource'; // Path to your backend resource definition

const client = generateClient<Schema>({
  authMode: 'oidc',
});
```

</Block>
<Block name="Lambda Authorizer">

Use "Lambda Authorizer" when using your own custom authorization logic via `allow.custom()`. Review [Customize your auth rules](/[platform]/build-a-backend/data/customize-authz) to learn more about how to implement your authorization protocol.

```ts
import { generateClient } from 'aws-amplify/data';
import type { Schema } from '../amplify/data/resource'; // Path to your backend resource definition

const getAuthToken = () => 'myAuthToken';
const lambdaAuthToken = getAuthToken();

const client = generateClient<Schema>({
  authMode: 'lambda',
  authToken: lambdaAuthToken,
});
```

</Block>
</BlockSwitcher>

</InlineFilter>


### Set authorization mode on the request-level

You can also specify the authorization mode on each individual API request. This is useful if your application typically only uses one authorization mode with a small number of exceptions.

<BlockSwitcher>

<Block name="API Key">

<InlineFilter filters={["javascript", "angular", "react-native", "react", "nextjs", "vue"]}>

```ts
const { data: todos, errors } = await client.models.Todo.list({
  authMode: 'apiKey',
});
```

</InlineFilter>

<InlineFilter filters={["android"]}>

```kt
val query = ModelQuery.list(Todo::class.java) as AppSyncGraphQLRequest<PaginatedResult<Todo>>
val apiKeyQuery = query
    .newBuilder()
    .authorizationType(AuthorizationType.API_KEY)
    .build<PaginatedResult<Todo>>()
Amplify.API.query(apiKeyQuery,
    { Log.i("MyAmplifyApp", "Queried with API key ${it.data}")},
    { Log.e("MyAmplifyApp", "Error querying with API Key")})
```

</InlineFilter>

<InlineFilter filters={["swift"]}>

```swift
let result = try await Amplify.API.query(
    request: .list(
        Todo.self,
        authMode: .apiKey))
```

</InlineFilter>

<InlineFilter filters={["flutter"]}>

```dart
final apiKeyRequest = ModelQueries.list(Todo.classType, authorizationMode: APIAuthorizationType.apiKey);
final apiKeyResponse = await Amplify.API.query(request: apiKeyRequest).response;
```

</InlineFilter>

</Block>
<Block name="Amazon Cognito user pool">

<InlineFilter filters={["javascript", "angular", "react-native", "react", "nextjs", "vue"]}>

```ts
const { data: todos, errors } = await client.models.Todo.list({
  authMode: 'userPool',
});
```

</InlineFilter>

<InlineFilter filters={["android"]}>

```kt
val query = ModelQuery.list(Todo::class.java) as AppSyncGraphQLRequest<PaginatedResult<Todo>>
val userPoolQuery = query
  .newBuilder()
  .authorizationType(AuthorizationType.AMAZON_COGNITO_USER_POOLS)
  .build<PaginatedResult<Todo>>()
Amplify.API.query(userPoolQuery,
  { Log.i("MyAmplifyApp", "Queried with Cognito user pool ${it.data}")},
  { Log.e("MyAmplifyApp", "Error querying with Cognito user pool")})
```

</InlineFilter>

<InlineFilter filters={["swift"]}>

```swift
let result = try await Amplify.API.query(
    request: .list(
        Todo.self,
        authMode: .amazonCognitoUserPools))
```

</InlineFilter>

<InlineFilter filters={["flutter"]}>

```dart
final userPoolRequest = ModelQueries.list(Todo.classType, authorizationMode: APIAuthorizationType.userPools);
final userPoolResponse = await Amplify.API.query(request: userPoolRequest).response;
```

</InlineFilter>

</Block>
<Block name="AWS IAM (including Amazon Cognito identity pool roles)">

<InlineFilter filters={["javascript", "angular", "react-native", "react", "nextjs", "vue"]}>

```ts
const { data: todos, errors } = await client.models.Todo.list({
  authMode: 'identityPool',
});
```

</InlineFilter>

<InlineFilter filters={["android"]}>

```kt
val query = ModelQuery.list(Todo::class.java) as AppSyncGraphQLRequest<PaginatedResult<Todo>>
val iamQuery = query
    .newBuilder()
    .authorizationType(AuthorizationType.AWS_IAM)
    .build<PaginatedResult<Todo>>()
Amplify.API.query(iamQuery,
    { Log.i("MyAmplifyApp", "Queried with AWS IAM ${it.data}")},
    { Log.e("MyAmplifyApp", "Error querying with AWS IAM")})
```

</InlineFilter>


<InlineFilter filters={["swift"]}>

```swift
let result = try await Amplify.API.query(
    request: .list(
        Todo.self,
        authMode: .awsIAM))
```

</InlineFilter>

<InlineFilter filters={["flutter"]}>

```dart
final iamRequest = ModelQueries.list(Todo.classType, authorizationMode: APIAuthorizationType.iam);
final iamResponse = await Amplify.API.query(request: iamRequest).response;
```

</InlineFilter>

</Block>
<Block name="OpenID Connect (OIDC)">

<InlineFilter filters={["javascript", "angular", "react-native", "react", "nextjs", "vue"]}>

```ts
const { data: todos, errors } = await client.models.Todo.list({
  authMode: 'oidc',
});
```

</InlineFilter>

<InlineFilter filters={["android"]}>

```kt
val query = ModelQuery.list(Todo::class.java) as AppSyncGraphQLRequest<PaginatedResult<Todo>>
val oidcQuery = query
    .newBuilder()
    .authorizationType(AuthorizationType.OPENID_CONNECT)
    .build<PaginatedResult<Todo>>()
Amplify.API.query(oidcQuery,
    { Log.i("MyAmplifyApp", "Queried with OIDC authorization mode ${it.data}")},
    { Log.e("MyAmplifyApp", "Error querying with OIDC authorization mode")})
```

</InlineFilter>

<InlineFilter filters={["swift"]}>

```swift
let result = try await Amplify.API.query(
    request: .list(
        Todo.self,
        authMode: .openIDConnect))
```

</InlineFilter>

<InlineFilter filters={["flutter"]}>

```dart
final oidcRequest = ModelQueries.list(Todo.classType, authorizationMode: APIAuthorizationType.oidc);
final oidcResponse = await Amplify.API.query(request: oidcRequest).response;
```

</InlineFilter>

</Block>
<Block name="Lambda Authorizer">

You can implement your own custom API authorization logic using a AWS Lambda function. Review [Customize your auth rules](/[platform]/build-a-backend/data/customize-authz) to learn more about how to implement your authorization protocol with AWS Lambda.

<InlineFilter filters={["javascript", "angular", "react-native", "react", "nextjs", "vue"]}>

```ts
const getAuthToken = () => 'myAuthToken';
const lambdaAuthToken = getAuthToken();

const { data: todos, errors } = await client.models.Todo.list({
  authMode: 'lambda',
  authToken: lambdaAuthToken,
});
```

</InlineFilter>

<InlineFilter filters={["android"]}>

```kt
val query = ModelQuery.list(Todo::class.java) as AppSyncGraphQLRequest<PaginatedResult<Todo>>
val lambdaQuery = query
    .newBuilder()
    .authorizationType(AuthorizationType.AWS_LAMBDA)
    .build<PaginatedResult<Todo>>()
Amplify.API.query(lambdaQuery,
    { Log.i("MyAmplifyApp", "Queried with AWS Lambda authorizer ${it.data}")},
    { Log.e("MyAmplifyApp", "Error querying with AWS Lambda authorizer")})
```

</InlineFilter>

<InlineFilter filters={["swift"]}>

```swift
let result = try await Amplify.API.query(
    request: .list(
        Todo.self,
        authMode: .function))
```

</InlineFilter>

<InlineFilter filters={["flutter"]}>

```dart
final lambdaRequest = ModelQueries.list(Todo.classType, authorizationMode: APIAuthorizationType.function);
final lambdaResponse = await Amplify.API.query(request: lambdaRequest).response;
```

</InlineFilter>

</Block>
</BlockSwitcher>

## Set custom request headers

When working with the Amplify Data endpoint, you may need to set request headers for authorization purposes or to pass additional metadata from your frontend to the backend API.

<InlineFilter filters={["javascript", "angular", "react-native", "react", "nextjs", "vue"]}>

This is done by specifying a `headers` parameter into the configuration. You can define headers either on a per Data client-level or on a per-request level:

<BlockSwitcher>

<Block name="Custom headers per Data client">

```ts
import type { Schema } from '../amplify/data/resource';
import { generateClient } from 'aws-amplify/data';

const client = generateClient<Schema>({
  headers: {
    'My-Custom-Header': 'my value',
  },
});
```

</Block>

<Block name="Custom headers per request">

```ts
// same way for all CRUDL: .create, .get, .update, .delete, .list, .observeQuery
const { data: blog, errors } = await client.models.Blog.get(
  { id: 'myBlogId' },
  {
    headers: {
      'My-Custom-Header': 'my value',
    },
  }
);
```

</Block>

</BlockSwitcher>

The examples above show you how to set static headers but you can also programmatically set headers by specifying an async function for `headers`:

<BlockSwitcher>

<Block name="Custom headers per Data client">

```ts
import type { Schema } from '../amplify/data/resource';
import { generateClient } from 'aws-amplify/data';

const client = generateClient<Schema>({
  headers: async (requestOptions) => {
    console.log(requestOptions);
    /* The request options allow you to customize your headers based on the request options such
       as http method, headers, request URI, and query string. These options are typically used
       to create a request signature.
    {
      method: '...',
      headers: { },
      uri: '/',
      queryString: ""
    }
    */
    return {
      'My-Custom-Header': 'my value',
    };
  },
});
```

</Block>

<Block name="Custom headers per request">

```ts
// same way for all CRUDL: .create, .get, .update, .delete, .list, .observeQuery
const res = await client.models.Blog.get(
  { id: 'myBlogId' },
  {
    headers: async (requestOptions) => {
      console.log(requestOptions);
      /* The request options allow you to customize your headers based on the request options such
        as http method, headers, request URI, and query string. These options are typically used
        to create a request signature.
      {
        method: '...',
        headers: { },
        uri: '/',
        queryString: ""
      }
      */
      return {
        'My-Custom-Header': 'my value',
      };
    },
  }
);
```

</Block>

</BlockSwitcher>

</InlineFilter>

<InlineFilter filters={["android"]}>

To specify your own headers, use the `configureClient()` configuration option on the `AWSApiPlugin`'s builder. Specify the name of one of the configured APIs in your **amplify_outputs.json**. Apply customizations to the underlying OkHttp instance by providing a lambda expression as below.

<BlockSwitcher>
<Block name="Java">

```java
AWSApiPlugin plugin = AWSApiPlugin.builder()
    .configureClient(AWSApiPlugin.DEFAULT_GRAPHQL_API, okHttpBuilder -> {
        okHttpBuilder.addInterceptor(chain -> {
            Request originalRequest = chain.request();
            Request updatedRequest = originalRequest.newBuilder()
                .addHeader("customHeader", "someValue")
                .build();
            return chain.proceed(updatedRequest);
        });
    })
    .build();
Amplify.addPlugin(plugin);
```

</Block>
<Block name="Kotlin - Callbacks">

```kotlin
val plugin = AWSApiPlugin.builder()
    .configureClient(AWSApiPlugin.DEFAULT_GRAPHQL_API) { okHttpBuilder ->
        okHttpBuilder.addInterceptor { chain ->
            val originalRequest = chain.request()
            val updatedRequest = originalRequest.newBuilder()
                .addHeader("customHeader", "someValue")
                .build()
            chain.proceed(updatedRequest)
        }
    }
    .build()
Amplify.addPlugin(plugin)
```

</Block>
<Block name="Kotlin - Coroutines">

```kotlin
val plugin = AWSApiPlugin.builder()
    .configureClient(AWSApiPlugin.DEFAULT_GRAPHQL_API) { okHttpBuilder ->
        okHttpBuilder.addInterceptor { chain ->
            val originalRequest = chain.request()
            val updatedRequest = originalRequest.newBuilder()
                .addHeader("customHeader", "someValue")
                .build()
            chain.proceed(updatedRequest)
        }
    }
    .build()
Amplify.addPlugin(plugin)
```

</Block>
<Block name="RxJava">

```java
AWSApiPlugin plugin = AWSApiPlugin.builder()
    .configureClient(AWSApiPlugin.DEFAULT_GRAPHQL_API, okHttpBuilder -> {
        okHttpBuilder.addInterceptor(chain -> {
            Request originalRequest = chain.request();
            Request updatedRequest = originalRequest.newBuilder()
                .addHeader("customHeader", "someValue")
                .build();
            return chain.proceed(updatedRequest);
        });
    })
    .build();
RxAmplify.addPlugin(plugin);
```

</Block>
</BlockSwitcher>

</InlineFilter>

<InlineFilter filters={["swift"]}>

To include custom headers in your outgoing requests, add an `URLRequestInterceptor` to the `AWSAPIPlugin`.

```swift
import Amplify
import AWSAPIPlugin

struct CustomInterceptor: URLRequestInterceptor {
    func intercept(_ request: URLRequest) throws -> URLRequest {
        var request = request
        request.setValue("headerValue", forHTTPHeaderField: "headerKey")
        return request
    }
}
let apiPlugin = AWSAPIPlugin(modelRegistration: AmplifyModels())
try apiPlugin.add(interceptor: CustomInterceptor(), for: AWSAPIPlugin.defaultGraphQLAPI)
try Amplify.add(plugin: apiPlugin)
try Amplify.configure(with: .amplifyOutputs)

```

</InlineFilter>

<InlineFilter filters={["flutter"]}>

The simplest option for GraphQL requests is to use the `headers` property of a `GraphQLRequest`.

```dart
Future<void> queryWithCustomHeaders() async {
  final operation = Amplify.API.query<String>(
    request: GraphQLRequest(
      document: graphQLDocumentString,
      headers: {'customHeader': 'someValue'},
    ),
  );
  final response = await operation.response;
  final data = response.data;
  safePrint('data: $data');
}
```

Another option is to use the `baseHttpClient` property of the API plugin which can customize headers or otherwise alter HTTP functionality for all HTTP calls.

```dart
// First create a custom HTTP client implementation to extend HTTP functionality.
class MyHttpRequestInterceptor extends AWSBaseHttpClient {
  @override
  Future<AWSBaseHttpRequest> transformRequest(
    AWSBaseHttpRequest request,
  ) async {
    request.headers.putIfAbsent('customHeader', () => 'someValue');
    return request;
  }
}

// Then you can pass an instance of this client to `baseHttpClient` when you configure Amplify.
await Amplify.addPlugins([
  AmplifyAPI(baseHttpClient: MyHttpRequestInterceptor()),
]);
```

</InlineFilter>

<InlineFilter filters={["javascript", "angular", "react-native", "react", "nextjs", "vue"]}>

## Use an additional Data endpoint

If you have an additional Data endpoint that you're managing with a different Amplify project or through other means, this section will show you how to utilize that endpoint in your frontend code.

This is done by specifying the `endpoint` parameter on the `generateClient` function.

```ts
import { generateClient } from 'aws-amplify/data';

const client = generateClient({
  endpoint: 'https://my-other-endpoint.com/graphql',
});
```

If this Data endpoint shares its authorization configuration (for example, both endpoints share the same user pool and/or identity pool as the one in your `amplify_outputs.json` file), you can specify the `authMode` parameter on `generateClient`.

```ts
const client = generateClient({
  endpoint: 'https://my-other-endpoint.com/graphql',
  authMode: 'userPool',
});
```

If the endpoint uses API Key authorization, you can pass in the `apiKey` parameter on `generateClient`.

```ts
const client = generateClient({
  endpoint: 'https://my-other-endpoint.com/graphql',
  authMode: 'apiKey',
  apiKey: 'my-api-key',
});
``` 

If the endpoint uses a different authorization configuration, you can manually pass in the authorization header using the instructions in the [Set custom request headers](#set-custom-request-headers) section.

</InlineFilter>


Contents of build-a-backend_data_connect-to-existing-data-sources_connect-external-ddb-table_index.txt:
import { getCustomStaticPath } from '@/utils/getCustomStaticPath';

export const meta = {
  title: 'Connect to external Amazon DynamoDB data sources',
  description:
    'Connect to external Amazon DynamoDB data sources with custom queries and mutations',
  platforms: [
    'android',
    'angular',
    'flutter',
    'javascript',
    'nextjs',
    'react',
    'react-native',
    'swift',
    'vue',
  ],
};

export const getStaticPaths = async () => {
  return getCustomStaticPath(meta.platforms);
};

export function getStaticProps() {
  return {
    props: {
      meta
    }
  };
}

The `a.model()` data model allows you to define a GraphQL schema for an AWS AppSync API where models are backed by DynamoDB Tables managed by Amplify. The generated schema also provides queries and mutations to the Amplify Data client. However, you may want to connect to an external DynamoDB table and execute custom business logic against it instead.

<Callout info>
Using an external DynamoDB table as a data source may be useful if you need to leverage patterns such as single table design.
</Callout>

In the following sections, we walk through the steps to add and use an external DynamoDB table as a data source for your API:

1. Set up your Amazon DynamoDB table
2. Add your Amazon DynamoDB table as a data source
3. Define custom queries and mutations
4. Configure custom business logic handler code
5. Invoke custom queries or mutations

## Step 1 - Set up your Amazon DynamoDB table

For the purpose of this guide we will define a `Post` type and create an external DynamoDB table that will store records for it. In Amplify Gen 2, `customType` adds a type to the schema that is not backed by an Amplify-generated DynamoDB table.

With the `Post` type defined, it can then be referenced as the return type when defining your custom queries and mutations.

First, add the `Post` custom type to your schema:

```ts title="amplify/data/resource.ts"
import { type ClientSchema, a, defineData } from "@aws-amplify/backend";

const schema = a.schema({
  Todo: a
    .model({
      content: a.string(),
    })
    .authorization(allow => [allow.publicApiKey()]),
  // highlight-start
  Post: a.customType({
    id: a.id().required(),
    author: a.string().required(),
    title: a.string(),
    content: a.string(),
    url: a.string(),
    ups: a.integer(),
    downs: a.integer(),
    version: a.integer(),
  }),
  // highlight-end
});

export type Schema = ClientSchema<typeof schema>;

export const data = defineData({
  schema,
  authorizationModes: {
    defaultAuthorizationMode: 'apiKey',
    apiKeyAuthorizationMode: {
      expiresInDays: 30,
    },
  },
});
```

<Callout info>
**NOTE:** To comply with the GraphQL spec, at least one query is required for a schema to be valid. Otherwise, deployments will fail with a schema error. The Amplify Data schema is auto-generated with a `Todo` model and corresponding queries under the hood. You can leave the `Todo` model in the schema until you add the first custom query to the schema in the next steps.
</Callout>

Once the deployment successfully completes, navigate to the AppSync console and select your Amplify-generated API. Follow these steps to create a new DynamoDB table:

1. On the **Schema** page, choose **Create Resources**.

![AWS AppSync console showing navigation pane with "AWS AppSync" expanded and "APIs" > "TestAPI" selected. Main content displays "Schema Info" section with a "Create Resources" button.](/images/create-ddb-resource-0.png)

2. Choose **Use existing type**, then choose the **Post** type.

![AWS AppSync console, "Create Resources" page. A prominent heading reads "Create Resources". Radio buttons are presented for either defining a new type or selecting an existing type for the table creation.](/images/create-ddb-resource-1.png)

3. Set the **Primary key** to `id` and the **Sort key** to `None`.

4. Disable **Automatically generate GraphQL**. In this example, we'll create the resolver ourselves.

![AWS AppSync console, "Create a table to hold Post objects" page. A table structure is shown with columns and values of "Table name": "PostTable", "Primary Key": "id", and "Sort key": "None". Below the table, there is an option to "Automatically generate GraphQL" which is disabled.](/images/create-ddb-resource-2.png)

5. Choose **Create**.

You now have a new DynamoDB table named `PostTable`, which you can see by visiting `Data sources` in the side tab. You will use this table as the data source for your custom queries and mutations to your Amazon DynamoDB table.

![AWS AppSync console, 'Data sources' page. The page shows a list of existing data sources connected to an API. The data sources include an Amazon DynamoDB table named 'PostTable' and another table named 'Todo'.*](/images/create-ddb-resource-3.png)


## Step 2 - Add your Amazon DynamoDB table as a data source

In your `amplify/backend.ts` file, add your DynamoDB table as a data source for your API:

```ts title="amplify/backend.ts"
import { defineBackend } from "@aws-amplify/backend";
import { auth } from "./auth/resource";
import { data } from "./data/resource";
import { aws_dynamodb } from "aws-cdk-lib";

export const backend = defineBackend({
  auth,
  data,
});

// highlight-start
const externalDataSourcesStack = backend.createStack("MyExternalDataSources");

const externalTable = aws_dynamodb.Table.fromTableName(
  externalDataSourcesStack,
  "MyExternalPostTable",
  "PostTable"
);

backend.data.addDynamoDbDataSource(
  "ExternalPostTableDataSource",
  externalTable
);
// highlight-end
```


## Step 3 - Define custom queries and mutations

Now that your DynamoDB table has been added as a data source, you can reference it in custom queries and mutations using the `a.handler.custom()` modifier which accepts the name of the data source and an entry point for your resolvers.

Use the following code examples to add `addPost`, `getPost`, `updatePost`, and `deletePost` as custom queries and mutations to your schema:

<BlockSwitcher>
<Block name="addPost">
```ts title="amplify/data/resource.ts"
import { type ClientSchema, a, defineData } from "@aws-amplify/backend";

const schema = a.schema({
  Post: a.customType({
    author: a.string().required(),
    title: a.string(),
    content: a.string(),
    url: a.string(),
    ups: a.integer(),
    downs: a.integer(),
    version: a.integer(),
  }),
  // highlight-start
  addPost: a
    .mutation()
    .arguments({
      id: a.id(),
      author: a.string().required(),
      title: a.string(),
      content: a.string(),
      url: a.string(),
    })
    .returns(a.ref("Post"))
    .authorization(allow => [allow.publicApiKey()])
    .handler(
      a.handler.custom({
        dataSource: "ExternalPostTableDataSource",
        entry: "./addPost.js",
      })
    ),
  // highlight-end
});

export type Schema = ClientSchema<typeof schema>;

export const data = defineData({
  schema,
  authorizationModes: {
    defaultAuthorizationMode: 'apiKey',
    apiKeyAuthorizationMode: {
      expiresInDays: 30,
    },
  },
});
```
</Block>
<Block name="getPost">
```ts title="amplify/data/resource.ts"
import { type ClientSchema, a, defineData } from "@aws-amplify/backend";

const schema = a.schema({
  Post: a.customType({
    author: a.string().required(),
    title: a.string(),
    content: a.string(),
    url: a.string(),
    ups: a.integer(),
    downs: a.integer(),
    version: a.integer(),
  }),
  // highlight-start
  getPost: a
    .query()
    .arguments({ id: a.id().required() })
    .returns(a.ref("Post"))
    .authorization(allow => [allow.publicApiKey()])
    .handler(
      a.handler.custom({
        dataSource: "ExternalPostTableDataSource",
        entry: "./getPost.js",
      })
    ),
  // highlight-end
});

export type Schema = ClientSchema<typeof schema>;

export const data = defineData({
  schema,
  authorizationModes: {
    defaultAuthorizationMode: 'apiKey',
    apiKeyAuthorizationMode: {
      expiresInDays: 30,
    },
  },
});
```
</Block>
<Block name="updatePost">
```ts title="amplify/data/resource.ts"
import { type ClientSchema, a, defineData } from "@aws-amplify/backend";

const schema = a.schema({
  Post: a.customType({
    author: a.string().required(),
    title: a.string(),
    content: a.string(),
    url: a.string(),
    ups: a.integer(),
    downs: a.integer(),
    version: a.integer(),
  }),
  // highlight-start
  updatePost: a
    .mutation()
    .arguments({
      id: a.id().required(),
      author: a.string(),
      title: a.string(),
      content: a.string(),
      url: a.string(),
      expectedVersion: a.integer().required(),
    })
    .returns(a.ref("Post"))
    .authorization(allow => [allow.publicApiKey()])
    .handler(
      a.handler.custom({
        dataSource: "ExternalPostTableDataSource",
        entry: "./updatePost.js",
      })
    ),
  // highlight-end
});

export type Schema = ClientSchema<typeof schema>;

export const data = defineData({
  schema,
  authorizationModes: {
    defaultAuthorizationMode: 'apiKey',
    apiKeyAuthorizationMode: {
      expiresInDays: 30,
    },
  },
});
```
</Block>
<Block name="deletePost">
```ts title="amplify/data/resource.ts"
import { type ClientSchema, a, defineData } from "@aws-amplify/backend";

const schema = a.schema({
  Post: a.customType({
    author: a.string().required(),
    title: a.string(),
    content: a.string(),
    url: a.string(),
    ups: a.integer(),
    downs: a.integer(),
    version: a.integer(),
  }),
  // highlight-start
  deletePost: a
    .mutation()
    .arguments({ id: a.id().required(), expectedVersion: a.integer() })
    .returns(a.ref("Post"))
    .authorization(allow => [allow.publicApiKey()])
    .handler(
      a.handler.custom({
        dataSource: "ExternalPostTableDataSource",
        entry: "./deletePost.js",
      })
    ),
  // highlight-end
});

export type Schema = ClientSchema<typeof schema>;

export const data = defineData({
  schema,
  authorizationModes: {
    defaultAuthorizationMode: 'apiKey',
    apiKeyAuthorizationMode: {
      expiresInDays: 30,
    },
  },
});
```
</Block>
</BlockSwitcher>


## Step 4 - Configure custom business logic handler code

Next, create the following files in your `amplify/data` folder and use the code examples to define custom resolvers for the custom queries and mutations added to your schema from the previous step. These are AppSync JavaScript resolvers

<BlockSwitcher>
<Block name="addPost">
```js title="amplify/data/addPost.js"
import { util } from "@aws-appsync/utils";
import * as ddb from "@aws-appsync/utils/dynamodb";

export function request(ctx) {
  const item = { ...ctx.arguments, ups: 1, downs: 0, version: 1 };
  const key = { id: ctx.args.id ?? util.autoId() };
  return ddb.put({ key, item });
}

export function response(ctx) {
  return ctx.result;
}
```
</Block>
<Block name="getPost">
```js title="amplify/data/getPost.js"
import * as ddb from "@aws-appsync/utils/dynamodb";

export function request(ctx) {
  return ddb.get({ key: { id: ctx.args.id } });
}

export const response = (ctx) => ctx.result;
```
</Block>
<Block name="updatePost">
```js title="amplify/data/updatePost.js"
import { util } from "@aws-appsync/utils";
import * as ddb from "@aws-appsync/utils/dynamodb";

export function request(ctx) {
  const { id, expectedVersion, ...rest } = ctx.args;
  const values = Object.entries(rest).reduce((obj, [key, value]) => {
    obj[key] = value ?? ddb.operations.remove();
    return obj;
  }, {});

  return ddb.update({
    key: { id },
    condition: { version: { eq: expectedVersion } },
    update: { ...values, version: ddb.operations.increment(1) },
  });
}

export function response(ctx) {
  const { error, result } = ctx;
  if (error) {
    util.appendError(error.message, error.type);
  }
  return result;
}
```
</Block>
<Block name="deletePost">
```js title="amplify/data/deletePost.js"
import { util } from "@aws-appsync/utils";
import * as ddb from "@aws-appsync/utils/dynamodb";

export function request(ctx) {
  let condition = null;
  if (ctx.args.expectedVersion) {
    condition = {
      or: [
        { id: { attributeExists: false } },
        { version: { eq: ctx.args.expectedVersion } },
      ],
    };
  }
  return ddb.remove({ key: { id: ctx.args.id }, condition });
}

export function response(ctx) {
  const { error, result } = ctx;
  if (error) {
    util.appendError(error.message, error.type);
  }
  return result;
}
```
</Block>
</BlockSwitcher>


## Step 5 - Invoke custom queries or mutations

From your generated Data client, you can find all your custom queries and mutations under the client.queries. and client.mutations. APIs respectively.

<BlockSwitcher>
<Block name="addPost">
```ts title="App.tsx"
const { data, errors } = await client.mutations.addPost({
  title: "My Post",
  content: "My Content",
  author: "Chris",
});
```
</Block>
<Block name="getPost">
```ts title="App.tsx"
const { data, errors } = await client.queries.getPost({
  id: "<post-id>"
});
```
</Block>
<Block name="updatePost">
```ts title="App.tsx"
const { data, errors } = await client.mutations.updatePost({
  id: "<post-id>",
  title: "An Updated Post",
  expectedVersion: 1,
});
```
</Block>
<Block name="deletePost">
```ts title="App.tsx"
const { data, errors } = await client.mutations.deletePost({
  id: "<post-id>",
});
```
</Block>
</BlockSwitcher>

## Conclusion

In this guide, you’ve added an external DynamoDB table as a data source to an Amplify GraphQL API and defined custom queries and mutations, handled by AppSync JS resolvers, to manipulate Post items in an external DynamoDB table using the Amplify Gen 2 Data client.

To clean up, you can delete your sandbox by accepting the prompt when terminating the sandbox process in your terminal. Alternatively, you can also use the AWS Amplify console to manage and delete sandbox environments.

To delete your external DynamoDB table, you can navigate to the AppSync console and click on the name of the table in the data sources list. This takes you to the DynamoDB console where you can delete the table.

## All DynamoDB operations & example resolvers

### GetItem

[Reference](https://docs.aws.amazon.com/appsync/latest/devguide/js-resolver-reference-dynamodb.html#js-aws-appsync-resolver-reference-dynamodb-getitem) - The `GetItem` request lets you tell the AWS AppSync DynamoDB function to make a `GetItem` request to DynamoDB, and enables you to specify:

- The key of the item in DynamoDB
- Whether to use a consistent read or not

**Example:**

```js
export function request(ctx) {
  const { foo, bar } = ctx.args;
  return {
    operation: 'GetItem',
    key: util.dynamodb.toMapValues({ foo, bar }),
    consistentRead: true
  };
}
```

### PutItem

[PutItem](https://docs.aws.amazon.com/appsync/latest/devguide/js-resolver-reference-dynamodb.html#js-aws-appsync-resolver-reference-dynamodb-putitem) - The `PutItem` request mapping document lets you tell the AWS AppSync DynamoDB function to make a `PutItem` request to DynamoDB, and enables you to specify the following:

- The key of the item in DynamoDB
- The full contents of the item (composed of key and attributeValues)
- Conditions for the operation to succeed

**Example:**

```js
import { util } from '@aws-appsync/utils';

export function request(ctx) {
  const { foo, bar, ...values } = ctx.args;
  return {
    operation: 'PutItem',
    key: util.dynamodb.toMapValues({ foo, bar }),
    attributeValues: util.dynamodb.toMapValues(values)
  };
}
```

### UpdateItem

[UpdateItem](https://docs.aws.amazon.com/appsync/latest/devguide/js-resolver-reference-dynamodb.html#js-aws-appsync-resolver-reference-dynamodb-updateitem) - The `UpdateItem` request enables you to tell the AWS AppSync DynamoDB function to make a `UpdateItem` request to DynamoDB and allows you to specify the following:

- The key of the item in DynamoDB
- An update expression describing how to update the item in DynamoDB
- Conditions for the operation to succeed

**Example:**

```js
import { util } from '@aws-appsync/utils';

export function request(ctx) {
  const { id } = ctx.args;
  return {
    operation: 'UpdateItem',
    key: util.dynamodb.toMapValues({ id }),
    update: {
      expression: 'ADD #voteField :plusOne, version :plusOne',
      expressionNames: { '#voteField': 'upvotes' },
      expressionValues: { ':plusOne': { N: 1 } }
    }
  };
}
```

### DeleteItem

[DeleteItem](https://docs.aws.amazon.com/appsync/latest/devguide/js-resolver-reference-dynamodb.html#js-aws-appsync-resolver-reference-dynamodb-deleteitem) - The `DeleteItem` request lets you tell the AWS AppSync DynamoDB function to make a `DeleteItem` request to DynamoDB, and enables you to specify the following:

- The key of the item in DynamoDB
- Conditions for the operation to succeed

**Example:**

```js
import { util } from '@aws-appsync/utils';

export function request(ctx) {
  return {
    operation: 'DeleteItem',
    key: util.dynamodb.toMapValues({ id: ctx.args.id })
  };
}
```

### Query

[Query](https://docs.aws.amazon.com/appsync/latest/devguide/js-resolver-reference-dynamodb.html#js-aws-appsync-resolver-reference-dynamodb-query) - The Query request object lets you tell the AWS AppSync DynamoDB resolver to make a Query request to DynamoDB, and enables you to specify the following:

- Key expression
- Which index to use
- Any additional filter
- How many items to return
- Whether to use consistent reads
- query direction (forward or backward)
- Pagination token

**Example:**

```js
import { util } from '@aws-appsync/utils';

export function request(ctx) {
  const { owner } = ctx.args;
  return {
    operation: 'Query',
    query: {
      expression: 'ownerId = :ownerId',
      expressionValues: util.dynamodb.toMapValues({ ':ownerId': owner })
    },
    index: 'owner-index'
  };
}
```
### Scan

[Scan](https://docs.aws.amazon.com/appsync/latest/devguide/js-resolver-reference-dynamodb.html#js-aws-appsync-resolver-reference-dynamodb-scan) - The `Scan` request lets you tell the AWS AppSync DynamoDB function to make a `Scan` request to DynamoDB, and enables you to specify the following:

- A filter to exclude results
- Which index to use
- How many items to return
- Whether to use consistent reads
- Pagination token
- Parallel scans

**Example:**

```js
export function request(ctx) {
  return { operation: 'Scan' };
}
```
### Sync

[Sync](https://docs.aws.amazon.com/appsync/latest/devguide/js-resolver-reference-dynamodb.html#js-aws-appsync-resolver-reference-dynamodb-sync) - The `Sync` request object lets you retrieve all the results from a DynamoDB table and then receive only the data altered since your last query (the delta updates). `Sync` requests can only be made to versioned DynamoDB data sources. You can specify the following:

- A filter to exclude results

- How many items to return

- Pagination Token

- When your last Sync operation was started

**Example:**

```js
export function request(ctx) {
  const { nextToken, lastSync } = ctx.args;
  return { operation: 'Sync', limit: 100, nextToken, lastSync };
}
```

### BatchGetItem

[BatchGetItem](https://docs.aws.amazon.com/appsync/latest/devguide/js-resolver-reference-dynamodb.html#js-aws-appsync-resolver-reference-dynamodb-batch-get-item) - The `BatchGetItem` request object lets you tell the AWS AppSync DynamoDB function to make a `BatchGetItem` request to DynamoDB to retrieve multiple items, potentially across multiple tables. For this request object, you must specify the following:

- The table names where to retrieve the items from

- The keys of the items to retrieve from each table

The DynamoDB `BatchGetItem` limits apply and **no condition expression** can be provided.

**Example:**
```js
import { util } from '@aws-appsync/utils';

export function request(ctx) {
  const { authorId, postId } = ctx.args;
  return {
    operation: 'BatchGetItem',
    tables: {
      authors: [util.dynamodb.toMapValues({ authorId })],
      posts: [util.dynamodb.toMapValues({ authorId, postId })],
    },
  };
}
```

### BatchDeleteItem

[BatchDeleteItem](https://docs.aws.amazon.com/appsync/latest/devguide/js-resolver-reference-dynamodb.html#js-aws-appsync-resolver-reference-dynamodb-batch-delete-item) - The BatchDeleteItem request object lets you tell the AWS AppSync DynamoDB function to make a BatchWriteItem request to DynamoDB to delete multiple items, potentially across multiple tables. For this request object, you must specify the following:

- The table names where to delete the items from

- The keys of the items to delete from each table

The DynamoDB `BatchWriteItem` limits apply and **no condition expression** can be provided.

**Example:**

```js
import { util } from '@aws-appsync/utils';

export function request(ctx) {
  const { authorId, postId } = ctx.args;
  return {
    operation: 'BatchDeleteItem',
    tables: {
      authors: [util.dynamodb.toMapValues({ authorId })],
      posts: [util.dynamodb.toMapValues({ authorId, postId })],
    },
  };
}
```

### BatchPutItem

[BatchPutItem](https://docs.aws.amazon.com/appsync/latest/devguide/js-resolver-reference-dynamodb.html#js-aws-appsync-resolver-reference-dynamodb-batch-put-item) - The `BatchPutItem` request object lets you tell the AWS AppSync DynamoDB function to make a `BatchWriteItem` request to DynamoDB to put multiple items, potentially across multiple tables. For this request object, you must specify the following:

- The table names where to put the items in

- The full items to put in each table

The DynamoDB `BatchWriteItem` limits apply and **no condition expression** can be provided.

**Example:**

```js
import { util } from '@aws-appsync/utils';

export function request(ctx) {
  const { authorId, postId, name, title } = ctx.args;
  return {
    operation: 'BatchPutItem',
    tables: {
      authors: [util.dynamodb.toMapValues({ authorId, name })],
      posts: [util.dynamodb.toMapValues({ authorId, postId, title })],
    },
  };
}
```

### TransactGetItems

[TransactGetItems](https://docs.aws.amazon.com/appsync/latest/devguide/js-resolver-reference-dynamodb.html#js-aws-appsync-resolver-reference-dynamodb-transact-get-items) - The `TransactGetItems` request object lets you to tell the AWS AppSync DynamoDB function to make a `TransactGetItems` request to DynamoDB to retrieve multiple items, potentially across multiple tables. For this request object, you must specify the following:

- The table name of each request item where to retrieve the item from

- The key of each request item to retrieve from each table

The DynamoDB `TransactGetItems` limits apply and **no condition expression** can be provided.

**Example:**

```js
import { util } from '@aws-appsync/utils';

export function request(ctx) {
  const { authorId, postId } = ctx.args;
  return {
    operation: 'TransactGetItems',
    transactItems: [
      {
        table: 'posts',
        key: util.dynamodb.toMapValues({ postId }),
      },
      {
        table: 'authors',
        key: util.dynamodb.toMapValues({ authorId }),
      },
    ],
  };
}
```

### TransactWriteItems

[TransactWriteItems](https://docs.aws.amazon.com/appsync/latest/devguide/js-resolver-reference-dynamodb.html#js-aws-appsync-resolver-reference-dynamodb-transact-write-items) - The `TransactWriteItems` request object lets you tell the AWS AppSync DynamoDB function to make a `TransactWriteItems` request to DynamoDB to write multiple items, potentially to multiple tables. For this request object, you must specify the following:

- The destination table name of each request item

- The operation of each request item to perform. There are four types of operations that are supported: `PutItem`, `UpdateItem`, `DeleteItem`, and `ConditionCheck`

- The key of each request item to write

The DynamoDB `TransactWriteItems` limits apply.

**Example:**

```js
import { util } from '@aws-appsync/utils';

export function request(ctx) {
  const { authorId, postId, title, description, oldTitle, authorName } = ctx.args;
  return {
    operation: 'TransactWriteItems',
    transactItems: [
      {
        table: 'posts',
        operation: 'PutItem',
        key: util.dynamodb.toMapValues({ postId }),
        attributeValues: util.dynamodb.toMapValues({ title, description }),
        condition: util.transform.toDynamoDBConditionExpression({
          title: { eq: oldTitle },
        }),
      },
      {
        table: 'authors',
        operation: 'UpdateItem',
        key: util.dynamodb.toMapValues({ authorId }),
        update: {
          expression: 'SET authorName = :name',
          expressionValues: util.dynamodb.toMapValues({ ':name': authorName }),
        },
      },
    ],
  };
}
```


Contents of build-a-backend_data_connect-to-existing-data-sources_connect-postgres-mysql-database_index.txt:
import { getCustomStaticPath } from '@/utils/getCustomStaticPath';

export const meta = {
  title: 'Connect your app to existing MySQL and PostgreSQL database',
  description:
    'Learn how to connect your app to existing MySQL and PostgreSQL database.',
  platforms: [
    'android',
    'angular',
    'flutter',
    'javascript',
    'nextjs',
    'react',
    'react-native',
    'swift',
    'vue',
  ],
};

export const getStaticPaths = async () => {
  return getCustomStaticPath(meta.platforms);
};

export function getStaticProps() {
  return {
    props: {
      meta
    }
  };
}


Amplify's native integration supports any MySQL or Postgres database, no matter if they're hosted on AWS within a VPC or outside of AWS with a 3rd party hosted database provider.

You must create a connection string using the following database information to get started:

- Database **hostname**
- Database **port**
- Database **username**
- Database **user password**
- Database **name**

## Step 1 - Set secrets for database connection

First, provide all the database connection information as secrets, you can use the Amplify sandbox's secret functionality to set them or go to the Amplify console to set secrets in a shared environment:

```bash showLineNumbers={false}
npx ampx sandbox secret set SQL_CONNECTION_STRING
```

<BlockSwitcher>
<Block name="MySQL">
**Connection string format for MySQL**
```console showLineNumbers={false}
mysql://user:password@hostname:port/db-name
```
</Block>

<Block name="PostgreSQL">
**Connection string format for PostgreSQL**
```console showLineNumbers={false}
postgres://user:password@hostname:port/db-name
```
</Block>
</BlockSwitcher>


## Step 2 - Generate TypeScript representation of your database schema

Run the following command to generate the Data schema with your database connection information. It'll infer an `a.model()` representation for **all database tables that have primary key specified**.

```bash
npx ampx generate schema-from-database --connection-uri-secret SQL_CONNECTION_STRING --out amplify/data/schema.sql.ts
```

<Accordion eyebrow="Info" title="Connecting to a database behind the VPC">

If your RDS database exists within a VPC, it must be configured to be `Publicly accessible`. This does not mean the instance needs to be accessible from all IP addresses on the Internet, but this flag is required to allow your local machine to connect via an **Inbound Rule** rather than being inside your VPC or connected to the VPC via VPN.

**To generate the TypeScript representation of your database schema:**

If your database is protected by a VPC, you will need to add an **Inbound Rule** for the database port from your local IP address. The `npx ampx generate schema-from-database` command connects to your database from your local workstation to read schema information.

If you are connecting to an RDS Proxy, the machine you run the `generate schema-from-database` command must be in the same VPC as the proxy itself, or you must connect to it via VPN. Simply opening an **Inbound Rule** for the database port is not sufficient.

**To connect to your database during runtime:**
When you specify connection information, we'll compare the hostname you supply against a list of RDS instances, clusters, and proxies in your account in the same region as your project. If we find a match, we'll automatically detect the VPC configuration for your database and provision a SQL Lambda function to connect to the database and retrieve the schema.

The VPC security group in which your database instance, cluster, or proxy is installed must have **Inbound rules** that allow traffic from the following TCP ports:

1. The specified database port (e.g., 3306 for MySQL databases or 5432 for Postgres databases).
2. Port 443 (HTTPS) to allow the Lambda function to connect to AWS Systems Manager to retrieve configuration parameters.

Finally, the security group must have **Outbound rules** that allow traffic on those same ports from the security group itself.

</Accordion>

<Accordion eyebrow="Info" title="Handling of implicit fields (id, createdAt, updatedAt)">

When creating new DynamoDB-backed data models via `a.model()`, a set of a implicit fields, such as `id`, `createdAt`, and `updatedAt` are added by default. When connecting to an existing SQL database, these fields are not implicitly added as they are not part of the underlying data source. If `createdAt` and `updatedAt` are valid columns in the underlying database table, then Amplify Data will automatically populate those fields with their respective values upon create and update mutations.

</Accordion>

<Accordion title="RDS Proxy for improved connectivity" eyebrow="Learn more">

Consider adding an RDS Proxy in front of the cluster to manage database connections.

When using Amplify GraphQL API with a relational database like Amazon RDS, each query from your application needs to open a separate connection to the database.

If there are a large number of queries occurring concurrently, it can exceed the connection limit on the database and result in errors like "Too many connections". To avoid this, Amplify can use an RDS Proxy when connecting your GraphQL API to a database.

The RDS Proxy acts as an intermediary sitting in front of your database. Instead of each application query opening a direct connection to the database, they will connect through the Proxy. The Proxy helps manage and pool these connections to avoid overwhelming your database cluster. This improves the availability of your API, allowing more queries to execute concurrently without hitting connection limits.

However, there is a tradeoff of increased latency - queries may take slightly longer as they wait for an available connection from the Proxy pool. There are also additional costs associated with using RDS Proxy. Please refer to the [pricing page for RDS Proxy](https://aws.amazon.com/rds/proxy/pricing/) to learn more.

</Accordion>

<Accordion title="Connecting to a database with a custom SSL certificate">

Amplify creates an [AWS Lambda](https://aws.amazon.com/lambda) function using a Node.js runtime to connect your AppSync API to your SQL database. The Lambda function connects to the database using Secure Socket Layer (SSL) or Transport Layer Security (TLS) to protect data in transit. Amplify automatically uses the correct root certificate authority (CA) certificates for Amazon RDS databases, and the Node.js runtime includes root CAs from [well-known certificate providers](https://github.com/nodejs/node/issues/4175) to connect to non-RDS databases.

However, if your database uses a custom or self-signed SSL certificate, you can upload the PEM-encoded public CA certificate of 4 KB or less to your Amplify project as a secret when you generate the database configuration, and specify that secret when generating the schema from your database:

```bash title="Terminal" showLineNumbers={false}
npx ampx sandbox secret set CUSTOM_SSL_CERT < /path/to/custom/ssl/public-ca-cert.pem
npx ampx generate schema-from-database --connection-uri-secret SQL_CONNECTION_STRING --ssl-cert-secret CUSTOM_SSL_CERT --out amplify/data/schema.sql.ts
```

The Lambda function will then use the specified root CA to validate connections to the database.

When deploying your app to production, you need to [add the PEM-encoded public CA certificate as a secret](/[platform]/deploy-and-host/fullstack-branching/secrets-and-vars/#set-secrets). Make sure to add the certificate with the same secret name you used in the sandbox environment. For example, we used `CUSTOM_SSL_CERT` above. Make sure to preserve the newlines and the `------BEGIN CERTIFICATE------` and `------END CERTIFICATE------` delimiters in the value. Finally, make sure the size of the entire value does not exceed 4KB.

</Accordion>

This creates a new **schema.sql.ts** with a schema reflecting the types of your database. **Do not edit the schema.sql.ts file directly**. Import the schema to your **amplify/data/resource.ts** file and apply any additive changes there. This ensures that you can continuously regenerate the TypeScript schema representation of your SQL database without losing any additive changes that you apply out-of-band.

```ts
import { type ClientSchema, a, defineData } from '@aws-amplify/backend';
// highlight-start
import { schema as generatedSqlSchema } from './schema.sql';

// Add a global authorization rule
const sqlSchema = generatedSqlSchema.authorization(allow => allow.guest())
// highlight-end

// Relational database sources can coexist with DynamoDB tables managed by Amplify.
const schema = a.schema({
  Todo: a.model({
    content: a.string(),
  }).authorization(allow => [allow.guest()])
});

// Use the a.combine() operator to stitch together the models backed by DynamoDB
// and the models backed by Postgres or MySQL databases.
// highlight-next-line
const combinedSchema = a.combine([schema, sqlSchema]);

// Don't forget to update your client types to take into account the types from
// both schemas.
// highlight-next-line
export type Schema = ClientSchema<typeof combinedSchema>;

export const data = defineData({
  // Update the data definition to use the combined schema, instead of just
  // your DynamoDB-backed schema
  // highlight-next-line
  schema: combinedSchema
});
```

## Step 3 - Fine-grained authorization rules

Use the `.setAuthorization()` modifier to set model-level and field-level authorization rules for the SQL-backed data models. Review [Customize your auth rules](/[platform]/build-a-backend/data/customize-authz) for detailed authorization rule options.

```ts
// Add an authorization rule to the schema
// highlight-start
const sqlSchema = generatedSqlSchema.setAuthorization((models) => [
  // Model-level authorization rules
  models.event.authorization((allow) => [allow.publicApiKey()]),
  // Field-level authorization rules
  models.event.fields.id.authorization(allow => [allow.publicApiKey(), allow.guest()]),
  models.event.fields.created_at.authorization(allow => [allow.publicApiKey(), allow.guest()])
]);
// highlight-end
```

## Step 4 - Deploy your Data resources using the cloud sandbox

Finally, you can now validate your Data resources with your cloud sandbox:

```bash
npx ampx sandbox
```

On the client side, you can now make create, read, update, delete, and subscribe to your SQL-backed data models:

```ts
const { data: events } = await client.models.event.list()
```

## Step 5 - Configuring database connection for production

When deploying your app to production, you need to [add the database connection string as a secret](/[platform]/deploy-and-host/fullstack-branching/secrets-and-vars/#set-secrets). Make sure to add the appropriate database connection string with the same secret name you used in the sandbox environment. For example, we used `SQL_CONNECTION_STRING` above.

<Video autoPlay={true} muted={true} loop={true} width="100%" playsInline={true} description="Video - Configuring database connection for production" src="/images/gen2/secrets-and-vars/secrets.mp4">
</Video>

## Rename generated models and fields

To improve the ergonomics of your API, you might want to rename the generate fields or types to better accommodate your use case. Use the `renameModels()` modifier to rename the auto-inferred data models.

```ts
// Rename models or fields to be more idiomatic for frontend code
const sqlSchema = generatedSqlSchema.authorization(allow => allow.guest())
// highlight-start
  .renameModels(() => [
    //⌄⌄⌄⌄⌄ existing model name based on table name
    ['event', 'Event']
    //        ^^^^^^ renamed data model name
  ])
  // highlight-end
```

## Add relationships between tables

```ts
const sqlSchema = generatedSqlSchema
  .authorization(allow => allow.guest())
// highlight-start
  .setRelationships((models) => [
    models.Note.relationships({
      comments: a.hasMany("Comment", "note_id"),
    }),
    models.Comment.relationships({
      note: a.belongsTo("Note", "note_id")
    })
  ]);
// highlight-end
```

## Add custom queries, mutations, subscriptions auto-generated SQL data schema

Use the `.addToSchema(...)` to add in additional queries, mutations, and subscriptions to your auto-generated SQL data schema.

<Callout info>

Note: you can't add additional data models via `a.model()`. They should be exclusively generated via `npx ampx generate schema-from-database`.

</Callout>

### Use an inline SQL statement as a query or mutation handler

```ts
// Add custom mutations or queries that execute SQL statements
const sqlSchema = generatedSqlSchema.authorization(allow => allow.guest())
// highlight-start
  .addToSchema({
    listEventsWithDecodedLatLong: a.query()
      // reference custom types added to the schema
      .returns(a.ref("EventWithDecodedCoord").array())
      .handler(a.handler.inlineSql(
          `SELECT
            id,
            name,
            address,
            ST_X(geom) AS longitude,
            ST_Y(geom) AS latitude
          FROM locations;`
      ))
      .authorization(allow => [allow.guest()]),

      // Define custom types to provide end-to-end typed results
      // for custom queries / mutations
      EventWithDecodedCoord: a.customType({
        id: a.integer(),
        name: a.string(),
        address: a.string(),
        longitude: a.float(),
        latitude: a.float(),
      })
  })
// highlight-end
```

### Reference an existing SQL file as a query or mutation handler

You can define the different SQL handlers in separate `.sql` files and reference them in your custom queries / mutations.

First, configure the custom query or mutation in your **amplify/data/resource.ts** file:
```ts
const sqlSchema = generatedSqlSchema.authorization(allow => allow.guest())
  .addToSchema({
    createNewLocationWithLongLat: a.mutation()
      .arguments({
        lat: a.float().required(),
        long: a.float().required(),
        name: a.string().required(),
        address: a.string().required()
      })
      .returns(a.json().array())
      .authorization(allow => allow.authenticated())
      // highlight-next-line
      .handler(a.handler.sqlReference('./createNewLocationWithLongLat.sql'))
  })
```

Next, add a corresponding sql file to handle the request:

<BlockSwitcher>
<Block name="MySQL">
```sql title="createNewLocationWithLongLat.sql"
INSERT INTO locations (name, address, geom)
VALUES (:name, :address, ST_GEOMFROMTEXT(CONCAT('POINT (', :long, ' ', :lat, ')'), 4326));
```
</Block>
<Block name="PostgreSQL">
```sql title="createNewLocationWithLongLat.sql"
INSERT INTO locations (name, address, geom)
VALUES (:name, :address, ST_SetSRID(ST_MakePoint(:long, :lat), 4326))
```
</Block>
</BlockSwitcher>

<Callout info>
The return type for custom queries and mutations expecting to return row data from SQL statements must be an array of the corresponding model. This is true even for custom `get` queries, where a single row is expected.

**Example**

```ts
getPostBySlug: a
  .query()
  .arguments({
    slug: a.string().required(),
  })
  // highlight-start
  .returns(a.ref("Post").array())
  // highlight-end
  .handler(
    a.handler.inlineSql(`
    SELECT id, title, slug, content, created_at, updated_at
    FROM posts
    WHERE slug = :slug;
    `)
  )
```
</Callout>

## How does it work?

The Amplify uses AWS Lambda functions to enable features like querying data from your database. To work properly, these Lambda functions need access to common logic and dependencies.

Amplify provides this shared code in the form of Lambda Layers. You can think of Lambda Layers as a package of reusable runtime code that Lambda functions can reference.

When you deploy an Amplify API, it will create two Lambda functions:

### SQL Lambda

This allows you to query and write data to your database from your API.

<Callout>
  **NOTE:** If the database is in a VPC, this Lambda function will be deployed
  in the same VPC as the database. The usage of Amazon Virtual Private Cloud
  (VPC) or VPC peering, with AWS Lambda functions will incur additional charges
  as explained, this comes with an additional cost as explained on the [Amazon
  Elastic Compute Cloud (EC2) on-demand pricing
  page](https://aws.amazon.com/ec2/pricing/on-demand/).
</Callout>

### Updater Lambda

This automatically keeps the SQL Lambda up-to-date by managing its Lambda Layers.

A Lambda layer that includes all the core SQL connection logic lives within the AWS Amplify service account but is executed within your AWS account, when invoked by the SQL Lambda. This allows the Amplify service team to own the ongoing maintenance and security enhancements of the SQL connection logic.

This allows the Amplify team to maintain and enhance the SQL Layer without needing direct access to your Lambdas. If updates to the Layer are needed, the Updater Lambda will receive a signal from Amplify and automatically update the SQL Lambda with the latest Layer.

### Mapping of SQL data types to field types for auto-generated schema

<Callout warning>

**Note:** MySQL does not support time zone offsets in date time or timestamp fields. Instead, we will convert these values to `datetime`, without the offset. Unlike MySQL, PostgreSQL does support date time or timestamp values with an offset.

</Callout>

| SQL                | Mapped field types      |
|--------------------|--------------|
| **String**         |              |
| char               | a.string()       |
| varchar            | a.string()       |
| tinytext           | a.string()       |
| text               | a.string()       |
| mediumtext         | a.string()       |
| longtext           | a.string()       |
| **Geometry**       |              |
| geometry           | a.string()       |
| point              | a.string()       |
| linestring         | a.string()       |
| geometryCollection | a.string()       |
| **Numeric**        |              |
| smallint           | a.integer()          |
| mediumint          | a.integer()          |
| int                | a.integer()          |
| integer            | a.integer()          |
| bigint             | a.integer()          |
| tinyint            | a.integer()          |
| float              | a.float()        |
| double             | a.float()        |
| decimal            | a.float()        |
| dec                | a.float()        |
| numeric            | a.float()        |
| **Date and Time**  |              |
| date               | a.date()      |
| datetime           | a.datetime()   |
| timestamp          | a.datetime()   |
| time               | a.time()       |
| year               | a.integer()          |
| **Binary**         |              |
| binary             | a.string()        |
| varbinary          | a.string()        |
| tinyblob           | a.string()        |
| blob               | a.string()        |
| mediumblob         | a.string()        |
| longblob           | a.string()        |
| **Others**         |              |
| bool               | a.boolean()       |
| boolean            | a.boolean()       |
| bit                | a.integer()          |
| json               | a.json()       |
| enum               | a.enum()          |

## Troubleshooting

### Debug Mode

To return the actual SQL error instead of a generic error from underlying API responses, an environment variable `DEBUG_MODE` can be set to `true` on the Amplify-generated SQL Lambda function. You can find this Lambda function in the AWS Lambda console with the naming convention of: `<stack-name>-<api-name>-SQLLambdaFunction<hash>`.

### My SQL table doesn't get generated when running `npx ampx generate schema-from-database`

This is likely because the table doesn't have a designated primary key. A primary key is required for `npx ampx generate schema-from-database` to infer the table structure and create a create, read, update, and delete API.



Contents of build-a-backend_data_connect-to-existing-data-sources_index.txt:
import { getCustomStaticPath } from '@/utils/getCustomStaticPath';
import { getChildPageNodes } from '@/utils/getChildPageNodes';

export const meta = {
  title: 'Connect to existing data sources',
  description: 'Learn how to connect your Data API to existing DynamoDB tables, MySQL databases, or PostgreSQL databases.',
  route: "/[platform]/build-a-backend/data/connect-to-existing-data-sources",
  platforms: [
    'android',
    'angular',
    'flutter',
    'javascript',
    'nextjs',
    'react',
    'react-native',
    'swift',
    'vue'
  ]
};

export const getStaticPaths = async () => {
  return getCustomStaticPath(meta.platforms);
};

export function getStaticProps(context) {
  const childPageNodes = getChildPageNodes(meta.route);
  return {
    props: {
      meta,
      childPageNodes
    }
  };
}

<Overview childPageNodes={props.childPageNodes} />


Contents of build-a-backend_data_custom-business-logic_batch-ddb-operations_index.txt:
import { getCustomStaticPath } from '@/utils/getCustomStaticPath';

export const meta = {
  title: 'Batch DynamoDB Operations',
  description:
    'Batch DynamoDB Operations',
  platforms: [
    'android',
    'angular',
    'flutter',
    'javascript',
    'nextjs',
    'react',
    'react-native',
    'swift',
    'vue'
  ]
};

export const getStaticPaths = async () => {
  return getCustomStaticPath(meta.platforms);
};

export function getStaticProps() {
  return {
    props: {
      meta
    }
  };
}

Batch DynamoDB operations allow you to add multiple items in single mutation.

## Step 1 - Define a custom mutation

```ts title="amplify/data/resource.ts"
import { type ClientSchema, a, defineData } from '@aws-amplify/backend';

const schema = a.schema({
  // 1. Define your return type as a custom type or model
  Post: a.model({
    id: a.id(),
    content: a.string(),
    likes: a.integer()
  }),

  // 2. Define your mutation with the return type and, optionally, arguments
  BatchCreatePost: a
    .mutation()
    // arguments that this query accepts
    .arguments({
      content: a.string().array()
    })
    .returns(a.ref('Post').array())
    // only allow signed-in users to call this API
    .authorization(allow => [allow.authenticated()])
});

export type Schema = ClientSchema<typeof schema>;

export const data = defineData({
  schema
});
```

## Step 2 - Configure custom business logic handler code

After your query or mutation is defined, you need to author your custom business logic using a [custom resolver powered by AppSync JavaScript resolver](https://docs.aws.amazon.com/appsync/latest/devguide/tutorials-js.html).

Custom resolvers work on a "request/response" basis. You choose a data source, map your request to the data source's input parameters, and then map the data source's response back to the query/mutation's return type. Custom resolvers provide the benefit of no cold starts, less infrastructure to manage, and no additional charge for Lambda function invocations. Review [Choosing between custom resolver and function](https://docs.aws.amazon.com/appsync/latest/devguide/resolver-reference-overview-js.html#choosing-data-source).

In your `amplify/data/resource.ts` file, define a custom handler using `a.handler.custom`.

```ts title="amplify/data/resource.ts"
import { type ClientSchema, a, defineData } from '@aws-amplify/backend';

const schema = a.schema({
  Post: a.model({
    id: a.id(),
    content: a.string(),
    likes: a.integer()
  }),

  BatchCreatePost: a
    .mutation()
    .arguments({
      contents: a.string().array()
    })
    .returns(a.ref('Post').array())
    .authorization(allow => [allow.authenticated()])
    // 1. Add the custom handler
    .handler(
      a.handler.custom({
        dataSource: a.ref('Post'),
        entry: './BatchCreatePostHandler.js',
      })
    )
});

export type Schema = ClientSchema<typeof schema>;

export const data = defineData({
  schema
});
```

Amplify will store some values in the resolver context stash that can be accessed in the custom resolver.

| Name                      | Description                                  |
| ------------------------- | -------------------------------------------- |
| awsAppsyncApiId           | The ID of the AppSync API.                   |
| amplifyApiEnvironmentName | The Amplify api environment name. (`NONE` in sandbox) |

The Amplify generated DynamoDB table names can be constructed from the variables in the context stash. The table name is in the format `<model-name>-<aws-appsync-api-id>-<amplify-api-environment-name>`. For example, the table name for the `Post` model would be `Post-123456-dev` where `123456` is the AppSync API ID and `dev` is the Amplify API environment name.

```ts title="amplify/data/BatchCreatePostHandler.js"
import { util } from '@aws-appsync/utils';

export function request(ctx) {
  var now = util.time.nowISO8601();

  return {
    operation: 'BatchPutItem',
    tables: {
      [`Post-${ctx.stash.awsAppsyncApiId}-${ctx.stash.amplifyApiEnvironmentName}`]: ctx.args.contents.map((content) =>
        util.dynamodb.toMapValues({
          content,
          id: util.autoId(),
          createdAt: now,
          updatedAt: now,
        })
      ),
    },
  };
}

export function response(ctx) {
  if (ctx.error) {
    util.error(ctx.error.message, ctx.error.type);
  }
  return ctx.result.data[`Post-${ctx.stash.awsAppsyncApiId}-${ctx.stash.amplifyApiEnvironmentName}`];
}
```

## Step 3 - Invoke the custom query or mutation

From your generated Data client, you can find all your custom queries and mutations under the `client.queries.` and `client.mutations.` APIs respectively.

```ts
const { data, errors } = await client.mutations.BatchCreatePost({
  contents: ['Post 1', 'Post 2', 'Post 3']
});
```


Contents of build-a-backend_data_custom-business-logic_connect-amazon-polly_index.txt:
import { getCustomStaticPath } from '@/utils/getCustomStaticPath';

export const meta = {
  title: 'Connect to Amazon Polly for Text-To-Speech APIs',
  description:
    'Connect to Amazon Polly.',
  platforms: [
    'android',
    'angular',
    'flutter',
    'javascript',
    'nextjs',
    'react',
    'react-native',
    'swift',
    'vue'
  ]
};

export const getStaticPaths = async () => {
  return getCustomStaticPath(meta.platforms);
};

export function getStaticProps() {
  return {
    props: {
      meta
    }
  };
}


Amazon Polly is a text-to-speech (TTS) service offered by Amazon Web Services (AWS). It uses advanced deep learning technologies to convert written text into lifelike speech, enabling you to create applications with speech capabilities in various languages and voices.

With Amazon Polly, you can easily add voice interactions and accessibility features to your applications. The service supports a wide range of use cases, such as providing audio content for the visually impaired, enhancing e-learning experiences, creating interactive voice response (IVR) systems, and more.

Key features of Amazon Polly include:

- **Multiple Voices and Languages**: Amazon Polly supports dozens of voices across various languages and dialects, giving you the flexibility to choose the most appropriate voice for your use case.

- **High-Quality Speech**: Amazon Polly's neural and standard voices offer natural and realistic speech quality.

- **Speech Marks and Speech Synthesis Markup Language**: Customize your speech output with Speech Synthesis Markup Language tags and obtain speech timing information with speech marks.

- **Scalable and Cost-Effective**: Amazon Polly's pay-as-you-go pricing model makes it a cost-effective solution for adding speech capabilities to your applications.

In this section, you'll learn how to integrate Amazon Polly into your application using AWS Amplify, enabling you to leverage its powerful text-to-speech capabilities seamlessly.

## Step 1 - Setup the project

Set up your project by following the instructions in the [Quickstart guide](/[platform]/start/quickstart/).

## Step 2 - Install Polly Libraries
We'll create a new API endpoint that'll use the the AWS SDK to call the Amazon Polly service. To install the Amazon Polly SDK, run the following command in your project's root folder:

```bash title="Terminal" showLineNumbers={false}
npm add @aws-sdk/client-polly
```

## Step 3 - Setup Storage

Create a file named `amplify/storage/resource.ts` and add the following content to configure a storage resource:


```ts title="amplify/storage/resource.ts"
import { defineStorage } from '@aws-amplify/backend';

export const storage = defineStorage({
  name: 'predictions_gen2'
});

```

## Step 4 - Configure IAM Roles

 To access Amazon Polly service, you need to configure the proper IAM policy for Lambda to utilize the desired feature effectively. Update the `amplify/backend.ts` file with the following code to add the necessary permissions to a lambda's Role policy.

 ```ts title= "amplify/backend.ts"
import { defineBackend } from "@aws-amplify/backend";
import { auth } from "./auth/resource";
import { data, convertTextToSpeech } from "./data/resource";
import { Stack } from "aws-cdk-lib";
import { PolicyStatement } from "aws-cdk-lib/aws-iam";
import { storage } from "./storage/resource";

const backend = defineBackend({
  auth,
  data,
  storage,
  convertTextToSpeech,
});

backend.convertTextToSpeech.resources.lambda.addToRolePolicy(
  new PolicyStatement({
    actions: ["polly:StartSpeechSynthesisTask"],
    resources: ["*"],
  })
);
```
## Step 5 - Configure the function handler

Define the function handler by creating a new file, `amplify/data/convertTextToSpeech.ts`. This function converts text into speech using Amazon Polly and stores the synthesized speech as an MP3 file in an S3 bucket.

```ts title="amplify/data/convertTextToSpeech.ts"
import { Schema } from "./resource";
import {
  PollyClient,
  StartSpeechSynthesisTaskCommand,
} from "@aws-sdk/client-polly";
import { env } from "$amplify/env/convertTextToSpeech";

export const handler: Schema["convertTextToSpeech"]["functionHandler"] = async (
  event
) => {
  const client = new PollyClient();
  const task = new StartSpeechSynthesisTaskCommand({
    OutputFormat: "mp3",
    SampleRate: "8000",
    Text: event.arguments.text,
    TextType: "text",
    VoiceId: "Amy",
    OutputS3BucketName: env.PREDICTIONS_GEN_2_BUCKET_NAME,
    OutputS3KeyPrefix: "public/",
  });
  const result = await client.send(task);

  return (
    result.SynthesisTask?.OutputUri?.replace(
      "https://s3.us-east-1.amazonaws.com/" +
        env.PREDICTIONS_GEN_2_BUCKET_NAME +
        "/public/",
      ""
    ) ?? ""
  );
};
```

## Step 6 - Define the custom mutation and function

In your `amplify/data/resource.ts` file, define the function using defineFunction and then reference the function with your mutation using a.handler.function() as a handler.

```ts title="amplify/data/resource.ts"
import {
  type ClientSchema,
  a,
  defineData,
  defineFunction,
} from "@aws-amplify/backend";

export const convertTextToSpeech = defineFunction({
  entry: "./convertTextToSpeech.ts",
});

const schema = a.schema({
  Todo: a
    .model({
      content: a.string(),
    })
    .authorization(allow => [allow.publicApiKey()]),
  convertTextToSpeech: a
    .mutation()
    .arguments({
      text: a.string().required(),
    })
    .returns(a.string().required())
    .authorization(allow => [allow.publicApiKey()])
    .handler(a.handler.function(convertTextToSpeech)),
});

export type Schema = ClientSchema<typeof schema>;

export const data = defineData({
  schema,
  authorizationModes: {
    defaultAuthorizationMode: "apiKey",
    // API Key is used for allow.publicApiKey() rules
    apiKeyAuthorizationMode: {
      expiresInDays: 30,
    },
  },
});
```

<Callout info>
**NOTE:** At least one query is required for a schema to be valid. Otherwise, deployments will fail a schema error. The Amplify Data schema is auto-generated with a `Todo` model and corresponding queries under the hood. You can leave the `Todo` model in the schema until you add the first custom query to the schema in the next steps.
</Callout>


## Step 7 - Update Storage permissions

Customize your storage settings to manage access to various paths within your storage bucket. It's necessary to update the Storage resource to provide access to the `convertTextToSpeech` resource. Modify the file `amplify/storage/resource.ts` as shown below.

```ts title="amplify/storage/resource.ts"
import { defineStorage } from "@aws-amplify/backend";
import { convertTextToSpeech } from "../data/resource";

export const storage = defineStorage({
  name: "predictions_gen2",
  access: (allow) => ({
    "public/*": [
      allow.resource(convertTextToSpeech).to(["write"]),
      allow.guest.to(["read", "write"]),
    ],
  }),
});
```

## Step 8 - Configure the frontend

Import and load the configuration file in your app. It's recommended you add the Amplify configuration step to your app's root entry point.
``` ts title="main.tsx"
import { Amplify } from "aws-amplify";
import outputs from "../amplify_outputs.json";

Amplify.configure(outputs);
```
### Invoke the API

Example frontend code to create an audio buffer for playback using a text input.

<InlineFilter filters={["react", "javascript", "nextjs", "react-native"]}>
```ts title="App.tsx"
import "./App.css";
import { generateClient } from "aws-amplify/api";
import type { Schema } from "../amplify/data/resource";
import { getUrl } from "aws-amplify/storage";
import { useState } from "react";

const client = generateClient<Schema>();

type PollyReturnType = Schema["convertTextToSpeech"]["returnType"];

function App() {
  const [src, setSrc] = useState("");
  const [file, setFile] = useState<PollyReturnType>("");
  return (
    <div className="flex flex-col">
      <button
        onClick={async () => {
          const { data, errors } = await client.mutations.convertTextToSpeech({
            text: "Hello World!",
          });

          if (!errors && data) {
            setFile(data);
          } else {
            console.log(errors);
          }
        }}
      >
        Synth
      </button>
      <button
        onClick={async () => {
          const res = await getUrl({
            path: "public/" + file,
          });

          setSrc(res.url.toString());
        }}
      >
        Fetch audio
      </button>
      <a href={src}>Get audio file</a>
    </div>
  );
}

export default App;
```
</InlineFilter>

<InlineFilter filters={["angular"]}>
```ts title="app.component.ts"
import type { Schema } from '../../../amplify/data/resource';
import { Component } from '@angular/core';
import { generateClient } from 'aws-amplify/api';
import { getUrl } from 'aws-amplify/storage';

const client = generateClient<Schema>();

type PollyReturnType = Schema['convertTextToSpeech']['returnType'];

@Component({
  selector: 'app-root',
  template: `
    <div class="flex flex-col">
      <button (click)="synthesize()">Synth</button>
      <button (click)="fetchAudio()">Fetch audio</button>
      <a [href]="src">Get audio file</a>
    </div>
  `,
  styleUrls: ['./app.component.css'],
})
export class App {
  src: string = '';
  file: PollyReturnType = '';

  async synthesize() {
    const { data, errors } = await client.mutations.convertTextToSpeech({
      text: 'Hello World!',
    });

    if (!errors && data) {
      this.file = data;
    } else {
      console.log(errors);
    }
  }

  async fetchAudio() {
    const res = await getUrl({
      path: 'public/' + this.file,
    });

    this.src = res.url.toString();
  }
}
```
</InlineFilter> 


Contents of build-a-backend_data_custom-business-logic_connect-amazon-rekognition_index.txt:
import { getCustomStaticPath } from '@/utils/getCustomStaticPath';

export const meta = {
  title: 'Connect to Amazon Rekognition for Image Analysis APIs',
  description:
    'Connect to Amazon Rekognition.',
  platforms: [
    'android',
    'angular',
    'flutter',
    'javascript',
    'nextjs',
    'react',
    'react-native',
    'swift',
    'vue'
  ]
};

export const getStaticPaths = async () => {
  return getCustomStaticPath(meta.platforms);
};

export function getStaticProps() {
  return {
    props: {
      meta
    }
  };
}

**Amazon Rekognition** is an advanced machine learning service provided by Amazon Web Services (AWS), allowing developers to incorporate image and video analysis into their applications. It uses state-of-the-art machine learning models to analyze images and videos, providing valuable insights such as object and scene detection, text recognition, face analysis, and more.

Key features of Amazon Rekognition include:

- **Object and Scene Detection**: Amazon Rekognition can identify thousands of objects and scenes in images and videos, providing valuable context for your media content.

- **Text Detection and Recognition**: The service can detect and recognize text within images and videos, making it an invaluable tool for applications requiring text extraction.

- **Facial Analysis**: Amazon Rekognition offers accurate facial analysis, enabling you to detect, analyze, and compare faces in images and videos.

- **Facial Recognition**: You can build applications with the capability to recognize and verify individuals using facial recognition.

- **Content Moderation**: Amazon Rekognition can analyze images and videos to identify inappropriate or objectionable content, helping you maintain safe and compliant content.

In this section, you will learn how to integrate Amazon Rekognition into your application using AWS Amplify, leveraging its powerful image analysis capabilities seamlessly.

## Step 1 - Set up the project

Set up your project by following the instructions in the [Quickstart guide](/[platform]/start/quickstart/).

## Step 2 - Install Rekognition Libraries
Create a new API endpoint that'll use the the AWS SDK to call the Amazon Rekognition service. To install the Amazon Rekognition SDK, run the following command in your project's root folder:

```bash title="Terminal" showLineNumbers={false}
npm add @aws-sdk/client-rekognition
```

## Step 3 - Setup Storage

Create a file named `amplify/storage/resource.ts` and add the following content to configure a storage resource:


```ts title="amplify/storage/resource.ts"
import { defineStorage } from '@aws-amplify/backend';

export const storage = defineStorage({
  name: 'predictions_gen2'
});

```

## Step 4 - Add your Amazon Rekognition as Datasource

To use the Amazon Rekognition service, you need to add Amazon Rekognition as an HTTP Data Source and configure the proper IAM policy for Lambda to effectively utilize the desired feature and grant permission to access the storage. In this case, you can add the `rekognition:DetectText` and `rekognition:DetectLabels` actions to the policy. Update the `amplify/backend.ts` file as shown below.

 ```ts title= "amplify/backend.ts"
import { PolicyStatement } from 'aws-cdk-lib/aws-iam';
import { defineBackend } from '@aws-amplify/backend';
import { auth } from './auth/resource';
import { data } from './data/resource';
import { storage } from './storage/resource';

const backend = defineBackend({
  auth,
  data,
  storage
});

// Set environment variables for the S3 Bucket name
backend.data.resources.cfnResources.cfnGraphqlApi.environmentVariables = {
  S3_BUCKET_NAME: backend.storage.resources.bucket.bucketName,
};

const rekognitionDataSource = backend.data.addHttpDataSource(
  "RekognitionDataSource",
  `https://rekognition.${backend.data.stack.region}.amazonaws.com`,
  {
    authorizationConfig: {
      signingRegion: backend.data.stack.region,
      signingServiceName: "rekognition",
    },
  }
);

rekognitionDataSource.grantPrincipal.addToPrincipalPolicy(
  new PolicyStatement({
    actions: ["rekognition:DetectText", "rekognition:DetectLabels"],
    resources: ["*"],
  })
);

backend.storage.resources.bucket.grantReadWrite(
  rekognitionDataSource.grantPrincipal
);

```
## Step 5 - Configure the function handler

Define the function handler by creating a new file, `amplify/data/identifyText.ts`. This function analyzes the image and extracts text using the Amazon Rekognition DetectText service.

```ts title="amplify/data/identifyText.ts"

export function request(ctx) {
  return {
    method: "POST",
    resourcePath: "/",
    params: {
      body: {
        Image: {
          S3Object: {
            Bucket: ctx.env.S3_BUCKET_NAME,
            Name: ctx.arguments.path,
          },
        },
      },
      headers: {
        "Content-Type": "application/x-amz-json-1.1",
        "X-Amz-Target": "RekognitionService.DetectText",
      },
    },
  };
}

export function response(ctx) {
  return JSON.parse(ctx.result.body)
    .TextDetections.filter((item) => item.Type === "LINE")
    .map((item) => item.DetectedText)
    .join("\n")
    .trim();
}

```

## Step 6 - Define the custom query

After adding Amazon Rekognition as a data source, you can reference it in custom query using the `a.handler.custom()` modifier, which takes the name of the data source and an entry point for your resolvers. In your `amplify/data/resource.ts` file, specify `RekognitionDataSource` as the data source and `identifyText.js` as the entry point, as shown below.

```ts title="amplify/data/resource.ts"
import { type ClientSchema, a, defineData } from "@aws-amplify/backend";

const schema = a.schema({
  identifyText: a
    .query()
    .arguments({
      path: a.string(),
    })
    .returns(a.string())
    .authorization((allow) => [allow.publicApiKey()])
    .handler(
      a.handler.custom({
        entry: "./identifyText.js",
        dataSource: "RekognitionDataSource",
      })
    ),
});

export type Schema = ClientSchema<typeof schema>;

export const data = defineData({
  schema,
  authorizationModes: {
    defaultAuthorizationMode: "apiKey",
    apiKeyAuthorizationMode: {
      expiresInDays: 30,
    },
  },
});
```
## Step 7 - Update Storage permissions

Customize your storage settings to manage access to various paths within your storage bucket. Modify the file `amplify/storage/resource.ts` as shown below.

```ts title="amplify/storage/resource.ts"
import { defineStorage } from "@aws-amplify/backend"

export const storage = defineStorage({
  name: "predictions_gen2",
  access: allow => ({
    'public/*': [
      allow.guest.to(['list', 'write', 'get'])
    ]
  })
})
```

## Step 8 - Configure the frontend

Import and load the configuration file in your app. It's recommended you add the Amplify configuration step to your app's root entry point.

``` ts title="main.tsx"
import { Amplify } from "aws-amplify";
import outputs from "../amplify_outputs.json";

Amplify.configure(outputs);

```
### Invoke the Text Recognition API

This code sets up a React app to upload an image to an S3 bucket and then use Amazon Rekognition to recognize the text in the uploaded image.

<InlineFilter filters={["react", "javascript", "nextjs", "react-native"]}>
```ts title="App.tsx"
import { type ChangeEvent, useState } from "react";
import { generateClient } from "aws-amplify/api";
import { uploadData } from "aws-amplify/storage";
import { Schema } from "@/amplify/data/resource";
import "./App.css";

// Generating the client
const client = generateClient<Schema>();

type IdentifyTextReturnType = Schema["identifyText"]["returnType"];

function App() {
  // State to hold the recognized text
  const [path, setPath] = useState<string>("");
  const [textData, setTextData] = useState<IdentifyTextReturnType>();

  // Function to handle file upload to S3 bucket
  const handleTranslate = async (event: ChangeEvent<HTMLInputElement>) => {
    if (event.target.files) {
      const file = event.target.files[0];

      const s3Path = "public/" + file.name;

      try {
        uploadData({
          path: s3Path,
          data: file,
        });

        setPath(s3Path);
      } catch (error) {
        console.error(error);
      }
    }
  };

  // Function to recognize text from the uploaded image
  const recognizeText = async () => {
    // Identifying text in the uploaded image
    const { data } = await client.queries.identifyText({
      path, // File name
    });
    setTextData(data);
  };

  return (
    <div>
      <h1>Amazon Rekognition Text Recognition</h1>
      <div>
        <input type="file" onChange={handleTranslate} />
        <button onClick={recognizeText}>Recognize Text</button>
        <div>
          <h3>Recognized Text:</h3>
          {textData}
        </div>
      </div>
    </div>
  );
}

export default App;
```
</InlineFilter>
<InlineFilter filters={["angular"]}>
```ts title="app.component.ts"
import type { Schema } from '../../../amplify/data/resource';
import { Component } from '@angular/core';
import { generateClient } from 'aws-amplify/api';
import { uploadData } from 'aws-amplify/storage';
import { CommonModule } from '@angular/common';

// Generating the client
const client = generateClient<Schema>();

type IdentifyTextReturnType = Schema['identifyText']['returnType'];

@Component({
  selector: 'app-text-recognition',
  standalone: true,
  imports: [CommonModule],
  template: `
    <div>
      <h1>Amazon Rekognition Text Recognition</h1>
      <div>
        <input type="file" (change)="handleTranslate($event)" />
        <button (click)="recognizeText()">Recognize Text</button>
        <div>
          <h3>Recognized Text:</h3>
          {{ textData }}
        </div>
      </div>
    </div>
  `,
})
export class TodosComponent {
  // Component properties instead of React state
  path: string = '';
  textData?: IdentifyTextReturnType;

  // Function to handle file upload to S3 bucket
  async handleTranslate(event: Event) {
    const target = event.target as HTMLInputElement;
    if (target.files && target.files.length > 0) {
      const file = target.files[0];
      const s3Path = 'public/' + file.name;

      try {
        await uploadData({
          path: s3Path,
          data: file,
        });

        this.path = s3Path;
      } catch (error) {
        console.error(error);
      }
    }
  }

  // Function to recognize text from the uploaded image
  async recognizeText() {
    // Identifying text in the uploaded image
    const { data } = await client.queries.identifyText({
      path: this.path, // File name
    });
    this.textData = data;
  }
}
```
</InlineFilter>


Contents of build-a-backend_data_custom-business-logic_connect-amazon-translate_index.txt:
import { getCustomStaticPath } from '@/utils/getCustomStaticPath';

export const meta = {
  title: 'Connect to Amazon Translate for language translation APIs',
  description:
    'Connect to Amazon Translate.',
  platforms: [
    'android',
    'angular',
    'flutter',
    'javascript',
    'nextjs',
    'react',
    'react-native',
    'swift',
    'vue'
  ]
};

export const getStaticPaths = async () => {
  return getCustomStaticPath(meta.platforms);
};

export function getStaticProps() {
  return {
    props: {
      meta
    }
  };
}

Amazon Translate is a neural machine translation service provided by Amazon Web Services (AWS). It uses advanced deep learning technologies to deliver fast and high-quality language translation. With Amazon Translate, you can easily add multilingual support to your applications and services, enabling users to communicate and interact in their preferred language.

Key features of Amazon Translate include:

- **Accurate and Fluent Translations**: Amazon Translate produces translations that are both accurate and natural-sounding, providing a seamless experience for users.

- **Support for Multiple Languages**: The service supports a broad range of languages, allowing you to expand your application’s reach to diverse audiences around the world.

- **Real-Time and Batch Translation**: Amazon Translate can handle real-time translation for dynamic content and batch translation for larger volumes of text, making it suitable for various use cases.

- **Cost-Effective and Scalable**: With its pay-as-you-go pricing model and automatic scaling, Amazon Translate is an economical and flexible solution for adding translation capabilities to your applications.

In this section, you will learn how to integrate Amazon Translate into your application using AWS Amplify, enabling you to leverage its powerful translation capabilities effortlessly.

## Step 1 - Set up the project

Set up your project by following the instructions in the [Quickstart guide](/[platform]/start/quickstart/).

## Step 2 - Install Amazon Translate libraries
To install the Amazon Translate SDK, run the following command in your project's root folder:

```bash title="Terminal" showLineNumbers={false}
npm add @aws-sdk/client-translate
```

## Step 3 - Add your Amazon Translate as Datasource

 To access Amazon Translate service, you need to add Amazon Translate as an HTTP Data Source and configure the proper IAM policy for AWS Lambda to utilize the desired feature effectively. Update `amplify/backend.ts` file as shown below.

 ```ts title="amplify/backend.ts"
import { defineBackend } from '@aws-amplify/backend';
import { PolicyStatement } from 'aws-cdk-lib/aws-iam';
import { auth } from './auth/resource';
import { data } from './data/resource';

const backend = defineBackend({
  auth,
  data
});

const translateDataSource = backend.data.addHttpDataSource(
  "TranslateDataSource",
  `https://translate.${backend.data.stack.region}.amazonaws.com`,
  {
    authorizationConfig: {
      signingRegion: backend.data.stack.region,
      signingServiceName: "translate",
    },
  }
);

translateDataSource.grantPrincipal.addToPrincipalPolicy(
  new PolicyStatement({
    actions: ["translate:TranslateText"],
    resources: ["*"],
  })
);
```
## Step 4 - Configure custom business logic handler

Next, create the following `translate.js` file in your `amplify/data` folder and use the code below to define custom resolvers.

```ts title="amplify/data/translate.js"

export function request(ctx) {
  return {
    method: 'POST',
    resourcePath: '/',
    params: {
      body: {
        SourceLanguageCode: ctx.arguments.sourceLanguage,
        TargetLanguageCode: ctx.arguments.targetLanguage,
        Text: ctx.arguments.text
      },
      headers: {
        'Content-Type': 'application/x-amz-json-1.1',
        'X-Amz-Target': 'AWSShineFrontendService_20170701.TranslateText'
      }
    },
  }
}

export function response(ctx) {
  return JSON.parse(ctx.result.body).TranslatedText
}

```

## Step 5 - Define the custom query

After adding Amazon Translate as a data source, you can reference it in a custom query using the `a.handler.custom()` modifier, which takes the name of the data source and an entry point for your resolvers. In your `amplify/data/resource.ts` file, specify `TranslateDataSource` as the data source and `translate.js` as the entry point, as shown below.

```ts title="amplify/data/resource.ts"
import { type ClientSchema, a, defineData } from '@aws-amplify/backend';


const schema = a.schema({
  translate: a.query()
    .arguments({
      sourceLanguage: a.string().required(),
      targetLanguage: a.string().required(),
      text: a.string().required()
    })
    .returns(a.string())
    .authorization(allow => [allow.publicApiKey()])
    .handler(a.handler.custom({
      dataSource: "TranslateDataSource",
      entry: './translate.js'
    }))
});

export type Schema = ClientSchema<typeof schema>;

export const data = defineData({
  schema,
  authorizationModes: {
    defaultAuthorizationMode: 'apiKey',
    apiKeyAuthorizationMode: {
      expiresInDays: 30,
    },
  },
});

```

## Step 6 - Configure the frontend

Import and load the configuration file in your app. It's recommended you add the Amplify configuration step to your app's root entry point.

``` ts title="main.tsx"
import { Amplify } from "aws-amplify";
import outputs from "../amplify_outputs.json";

Amplify.configure(outputs);
```
### Invoke the API

Sample frontend code to translate text from one language to another.

```ts
import { generateClient } from 'aws-amplify/data';
import { type Schema } from '../amplify/data/resource';

const client = generateClient<Schema>();


const { data } = await client.queries.translate({
  sourceLanguage: "en",
  targetLanguage: "es",
  text: "Hello World!",
});
```


Contents of build-a-backend_data_custom-business-logic_connect-bedrock_index.txt:
import { getCustomStaticPath } from '@/utils/getCustomStaticPath';

export const meta = {
  title: 'Connect to Amazon Bedrock for generative AI use cases',
  description:
    'Connect to Amazon Bedrock to build generative AI applications with AWS Amplify.',
  platforms: [
    'android',
    'angular',
    'flutter',
    'javascript',
    'nextjs',
    'react',
    'react-native',
    'swift',
    'vue',
  ],
};

export const getStaticPaths = async () => {
  return getCustomStaticPath(meta.platforms);
};

export function getStaticProps() {
  return {
    props: {
      meta
    }
  };
}

[Amazon Bedrock](https://aws.amazon.com/bedrock/) is a fully managed service that removes the complexity of using foundation models (FMs) for generative AI development. It acts as a central hub, offering a curated selection of high-performing FMs from leading AI companies like Anthropic, AI21 Labs, Cohere, and Amazon itself.

Amazon Bedrock streamlines generative AI development by providing:

- **Choice and Flexibility**: Experiment and evaluate a wide range of FMs to find the perfect fit for your use case.

- **Simplified Integration**: Access and use FMs through a single, unified API, reducing development time.

- **Enhanced Security and Privacy**: Benefit from built-in safeguards to protect your data and prevent misuse.

- **Responsible AI Features**: Implement guardrails to control outputs and mitigate bias.

In the following sections, we walk through the steps to add Amazon Bedrock to your API as a data source and connect to it from your Amplify app:

1. Add Amazon Bedrock as a data source
2. Define a custom query
3. Configure custom business logic handler code
4. Invoke a custom query to prompt a generative AI model

## Step 1 - Add Amazon Bedrock as a data source

To connect to Amazon Bedrock as a data source, you can choose between two methods - using a Lambda function or a custom resolver powered by AppSync JavaScript resolvers. The following steps demonstrate both methods:

<BlockSwitcher>
<Block name="Function">

In your `amplify/backend.ts` file, replace the content with the following code to add a lambda function to your backend and grant it permission to invoke a generative AI model in Amazon Bedrock. The `generateHaikuFunction` lambda function will be defined in and exported from the `amplify/data/resource.ts` file in the next steps:

```ts title="amplify/backend.ts"
import { defineBackend } from "@aws-amplify/backend";
import { auth } from "./auth/resource";
import { data, MODEL_ID, generateHaikuFunction } from "./data/resource";
import { Effect, PolicyStatement } from "aws-cdk-lib/aws-iam";

export const backend = defineBackend({
  auth,
  data,
  generateHaikuFunction,
});

backend.generateHaikuFunction.resources.lambda.addToRolePolicy(
  new PolicyStatement({
    effect: Effect.ALLOW,
    actions: ["bedrock:InvokeModel"],
    resources: [
      `arn:aws:bedrock:*::foundation-model/${MODEL_ID}`,
    ],
  })
);
```
</Block>
<Block name="Custom resolver powered by AppSync JavaScript resolvers">

In your `amplify/backend.ts` file, replace the content with the following code to add an HTTP data source for Amazon Bedrock to your API and grant it permissions to invoke a generative AI model:

```ts title="amplify/backend.ts"
import { Effect, PolicyStatement } from "aws-cdk-lib/aws-iam";
import { defineBackend } from "@aws-amplify/backend";
import { auth } from "./auth/resource";
import { data } from "./data/resource";

export const backend = defineBackend({
  auth,
  data,
});

const MODEL_ID = "anthropic.claude-3-haiku-20240307-v1:0";

const bedrockDataSource = backend.data.addHttpDataSource(
  "BedrockDataSource",
  "https://bedrock-runtime.us-east-1.amazonaws.com",
  {
    authorizationConfig: {
      signingRegion: backend.data.stack.region,
      signingServiceName: "bedrock",
    },
  }
);

bedrockDataSource.grantPrincipal.addToPrincipalPolicy(
  new PolicyStatement({
    effect: Effect.ALLOW,
    actions: ["bedrock:InvokeModel"],
    resources: [
      `arn:aws:bedrock:${backend.data.stack.region}::foundation-model/${MODEL_ID}`,
    ],
  })
);

backend.data.resources.cfnResources.cfnGraphqlApi.environmentVariables = {
  MODEL_ID
}
```
</Block>
</BlockSwitcher>

For the purpose of this guide, we will use Anthropic's Claude 3 Haiku to generate content. If you want to use a different model, you can find the ID for your model of choice in the Amazon Bedrock documentation's [list of model IDs](https://docs.aws.amazon.com/bedrock/latest/userguide/model-ids.html) or the [Amazon Bedrock console](https://console.aws.amazon.com/bedrock/) and replace the value of `MODEL_ID`.

<Callout info>
The availability of Amazon Bedrock and its foundation models may vary by region.

The policy statement in the code above assumes that your Amplify app is deployed in a region supported by Amazon Bedrock and the Claude 3 Haiku model. If you are deploying your app in a region where Amazon Bedrock is not available, update the code above accordingly.

For a list of supported regions please refer to the [Amazon Bedrock documentation](https://docs.aws.amazon.com/bedrock/latest/userguide/bedrock-regions.html).
</Callout>


## Step 2 - Define a custom query

<BlockSwitcher>
<Block name="Function">
Next, replace the contents of your `amplify/data/resource.ts` file with the following code. This will define and export a lambda function that was granted permission to invoke a generative AI model in Amazon Bedrock in the previous step. A custom query named `generateHaiku` is added to the schema with the `generateHaikuFunction` as the handler using the `a.handler.function()` modifier:

```ts title="amplify/data/resource.ts"
import {
  type ClientSchema,
  a,
  defineData,
  defineFunction,
} from "@aws-amplify/backend";

export const MODEL_ID = "anthropic.claude-3-haiku-20240307-v1:0";

export const generateHaikuFunction = defineFunction({
  entry: "./generateHaiku.ts",
  environment: {
    MODEL_ID,
  },
});

const schema = a.schema({
  generateHaiku: a
    .query()
    .arguments({ prompt: a.string().required() })
    .returns(a.string())
    .authorization((allow) => [allow.publicApiKey()])
    .handler(a.handler.function(generateHaikuFunction)),
});

export type Schema = ClientSchema<typeof schema>;

export const data = defineData({
  schema,
  authorizationModes: {
    defaultAuthorizationMode: "apiKey",
    apiKeyAuthorizationMode: {
      expiresInDays: 30,
    },
  },
});
```
</Block>
<Block name="Custom resolver powered by AppSync JavaScript resolvers">
With Amazon Bedrock added as a data source, you can reference it in custom queries using the `a.handler.custom()` modifier which accepts the name of the data source and an entry point for your resolvers. Replace the contents of your `amplify/data/resource.ts` file with the following code to define a custom query named `generateHaiku` in the schema:

```ts title="amplify/data/resource.ts"
import { type ClientSchema, a, defineData } from "@aws-amplify/backend";

const schema = a.schema({
  generateHaiku: a
    .query()
    .arguments({ prompt: a.string().required() })
    .returns(a.string())
    .authorization((allow) => [allow.publicApiKey()])
    .handler(
      a.handler.custom({
        dataSource: "BedrockDataSource",
        entry: "./generateHaiku.js",
      })
    ),
});

export type Schema = ClientSchema<typeof schema>;

export const data = defineData({
  schema,
  authorizationModes: {
    defaultAuthorizationMode: "apiKey",
    apiKeyAuthorizationMode: {
      expiresInDays: 30,
    },
  },
});
```
</Block>
</BlockSwitcher>

## Step 3 - Configure custom business logic handler code

<BlockSwitcher>
<Block name="Function">
Next, create a `generateHaiku.ts` file in your `amplify/data` folder and use the following code to define a custom resolver for the custom query added to your schema in the previous step:

The following code uses the `BedrockRuntimeClient` from the `@aws-sdk/client-bedrock-runtime` package to invoke the generative AI model in Amazon Bedrock. The `handler` function takes the user prompt as an argument, invokes the model, and returns the generated haiku.

```ts title="amplify/data/generateHaiku.ts"
import type { Schema } from "./resource";
import {
  BedrockRuntimeClient,
  InvokeModelCommand,
  InvokeModelCommandInput,
} from "@aws-sdk/client-bedrock-runtime";

// initialize bedrock runtime client
const client = new BedrockRuntimeClient();

export const handler: Schema["generateHaiku"]["functionHandler"] = async (
  event,
  context
) => {
  // User prompt
  const prompt = event.arguments.prompt;

  // Invoke model
  const input = {
    modelId: process.env.MODEL_ID,
    contentType: "application/json",
    accept: "application/json",
    body: JSON.stringify({
      anthropic_version: "bedrock-2023-05-31",
      system:
        "You are a an expert at crafting a haiku. You are able to craft a haiku out of anything and therefore answer only in haiku.",
      messages: [
        {
          role: "user",
          content: [
            {
              type: "text",
              text: prompt,
            },
          ],
        },
      ],
      max_tokens: 1000,
      temperature: 0.5,
    }),
  } as InvokeModelCommandInput;

  const command = new InvokeModelCommand(input);

  const response = await client.send(command);

  // Parse the response and return the generated haiku
  const data = JSON.parse(Buffer.from(response.body).toString());

  return data.content[0].text;
};
```
</Block>
<Block name="Custom resolver powered by AppSync JavaScript resolvers">
Next, create a `generateHaiku.js` file in your `amplify/data` folder and use the following code to define a custom resolver for the custom query added to your schema in the previous step:

The following code defines a `request` function that constructs the HTTP request to invoke the generative AI model in Amazon Bedrock. The `response` function parses the response and returns the generated haiku.

```js title="amplify/data/generateHaiku.js"
export function request(ctx) {

  // Define a system prompt to give the model a persona
  const system =
    "You are a an expert at crafting a haiku. You are able to craft a haiku out of anything and therefore answer only in haiku.";

  const prompt = ctx.args.prompt

  // Construct the HTTP request to invoke the generative AI model
  return {
    resourcePath: `/model/${ctx.env.MODEL_ID}/invoke`,
    method: "POST",
    params: {
      headers: {
        "Content-Type": "application/json",
      },
      body: {
        anthropic_version: "bedrock-2023-05-31",
        system,
        messages: [
          {
            role: "user",
            content: [
              {
                type: "text",
                text: prompt,
              },
            ],
          },
        ],
        max_tokens: 1000,
        temperature: 0.5,
      },
    },
  };
}

// Parse the response and return the generated haiku
export function response(ctx) {
  const res = JSON.parse(ctx.result.body);
  const haiku = res.content[0].text;

  return haiku;
}
```
</Block>
</BlockSwitcher>

The code above uses the [Messages API](https://docs.aws.amazon.com/bedrock/latest/userguide/model-parameters-anthropic-claude-messages.html), which is supported by chat models such as Anthropic's Claude 3 Haiku.

The `system` prompt is used to give the model a persona or directives to follow, and the `messages` array can contain a history of messages. The `max_tokens` parameter controls the maximum number of tokens the model can generate, and the `temperature` parameter determines the randomness, or creativity, of the generated response.

## Step 4 - Invoke a custom query to prompt a generative AI model

From your generated Data client, you can find all your custom queries and mutations under the `client.queries` and `client.mutations` APIs respectively.

The custom query below will prompt a generative AI model to create a haiku based on the given prompt. Replace the `prompt` value with your desired prompt text or user input and invoke the query as shown below:

```ts title="App.tsx"
const { data, errors } = await client.queries.generateHaiku({
  prompt: "Frank Herbert's Dune",
});
```

Here's an example of a simple UI that prompts a generative AI model to create a haiku based on user input:

<InlineFilter filters={["react", "javascript", "nextjs", "react-native", "vue"]}>
```tsx title="App.tsx"
import type { Schema } from '@/amplify/data/resource';
import type { FormEvent } from 'react';
import { useState } from 'react';
import { Amplify } from 'aws-amplify';
import { generateClient } from 'aws-amplify/api';
import outputs from '@/amplify_outputs.json';

Amplify.configure(outputs);

const client = generateClient<Schema>();

export default function App() {
  const [prompt, setPrompt] = useState<string>('');
  const [answer, setAnswer] = useState<string | null>(null);

  const sendPrompt = async (event: FormEvent<HTMLFormElement>) => {
    event.preventDefault();

    const { data, errors } = await client.queries.generateHaiku({
      prompt
    });

    if (!errors) {
      setAnswer(data);
      setPrompt('');
    } else {
      console.log(errors);
    }
  };

  return (
    <main className="flex min-h-screen flex-col items-center justify-center p-24 dark:text-white">
      <div>
        <h1 className="text-3xl font-bold text-center mb-4">Haiku Generator</h1>
        <form className="mb-4 self-center max-w-[500px]" onSubmit={sendPrompt}>
          <input
            className="text-black p-2 w-full"
            placeholder="Enter a prompt..."
            name="prompt"
            value={prompt}
            onChange={(event) => setPrompt(event.target.value)}
          />
        </form>
        <div className="text-center">
          <pre>{answer}</pre>
        </div>
      </div>
    </main>
  );
}
```
</InlineFilter>

<InlineFilter filters={['angular']}>
```ts title="app.component.ts"
import type { Schema } from '../../../amplify/data/resource';
import { Component } from '@angular/core';
import { FormsModule } from '@angular/forms';
import { Amplify } from 'aws-amplify';
import { generateClient } from 'aws-amplify/api';
import outputs from '../../../amplify_outputs.json';

Amplify.configure(outputs);

const client = generateClient<Schema>();

@Component({
  selector: 'app-haiku',
  standalone: true,
  imports: [FormsModule],
  template: `
    <main
      class="flex min-h-screen flex-col items-center justify-center p-24 dark:text-white"
    >
      <div>
        <h1 class="text-3xl font-bold text-center mb-4">Haiku Generator</h1>
        <form class="mb-4 self-center max-w-[500px]" (ngSubmit)="sendPrompt()">
          <input
            class="text-black p-2 w-full"
            placeholder="Enter a prompt..."
            name="prompt"
            [(ngModel)]="prompt"
          />
        </form>
        <div class="text-center">
          <pre>{{ answer }}</pre>
        </div>
      </div>
    </main>
  `,
})
export class HaikuComponent {
  prompt: string = '';
  answer: string | null = null;

  async sendPrompt() {
    const { data, errors } = await client.queries.generateHaiku({
      prompt: this.prompt,
    });

    if (!errors) {
      this.answer = data;
      this.prompt = '';
    } else {
      console.log(errors);
    }
  }
}
```
</InlineFilter>

![A webpage titled "Haiku Generator" and input field. "Frank Herbert's Dune" is entered and submitted. Shortly after, a haiku is rendered to the page.](/images/haiku-generator.gif)

## Conclusion

In this guide, you learned how to connect to Amazon Bedrock from your Amplify app. By adding Bedrock as a data source, defining a custom query, configuring custom business logic handler code, and invoking custom queries, you can leverage the power of generative AI models in your application.

To clean up, you can delete your sandbox by accepting the prompt when terminating the sandbox process in your terminal. Alternatively, you can also use the AWS Amplify console to manage and delete sandbox environments.



Contents of build-a-backend_data_custom-business-logic_connect-eventbridge-datasource_index.txt:
import { getCustomStaticPath } from '@/utils/getCustomStaticPath';

export const meta = {
  title: 'Connect to Amazon EventBridge to send and receive events',
  description:
    'Connect to Amazon EventBridge data sources to build event-driven applications with AWS Amplify.',
  platforms: [
    'android',
    'angular',
    'flutter',
    'javascript',
    'nextjs',
    'react',
    'react-native',
    'swift',
    'vue',
  ],
};

export const getStaticPaths = async () => {
  return getCustomStaticPath(meta.platforms);
};

export function getStaticProps() {
  return {
    props: {
      meta
    }
  };
}

Amazon EventBridge is a serverless event bus that simplifies how applications communicate with each other. It acts as a central hub for events generated by various sources, including AWS services, custom applications, and third-party SaaS providers.

EventBridge delivers this event data in real-time, allowing you to build applications that react swiftly to changes. You define rules to filter and route these events to specific destinations, known as targets. Targets can include services like AWS Lambda, Amazon SQS Queues, Amazon SNS Topics. For the purpose of this guide, we will use AWS AppSync as the target for events.

By adopting an event-driven architecture with EventBridge, you can achieve:

- **Loose Coupling**: Applications become independent and communicate through events, improving scalability and maintainability.

- **Increased Resilience**: System failures are isolated as events are delivered asynchronously, ensuring overall application availability.

- **Simplified Integration**: EventBridge provides a unified interface for integrating diverse event sources, streamlining development.

This section will guide you through adding an event bus as a datasource to your API, defining routing rules, and configuring targets to build robust event-driven applications with AWS Amplify Gen 2 and Amazon EventBridge.

1. Set up your API
2. Add your Amazon EventBridge event bus as a data source
3. Define custom queries and mutations
4. Configure custom business logic handler code
5. Invoke custom mutations to send events to EventBridge
6. Subscribe to mutations invoked by EventBridge
7. Invoke mutations and trigger subscriptions from EventBridge

## Step 1 - Set up your API

For the purpose of this guide, we will define an `OrderStatusChange` custom type that represents an order status change event. This type includes fields for the order ID, status, and message.

In your `amplify/data/resource.ts` file, use the following code to define an `OrderStatusChange` custom type and an `OrderStatus` enum, adding them to your schema:

```ts title="amplify/data/resource.ts"
import { type ClientSchema, a, defineData } from "@aws-amplify/backend";

const schema = a.schema({
  Todo: a
    .model({
      content: a.string(),
    })
    .authorization(allow => [allow.publicApiKey()]),
  // highlight-start
  OrderStatus: a.enum(["OrderPending", "OrderShipped", "OrderDelivered"]),
  OrderStatusChange: a.customType({
    orderId: a.id().required(),
    status: a.ref("OrderStatus").required(),
    message: a.string().required(),
  }),
  // highlight-end
});

export type Schema = ClientSchema<typeof schema>;

export const data = defineData({
  schema,
  authorizationModes: {
    defaultAuthorizationMode: 'apiKey',
    apiKeyAuthorizationMode: {
      expiresInDays: 30,
    },
  },
});
```

<Callout info>
**NOTE:** At least one query is required for a schema to be valid. Otherwise, deployments will fail a schema error. The Amplify Data schema is auto-generated with a `Todo` model and corresponding queries under the hood. You can leave the `Todo` model in the schema until you add the first custom query to the schema in the next steps.
</Callout>

## Step 2 - Add your Amazon EventBridge event bus as a data source

In your `amplify/backend.ts` file, use the following code to add the default event bus as a data source for your API:

```ts title="amplify/backend.ts"
import { defineBackend } from "@aws-amplify/backend";
import { auth } from "./auth/resource";
import { data } from "./data/resource";
import { aws_events } from "aws-cdk-lib";
import {
  Effect,
  PolicyDocument,
  PolicyStatement,
  Role,
  ServicePrincipal,
} from "aws-cdk-lib/aws-iam";

export const backend = defineBackend({
  auth,
  data,
});

// Create a new stack for the EventBridge data source
const eventStack = backend.createStack("MyExternalDataSources");

// Reference or create an EventBridge EventBus
const eventBus = aws_events.EventBus.fromEventBusName(
  eventStack,
  "MyEventBus",
  "default"
);

// Add the EventBridge data source
// highlight-start
backend.data.addEventBridgeDataSource("MyEventBridgeDataSource", eventBus);
// highlight-end

// Create a policy statement to allow invoking the AppSync API's mutations
const policyStatement = new PolicyStatement({
  effect: Effect.ALLOW,
  actions: ["appsync:GraphQL"],
  resources: [`${backend.data.resources.graphqlApi.arn}/types/Mutation/*`],
});

// Create a role for the EventBus to assume
const eventBusRole = new Role(eventStack, "AppSyncInvokeRole", {
  assumedBy: new ServicePrincipal("events.amazonaws.com"),
  inlinePolicies: {
    PolicyStatement: new PolicyDocument({
      statements: [policyStatement],
    }),
  },
});

// Create an EventBridge rule to route events to the AppSync API
const rule = new aws_events.CfnRule(eventStack, "MyOrderRule", {
  eventBusName: eventBus.eventBusName,
  name: "broadcastOrderStatusChange",
  eventPattern: {
    source: ["amplify.orders"],
    /* The shape of the event pattern must match EventBridge's event message structure.
    So, this field must be spelled as "detail-type". Otherwise, events will not trigger the rule.

    https://docs.aws.amazon.com/AmazonS3/latest/userguide/ev-events.html
    */
    ["detail-type"]: ["OrderStatusChange"],
    detail: {
      orderId: [{ exists: true }],
      status: ["PENDING", "SHIPPED", "DELIVERED"],
      message: [{ exists: true }],
    },
  },
  targets: [
    {
      id: "orderStatusChangeReceiver",
      arn: backend.data.resources.cfnResources.cfnGraphqlApi
        .attrGraphQlEndpointArn,
      roleArn: eventBusRole.roleArn,
      appSyncParameters: {
        graphQlOperation: `
        mutation PublishOrderFromEventBridge(
          $orderId: String!
          $status: String!
          $message: String!
        ) {
          publishOrderFromEventBridge(orderId: $orderId, status: $status, message: $message) {
            orderId
            status
            message
          }
        }`,
      },
      inputTransformer: {
        inputPathsMap: {
          orderId: "$.detail.orderId",
          status: "$.detail.status",
          message: "$.detail.message",
        },
        inputTemplate: JSON.stringify({
          orderId: "<orderId>",
          status: "<status>",
          message: "<message>",
        }),
      },
    },
  ],
});
```

<Callout warning>
The selection set returned by the mutation must match the selection set of the subscription. If the selection set of the mutation is different from the selection set of the subscription, the subscription will not receive the event.
</Callout>

In the code snippet above, the `addEventBridgeDataSource` method is used to add the default event bus as a data source to your API. This allows you to reference the event bus in your custom queries and mutations.

The `CfnRule` construct is used to create an EventBridge rule that routes events to the AppSync API. The rule specifies the event pattern to match and the target to invoke when the event is received. In this example, the target is an AppSync mutation named `publishOrderFromEventBridge`.

The `appSyncParameters` property specifies the mutation to invoke when the event is received. The `inputTransformer` property maps the event data to the mutation arguments.

## Step 3 - Define custom queries and mutations

Now that your event bus has been added as a data source, you can reference it in custom queries and mutations using the `a.handler.custom()` modifier which accepts the name of the data source and an entry point for your resolver.

Use the following code to add `publishOrderToEventBridge` and `publishOrderFromEventBridge` custom mutations, and an `onOrderStatusChange` custom subscription to your schema:

```ts title="amplify/data/resource.ts"
import { type ClientSchema, a, defineData } from "@aws-amplify/backend";

const schema = a.schema({
  // ...
  OrderStatus: a.enum(["OrderPending", "OrderShipped", "OrderDelivered"]),
  OrderStatusChange: a.customType({
    orderId: a.id().required(),
    status: a.ref("OrderStatus").required(),
    message: a.string().required(),
  }),
  // highlight-start
  publishOrderToEventBridge: a
    .mutation()
    .arguments({
      orderId: a.id().required(),
      status: a.string().required(),
      message: a.string().required(),
    })
    .returns(a.ref("OrderStatusChange"))
    .authorization((allow) => [allow.publicApiKey()])
    .handler(
      a.handler.custom({
        dataSource: "EventBridgeDataSource",
        entry: "./publishOrderToEventBridge.js",
      })
    ),
  publishOrderFromEventBridge: a
    .mutation()
    .arguments({
      orderId: a.id().required(),
      status: a.string().required(),
      message: a.string().required(),
    })
    .returns(a.ref("OrderStatusChange"))
    .authorization((allow) => [allow.publicApiKey(), allow.guest()])
    .handler(
      a.handler.custom({
        entry: "./publishOrderFromEventBridge.js",
      })
    ),
  onOrderFromEventBridge: a
    .subscription()
    .for(a.ref("publishOrderFromEventBridge"))
    .authorization((allow) => [allow.publicApiKey()])
    .handler(
      a.handler.custom({
        entry: "./onOrderFromEventBridge.js",
      })
    ),
  // highlight-end
});

export type Schema = ClientSchema<typeof schema>;

export const data = defineData({
  schema,
  name: "MyLibrary",
  authorizationModes: {
    defaultAuthorizationMode: "apiKey",
    apiKeyAuthorizationMode: {
      expiresInDays: 30,
    },
  },
});
```

In the code snippet above:

- The `publishOrderToEventBridge` custom mutation uses an EventBridge data source and so it is able to publish events to the event bus from its resolver.

- The `publishOrderFromEventBridge` custom mutation uses a None data source as a passthrough and is invoked by the EventBridge rule when an event is received that matches the rule pattern. The `allow.guest` rule uses IAM under the hood and allows the mutation to be invoked by the EventBridge rule.

- The `onOrderFromEventBridge` custom subscription can be triggered either by EventBridge invoking the `publishOrderFromEventBridge` mutation or by a client invoking the `publishOrderToEventBridge` mutation.

## Step 4 - Configure custom business logic handler code

Next, create the following files in your `amplify/data` folder and use the code examples to define custom resolvers for the custom queries and mutations added to your schema from the previous step. These are AppSync JavaScript resolvers

<BlockSwitcher>
<Block name="Subscription">

The following code defines the custom business logic handler for the `onOrderStatusChange` subscription. Since the subscription uses a None data source the `response` function is empty as the subscription does not require any additional processing.

```js title="amplify/data/onOrderStatusChange.js"
export function request(ctx) {
  return {
    payload: {},
  };
}

export function response(ctx) {
}
```
</Block>
<Block name="Publish Order to EventBridge">

In the following code, the `request` function constructs the event payload to be published to the event bus. To match the rule pattern configured in the previous steps, the event source is set to `amplify.orders` and the `detail-type` is set to `OrderStatusChange`. The mutation arguments are passed to the event detail.

```js title="amplify/data/publishOrderToEventBridge.js"
export function request(ctx) {
  return {
    operation: "PutEvents",
    events: [
      {
        source: "amplify.orders",
        ["detail-type"]: "OrderStatusChange",
        detail: { ...ctx.args },
      },
    ],
  };
}

export function response(ctx) {
  return ctx.args;
}
```
</Block>
<Block name="Publish Order From EventBridge">

The following code defines the custom business logic handler for the `publishOrderFromEventBridge` mutation. The `request` function constructs the mutation arguments from the event payload received from the event bus. The `response` function returns the mutation arguments.

```js title="amplify/data/publishOrderFromEventBridge.js"
export function request(ctx) {
  return {
    payload: ctx.arguments,
  };
}

export function response(ctx) {
  return ctx.arguments;
}
```
</Block>
</BlockSwitcher>

## Step 5 - Invoke custom mutations to send events to EventBridge

From your generated Data client, you can find all your custom queries and mutations under the `client.queries` and `client.mutations` APIs respectively.

The custom mutation below will publish an order status change event to the event bus:

```ts title="App.tsx"
await client.mutations.publishOrderToEventBridge({
  orderId: "12345",
  status: "SHIPPED",
  message: "Order has been shipped",
});
```

## Step 6 - Subscribe to mutations invoked by EventBridge

To subscribe to events from your event bus, you can use the `client.subscriptions` API:

```ts title="App.tsx"
// Subscribe to the mutations triggered by the EventBridge rule
const sub = client.subscriptions.onOrderStatusChange().subscribe({
  next: (data) => {
    console.log(data);
  },
});

//...

// Clean up subscription
sub.unsubscribe();
```

## Step 7 - Invoke a mutation and trigger a subscription from EventBridge

You can test your custom mutation and subscriptions by using the EventBridge console to send an event which will invoke the custom mutation. You can then observe the results from the subscription being triggered:

1. Navigate to the Amazon EventBridge console and choose "Send Events"

![Amazon EventBridge console, page titled “Event buses”. Shows a table of event buses and a highlighted button labeled "Send events."](/images/send-events.png)

2. Fill out the form, specifying the event source to be `amplify.orders` and the `detail-type` to be `OrderStatusChange`.

![Amazon EventBridge console, page titled "Send events". Shows a form with input fields and values of "event bus: default", "event source: amplify.orders", "detail type: OrderStatusChange", and an Event detail field with JSON data containing an "orderId", "status", and "message". ](/images/send-events-2.png)

3. Choose "Send" and observe the subscription output in the AppSync Queries console.

![AppSync console, page titled "Queries". Shows a running subscription named "onOrderFromEventBridge" and a result with data containing an "orderId", "status", and "message."  ](/images/send-events-3.png)

## Conclusion

In this guide, you’ve added an Amazon EventBridge event bus as a data source to an Amplify API and defined custom queries and mutations to publish and receive events from the event bus. You’ve also configured custom business logic handler code to handle the event data and invoke the appropriate mutations.

To clean up, you can delete your sandbox by accepting the prompt when terminating the sandbox process in your terminal. Alternatively, you can also use the AWS Amplify console to manage and delete sandbox environments.



Contents of build-a-backend_data_custom-business-logic_connect-http-datasource_index.txt:
import { getCustomStaticPath } from '@/utils/getCustomStaticPath';

export const meta = {
  title: 'Connect to an external HTTP endpoint',
  description:
    'Connect to HTTP Datasource.',
  platforms: [
    'android',
    'angular',
    'flutter',
    'javascript',
    'nextjs',
    'react',
    'react-native',
    'swift',
    'vue'
  ]
};

export const getStaticPaths = async () => {
  return getCustomStaticPath(meta.platforms);
};

export function getStaticProps() {
  return {
    props: {
      meta
    }
  };
}

The HTTP Datasource allows you to quickly configure HTTP resolvers within your Data API.

This guide will demonstrate how to establish a connection to an external REST API using an HTTP data source and use Amplify Data's custom mutations and queries to interact with the REST API.

## Step 1 - Set up your custom type

For the purpose of this guide we will define a `Post` type and use an existing external REST API that will store records for it. In Amplify Gen 2, `customType` adds a type to the schema that is not backed by an Amplify-generated DynamoDB table.

With the `Post` type defined, it can then be referenced as the return type when defining your custom queries and mutations.

First, add the `Post` custom type to your schema:

```ts title="amplify/data/resource.ts"
import { type ClientSchema, a, defineData } from "@aws-amplify/backend";

const schema = a.schema({
  Todo: a
    .model({
      content: a.string(),
    })
    .authorization(allow => [allow.publicApiKey()]),
  // highlight-start
  Post: a.customType({
    title: a.string(),
    content: a.string(),
    author: a.string().required(),
  }),
  // highlight-end
});

export type Schema = ClientSchema<typeof schema>;

export const data = defineData({
  schema,
  authorizationModes: {
    defaultAuthorizationMode: 'apiKey',
    apiKeyAuthorizationMode: {
      expiresInDays: 30,
    },
  },
});
```

## Step 2 - Add your REST API or HTTP API as Datasource

To integrate the external REST API or HTTP API, you'll need to set it up as the HTTP Datasource. Add the following code in your `amplify/backend.ts` file.

```ts title="amplify/backend.ts"

import { defineBackend } from "@aws-amplify/backend";
import { auth } from "./auth/resource";
import { data } from "./data/resource";

const backend = defineBackend({
  auth,
  data,
});

const httpDataSource = backend.data.addHttpDataSource(
  "HttpDataSource",
  "https://www.example.com"
);

```
## Step 3 - Define custom queries and mutations

Now that your REST API has been added as a data source, you can reference it in custom queries and mutations using the `a.handler.custom()` modifier which accepts the name of the data source and an entry point for your resolvers.

Use the following code examples to add `addPost`, `getPost`, `updatePost`, and `deletePost` as custom queries and mutations to your schema:

<BlockSwitcher>
<Block name="addPost">
```ts title="amplify/data/resource.ts"
import { type ClientSchema, a, defineData } from "@aws-amplify/backend";

const schema = a.schema({
  Post: a.customType({
    title: a.string(),
    content: a.string(),
    author: a.string().required(),
  }),
  // highlight-start
  addPost: a
    .mutation()
    .arguments({
      title: a.string(),
      content: a.string(),
      author: a.string().required(),
    })
    .returns(a.ref("Post"))
    .authorization(allow => [allow.publicApiKey()])
    .handler(
      a.handler.custom({
        dataSource: "HttpDataSource",
        entry: "./addPost.js",
      })
    ),
  // highlight-end
});

export type Schema = ClientSchema<typeof schema>;

export const data = defineData({
  schema,
  authorizationModes: {
    defaultAuthorizationMode: 'apiKey',
    apiKeyAuthorizationMode: {
      expiresInDays: 30,
    },
  },
});
```
</Block>
<Block name="getPost">
```ts title="amplify/data/resource.ts"
import { type ClientSchema, a, defineData } from "@aws-amplify/backend";

const schema = a.schema({
  Post: a.customType({
    title: a.string(),
    content: a.string(),
    author: a.string().required(),
  }),
  // highlight-start
  getPost: a
    .query()
    .arguments({ id: a.id().required() })
    .returns(a.ref("Post"))
    .authorization(allow => [allow.publicApiKey()])
    .handler(
      a.handler.custom({
        dataSource: "HttpDataSource",
        entry: "./getPost.js",
      })
    ),
  // highlight-end
});

export type Schema = ClientSchema<typeof schema>;

export const data = defineData({
  schema,
  authorizationModes: {
    defaultAuthorizationMode: 'apiKey',
    apiKeyAuthorizationMode: {
      expiresInDays: 30,
    },
  },
});
```
</Block>
<Block name="updatePost">
```ts title="amplify/data/resource.ts"
import { type ClientSchema, a, defineData } from "@aws-amplify/backend";

const schema = a.schema({
  Post: a.customType({
    title: a.string(),
    content: a.string(),
    author: a.string().required(),
  }),
  // highlight-start
  updatePost: a
    .mutation()
    .arguments({
      id: a.id().required(),
      title: a.string(),
      content: a.string(),
      author: a.string(),
    })
    .returns(a.ref("Post"))
    .authorization(allow => [allow.publicApiKey()])
    .handler(
      a.handler.custom({
        dataSource: "HttpDataSource",
        entry: "./updatePost.js",
      })
    ),
  // highlight-end
});

export type Schema = ClientSchema<typeof schema>;

export const data = defineData({
  schema,
  authorizationModes: {
    defaultAuthorizationMode: 'apiKey',
    apiKeyAuthorizationMode: {
      expiresInDays: 30,
    },
  },
});
```
</Block>
<Block name="deletePost">
```ts title="amplify/data/resource.ts"
import { type ClientSchema, a, defineData } from "@aws-amplify/backend";

const schema = a.schema({
  Post: a.customType({
    title: a.string(),
    content: a.string(),
    author: a.string().required(),
  }),
  // highlight-start
  deletePost: a
    .mutation()
    .arguments({ id: a.id().required() })
    .returns(a.ref("Post"))
    .authorization(allow => [allow.publicApiKey()])
    .handler(
      a.handler.custom({
        dataSource: "HttpDataSource",
        entry: "./deletePost.js",
      })
    ),
  // highlight-end
});

export type Schema = ClientSchema<typeof schema>;

export const data = defineData({
  schema,
  authorizationModes: {
    defaultAuthorizationMode: 'apiKey',
    apiKeyAuthorizationMode: {
      expiresInDays: 30,
    },
  },
});
```
</Block>
</BlockSwitcher>

## Step 4 - Configure custom business logic handler code

Next, create the following files in your `amplify/data` folder and use the code examples to define custom resolvers for the custom queries and mutations added to your schema from the previous step. These are AppSync JavaScript resolvers.

<BlockSwitcher>
<Block name="addPost">
```js title="amplify/data/addPost.js"
import { util } from "@aws-appsync/utils";

export function request(ctx) {
  return {
    method: "POST",
    resourcePath: "/post",
    params: {
      headers: {
        "Content-Type": "application/json",
      },
      body: {
        title: ctx.arguments.title,
        content: ctx.arguments.content,
        author: ctx.arguments.author,
      },
    },
  };
}

export function response(ctx) {
  if (ctx.error) {
    return util.error(ctx.error.message, ctx.error.type);
  }
  if (ctx.result.statusCode == 200) {
    return JSON.parse(ctx.result.body).data;
  } else {
    return util.appendError(ctx.result.body, "ctx.result.statusCode");
  }
}
```
</Block>
<Block name="getPost">
```js title="amplify/data/getPost.js"
import { util } from "@aws-appsync/utils";

export function request(ctx) {
  return {
    method: "GET",
    resourcePath: "/posts/" + ctx.arguments.id,
    params: {
      headers: {
        "Content-Type": "application/json",
      },
    },
  };
}

export function response(ctx) {
  if (ctx.error) {
    return util.error(ctx.error.message, ctx.error.type);
  }
  if (ctx.result.statusCode == 200) {
    return JSON.parse(ctx.result.body).data;
  } else {
    return util.appendError(ctx.result.body, "ctx.result.statusCode");
  }
}
```
</Block>
<Block name="updatePost">
```js title="amplify/data/updatePost.js"
import { util } from "@aws-appsync/utils";

export function request(ctx) {
  return {
    method: "POST",
    resourcePath: "/posts/" + ctx.arguments.id,
    params: {
      headers: {
        "Content-Type": "application/json",
      },
      body: {
        title: ctx.arguments.title,
        content: ctx.arguments.content,
        author: ctx.arguments.author,
      },
    },
  };
}

export function response(ctx) {
  if (ctx.error) {
    return util.error(ctx.error.message, ctx.error.type);
  }
  if (ctx.result.statusCode == 200) {
    return JSON.parse(ctx.result.body).data;
  } else {
    return util.appendError(ctx.result.body, "ctx.result.statusCode");
  }
}

```
</Block>
<Block name="deletePost">
```js title="amplify/data/deletePost.js"
import { util } from "@aws-appsync/utils";

export function request(ctx) {
  return {
    method: "DELETE",
    resourcePath: "/posts/" + ctx.arguments.id,
    params: {
      headers: {
        "Content-Type": "application/json",
      },
    },
  };
}

export function response(ctx) {
  if (ctx.error) {
    return util.error(ctx.error.message, ctx.error.type);
  }
  if (ctx.result.statusCode == 200) {
    return JSON.parse(ctx.result.body).data;
  } else {
    return util.appendError(ctx.result.body, "ctx.result.statusCode");
  }
}
```
</Block>
</BlockSwitcher>

## Step 5 - Invoke custom queries or mutations

From your generated Data client, you can find all your custom queries and mutations under the client.queries. and client.mutations. APIs respectively.

<BlockSwitcher>
<Block name="addPost">
```ts title="App.tsx"
const { data, errors } = await client.mutations.addPost({
  title: "My Post",
  content: "My Content",
  author: "Chris",
});
```
</Block>
<Block name="getPost">
```ts title="App.tsx"
const { data, errors } = await client.queries.getPost({
  id: "<post-id>"
});
```
</Block>
<Block name="updatePost">
```ts title="App.tsx"
const { data, errors } = await client.mutations.updatePost({
  id: "<post-id>",
  title: "An Updated Post",
});
```
</Block>
<Block name="deletePost">
```ts title="App.tsx"
const { data, errors } = await client.mutations.deletePost({
  id: "<post-id>",
});
```
</Block>
</BlockSwitcher>

## Conclusion

In this guide, you’ve added an external REST API as a HTTP data source to an Amplify Data API and defined custom queries and mutations, handled by AppSync JS resolvers, to manipulate Post items in an external REST API using the Amplify Gen 2 Data client.

To clean up, you can delete your sandbox by accepting the prompt when terminating the sandbox process in your terminal. Alternatively, you can also use the AWS Amplify console to manage and delete sandbox environments.




Contents of build-a-backend_data_custom-business-logic_index.txt:
import { getCustomStaticPath } from '@/utils/getCustomStaticPath';

export const meta = {
  title: 'Add custom queries and mutations',
  description:
    'Customize your business logic for queries and mutations.',
  platforms: [
    'android',
    'angular',
    'flutter',
    'javascript',
    'nextjs',
    'react',
    'react-native',
    'swift',
    'vue'
  ]
};

export const getStaticPaths = async () => {
  return getCustomStaticPath(meta.platforms);
};

export function getStaticProps() {
  return {
    props: {
      meta
    }
  };
}

The `a.model()` data model provides a solid foundation for querying, mutating, and fetching data. However, you may need additional customizations to meet specific requirements around custom API requests, response formatting, and/or fetching from external data sources.

In the following sections, we walk through the three steps to create a custom query or mutation:

1. Define a custom query or mutation
2. Configure custom business logic handler code
3. Invoke the custom query or mutation

## Step 1 - Define a custom query or mutation

| Type | When to choose |
| --- | --- |
| Query | When the request only needs to read data and will not modify any backend data |
| Mutation | When the request will modify backend data |

For every custom query or mutation, you need to set a return type and, optionally, arguments. Use `a.query()` or `a.mutation()` to define your custom query or mutation in your **amplify/data/resource.ts** file:

<BlockSwitcher>

<Block name="Custom query">

```ts
import { type ClientSchema, a, defineData } from '@aws-amplify/backend';

const schema = a.schema({
  // 1. Define your return type as a custom type
  EchoResponse: a.customType({
    content: a.string(),
    executionDuration: a.float()
  }),

  // 2. Define your query with the return type and, optionally, arguments
  echo: a
    .query()
    // arguments that this query accepts
    .arguments({
      content: a.string()
    })
    // return type of the query
    .returns(a.ref('EchoResponse'))
    // only allow signed-in users to call this API
    .authorization(allow => [allow.authenticated()])
});

export type Schema = ClientSchema<typeof schema>;

export const data = defineData({
  schema
});
```

</Block>

<Block name="Custom mutation">

```ts
import { type ClientSchema, a, defineData } from '@aws-amplify/backend';

const schema = a.schema({
  // 1. Define your return type as a custom type or model
  Post: a.model({
    id: a.id(),
    content: a.string(),
    likes: a.integer()
  }),

  // 2. Define your mutation with the return type and, optionally, arguments
  likePost: a
    .mutation()
    // arguments that this query accepts
    .arguments({
      postId: a.string()
    })
    // return type of the query
    .returns(a.ref('Post'))
    // only allow signed-in users to call this API
    .authorization(allow => [allow.authenticated()])
});

export type Schema = ClientSchema<typeof schema>;

export const data = defineData({
  schema
});
```

</Block>

</BlockSwitcher>

## Step 2 - Configure custom business logic handler code

After your query or mutation is defined, you need to author your custom business logic. You can either define it in a [function](/[platform]/build-a-backend/functions/) or using a [custom resolver powered by AppSync JavaScript resolver](https://docs.aws.amazon.com/appsync/latest/devguide/tutorials-js.html).

<BlockSwitcher>

<Block name="Function">

In your `amplify/data/echo-handler/` folder, create a `handler.ts` file. You can import a utility type for your function handler via the `Schema` type from your backend resource. This gives you type-safe handler parameters and return values.

```ts title="amplify/data/echo-handler/handler.ts"
import type { Schema } from '../resource'

export const handler: Schema["echo"]["functionHandler"] = async (event, context) => {
  const start = performance.now();
  return {
    content: `Echoing content: ${event.arguments.content}`,
    executionDuration: performance.now() - start
  };
};
```

In your `amplify/data/resource.ts` file, define the function using `defineFunction` and then reference the function with your query or mutation using `a.handler.function()` as a handler.

```ts title="amplify/data/resource.ts"
import {
  type ClientSchema,
  a,
  defineData,
  defineFunction // 1.Import "defineFunction" to create new functions
} from '@aws-amplify/backend';

// 2. define a function
const echoHandler = defineFunction({
  entry: './echo-handler/handler.ts'
})

const schema = a.schema({
  EchoResponse: a.customType({
    content: a.string(),
    executionDuration: a.float()
  }),

  echo: a
    .query()
    .arguments({ content: a.string() })
    .returns(a.ref('EchoResponse'))
    .authorization(allow => [allow.publicApiKey()])
    // 3. set the function has the handler
    .handler(a.handler.function(echoHandler))
});

export type Schema = ClientSchema<typeof schema>;

export const data = defineData({
  schema,
  authorizationModes: {
    defaultAuthorizationMode: 'apiKey',
    apiKeyAuthorizationMode: {
      expiresInDays: 30
    },
  },
});
```

If you want to use an existing lambda function, you can reference it by its name: `a.handler.function('name-of-existing-lambda-fn')`. This references an external lambda resource which Amplify is not aware of. You need to make sure the function and all dependencies are being managed outside of Amplify.

</Block>
<Block name="Custom resolver powered by AppSync JavaScript resolvers">

Custom resolvers work on a "request/response" basis. You choose a data source, map your request to the data source's input parameters, and then map the data source's response back to the query/mutation's return type. Custom resolvers provide the benefit of no cold starts, less infrastructure to manage, and no additional charge for Lambda function invocations. Review [Choosing between custom resolver and function](https://docs.aws.amazon.com/appsync/latest/devguide/resolver-reference-overview-js.html#choosing-data-source).

In your `amplify/data/resource.ts` file, define a custom handler using `a.handler.custom`.

```ts title="amplify/data/resource.ts"
import {
  type ClientSchema,
  a,
  defineData,
} from '@aws-amplify/backend';

const schema = a.schema({
  Post: a.model({
    content: a.string(),
    likes: a.integer()
      .authorization(allow => [allow.authenticated().to(['read'])])
  }).authorization(allow => [
    allow.owner(),
    allow.authenticated().to(['read'])
  ]),

  likePost: a
    .mutation()
    .arguments({ postId: a.id() })
    .returns(a.ref('Post'))
    .authorization(allow => [allow.authenticated()])
    .handler(a.handler.custom({
      dataSource: a.ref('Post'),
      entry: './increment-like.js'
    }))
});

export type Schema = ClientSchema<typeof schema>;

export const data = defineData({
  schema,
  authorizationModes: {
    defaultAuthorizationMode: 'apiKey',
    apiKeyAuthorizationMode: {
      expiresInDays: 30
    }
  },
});
```

```ts title="amplify/data/increment-like.js"
import { util } from '@aws-appsync/utils';

export function request(ctx) {
  return {
    operation: 'UpdateItem',
    key: util.dynamodb.toMapValues({ id: ctx.args.postId}),
    update: {
      expression: 'ADD likes :plusOne',
      expressionValues: { ':plusOne': { N: 1 } },
    }
  }
}

export function response(ctx) {
  return ctx.result
}
```

By default, you'll be able to access any existing database tables (powered by Amazon DynamoDB) using `a.ref('MODEL_NAME')`. But you can also reference any other external data source from within your AWS account, by adding them to your backend definition.

The supported data sources are:
- Amazon DynamoDB
- AWS Lambda
- Amazon RDS databases with Data API
- Amazon EventBridge
- OpenSearch
- HTTP endpoints

You can add these additional data sources via our `amplify/backend.ts` file:

```ts title="amplify/backend.ts"
import * as dynamoDb from 'aws-cdk-lib/aws-dynamodb'
import { defineBackend } from '@aws-amplify/backend';
import { auth } from './auth/resource';
import { data } from './data/resource';

export const backend = defineBackend({
  auth,
  data,
});

const externalDataSourcesStack = backend.createStack("MyExternalDataSources")

const externalTable = dynamoDb.Table.fromTableName(externalDataSourcesStack, "MyTable", "MyExternalTable")

backend.data.addDynamoDbDataSource(
  // highlight-next-line
  "ExternalTableDataSource",
  externalTable)
```

In your schema you can then reference these additional data sources based on their name:

```ts title="amplify/data/resource.ts"
import {
  type ClientSchema,
  a,
  defineData,
} from '@aws-amplify/backend';

const schema = a.schema({
  Post: a.model({
    content: a.string(),
    likes: a.integer()
      .authorization(allow => [allow.authenticated().to(['read'])])
  }).authorization(allow => [
    allow.owner(),
    allow.authenticated().to(['read'])
  ]),

  likePost: a
    .mutation()
    .arguments({ postId: a.id() })
    .returns(a.ref('Post'))
    .authorization(allow => [allow.authenticated()])
    .handler(a.handler.custom({
      // highlight-next-line
      dataSource: "ExternalTableDataSource",
      entry: './increment-like.js'
    }))
});

export type Schema = ClientSchema<typeof schema>;

export const data = defineData({
  schema,
  authorizationModes: {
    defaultAuthorizationMode: 'apiKey',
    apiKeyAuthorizationMode: {
      expiresInDays: 30
    }
  },
});
```

</Block>
</BlockSwitcher>


<Callout warning>

All handlers must be of the same type. For example, you can't mix and match `a.handler.function` with `a.handler.custom` within a single `.handler()` modifier.

</Callout>

## Step 3 - Invoke the custom query or mutation

<InlineFilter filters={["javascript", "angular", "react-native", "react", "nextjs", "vue"]}>

From your generated Data client, you can find all your custom queries and mutations under the `client.queries.` and `client.mutations.` APIs respectively.

<BlockSwitcher>
<Block name="Custom query">

```ts
const { data, errors } = await client.queries.echo({
  content: 'hello world!!!'
});
```

</Block>
<Block name="Custom mutation">

```ts
const { data, errors } = await client.mutations.likePost({
  postId: 'hello'
});
```

</Block>
</BlockSwitcher>

</InlineFilter>

<InlineFilter filters={["swift"]}>

```swift
struct EchoResponse: Codable {
    public let echo: Echo

    struct Echo: Codable {
        public let content: String
        public let executionDuration: Float
    }
}

let document = """
    query EchoQuery($content: String!) {
        echo(content: $content) {
            content
            executionDuration
        }
    }
    """

let result = try await Amplify.API.query(request: GraphQLRequest<EchoResponse>(
    document: document,
    variables: [
        "content": "hello world!!!"
    ],
    responseType: EchoResponse.self
))
switch result {
case .success(let response):
    print(response.echo)
case .failure(let error):
    print(error)
}
```

</InlineFilter>

<InlineFilter filters={["android"]}>

```kt
data class EchoDetails(
    val content: String,
    val executionDuration: Float
)

data class EchoResponse(
    val echo: EchoDetails
)

val document = """
    query EchoQuery(${'$'}content: String!) {
        echo(content: ${'$'}content) {
            content
            executionDuration
        }
    }
""".trimIndent()
val echoQuery = SimpleGraphQLRequest<String>(
    document,
    mapOf("content" to "hello world!!!"),
    String::class.java,
    GsonVariablesSerializer())

Amplify.API.query(
    echoQuery,
    {
        var gson = Gson()
        val response = gson.fromJson(it.data, EchoResponse::class.java)
        Log.i("MyAmplifyApp", "${response.echo.content}")
    },
    { Log.e("MyAmplifyApp", "$it")}
)
```

</InlineFilter>

<InlineFilter filters={["flutter"]}>

First define a class that matches your response shape:

```dart
class EchoResponse {
  final Echo echo;

  EchoResponse({required this.echo});

  factory EchoResponse.fromJson(Map<String, dynamic> json) {
    return EchoResponse(
      echo: Echo.fromJson(json['echo']),
    );
  }
}

class Echo {
  final String content;
  final double executionDuration;

  Echo({required this.content, required this.executionDuration});

  factory Echo.fromJson(Map<String, dynamic> json) {
    return Echo(
      content: json['content'],
      executionDuration: json['executionDuration'],
    );
  }
}
```

Next, make the request and map the response to the classes defined above:

```dart
// highlight-next-line
import 'dart:convert';

// highlight-start
const graphQLDocument = '''
  query Echo(\$content: String!) {
    echo(content: \$content) {
      content
      executionDuration
    }
  }
''';

final echoRequest = GraphQLRequest<String>(
  document: graphQLDocument,
  variables: <String, String>{"content": "Hello world!!!"},
);

final response =
    await Amplify.API.query(request: echoRequest).response;
safePrint(response);

Map<String, dynamic> jsonMap = json.decode(response.data!);
EchoResponse echoResponse = EchoResponse.fromJson(jsonMap);
safePrint(echoResponse.echo.content);
// highlight-end
```

</InlineFilter>

## Async function handlers

Async function handlers allow you to execute long-running operations asynchronously, improving the responsiveness of your API. This is particularly useful for tasks that don't require an immediate response, such as batch processing, putting messages in a queue, and initiating a generative AI model inference.

### Usage

To define an async function handler, use the `.async()` method when defining your handler:

```ts title="amplify/data/resource.ts"
const signUpForNewsletter = defineFunction({
  entry: './sign-up-for-newsletter/handler.ts'
});

const schema = a.schema({
  someAsyncOperation: a.mutation()
    .arguments({
      email: a.email().required()
    })
    .handler(a.handler.function(signUpForNewsletter).async())
    .authorization((allow) => allow.guest()),
})
```

### Key Characteristics

1. **Single Return Type**: Async handlers return a static type `EventInvocationResponse` and don't support specifying a return type. The `.returns()` method is not available for operations using async handlers.

2. **Fire and Forget**: The client is informed whether the invocation was successfully queued, but doesn't receive data from the Lambda function execution.

3. **Pipeline Support**: Async handlers can be used in function pipelines. If the final handler is an async function, the return type of the query or mutation is `EventInvocationResponse`.


Contents of build-a-backend_data_custom-business-logic_search-and-aggregate-queries_index.txt:
import { getCustomStaticPath } from '@/utils/getCustomStaticPath';

export const meta = {
  title: 'Connect to Amazon OpenSearch for search and aggregate queries',
  description:
    'Build search and aggregate queries with Amazon OpenSearch Service and Zero ETL DynamoDB-to-OpenSearch.',
  platforms: [
    'android',
    'angular',
    'flutter',
    'javascript',
    'nextjs',
    'react',
    'react-native',
    'swift',
    'vue'
  ]
};

export const getStaticPaths = async () => {
  return getCustomStaticPath(meta.platforms);
};

export function getStaticProps() {
  return {
    props: {
      meta
    }
  };
}

Amazon OpenSearch Service provides a managed platform for deploying search and analytics solutions with OpenSearch or Elasticsearch. The zero-ETL integration between Amazon DynamoDB and OpenSearch Service allows seamless search on DynamoDB data by automatically replicating and transforming it without requiring custom code or infrastructure. This integration simplifies processes and reduces the operational workload of managing data pipelines.

DynamoDB users gain access to advanced OpenSearch features like full-text search, fuzzy search, auto-complete, and vector search for machine learning capabilities. Amazon OpenSearch Ingestion synchronizes data between DynamoDB and OpenSearch Service, enabling near-instant updates and comprehensive insights across multiple DynamoDB tables. Developers can adjust index mapping templates to match Amazon DynamoDB fields with OpenSearch Service indexes. 

Amazon OpenSearch Ingestion, combined with S3 exports and DynamoDB streams, facilitates seamless data input from DynamoDB tables and automatic ingestion into OpenSearch. Additionally, the pipeline can back up data to S3 for potential future re-ingestion as needed.

## Step 1: Setup the project

Begin by setting up your project by following the instructions in the [Quickstart guide](/[platform]/start/quickstart/). For the purpose of this guide, we'll sync a Todo table from DynamoDB to OpenSearch.

Firstly, add the Todo model to your schema:

```ts title="amplify/data/resource.ts"
import { type ClientSchema, a, defineData } from "@aws-amplify/backend";

const schema = a.schema({
  // highlight-start
  Todo: a
    .model({
      content: a.string(),
      done: a.boolean(),
      priority: a.enum(["low", "medium", "high"]),
    })
    .authorization((allow) => [allow.publicApiKey()])
  // highlight-end  
});

export type Schema = ClientSchema<typeof schema>;

export const data = defineData({
  schema,
  authorizationModes: {
    defaultAuthorizationMode: "apiKey",
    apiKeyAuthorizationMode: {
      expiresInDays: 30,
    },
  },
});

```
<Callout>

Important considerations:

Ensure Point in Time Recovery (PITR) is enabled, which is crucial for the pipeline integration.
Enable DynamoDB streams to capture item changes that will be ingested into OpenSearch.

</Callout>

```ts title="amplify/backend.ts"
// highlight-start
import * as dynamodb from 'aws-cdk-lib/aws-dynamodb';
// highlight-end
import { defineBackend } from '@aws-amplify/backend';
import { auth } from './auth/resource';
import { data } from './data/resource';

const backend = defineBackend({
  auth,
  data
});

// highlight-start
const todoTable =
  backend.data.resources.cfnResources.amplifyDynamoDbTables['Todo'];

// Update table settings
todoTable.pointInTimeRecoveryEnabled = true;

todoTable.streamSpecification = {
  streamViewType: dynamodb.StreamViewType.NEW_IMAGE
};

// Get the DynamoDB table ARN
const tableArn = backend.data.resources.tables['Todo'].tableArn;
// Get the DynamoDB table name
const tableName = backend.data.resources.tables['Todo'].tableName;
// highlight-end
```

## Step 2: Setting Up the OpenSearch Instance

Create an OpenSearch instance with encryption.

```ts title="amplify/backend.ts"
// highlight-start
import * as opensearch from 'aws-cdk-lib/aws-opensearchservice';
import { RemovalPolicy } from "aws-cdk-lib";
// highlight-end
import { defineBackend } from '@aws-amplify/backend';
import { auth } from './auth/resource';
import { data } from './data/resource';

const backend = defineBackend({
  auth,
  data
});

const todoTable =
  backend.data.resources.cfnResources.amplifyDynamoDbTables['Todo'];

// Update table settings
todoTable.pointInTimeRecoveryEnabled = true;

todoTable.streamSpecification = {
  streamViewType: dynamodb.StreamViewType.NEW_IMAGE
};

// Get the DynamoDB table ARN
const tableArn = backend.data.resources.tables['Todo'].tableArn;
// Get the DynamoDB table name
const tableName = backend.data.resources.tables['Todo'].tableName;

// Create the OpenSearch domain
const openSearchDomain = new opensearch.Domain(
  backend.data.stack,
  'OpenSearchDomain',
  {
    version: opensearch.EngineVersion.OPENSEARCH_2_11,
    capacity: {
      // upgrade instance types for production use
      masterNodeInstanceType: "t3.small.search",
      masterNodes: 0,
      dataNodeInstanceType: "t3.small.search",
      dataNodes: 1,
    },
    nodeToNodeEncryption: true,
    // set removalPolicy to DESTROY to make sure the OpenSearch domain is deleted on stack deletion.
    removalPolicy: RemovalPolicy.DESTROY,
    encryptionAtRest: {
      enabled: true
    }
  }
);
// highlight-end
```
<Callout warning>

**Important considerations:**

We recommend configuring the `removalPolicy` to destroy resources for sandbox environments. By default, OpenSearch instances are not deleted when you run `npx ampx sandbox delete`, as the default removal policy for stateful resources is set to retain the resource.

</Callout>


## Step 3: Setting Up Zero ETL from DynamoDB to OpenSearch

### Step 3a: Setup Storage and IAM Role

Establish Storage to back up raw events consumed by the OpenSearch pipeline. 
Generate a file named `amplify/storage/resource.ts` and insert the provided content to set up a storage resource. Tailor your storage configurations to regulate access to different paths within your storage bucket.

```ts title="amplify/storage/resource.ts"
import { defineStorage } from "@aws-amplify/backend"

export const storage = defineStorage({
  name: "opensearch-backup-bucket-amplify-gen-2",
  access: allow => ({
    'public/*': [
      allow.guest.to(['list', 'write', 'get'])
    ]
  })
})
```

Get the `s3BucketArn` and `s3BucketName` values from storage resource as shown below. Additionally, configure an IAM role for the pipeline and assign the roles as indicated below. For further information on the required IAM roles, please refer to the [Setting up roles and users](https://docs.aws.amazon.com/opensearch-service/latest/developerguide/pipeline-security-overview.html#pipeline-security-create) documentation.

```ts title="amplify/backend.ts"
import * as dynamodb from "aws-cdk-lib/aws-dynamodb";
import * as opensearch from "aws-cdk-lib/aws-opensearchservice";
import { RemovalPolicy } from "aws-cdk-lib";
// highlight-next-line
import * as iam from "aws-cdk-lib/aws-iam";
import { defineBackend } from "@aws-amplify/backend";
import { auth } from "./auth/resource";
import { data } from "./data/resource";
// highlight-next-line
import { storage } from "./storage/resource";

// Define backend resources
const backend = defineBackend({
  auth,
  data,
  //highlight-start  
  storage,
  //highlight-end  
});

const todoTable =
  backend.data.resources.cfnResources.amplifyDynamoDbTables["Todo"];

// Update table settings
todoTable.pointInTimeRecoveryEnabled = true;

todoTable.streamSpecification = {
  streamViewType: dynamodb.StreamViewType.NEW_IMAGE,
};

// Get the DynamoDB table ARN
const tableArn = backend.data.resources.tables["Todo"].tableArn;
// Get the DynamoDB table name
const tableName = backend.data.resources.tables["Todo"].tableName;

// Create the OpenSearch domain
const openSearchDomain = new opensearch.Domain(
  backend.data.stack,
  "OpenSearchDomain",
  {
    version: opensearch.EngineVersion.OPENSEARCH_2_11,
    capacity: {
      // upgrade instance types for production use
      masterNodeInstanceType: "t3.small.search",
      masterNodes: 0,
      dataNodeInstanceType: "t3.small.search",
      dataNodes: 1,
    },
    nodeToNodeEncryption: true,
    // set removalPolicy to DESTROY to make sure the OpenSearch domain is deleted on stack deletion.
    removalPolicy: RemovalPolicy.DESTROY,
    encryptionAtRest: {
      enabled: true,
    },
  }
);
// highlight-start
// Get the S3Bucket ARN
const s3BucketArn = backend.storage.resources.bucket.bucketArn;
// Get the S3Bucket Name
const s3BucketName = backend.storage.resources.bucket.bucketName;

// Create an IAM role for OpenSearch integration
const openSearchIntegrationPipelineRole = new iam.Role(
  backend.data.stack,
  "OpenSearchIntegrationPipelineRole",
  {
    assumedBy: new iam.ServicePrincipal("osis-pipelines.amazonaws.com"),
    inlinePolicies: {
      openSearchPipelinePolicy: new iam.PolicyDocument({
        statements: [
          new iam.PolicyStatement({
            actions: ["es:DescribeDomain"],
            resources: [
              openSearchDomain.domainArn,
              openSearchDomain.domainArn + "/*",
            ],
            effect: iam.Effect.ALLOW,
          }),
          new iam.PolicyStatement({
            actions: ["es:ESHttp*"],
            resources: [
              openSearchDomain.domainArn,
              openSearchDomain.domainArn + "/*",
            ],
            effect: iam.Effect.ALLOW,
          }),
          new iam.PolicyStatement({
            effect: iam.Effect.ALLOW,
            actions: [
              "s3:GetObject",
              "s3:AbortMultipartUpload",
              "s3:PutObject",
              "s3:PutObjectAcl",
            ],
            resources: [s3BucketArn, s3BucketArn + "/*"],
          }),
          new iam.PolicyStatement({
            effect: iam.Effect.ALLOW,
            actions: [
              "dynamodb:DescribeTable",
              "dynamodb:DescribeContinuousBackups",
              "dynamodb:ExportTableToPointInTime",
              "dynamodb:DescribeExport",
              "dynamodb:DescribeStream",
              "dynamodb:GetRecords",
              "dynamodb:GetShardIterator",
            ],
            resources: [tableArn, tableArn + "/*"],
          }),
        ],
      }),
    },
    managedPolicies: [
      iam.ManagedPolicy.fromAwsManagedPolicyName(
        "AmazonOpenSearchIngestionFullAccess"
      ),
    ],
  }
);
// highlight-end
```

For the S3 bucket, follow standard security practices: block public access, encrypt data at rest, and enable versioning.

The IAM role should allow the OpenSearch Ingestion Service (OSIS) pipelines to assume it. Grant specific OpenSearch Service permissions and also provide DynamoDB and S3 access. You may customize permissions to follow the principle of least privilege.

### Step 3b: OpenSearch Service Pipeline

Define the pipeline construct and its configuration.

When using OpenSearch, you can define the index template or mapping in advance based on your data structure, which allows you to set data types for each field in the document. This approach can be incredibly powerful for precise data ingestion and search. For more information on index mapping/templates, please refer to [OpenSearch documentation](https://opensearch.org/docs/latest/im-plugin/index-templates/).

Customize the `template_content` JSON-representation to define the data structure for the ingestion pipeline.

```ts title="amplify/backend.ts"
import * as dynamodb from "aws-cdk-lib/aws-dynamodb";
import * as opensearch from "aws-cdk-lib/aws-opensearchservice";
import { RemovalPolicy } from "aws-cdk-lib";
import * as iam from "aws-cdk-lib/aws-iam";
import { defineBackend } from "@aws-amplify/backend";
import { auth } from "./auth/resource";
import { data } from "./data/resource";
import { storage } from "./storage/resource";
 
// Define backend resources
const backend = defineBackend({
  auth,
  data,
  storage,
});

const todoTable =
  backend.data.resources.cfnResources.amplifyDynamoDbTables["Todo"];

// Update table settings
todoTable.pointInTimeRecoveryEnabled = true;

todoTable.streamSpecification = {
  streamViewType: dynamodb.StreamViewType.NEW_IMAGE,
};

// Get the DynamoDB table ARN
const tableArn = backend.data.resources.tables["Todo"].tableArn;
// Get the DynamoDB table name
const tableName = backend.data.resources.tables["Todo"].tableName;

// Create the OpenSearch domain
const openSearchDomain = new opensearch.Domain(
  backend.data.stack,
  "OpenSearchDomain",
  {
    version: opensearch.EngineVersion.OPENSEARCH_2_11,
    capacity: {
      // upgrade instance types for production use
      masterNodeInstanceType: "t3.small.search",
      masterNodes: 0,
      dataNodeInstanceType: "t3.small.search",
      dataNodes: 1,
    },
    nodeToNodeEncryption: true,
    // set removalPolicy to DESTROY to make sure the OpenSearch domain is deleted on stack deletion.
    removalPolicy: RemovalPolicy.DESTROY,
    encryptionAtRest: {
      enabled: true,
    },
  }
);

// Get the S3Bucket ARN
const s3BucketArn = backend.storage.resources.bucket.bucketArn;
// Get the S3Bucket Name
const s3BucketName = backend.storage.resources.bucket.bucketName;

// Create an IAM role for OpenSearch integration
const openSearchIntegrationPipelineRole = new iam.Role(
  backend.data.stack,
  "OpenSearchIntegrationPipelineRole",
  {
    assumedBy: new iam.ServicePrincipal("osis-pipelines.amazonaws.com"),
    inlinePolicies: {
      openSearchPipelinePolicy: new iam.PolicyDocument({
        statements: [
          new iam.PolicyStatement({
            actions: ["es:DescribeDomain"],
            resources: [
              openSearchDomain.domainArn,
              openSearchDomain.domainArn + "/*",
            ],
            effect: iam.Effect.ALLOW,
          }),
          new iam.PolicyStatement({
            actions: ["es:ESHttp*"],
            resources: [
              openSearchDomain.domainArn,
              openSearchDomain.domainArn + "/*",
            ],
            effect: iam.Effect.ALLOW,
          }),
          new iam.PolicyStatement({
            effect: iam.Effect.ALLOW,
            actions: [
              "s3:GetObject",
              "s3:AbortMultipartUpload",
              "s3:PutObject",
              "s3:PutObjectAcl",
            ],
            resources: [s3BucketArn, s3BucketArn + "/*"],
          }),
          new iam.PolicyStatement({
            effect: iam.Effect.ALLOW,
            actions: [
              "dynamodb:DescribeTable",
              "dynamodb:DescribeContinuousBackups",
              "dynamodb:ExportTableToPointInTime",
              "dynamodb:DescribeExport",
              "dynamodb:DescribeStream",
              "dynamodb:GetRecords",
              "dynamodb:GetShardIterator",
            ],
            resources: [tableArn, tableArn + "/*"],
          }),
        ],
      }),
    },
    managedPolicies: [
      iam.ManagedPolicy.fromAwsManagedPolicyName(
        "AmazonOpenSearchIngestionFullAccess"
      ),
    ],
  }
);

// highlight-start
// Define OpenSearch index mappings
const indexName = "todo";

const indexMapping = {
  settings: {
    number_of_shards: 1,
    number_of_replicas: 0,
  },
  mappings: {
    properties: {
      id: {
        type: "keyword",
      },
      done: {
        type: "boolean",
      },
      content: {
        type: "text",
      },
    },
  },
};
// highlight-end
```

The configuration is a data-prepper feature of OpenSearch. For specific documentation on DynamoDB configuration, refer to [OpenSearch data-prepper documentation](https://opensearch.org/docs/latest/data-prepper/pipelines/configuration/sources/dynamo-db/).


```ts title="amplify/backend.ts"
import * as dynamodb from "aws-cdk-lib/aws-dynamodb";
import * as opensearch from "aws-cdk-lib/aws-opensearchservice";
import { RemovalPolicy } from "aws-cdk-lib";
import * as iam from "aws-cdk-lib/aws-iam";
import { defineBackend } from "@aws-amplify/backend";
import { auth } from "./auth/resource";
import { data } from "./data/resource";
import { storage } from "./storage/resource";
 
// Define backend resources
const backend = defineBackend({
  auth,
  data,
  storage,
});

const todoTable =
  backend.data.resources.cfnResources.amplifyDynamoDbTables["Todo"];

// Update table settings
todoTable.pointInTimeRecoveryEnabled = true;

todoTable.streamSpecification = {
  streamViewType: dynamodb.StreamViewType.NEW_IMAGE,
};

// Get the DynamoDB table ARN
const tableArn = backend.data.resources.tables["Todo"].tableArn;
// Get the DynamoDB table name
const tableName = backend.data.resources.tables["Todo"].tableName;

// Create the OpenSearch domain
const openSearchDomain = new opensearch.Domain(
  backend.data.stack,
  "OpenSearchDomain",
  {
    version: opensearch.EngineVersion.OPENSEARCH_2_11,
    capacity: {
      // upgrade instance types for production use
      masterNodeInstanceType: "t3.small.search",
      masterNodes: 0,
      dataNodeInstanceType: "t3.small.search",
      dataNodes: 1,
    },
    nodeToNodeEncryption: true,
    // set removalPolicy to DESTROY to make sure the OpenSearch domain is deleted on stack deletion.
    removalPolicy: RemovalPolicy.DESTROY,  
    encryptionAtRest: {
      enabled: true,
    },
  }
);

// Get the S3Bucket ARN
const s3BucketArn = backend.storage.resources.bucket.bucketArn;
// Get the S3Bucket Name
const s3BucketName = backend.storage.resources.bucket.bucketName;

// Create an IAM role for OpenSearch integration
const openSearchIntegrationPipelineRole = new iam.Role(
  backend.data.stack,
  "OpenSearchIntegrationPipelineRole",
  {
    assumedBy: new iam.ServicePrincipal("osis-pipelines.amazonaws.com"),
    inlinePolicies: {
      openSearchPipelinePolicy: new iam.PolicyDocument({
        statements: [
          new iam.PolicyStatement({
            actions: ["es:DescribeDomain"],
            resources: [
              openSearchDomain.domainArn,
              openSearchDomain.domainArn + "/*",
            ],
            effect: iam.Effect.ALLOW,
          }),
          new iam.PolicyStatement({
            actions: ["es:ESHttp*"],
            resources: [
              openSearchDomain.domainArn,
              openSearchDomain.domainArn + "/*",
            ],
            effect: iam.Effect.ALLOW,
          }),
          new iam.PolicyStatement({
            effect: iam.Effect.ALLOW,
            actions: [
              "s3:GetObject",
              "s3:AbortMultipartUpload",
              "s3:PutObject",
              "s3:PutObjectAcl",
            ],
            resources: [s3BucketArn, s3BucketArn + "/*"],
          }),
          new iam.PolicyStatement({
            effect: iam.Effect.ALLOW,
            actions: [
              "dynamodb:DescribeTable",
              "dynamodb:DescribeContinuousBackups",
              "dynamodb:ExportTableToPointInTime",
              "dynamodb:DescribeExport",
              "dynamodb:DescribeStream",
              "dynamodb:GetRecords",
              "dynamodb:GetShardIterator",
            ],
            resources: [tableArn, tableArn + "/*"],
          }),
        ],
      }),
    },
    managedPolicies: [
      iam.ManagedPolicy.fromAwsManagedPolicyName(
        "AmazonOpenSearchIngestionFullAccess"
      ),
    ],
  }
);

// Define OpenSearch index mappings
const indexName = "todo";

const indexMapping = {
  settings: {
    number_of_shards: 1,
    number_of_replicas: 0,
  },
  mappings: {
    properties: {
      id: {
        type: "keyword",
      },
      isDone: {
        type: "boolean",
      },
      content: {
        type: "text",
      },
      priority: {
        type: "text",
      },
    },
  },
};

// highlight-start

// OpenSearch template definition
const openSearchTemplate = `
version: "2"
dynamodb-pipeline:
  source:
    dynamodb:
      acknowledgments: true
      tables:
        - table_arn: "${tableArn}"
          stream:
            start_position: "LATEST"
          export:
            s3_bucket: "${s3BucketName}"
            s3_region: "${backend.storage.stack.region}"
            s3_prefix: "${tableName}/"
      aws:
        sts_role_arn: "${openSearchIntegrationPipelineRole.roleArn}"
        region: "${backend.data.stack.region}"
  sink:
    - opensearch:
        hosts:
          - "https://${openSearchDomain.domainEndpoint}"
        index: "${indexName}"
        index_type: "custom"
        template_content: |
          ${JSON.stringify(indexMapping)}
        document_id: '\${getMetadata("primary_key")}'
        action: '\${getMetadata("opensearch_action")}'
        document_version: '\${getMetadata("document_version")}'
        document_version_type: "external"
        bulk_size: 4
        aws:
          sts_role_arn: "${openSearchIntegrationPipelineRole.roleArn}"
          region: "${backend.data.stack.region}"
`;
// highlight-end
```

This configuration defines the desired behavior of the pipeline for a single model.

In the source configuration, DynamoDB is specified as the data source, along with the target table for ingestion and the starting point of the stream. Additionally, besides ingesting the stream into OpenSearch, a target S3 bucket is defined for backup purposes. Furthermore, an IAM role is set for the ingestion pipeline, ensuring it possesses the necessary permissions and policies as detailed in the documentation.

Regarding the sink configuration, the OpenSearch domain cluster is specified by setting the host, index name, type, and template content (index mapping) for data formatting. Document-related metadata is configured along with the maximum bulk size for requests to OpenSearch in MB. Once again, an IAM role is specified for the sink portion of the pipeline. For further details on Sink configuration, please refer to the [OpenSearch documentation](https://opensearch.org/docs/latest/data-prepper/pipelines/configuration/sinks/sinks/).

The sink configuration is an array. To create a different index on the same table, you can achieve this by adding a second OpenSearch configuration to the sink array.

To index multiple tables, you'll need to configure multiple pipelines in the configuration. For further guidance, please consult the [pipeline section](https://opensearch.org/docs/latest/data-prepper/pipelines/pipelines/) of the OpenSearch documentation.

<Callout>

**Note**: An OpenSearch Ingestion pipeline supports only one DynamoDB table as its source. For more details on current limitations, Please refer to [Amazon OpenSearch Limitation](https://docs.aws.amazon.com/opensearch-service/latest/developerguide/configure-client-ddb.html#ddb-pipeline-limitations) section.

</Callout>

Now, create the OSIS pipeline resource:

```ts title="amplify/backend.ts"
import * as dynamodb from "aws-cdk-lib/aws-dynamodb";
import * as opensearch from "aws-cdk-lib/aws-opensearchservice";
import { RemovalPolicy } from "aws-cdk-lib";
import * as iam from "aws-cdk-lib/aws-iam";
// highlight-start
import * as osis from "aws-cdk-lib/aws-osis";
import * as logs from "aws-cdk-lib/aws-logs";
import { RemovalPolicy } from "aws-cdk-lib"; 
// highlight-end
import { defineBackend } from "@aws-amplify/backend";
import { auth } from "./auth/resource";
import { data } from "./data/resource";
import { storage } from "./storage/resource";

// Define backend resources
const backend = defineBackend({
  auth,
  data,
  storage,
});

const todoTable =
  backend.data.resources.cfnResources.amplifyDynamoDbTables["Todo"];

// Update table settings
todoTable.pointInTimeRecoveryEnabled = true;

todoTable.streamSpecification = {
  streamViewType: dynamodb.StreamViewType.NEW_IMAGE,
};

// Get the DynamoDB table ARN
const tableArn = backend.data.resources.tables["Todo"].tableArn;
// Get the DynamoDB table name
const tableName = backend.data.resources.tables["Todo"].tableName;

// Create the OpenSearch domain
const openSearchDomain = new opensearch.Domain(
  backend.data.stack,
  "OpenSearchDomain",
  {
    version: opensearch.EngineVersion.OPENSEARCH_2_11,
    capacity: {
      // upgrade instance types for production use
      masterNodeInstanceType: "t3.small.search",
      masterNodes: 0,
      dataNodeInstanceType: "t3.small.search",
      dataNodes: 1,
    },
    nodeToNodeEncryption: true,
    // set removalPolicy to DESTROY to make sure the OpenSearch domain is deleted on stack deletion.
    removalPolicy: RemovalPolicy.DESTROY,
    encryptionAtRest: {
      enabled: true,
    },
  }
);

// Get the S3Bucket ARN
const s3BucketArn = backend.storage.resources.bucket.bucketArn;
// Get the S3Bucket Name
const s3BucketName = backend.storage.resources.bucket.bucketName;

// Create an IAM role for OpenSearch integration
const openSearchIntegrationPipelineRole = new iam.Role(
  backend.data.stack,
  "OpenSearchIntegrationPipelineRole",
  {
    assumedBy: new iam.ServicePrincipal("osis-pipelines.amazonaws.com"),
    inlinePolicies: {
      openSearchPipelinePolicy: new iam.PolicyDocument({
        statements: [
          new iam.PolicyStatement({
            actions: ["es:DescribeDomain"],
            resources: [
              openSearchDomain.domainArn,
              openSearchDomain.domainArn + "/*",
            ],
            effect: iam.Effect.ALLOW,
          }),
          new iam.PolicyStatement({
            actions: ["es:ESHttp*"],
            resources: [
              openSearchDomain.domainArn,
              openSearchDomain.domainArn + "/*",
            ],
            effect: iam.Effect.ALLOW,
          }),
          new iam.PolicyStatement({
            effect: iam.Effect.ALLOW,
            actions: [
              "s3:GetObject",
              "s3:AbortMultipartUpload",
              "s3:PutObject",
              "s3:PutObjectAcl",
            ],
            resources: [s3BucketArn, s3BucketArn + "/*"],
          }),
          new iam.PolicyStatement({
            effect: iam.Effect.ALLOW,
            actions: [
              "dynamodb:DescribeTable",
              "dynamodb:DescribeContinuousBackups",
              "dynamodb:ExportTableToPointInTime",
              "dynamodb:DescribeExport",
              "dynamodb:DescribeStream",
              "dynamodb:GetRecords",
              "dynamodb:GetShardIterator",
            ],
            resources: [tableArn, tableArn + "/*"],
          }),
        ],
      }),
    },
    managedPolicies: [
      iam.ManagedPolicy.fromAwsManagedPolicyName(
        "AmazonOpenSearchIngestionFullAccess"
      ),
    ],
  }
);

// Define OpenSearch index mappings
const indexName = "todo";

const indexMapping = {
  settings: {
    number_of_shards: 1,
    number_of_replicas: 0,
  },
  mappings: {
    properties: {
      id: {
        type: "keyword",
      },
      isDone: {
        type: "boolean",
      },
      content: {
        type: "text",
      },
      priority: {
        type: "text",
      },
    },
  },
};

// OpenSearch template definition
const openSearchTemplate = `
version: "2"
dynamodb-pipeline:
  source:
    dynamodb:
      acknowledgments: true
      tables:
        - table_arn: "${tableArn}"
          stream:
            start_position: "LATEST"
          export:
            s3_bucket: "${s3BucketName}"
            s3_region: "${backend.storage.stack.region}"
            s3_prefix: "${tableName}/"
      aws:
        sts_role_arn: "${openSearchIntegrationPipelineRole.roleArn}"
        region: "${backend.data.stack.region}"
  sink:
    - opensearch:
        hosts:
          - "https://${openSearchDomain.domainEndpoint}"
        index: "${indexName}"
        index_type: "custom"
        template_content: |
          ${JSON.stringify(indexMapping)}
        document_id: '\${getMetadata("primary_key")}'
        action: '\${getMetadata("opensearch_action")}'
        document_version: '\${getMetadata("document_version")}'
        document_version_type: "external"
        bulk_size: 4
        aws:
          sts_role_arn: "${openSearchIntegrationPipelineRole.roleArn}"
          region: "${backend.data.stack.region}"
`;

// highlight-start
// Create a CloudWatch log group
const logGroup = new logs.LogGroup(backend.data.stack, "LogGroup", {
  logGroupName: "/aws/vendedlogs/OpenSearchService/pipelines/1",
  removalPolicy: RemovalPolicy.DESTROY,
});

// Create an OpenSearch Integration Service pipeline
const cfnPipeline = new osis.CfnPipeline(
  backend.data.stack,
  "OpenSearchIntegrationPipeline",
  {
    maxUnits: 4,
    minUnits: 1,
    pipelineConfigurationBody: openSearchTemplate,
    pipelineName: "dynamodb-integration-2",
    logPublishingOptions: {
      isLoggingEnabled: true,
      cloudWatchLogDestination: {
        logGroup: logGroup.logGroupName,
      },
    },
  }
);
//highlight-end
```

After deploying the resources, you can test the data ingestion process by adding an item to the `Todo` table. However, before doing that, let's verify that the pipeline has been set up correctly.

In the AWS console, navigate to OpenSearch and then to the pipelines section. You should find your configured pipeline and review its settings to ensure they match your expectations:

![A screenshot displaying the OpenSearch OSIS pipeline created under the DynamoDB integrations section](/images/gen2/opensearch-integration/OpenSearch_pipeline.png)

You can also check this in the DynamoDB console by going to the Integrations section of the tables.

![A screenshot displaying the OpenSearch OSIS pipeline created within the 'Ingestion -> Pipelines' section of the OpenSearch Console.](/images/gen2/opensearch-integration/OpenSearch_DynamoDB_integration.png)

## Step 4: Expose new queries on OpenSearch

### Step 4a: Add OpenSearch Datasource to backend

First, Add the OpenSearch data source to the data backend. Add the following code to the end of the `amplify/backend.ts` file.

```ts title="amplify/backend.ts"
// Add OpenSearch data source 
const osDataSource = backend.data.addOpenSearchDataSource(
  "osDataSource",
  openSearchDomain
);

```
### Step 4b: Create Resolver and attach to query

Let's create the search resolver. Create a new file named `amplify/data/searchTodoResolver.js` and paste the following code. For additional details please refer to [Amazon OpenSearch Service Resolvers](https://docs.aws.amazon.com/appsync/latest/devguide/tutorial-elasticsearch-resolvers-js.html)

```ts title="amplify/data/searchTodoResolver.js"
import { util } from "@aws-appsync/utils";

/**
 * Searches for documents by using an input term
 * @param {import('@aws-appsync/utils').Context} ctx the context
 * @returns {*} the request
 */
export function request(ctx) {
  return {
    operation: "GET",
    path: "/todo/_search",
  };
}

/**
 * Returns the fetched items
 * @param {import('@aws-appsync/utils').Context} ctx the context
 * @returns {*} the result
 */
export function response(ctx) {
  if (ctx.error) {
    util.error(ctx.error.message, ctx.error.type);
  }
  return ctx.result.hits.hits.map((hit) => hit._source);
}
```

### Step 4c: Add the AppSync Resolver for the Search Query

Update the schema and add a searchTodo query.

```ts title="amplify/data/resource.ts"
const schema = a.schema({
  Todo: a
    .model({
      content: a.string(),
      done: a.boolean(),
      priority: a.enum(["low", "medium", "high"]),
    })
    .authorization((allow) => [allow.publicApiKey()]),

  //highlight-start  
    searchTodos: a
    .query()
    .returns(a.ref("Todo").array())
    .authorization((allow) => [allow.publicApiKey()])
    .handler(
      a.handler.custom({
        entry: "./searchTodoResolver.js",
        dataSource: "osDataSource",
      })
    ),
  //highlight-end

});
```

Once you've deployed the resources, you can verify the changes by checking the AppSync console. Run the 'searchTodo' query and review the results to confirm their accuracy.

![AppSync console displaying a generated query for 'searchTodo' with the results fetched from OpenSearch on the right side.](/images/gen2/opensearch-integration/opensearch_appsync_console.png)



Contents of build-a-backend_data_custom-subscription_index.txt:
import { getCustomStaticPath } from '@/utils/getCustomStaticPath';

export const meta = {
  title: 'Add custom real-time subscriptions',
  description:
    'Customize your business logic to create custom real-time subscriptions.',
  platforms: [
    'android',
    'angular',
    'flutter',
    'javascript',
    'nextjs',
    'react',
    'react-native',
    'swift',
    'vue'
  ]
};

export const getStaticPaths = async () => {
  return getCustomStaticPath(meta.platforms);
};

export function getStaticProps() {
  return {
    props: {
      meta
    }
  };
}

Create a custom real-time subscription for any mutation to enable PubSub use cases. 

## Define a custom subscription

For every custom subscription, you need to set:
1. the mutation(s) that should trigger a subscription event,
2. a return type that matches the subscribed mutations' return type,
3. authorization rules.

Optionally, you can set filter arguments to customize the server-side subscription filter rules.

Use `a.subscription()` to define your custom subscription in your **amplify/data/resource.ts** file:

```ts title="amplify/data/resource.ts"
import { type ClientSchema, a, defineData } from '@aws-amplify/backend';

const schema = a.schema({
  // Message type that's used for this PubSub sample
  Message: a.customType({
    content: a.string().required(),
    channelName: a.string().required()
  }),

  // Message publish mutation
  publish: a.mutation()
    .arguments({
      channelName: a.string().required(),
      content: a.string().required()
    })
    .returns(a.ref('Message'))
    .handler(a.handler.custom({ entry: './publish.js' }))
    .authorization(allow => [allow.publicApiKey()]),

  // highlight-start
  // Subscribe to incoming messages
  receive: a.subscription()
    // subscribes to the 'publish' mutation
    .for(a.ref('publish')) 
    // subscription handler to set custom filters
    .handler(a.handler.custom({entry: './receive.js'})) 
    // authorization rules as to who can subscribe to the data
    .authorization(allow => [allow.publicApiKey()]),
  // highlight-end

  // A data model to manage channels
  Channel: a.model({
    name: a.string(),
  }).authorization(allow => [allow.publicApiKey()]),
});

export type Schema = ClientSchema<typeof schema>;

export const data = defineData({
  schema
});
```

For this example, we're building a generic PubSub capability. This requires us to convert the arguments for `publish` into the `Channel`'s format. Create a new `publish.js` file in your **amplify/data/** folder with the following contents:

```js title="amplify/data/publish.js"
// This handler simply passes through the arguments of the mutation through as the result
export function request() {
  return {}
}

/**
 * @param {import('@aws-appsync/utils').Context} ctx
 */
export function response(ctx) {
  return ctx.args
}
```

Next, create a new `receive.js` file in your **amplify/data/** folder to define handlers for your subscription. In this case, it'll just be a simple passthrough. In the next section, we'll explore how to use this handler to construct more advanced subscription filters.

<Callout info>

**Note:** We're planning a developer experience enhancement in the near future that'll create this passthrough under the hood.

</Callout>

```ts title="amplify/data/receive.js"
export function request() {
  return {};
}

export const response = (ctx) => {
  return ctx.result;
};
```

## Subscribe to custom subscriptions client-side

From your generated Data client, you can find all your custom subscriptions under `client.subscriptions`. Subscribe using the `.subscribe()` function and then use the `next` function to handle incoming events.

```ts
import { generateClient } from 'aws-amplify/data'
import type { Schema } from '../amplify/data/resource'

const client = generateClient<Schema>()

const sub = client.subscriptions.receive()
  .subscribe({
    next: event => {
      console.log(event)
    }
  }
)
```

You can try publishing an event using the custom mutation to test the real-time subscription.

```ts
client.mutations.publish({
  channelName: "world",
  content: "My first message!"
})
```

Your subscription event should be received and logs the payload into your app's developer console. Unsubscribe your subscription to disconnect using the `unsubscribe()` function.

```ts
sub.unsubscribe()
```

## (Optionally) Add server-side subscription filters

You can add subscription filters by adding arguments to the custom subscriptions. 

{/* ### Basic subscription filters based on exact match
By default, every argument specified will be exact-matched to the subscription event's output. In the following example, we can introduce a required `name` argument, which allows your users to filter events based on a specific channel name:
```ts
import { type ClientSchema, a, defineData } from '@aws-amplify/backend';
const schema = a.schema({
  Channel: a.customType({
    name: a.string(),
    data: a.json()
  }),
  // Define a mutation to publish events to
  publish: a.mutation()
    .arguments({
      name: a.string(),
      data: a.json()
    })
    .returns(a.ref('Channel'))
    .handler(a.handler.custom({
      entry: "./publish.js"
    }))
    .authorization(allow => [allow.authenticated()]),
  
  // Subscribe to all events from the "publish" mutation
  receive: a.subscription(['publish'])
    // highlight-next-line
    .arguments({ name: a.string() })
    .authorization(allow => [allow.publicApiKey()])
});
export type Schema = ClientSchema<typeof schema>;
export const data = defineData({
  schema
});
```
### Enhanced subscription filters for custom filtering logic */}

If you want to customize the filters, modify the subscription handler. For this example, we'll allow a customer to pass in a `namePrefix` parameter that allows the end users to only receive channel events in channels that start with the `namePrefix`.

```ts title="amplify/data/resource.ts"
import { type ClientSchema, a, defineData } from '@aws-amplify/backend';

const schema = a.schema({
  Channel: a.model({
    name: a.string(),
  }).authorization(allow => [allow.publicApiKey()]),

  Message: a.customType({
    content: a.string().required(),
    channelName: a.string().required()
  }),

  publish: a.mutation()
    .arguments({
      channelName: a.string().required(),
      content: a.string().required()
    })
    .returns(a.ref('Message'))
    .handler(a.handler.custom({ entry: './publish.js' }))
    .authorization(allow => [allow.publicApiKey()]),

  receive: a.subscription()
    .for(a.ref('publish'))
    // highlight-next-line
    .arguments({ namePrefix: a.string() })
    .handler(a.handler.custom({entry: './receive.js'}))
    .authorization(allow => [allow.publicApiKey()])
});

export type Schema = ClientSchema<typeof schema>;

export const data = defineData({
  schema
});
```

In your handler, you can set custom subscription filters based on arguments passed into the custom subscription. For this example, create a new **receive.js** file alongside the **amplify/data/resource.ts** file:

```js
import { util, extensions } from "@aws-appsync/utils"

// Subscription handlers must return a `null` payload on the request
export function request() { return { payload: null } }

/**
 * @param {import('@aws-appsync/utils').Context} ctx
 */
export function response(ctx) {
  const filter = {
    channelName: {
      beginsWith: ctx.args.namePrefix
    }
  }

  extensions.setSubscriptionFilter(util.transform.toSubscriptionFilter(filter))

  return null
}
```


Contents of build-a-backend_data_customize-authz_configure-custom-identity-and-group-claim_index.txt:
import { getCustomStaticPath } from '@/utils/getCustomStaticPath';

export const meta = {
  title: 'Configure custom identity and group claims',
  description: "Amplify Data allows you to configure custom identity and group claims instead of using the default Cognito claims, which can be useful if you want to populate claims from an external source like a database or 3rd party auth provider. The example shows how to check the `user_id` identity claim and the `user_groups` group claim that could come from a custom pre token generation Lambda trigger. Defining these custom claims provides more flexibility in authorization rules.",
  platforms: [
    'android',
    'angular',
    'flutter',
    'javascript',
    'nextjs',
    'react',
    'react-native',
    'swift',
    'vue'
  ]
};

export const getStaticPaths = async () => {
  return getCustomStaticPath(meta.platforms);
};

export function getStaticProps(context) {
  return {
    props: {
      platform: context.params.platform,
      meta
    }
  };
}

Amplify Data supports using custom identity and group claims if you do not wish to use the default Amazon Cognito-provided `cognito:groups` or the double-colon-delimited claims, `sub::username`, from your JWT token. This can be helpful if you are using tokens from a 3rd party OIDC system or if you wish to populate a claim with a list of groups from an external system, such as when using a [Pre Token Generation Lambda Trigger](https://docs.aws.amazon.com/cognito/latest/developerguide/user-pool-lambda-pre-token-generation.html) which reads from a database.

To use custom claims specify `identityClaim` or `groupClaim` as appropriate. In the example below, the `identityClaim` is specified and the record owner will check against this `user_id` claim. Similarly, if the `user_groups` claim contains a "Moderator" string then access will be granted.

```ts title="amplify/data/resource.ts"
import { a, defineData, type ClientSchema } from '@aws-amplify/backend';

const schema = a.schema({
  Post: a
    .model({
      id: a.id(),
      owner: a.string(),
      postname: a.string(),
      content: a.string(),
    })
    .authorization(allow => [
      allow.owner().identityClaim('user_id'),
      allow.groups(['Moderator']).withClaimIn('user_groups'),
    ]),
});

export type Schema = ClientSchema<typeof schema>;

export const data = defineData({ schema });

```

<InlineFilter filters={["javascript", "angular", "react-native", "react", "nextjs", "vue", "android", "swift"]}>

In your application, you can perform CRUD operations against the model using `client.models.<model-name>` with the `userPool` auth mode.

```ts
import { generateClient } from 'aws-amplify/data';
import type { Schema } from '../amplify/data/resource'; // Path to your backend resource definition

const client = generateClient<Schema>();

const { errors, data: newTodo } = await client.models.Todo.create(
  {
    postname: 'My New Post'
    content: 'My post content',
  },
  // highlight-start
  {
    authMode: 'userPool',
  }
  // highlight-end
);
```

</InlineFilter>

<InlineFilter filters={["flutter"]}>
In your application, you can perform CRUD operations against the model with the `userPools` auth mode.
  
```dart
try {
  final todo = Todo(content: 'My new todo');
  final request = ModelMutations.create(
    todo,  
    authorizationMode: APIAuthorizationType.userPools,
  );
  final createdTodo = await Amplify.API.mutations(request: request).response;

  if (createdTodo == null) {
    safePrint('errors: ${response.errors}');
    return;
  }
  safePrint('Mutation result: ${createdTodo.name}');

} on APIException catch (e) {
  safePrint('Failed to create todo', e);
}
```
</InlineFilter>


Contents of build-a-backend_data_customize-authz_custom-data-access-patterns_index.txt:
import { getCustomStaticPath } from '@/utils/getCustomStaticPath';

export const meta = {
  title: 'Custom data access using Lambda functions',
  description: 'Define a custom authorization rule with a Lambda function.',
  platforms: [
    'android',
    'angular',
    'flutter',
    'javascript',
    'nextjs',
    'react',
    'react-native',
    'swift',
    'vue'
  ]
};

export const getStaticPaths = async () => {
  return getCustomStaticPath(meta.platforms);
};

export function getStaticProps(context) {
  return {
    props: {
      platform: context.params.platform,
      meta
    }
  };
}

You can define your own custom authorization rule with a Lambda function.

```ts title="amplify/data/resource.ts"
import {
  type ClientSchema,
  a,
  defineData,
  defineFunction,
} from '@aws-amplify/backend';

const schema = a.schema({
  Todo: a
    .model({
      content: a.string(),
    })
    // STEP 1
    // Indicate which models / fields should use a custom authorization rule
    .authorization(allow => [allow.custom()]),
});

export type Schema = ClientSchema<typeof schema>;

export const data = defineData({
  schema,
  authorizationModes: {
    defaultAuthorizationMode: 'lambda',
    // STEP 2
    // Pass in the function to be used for a custom authorization rule
    lambdaAuthorizationMode: {
      function: defineFunction({
        entry: './custom-authorizer.ts',
      }),
      // (Optional) STEP 3
      // Configure the token's time to live
      timeToLiveInSeconds: 300,
    },
  },
});
```
<InlineFilter filters={["javascript", "angular", "react-native", "react", "nextjs", "vue", "android", "swift"]}>

In your application, you can perform CRUD operations against the model using `client.models.<model-name>` with the `lambda` auth mode.

```ts
import { generateClient } from 'aws-amplify/data';
import type { Schema } from '../amplify/data/resource'; // Path to your backend resource definition

const client = generateClient<Schema>();

const { errors, data: newTodo } = await client.models.Todo.create(
  {
    content: 'My new todo',
  },
  // highlight-start
  {
    authMode: 'lambda',
  }
  // highlight-end
);
```

</InlineFilter>

<InlineFilter filters={["flutter"]}>
In your application, you can perform CRUD operations against the model with the `function` auth mode.

```dart
try {
  final todo = Todo(content: 'My new todo');
  final request = ModelMutations.create(
    todo,  
    authorizationMode: APIAuthorizationType.function,
  );
  final createdTodo = await Amplify.API.mutations(request: request).response;

  if (createdTodo == null) {
    safePrint('errors: ${response.errors}');
    return;
  }
  safePrint('Mutation result: ${createdTodo.name}');

} on APIException catch (e) {
  safePrint('Failed to create todo', e);
}
```

</InlineFilter>

The Lambda function of choice will receive an authorization token from the client and execute the desired authorization logic. The AppSync GraphQL API will receive a payload from Lambda after invocation to allow or deny the API call accordingly.

To configure a Lambda function as the authorization mode, create a new file `amplify/data/custom-authorizer.ts`. You can use this Lambda function code template as a starting point for your authorization handler code:

```ts
// amplify/data/custom-authorizer.ts

// This is sample code. Update this to suite your needs
import type { AppSyncAuthorizerHandler } from 'aws-lambda'; // types imported from @types/aws-lambda

type ResolverContext = {
  userid: string;
  info: string;
  more_info: string;
};

export const handler: AppSyncAuthorizerHandler<ResolverContext> = async (
  event
) => {
  console.log(`EVENT: ${JSON.stringify(event)}`);
  const {
    authorizationToken,
    requestContext: { apiId, accountId }
  } = event;
  const response = {
    isAuthorized: authorizationToken === 'custom-authorized',
    resolverContext: {
      // eslint-disable-next-line spellcheck/spell-checker
      userid: 'user-id',
      info: 'contextual information A',
      more_info: 'contextual information B'
    },
    deniedFields: [
      `arn:aws:appsync:${process.env.AWS_REGION}:${accountId}:apis/${apiId}/types/Event/fields/comments`,
      `Mutation.createEvent`
    ],
    ttlOverride: 300
  };
  console.log(`RESPONSE: ${JSON.stringify(response, null, 2)}`);
  return response;
};
```

You can use the template above as a starting point for your custom authorization rule. The authorization Lambda function receives the following event:

```json
{
    "authorizationToken": "ExampleAuthToken123123123", # Authorization token specified by client
    "requestContext": {
        "apiId": "aaaaaa123123123example123", # AppSync API ID
        "accountId": "111122223333", # AWS Account ID
        "requestId": "f4081827-1111-4444-5555-5cf4695f339f",
        "queryString": "mutation CreateEvent {...}\n\nquery MyQuery {...}\n", # GraphQL query
        "operationName": "MyQuery", # GraphQL operation name
        "variables": {} # any additional variables supplied to the operation
    }
}
```

Your Lambda authorization function needs to return the following JSON:

```json
{
  // required
  "isAuthorized": true, // if "false" then an UnauthorizedException is raised, access is denied
  "resolverContext": { "banana": "very yellow" }, // JSON object visible as $ctx.identity.resolverContext in VTL resolver templates

  // optional
  "deniedFields": ["TypeName.FieldName"], // Forces the fields to "null" when returned to the client
  "ttlOverride": 10 // The number of seconds that the response should be cached for. Overrides default specified in "amplify update api"
}
```

Review the Amplify documentation to set the custom authorization token for the [Data client](/[platform]/build-a-backend/data/connect-to-API).


Contents of build-a-backend_data_customize-authz_grant-lambda-function-access-to-api_index.txt:
import { getCustomStaticPath } from '@/utils/getCustomStaticPath';

export const meta = {
  title: 'Grant Lambda function access to API and Data',
  description: "Amplify Data uses a 'deny-by-default' authorization model. Function access must be explicitly defined in the schema.",
  platforms: [
    'android',
    'angular',
    'flutter',
    'javascript',
    'nextjs',
    'react',
    'react-native',
    'swift',
    'vue'
  ]
};

export const getStaticPaths = async () => {
  return getCustomStaticPath(meta.platforms);
};

export function getStaticProps(context) {
  return {
    props: {
      platform: context.params.platform,
      meta
    }
  };
}

Function access to `defineData` can be configured using an authorization rule on the schema object.

```ts title="amplify/data/resource.ts"
import {
  a,
  defineData,
  type ClientSchema
} from '@aws-amplify/backend';
import { functionWithDataAccess } from '../function/data-access/resource';

const schema = a
  .schema({
    Todo: a.model({
      name: a.string(),
      description: a.string(),
      isDone: a.boolean()
    })
  })
  // highlight-next-line
  .authorization(allow => [allow.resource(functionWithDataAccess)]);

export type Schema = ClientSchema<typeof schema>;

export const data = defineData({
  schema
});
```

Create a new directory and a resource file, `amplify/functions/data-access/resource.ts`. Then, define the Function with `defineFunction`:

```ts title="amplify/functions/data-access/resource.ts"
import { defineFunction } from '@aws-amplify/backend';

export const functionWithDataAccess = defineFunction({
  name: 'data-access',
});
```

The object returned from `defineFunction` can be passed directly to `allow.resource()` in the schema authorization rules. This will grant the function the ability to execute Query, Mutation, and Subscription operations against the GraphQL API. Use the `.to()` method to narrow down access to one or more operations.

```ts title="amplify/data/resource.ts"
const schema = a
  .schema({
    Todo: a.model({
      name: a.string(),
      description: a.string(),
      isDone: a.boolean()
    })
  })
  // highlight-start
  .authorization(allow => [
    allow.resource(functionWithDataAccess).to(['query', 'listen'])
  ]); // allow query and subscription operations but not mutations
// highlight-end
```

<Callout info>

Function access can only be configured on the schema object. It cannot be configured on individual models or fields.

</Callout>

## Access the API using `aws-amplify`

In the handler file for your function, configure the Amplify data client

```ts title="amplify/functions/data-access/handler.ts"
import type { Handler } from 'aws-lambda';
import type { Schema } from '../../data/resource';
import { Amplify } from 'aws-amplify';
import { generateClient } from 'aws-amplify/data';
import { getAmplifyDataClientConfig } from '@aws-amplify/backend/function/runtime';
import { env } from '$amplify/env/<function-name>'; // replace with your function name

const { resourceConfig, libraryOptions } = await getAmplifyDataClientConfig(env);

Amplify.configure(resourceConfig, libraryOptions);

const client = generateClient<Schema>();

export const handler = async (event) => {
  // your function code goes here
}
```

<Callout warning>
When configuring Amplify with `getAmplifyDataClientConfig`, your function consumes schema information from an S3 bucket created during backend deployment with grants for the access your function need to use it. Any changes to this bucket outside of backend deployment may break your function.
</Callout>

Once you have generated the client code, update the function to access the data. The following code creates a todo and then lists all todos.

```ts title="amplify/functions/data-access.ts"
const client = generateClient<Schema>();

export const handler: Handler = async (event) => {
  const { errors: createErrors, data: newTodo } = await client.models.Todo.create({
    name: "My new todo",
    description: "Todo description",
    isDone: false,
  })


  const { errors: listErrors, data: todos } = await client.models.Todo.list();

  return event;
};
```


Contents of build-a-backend_data_customize-authz_index.txt:
import { getChildPageNodes } from '@/utils/getChildPageNodes';
import { getCustomStaticPath } from '@/utils/getCustomStaticPath';

export const meta = {
  title: 'Customize your auth rules',
  description: 'Learn how to customize and combine your authorization rules.',
  route: "/[platform]/build-a-backend/data/customize-authz",
  platforms: [
    'android',
    'angular',
    'flutter',
    'javascript',
    'nextjs',
    'react',
    'react-native',
    'swift',
    'vue'
  ]
};

export const getStaticPaths = async () => {
  return getCustomStaticPath(meta.platforms);
};

export function getStaticProps(context) {
  const childPageNodes = getChildPageNodes(meta.route);
  return {
    props: {
      meta,
      childPageNodes
    }
  };
}


Use the `.authorization()` modifier to configure authorization rules for public, signed-in user, per user, and per user group data access. **Authorization rules operate on the deny-by-default principle**. Meaning that if an authorization rule is not specifically configured, it is denied.

```ts
const schema = a.schema({
  Post: a.model({
    content: a.string()
  }).authorization(allow => [
    // Allow anyone auth'd with an API key to read everyone's posts.
    allow.publicApiKey().to(['read']),
    // Allow signed-in user to create, read, update,
    // and delete their __OWN__ posts.
    allow.owner(),
  ])
})
```
In the example above, everyone (`public`) can read every Post but authenticated users (`owner`) can create, read, update, and delete their own posts. Amplify also allows you to restrict the allowed operations, combine multiple authorization rules, and apply fine-grained field-level authorization.

## Available authorization strategies

Use the guide below to select the correct authorization strategy for your use case:

| **Recommended use case** | **Strategy** | **`authMode`** |
|--------------------------|--------------|----------------|
| [Public data access where users or devices are anonymous. Anyone with the AppSync API key is granted access.](/[platform]/build-a-backend/data/customize-authz/public-data-access) | `publicApiKey` | `apiKey` |
| [Recommended for production environment's public data access. Public data access where unauthenticated users or devices are granted permissions using Amazon Cognito identity pool's role for unauthenticated identities.]( /[platform]/build-a-backend/data/customize-authz/public-data-access/#add-public-authorization-rule-using-iam-authentication) | `guest` | `identityPool` |
| [Per user data access. Access is restricted to the "owner" of a record. Leverages `amplify/auth/resource.ts` Cognito user pool by default.](/[platform]/build-a-backend/data/customize-authz/per-user-per-owner-data-access) | `owner`/`ownerDefinedIn`/`ownersDefinedIn` | `userPool` / `oidc` |
| [Any signed-in data access. Unlike owner-based access, **any** signed-in user has access.](/[platform]/build-a-backend/data/customize-authz/signed-in-user-data-access) | `authenticated` | `userPool` / `oidc` / `identityPool` |
| [Per user group data access. A specific or dynamically configured group of users has access.](/[platform]/build-a-backend/data/customize-authz/user-group-based-data-access) | `group`/`groupDefinedIn`/`groups`/`groupsDefinedIn` | `userPool` / `oidc` |
| [Define your own custom authorization rule within a serverless function.](/[platform]/build-a-backend/data/customize-authz/custom-data-access-patterns) | `custom` | `lambda` |

## Understand how authorization rules are applied

Authorization rules can be applied globally across all data models in a schema, onto specific data models, and onto specific fields.

Amplify will always use the most specific authorization rule that is available. For example, if there is an authorization rule for a field and an authorization rule for the model that the field belongs to, Amplify will evaluate against the field-level authorization rule. Review [Field-level authorization rules](#field-level-authorization-rules) to learn more.

If there are multiple authorization rules present, they will be logically OR'ed. Review [Configure multiple authorization rules](#configure-multiple-authorization-rules) to learn more. For `userPools` and `oidc` authorization modes, the rules are evaluated in the sequence `authenticated` > `group(s)` > `owner(s)DefinedIn` > `group(s)DefinedIn`.

### Global authorization rule (only for getting started)

To help you get started, you can define an authorization rule on the data schema that will be applied to all data models that **do not** have a model-level authorization rule. Instead of having a global authorization rule for all production environments, we recommend creating specific authorization rules for each model or field.

The global authorization rule below uses `allow.publicApiKey()`. This example allows anyone to create, read, update, and delete and is applied to every data model.

```ts
const schema = a.schema({
  // Because no model-level authorization rule is present
  // this model will use the global authorization rule.
  Todo: a.model({
    content: a.string()
  }),

  // Will use model-level authorization rule
  Notes: a.model({
    content: a.string()
    // [Model-level authorization rule]
  }).authorization(allow => [allow.publicApiKey().to(['read'])])

// [Global authorization rule]
}).authorization(allow => [
  allow.publicApiKey()
])
```

### Model-level authorization rules

Add an authorization rule to a model to apply the authorization rule to all fields of that model.

```ts
const schema = a.schema({
  Post: a.model({
    content: a.string(),
    createdBy: a.string()
    // [Model-level authorization rule]
    // All fields (content, createdBy) will be protected by
    // this authorization rule
  }).authorization(allow => [
    allow.publicApiKey().to(['read']),
    allow.owner(),
  ])
})
```

### Field-level authorization rules

When an authorization rule is added to a field, it will strictly define the authorization rules applied on the field. Field-level authorization rules **do not** inherit model-level authorization rules. Meaning, only the specified field-level authorization rule is applied.

In the example below:
- Owners are allowed to create, read, update, and delete Employee records they own
- Any signed in user has read access and can read data with the exception of the `ssn` field
- Only the `ssn` field has `owner` auth applied and this field-level auth rule means that model-level auth rules are not applied

```ts
const schema = a.schema({
  Employee: a.model({
    name: a.string(),
    email: a.string(),
    // [Field-level authorization rule]
    // This auth rule will be used for the "ssn" field
    // All other fields will use the model-level auth rule
    ssn: a.string().authorization(allow => [allow.owner()]),
  })

  // [Model-level authorization rule]
  .authorization(allow => [
    allow.authenticated().to(["read"]),
    allow.owner()
  ]),
});
```

### Non-model authorization rules

**Non-model** types are any types added to the schema without using `a.model()`. These consist of modifiers such as `a.customType()`, `a.enum()`,`a.query()`, `a.mutation()`, or `a.subscription()`.

Dynamic authorization rules such as `allow.owner()`, `allow.ownerDefinedIn()`, `allow.groupDefinedIn()` are not supported for **non-model** types.

```ts
const schema = a.schema({
  // ...
  listCustomType: a
    .query()
    .returns(a.ref("CustomType").array())
    .handler(
      a.handler.custom({
        entry: "./handler.js",
      })
    )
    .authorization((allow) => [
      // Static auth rules - Supported
      allow.guest(),
      allow.publicApiKey(),
      allow.authenticated(),
      allow.group("Admin"),
      allow.groups(["Teacher", "Student"]),

      // Dynamic auth rules - Not supported
      allow.owner(),
      allow.ownerDefinedIn("owner"),
      allow.ownersDefinedIn("otherOwners"),
      allow.groupDefinedIn("group"),
      allow.groupsDefinedIn("otherGroups"),
    ]),
});
```

There are TS warnings and validation checks in place that will cause a sandbox deployment to fail if unsupported auth rules are defined on custom queries and mutations.


### Configure multiple authorization rules

When combining multiple authorization rules, they are "logically OR"-ed. In the following example:
- Any user (using Amazon Cognito identity pool's unauthenticated roles) is allowed to read all posts
- Owners are allowed to create, read, update, and delete their own posts

```ts
const schema = a.schema({
  Post: a.model({
    title: a.string(),
    content: a.string()
  }).authorization(allow => [
    allow.guest().to(["read"]),
    allow.owner()
  ])
})
```

On the client side, make sure to always authenticate with the corresponding authorization mode.

<InlineFilter filters={["javascript", "angular", "react-native", "react", "nextjs", "vue", "android", "flutter"]}>

```ts
import { generateClient } from 'aws-amplify/data'
import type { Schema } from '@/amplify/data/resource' // Path to your backend resource definition

const client = generateClient<Schema>()

// Creating a post is restricted to Cognito User Pools
const { data: newPostResult , errors } = await client.models.Post.create({
	query: queries.createPost,
	variables: { input: { title: 'Hello World' } },
	authMode: 'userPool',
});

// Listing posts is available to unauthenticated users (verified by Amazon Cognito identity pool's unauthenticated role)
const { data: listPostsResult , errors } = await client.models.Post.list({
	query: queries.listPosts,
	authMode: 'identityPool',
});
```

</InlineFilter>

<InlineFilter filters={["swift"]}>

Creating a post is restricted to Cognito User Pools.

```swift
do {
    let post = Post(title: "Hello World")
    let createdTodo = try await Amplify.API.mutate(request: .create(
        post,
        authMode: .amazonCognitoUserPools)).get()
} catch {
    print("Failed to create post", error)
}
```

Listing posts is available to unauthenticated users (verified by Amazon Cognito identity pool's unauthenticated role)

```swift
do {
    let queriedPosts = try await Amplify.API.query(request: .list(
        Post.self,
        authMode: .awsIAM)).get()
    print("Number of posts:", queriedPosts.count)
} catch {
    print("Failed to list posts", error)
}
```

</InlineFilter>

## IAM authorization

All Amplify Gen 2 projects enable IAM authorization for data access. This ensures that the Amplify console's [data manager](/[platform]/build-a-backend/data/manage-with-amplify-console/) will be able to access your API. It also allows you to authorize other administrative or machine-to-machine access using your own IAM policies. See the [AWS AppSync Developer Guide](https://docs.aws.amazon.com/appsync/latest/devguide/security_iam_service-with-iam.html) for details on how AWS AppSync works with IAM.

## Authorization on custom types

Authorization rules are only supported on data models (model-level and field-level) and custom operations (queries, mutations and subscriptions). They are not fully supported on custom types, including custom types returned by custom operations. For example, consider a custom query that returns a custom type:

```ts
const schema = a.schema({
  Counter: a.customType({
    value: a.integer(),
  })
  .authorization(...), // <-- not supported
  getCounter: a
    .mutation()
    .arguments({
      id: a.string().required(),
    })
    .returns(a.ref("Counter"))
    .handler(
      a.handler.custom({
        entry: "./getCounter.js",
      })
    )
    .authorization((allow) => [allow.authenticated()]),
});

export type Schema = ClientSchema<typeof schema>;

export const data = defineData({
  schema: schema,
  authorizationModes: {
    defaultAuthorizationMode: "userPool",
  },
});
```

As you can see, the custom `Counter` type does not support the `.authorization()` modifier. Instead, behind the scenes, Amplify will add appropriate authorization rules to `Counter` to allow authenticated users to access it. That means that any signed-in user will be able to access the custom operation and all fields of the custom type.

<Callout info>

**Note**: IAM authorization is not currently supported for custom operations that return custom types if `defaultAuthorizationMode` is not `iam`. See [GitHub issue #2929](https://github.com/aws-amplify/amplify-category-api/issues/2929) for details and suggested workarounds.

</Callout>

## Learn more about specific authorization strategies

<Overview childPageNodes={props.childPageNodes} />



Contents of build-a-backend_data_customize-authz_multi-user-data-access_index.txt:
import { getCustomStaticPath } from '@/utils/getCustomStaticPath';

export const meta = {
  title: 'Multi-user data access',
  description: "The `ownersDefinedIn` rule grants a set of users access to a record by automatically creating an `owners` field to store the allowed record owners. You can override the default owners field name by specifying `inField` with the desired field name to store the owner information. You can dynamically manage which users can access a record by updating the owner field.",
  platforms: [
    'android',
    'angular',
    'flutter',
    'javascript',
    'nextjs',
    'react',
    'react-native',
    'swift',
    'vue'
  ]
};


export const getStaticPaths = async () => {
  return getCustomStaticPath(meta.platforms);
};

export function getStaticProps(context) {
  return {
    props: {
      platform: context.params.platform,
      meta
    }
  };
}

The `ownersDefinedIn` rule grants a set of users access to a record by automatically creating an `owners` field to store the allowed record owners. You can override the default owners field name by specifying `inField` with the desired field name to store the owner information. You can dynamically manage which users can access a record by updating the owner field.

## Add multi-user authorization rule

If you want to grant a set of users access to a record, you use the `ownersDefinedIn` rule. This automatically creates a `owners: a.string().array()` field to store the allowed owners.

```ts title="amplify/data/resource.ts"
const schema = a.schema({
  Todo: a
    .model({
      content: a.string(),
      owners: a.string().array(),
    })
    .authorization(allow => [allow.ownersDefinedIn('owners')]),
});
```

<InlineFilter filters={["javascript", "angular", "react-native", "react", "nextjs", "vue", "android"]}>

In your application, you can perform CRUD operations against the model using `client.models.<model-name>` with the `userPool` auth mode.

```ts
import { generateClient } from 'aws-amplify/data';
import type { Schema } from '../amplify/data/resource'; // Path to your backend resource definition

const client = generateClient<Schema>();

// Create a record with current user as first owner
const { errors, data: newTodo } = await client.models.Todo.create(
  {
    content: 'My new todo',
  },
  // highlight-start
  {
    authMode: 'userPool',
  }
  // highlight-end
);
```

Add another user as an owner

```ts
await client.models.Todo.update(
  {
    id: newTodo.id,
    owners: [...(newTodo.owners as string[]), otherUserId],
  },
  // highlight-start
  {
    authMode: "userPool"
  }
  // highlight-end
);
```

</InlineFilter>

<InlineFilter filters={["flutter"]}>
In your application, you can perform CRUD operations against the model with the `userPools` auth mode.
  
```dart
try {
  final todo = Todo(content: 'My new todo');
  final request = ModelMutations.create(
    todo,  
    authorizationMode: APIAuthorizationType.userPools,
  );
  final createdTodo = await Amplify.API.mutations(request: request).response;

  if (createdTodo == null) {
    safePrint('errors: ${response.errors}');
    return;
  }
  safePrint('Mutation result: ${createdTodo.name}');

} on APIException catch (e) {
  safePrint('Failed to create todo', e);
}
```

Add another user as an owner

```dart
try {
  createdTodo.owners!.add(otherUserId);
  let updateRequest = ModelMutations.update(
    createdTodo,
    authorizationMode: APIAuthorizationType.userPools,
  );
  final updatedTodo = await Amplify.API.mutations(request: updateRequest).response;

  if (updatedTodo == null) {
    safePrint('errors: ${response.errors}');
    return;
  }

} catch {
  safePrint("Failed to update todo", error)
}
```
</InlineFilter>

<InlineFilter filters={["swift"]}>

In your application, you can perform CRUD operations against the model with the `amazonCognitoUserPools` auth mode.

```swift
do {
    let todo = Todo(content: "My new todo")
    let createdTodo = try await Amplify.API.mutate(request: .create(
        todo,
        authMode: .amazonCognitoUserPools)).get()
} catch {
    print("Failed to create todo", error)
}
```

Add another user as an owner

```swift
do {
    createdTodo.owners?.append(otherUserId)
    let updatedTodo = try await Amplify.API.mutate(request: .update(
        createdTodo,
        authMode: .amazonCognitoUserPools)).get()
} catch {
    print("Failed to update todo", error)
}
```

</InlineFilter>

## Override to a list of owners

You can override the `inField` to a list of owners. Use this if you want a dynamic set of users to have access to a record. In the example below, the `authors` list is populated with the creator of the record upon record creation. The creator can then update the `authors` field with additional users. Any user listed in the `authors` field can access the record.

```ts
const schema = a.schema({
  Todo: a
    .model({
      content: a.string(),
      authors: a.string().array(), // record owner information now stored in "authors" field
    })
    .authorization(allow => [allow.ownersDefinedIn('authors')]),
});
```


Contents of build-a-backend_data_customize-authz_per-user-per-owner-data-access_index.txt:
import { getCustomStaticPath } from '@/utils/getCustomStaticPath';

export const meta = {
  title: 'Per-user/per-owner data access',
  description:
    "The owner authorization strategy restricts operations on a record to only the record's owner. When configured, the owner field (default `owner`) will automatically be added and populated with the identity of the created user. The API will authorize against the `owner` field to allow or deny operations.",
  platforms: [
    'android',
    'angular',
    'flutter',
    'javascript',
    'nextjs',
    'react',
    'react-native',
    'swift',
    'vue'
  ]
};

export const getStaticPaths = async () => {
  return getCustomStaticPath(meta.platforms);
};

export function getStaticProps(context) {
  return {
    props: {
      platform: context.params.platform,
      meta
    }
  };
}

The `owner` authorization strategy restricts operations on a record to only the record's owner. When configured, the `owner` field will automatically be added and populated with the identity of the created user. The API will authorize against the `owner` field to allow or deny operations.

## Add per-user/per-owner authorization rule

You can use the `owner` authorization strategy to restrict a record's access to a specific user. When `owner` authorization is configured, only the record's `owner` is allowed the specified operations.

```ts title="amplify/data/resource.ts"
// The "owner" of a Todo is allowed to create, read, update, and delete their own todos
const schema = a.schema({
  Todo: a
    .model({
      content: a.string(),
    })
    .authorization(allow => [allow.owner()]),
});
```

```ts title="amplify/data/resource.ts"
// The "owner" of a Todo record is only allowed to create, read, and update it.
// The "owner" of a Todo record is denied to delete it.
const schema = a.schema({
  Todo: a
    .model({
      content: a.string(),
    })
    .authorization(allow => [allow.owner().to(['create', 'read', 'update'])]),
});
```

<InlineFilter filters={["javascript", "angular", "react-native", "react", "nextjs", "vue", "android"]}>

In your application, you can perform CRUD operations against the model using `client.models.<model-name>` with the `userPool` auth mode.

```ts
import { generateClient } from 'aws-amplify/data';
import type { Schema } from '../amplify/data/resource'; // Path to your backend resource definition

const client = generateClient<Schema>();

const { errors, data: newTodo } = await client.models.Todo.create(
  {
    content: 'My new todo',
  },
  // highlight-start
  {
    authMode: 'userPool',
  }
  // highlight-end
);
```
</InlineFilter>

<InlineFilter filters={["flutter"]}>
In your application, you can perform CRUD operations against the model with the `userPools` auth mode.
  
```dart
try {
  final todo = Todo(content: 'My new todo');
  final request = ModelMutations.create(
    todo,  
    authorizationMode: APIAuthorizationType.userPools,
  );
  final createdTodo = await Amplify.API.mutations(request: request).response;

  if (createdTodo == null) {
    safePrint('errors: ${response.errors}');
    return;
  }
  safePrint('Mutation result: ${createdTodo.name}');

} on APIException catch (e) {
  safePrint('Failed to create todo', e);
}
```
</InlineFilter>

<InlineFilter filters={["swift"]}>

In your application, you can perform CRUD operations against the model with the `amazonCognitoUserPools` auth mode.

```swift
do {
    let todo = Todo(content: "My new todo")
    let createdTodo = try await Amplify.API.mutate(request: .create(
        todo,
        authMode: .amazonCognitoUserPools)).get()
} catch {
    print("Failed to create todo", error)
}
```
</InlineFilter>

Behind the scenes, Amplify will automatically add a `owner: a.string()` field to each record which contains the record owner's identity information upon record creation.

By default, the Cognito user pool's user information is populated into the `owner` field. The value saved includes `sub` and `username` in the format `<sub>::<username>`. The API will authorize against the full value of `<sub>::<username>` or `sub` / `username` separately and return `username`. You can alternatively configure [OpenID Connect as an authorization provider](/[platform]/build-a-backend/data/customize-authz/using-oidc-authorization-provider).

<Callout warning>

**By default, owners can reassign the owner of their existing record to another user.**

To prevent an owner from reassigning their record to another user, protect the owner field (by default `owner: String`) with a [field-level authorization rule](/[platform]/build-a-backend/data/customize-authz/#field-level-authorization-rules). For example, in a social media app, you would want to prevent Alice from being able to reassign Alice's Post to Bob.

```ts
const schema = a.schema({
  Todo: a
    .model({
      content: a.string(),
      owner: a.string().authorization(allow => [allow.owner().to(['read', 'delete'])]),
    })
    .authorization(allow => [allow.owner()]),
});
```

</Callout>

## Customize the owner field

You can override the `owner` field to your own preferred field, by specifying a custom `ownerField` in the authorization rule.

```ts
const schema = a.schema({
  Todo: a
    .model({
      content: a.string(),
      author: a.string(), // record owner information now stored in "author" field
    })
    .authorization(allow => [allow.ownerDefinedIn('author')]),
});
```


Contents of build-a-backend_data_customize-authz_public-data-access_index.txt:
import { getCustomStaticPath } from '@/utils/getCustomStaticPath';

export const meta = {
  title: "Public data access",
  description: "The public authorization strategy grants everyone access to the API, which is protected behind the scenes with an API key. You can also override the authorization provider to use an unauthenticated IAM role from Cognito instead of an API key for public access.",
  platforms: [
    'android',
    'angular',
    'flutter',
    'javascript',
    'nextjs',
    'react',
    'react-native',
    'swift',
    'vue'
  ]
};

export const getStaticPaths = async () => {
  return getCustomStaticPath(meta.platforms);
};

export function getStaticProps(context) {
  return {
    props: {
      platform: context.params.platform,
      meta
    }
  };
}

The public authorization strategy grants everyone access to the API, which is protected behind the scenes with an API key. You can also override the authorization provider to use an unauthenticated IAM role from Cognito instead of an API key for public access.

## Add public authorization rule using API key-based authentication

To grant everyone access, use the `.public()` authorization strategy. Behind the scenes, the API will be protected with an API key.

```ts title="amplify/data/resource.ts"
const schema = a.schema({
  Todo: a
    .model({
      content: a.string(),
    })
    .authorization(allow => [allow.publicApiKey()]),
});
```

<InlineFilter filters={["javascript", "angular", "react-native", "react", "nextjs", "vue", "android"]}>

In your application, you can perform CRUD operations against the model using `client.models.<model-name>` by specifying the `apiKey` auth mode.

```ts
import { generateClient } from 'aws-amplify/data';
import type { Schema } from '../amplify/data/resource'; // Path to your backend resource definition

const client = generateClient<Schema>();

const { errors, data: newTodo } = await client.models.Todo.create(
  {
    content: 'My new todo',
  },
  // highlight-start
  {
    authMode: 'apiKey',
  }
  // highlight-end
);
```

</InlineFilter>

<InlineFilter filters={["swift", "flutter"]}>
In your application, you can perform CRUD operations against the model by specifying the `apiKey` auth mode.
</InlineFilter>

<InlineFilter filters={["flutter"]}>

```dart
try {
  final todo = Todo(content: 'My new todo');
  final request = ModelMutations.create(
    todo,
    authorizationMode: APIAuthorizationType.apiKey,
  );
  final createdTodo = await Amplify.API.mutations(request: request).response;

  if (createdTodo == null) {
    safePrint('errors: ${response.errors}');
    return;
  }
  safePrint('Mutation result: ${createdTodo.name}');

} on APIException catch (e) {
  safePrint('Failed to create todo', e);
}
```

</InlineFilter>

<InlineFilter filters={["swift"]}>

```swift
do {
    let todo = Todo(content: "My new todo")
    let createdTodo = try await Amplify.API.mutate(request: .create(
        todo,
        authMode: .apiKey)).get()
} catch {
    print("Failed to create todo", error)
}
```

</InlineFilter>

### Extend API Key Expiration

If the API key has not expired, you can extend the expiration date by deploying your app again. The API key expiration date will be set to `expiresInDays` days from the date when the app is deployed. In the example below, the API key will expire 7 days from the latest deployment.

```ts title="amplify/data/resource.ts"
export const data = defineData({
  schema,
  authorizationModes: {
    defaultAuthorizationMode: 'apiKey',
    apiKeyAuthorizationMode: {
      expiresInDays: 7,
    },
  },
});
```

### Rotate an API Key

You can rotate an API key if it was expired, compromised, or deleted. To rotate an API key, you can override the logical ID of the API key resource in the `amplify/backend.ts` file. This will create a new API key with a new logical ID.

```ts title="amplify/backend.ts"
const backend = defineBackend({
  auth,
  data,
});

backend.data.resources.cfnResources.cfnApiKey?.overrideLogicalId(
  `recoverApiKey${new Date().getTime()}`
);
```

Deploy your app. After the deploy has finished, remove the override to the logical ID and deploy your app again to use the default logical ID.

```ts title="amplify/backend.ts"
const backend = defineBackend({
  auth,
  data,
});

// backend.data.resources.cfnResources.cfnApiKey?.overrideLogicalId(
//   `recoverApiKey${new Date().getTime()}`
// );
```

A new API key will be created for your app.

## Add public authorization rule using Amazon Cognito identity pool's unauthenticated role

You can also override the authorization provider. In the example below, `identityPool` is specified as the provider which allows you to use an "Unauthenticated Role" from the Cognito identity pool for public access instead of an API key. Your Auth resources defined in `amplify/auth/resource.ts` generates scoped down IAM policies for the "Unauthenticated role" in the Cognito identity pool automatically.

```ts title="amplify/data/resource.ts"
const schema = a.schema({
  Todo: a
    .model({
      content: a.string(),
    })
    .authorization(allow => [allow.guest()]),
});
```

<InlineFilter filters={["javascript", "angular", "react-native", "react", "nextjs", "vue", "android", "flutter"]}>

In your application, you can perform CRUD operations against the model using `client.models.<model-name>` with the `identityPool` auth mode.

<Callout info>
If you're not using the auto-generated **amplify_outputs.json** file, then you must set the Amplify Library resource configuration's `allowGuestAccess` flag to `true`. This lets the Amplify Library use the unauthenticated role from your Cognito identity pool when your user isn't logged in.

<Accordion title="Amplify configuration">
```ts title="src/App.tsx"
import { Amplify } from "aws-amplify";
import outputs from "../amplify_outputs.json";

Amplify.configure(
  {
    ...outputs,
    Auth: {
      Cognito: {
        identityPoolId: config.aws_cognito_identity_pool_id,
        userPoolClientId: config.aws_user_pools_web_client_id,
        userPoolId: config.aws_user_pools_id,
        allowGuestAccess: true,
      },
    },
  }
);
```
</Accordion>
</Callout>

```ts title="src/App.tsx"
import { generateClient } from 'aws-amplify/data';
import type { Schema } from '../amplify/data/resource'; // Path to your backend resource definition

const client = generateClient<Schema>();

const { errors, data: newTodo } = await client.models.Todo.create(
  {
    content: 'My new todo',
  },
  // highlight-start
  {
    authMode: 'identityPool',
  }
  // highlight-end
);
```

</InlineFilter>

<InlineFilter filters={["flutter"]}>
In your application, you can perform CRUD operations against the model with the `iam` auth mode.

```dart
try {
  final todo = Todo(content: 'My new todo');
  final request = ModelMutations.create(
    todo,
    authorizationMode: APIAuthorizationType.iam,
  );
  final createdTodo = await Amplify.API.mutations(request: request).response;

  if (createdTodo == null) {
    safePrint('errors: ${response.errors}');
    return;
  }
  safePrint('Mutation result: ${createdTodo.name}');

} on APIException catch (e) {
  safePrint('Failed to create todo', e);
}
```

</InlineFilter>

<InlineFilter filters={["swift"]}>
In your application, you can perform CRUD operations against the model with the `awsIAM` auth mode.

```swift
do {
    let todo = Todo(content: "My new todo")
    let createdTodo = try await Amplify.API.mutate(request: .create(
        todo,
        authMode: .awsIAM)).get()
} catch {
    print("Failed to create todo", error)
}
```

</InlineFilter>


Contents of build-a-backend_data_customize-authz_signed-in-user-data-access_index.txt:
import { getCustomStaticPath } from '@/utils/getCustomStaticPath';

export const meta = {
  title: 'Signed-in user data access',
  description: "The `private` authorization strategy restricts record access to only signed-in users authenticated through IAM, Cognito, or OpenID Connect, applying the authorization rule to all users. It provides a simple way to make data private to all authenticated users.",
  platforms: [
    'android',
    'angular',
    'flutter',
    'javascript',
    'nextjs',
    'react',
    'react-native',
    'swift',
    'vue'
  ]
};

export const getStaticPaths = async () => {
  return getCustomStaticPath(meta.platforms);
};

export function getStaticProps(context) {
  return {
    props: {
      platform: context.params.platform,
      meta
    }
  };
}

The `authenticated` authorization strategy restricts record access to only signed-in users authenticated through IAM, Cognito, or OpenID Connect, applying the authorization rule to all users. It provides a simple way to make data private to all authenticated users.

## Add signed-in user authorization rule

You can use the `authenticated` authorization strategy to restrict a record's access to every signed-in user.

<Callout>
**Note:** If you want to restrict a record's access to a specific user, see [Per-user/per-owner data access](/[platform]/build-a-backend/data/customize-authz/per-user-per-owner-data-access/). The `authenticated` authorization strategy detailed on this page applies the authorization rule for data access to **every** signed-in user.
</Callout>

In the example below, anyone with a valid JWT token from the Cognito user pool is allowed access to all Todos.

```ts title="amplify/data/resource.ts"
const schema = a.schema({
  Todo: a
    .model({
      content: a.string(),
    })
    .authorization(allow => [allow.authenticated()]),
});
```

<InlineFilter filters={["javascript", "angular", "react-native", "react", "nextjs", "vue", "android"]}>

In your application, you can perform CRUD operations against the model using `client.models.<model-name>` with the `userPool` auth mode.

```ts
import { generateClient } from 'aws-amplify/data';
import type { Schema } from '../amplify/data/resource'; // Path to your backend resource definition

const client = generateClient<Schema>();

const { errors, data: newTodo } = await client.models.Todo.create(
  {
    content: 'My new todo',
  },
  // highlight-start
  {
    authMode: 'userPool',
  }
  // highlight-end
);
```
</InlineFilter>

<InlineFilter filters={["flutter"]}>
In your application, you can perform CRUD operations against the model with the `userPools` auth mode.
  
```dart
try {
  final todo = Todo(content: 'My new todo');
  final request = ModelMutations.create(
    todo,  
    authorizationMode: APIAuthorizationType.userPools,
  );
  final createdTodo = await Amplify.API.mutations(request: request).response;

  if (createdTodo == null) {
    safePrint('errors: ${response.errors}');
    return;
  }
  safePrint('Mutation result: ${createdTodo.name}');

} on APIException catch (e) {
  safePrint('Failed to create todo', e);
}
```
</InlineFilter>

<InlineFilter filters={["swift"]}>

In your application, you can perform CRUD operations against the model with the `amazonCognitoUserPools` auth mode.

```swift
do {
    let todo = Todo(content: "My new todo")
    let createdTodo = try await Amplify.API.mutate(request: .create(
        todo,
        authMode: .amazonCognitoUserPools)).get()
} catch {
    print("Failed to create todo", error) 
}
```

</InlineFilter>

## Use identity pool for signed-in user authentication

You can also override the authorization provider. In the example below, `identityPool` is specified as the provider which allows you to use an "Unauthenticated Role" from the Cognito identity pool for public access instead of an API key. Your Auth resources defined in `amplify/auth/resource.ts` generates scoped down IAM policies for the "Unauthenticated role" in the Cognito identity pool automatically.


```ts title="amplify/data/resource.ts"
const schema = a.schema({
  Todo: a
    .model({
      content: a.string(),
    })
    .authorization(allow => [allow.authenticated('identityPool')]),
});
```

<InlineFilter filters={["javascript", "angular", "react-native", "react", "nextjs", "vue", "android"]}>

In your application, you can perform CRUD operations against the model using `client.models.<model-name>` with the `iam` auth mode.

<Callout info>
 The user must be logged in for the Amplify Library to use the authenticated role from your Cognito identity pool.
</Callout>

```ts
import { generateClient } from 'aws-amplify/data';
import type { Schema } from '../amplify/data/resource'; // Path to your backend resource definition

const client = generateClient<Schema>();

const { errors, data: newTodo } = await client.models.Todo.create(
  {
    content: 'My new todo',
  },
  // highlight-start
  {
    authMode: 'identityPool',
  }
  // highlight-end
);
```
</InlineFilter>

<InlineFilter filters={["flutter"]}>
In your application, you can perform CRUD operations against the model with the `iam` auth mode.

```dart
try {
  final todo = Todo(content: 'My new todo');
  final request = ModelMutations.create(
    todo,  
    authorizationMode: APIAuthorizationType.iam,
  );
  final createdTodo = await Amplify.API.mutations(request: request).response;

  if (createdTodo == null) {
    safePrint('errors: ${response.errors}');
    return;
  }
  safePrint('Mutation result: ${createdTodo.name}');

} on APIException catch (e) {
  safePrint('Failed to create todo', e);
}
```

</InlineFilter>

<InlineFilter filters={["swift"]}>

In your application, you can perform CRUD operations against the model with the `awsIAM` auth mode.

<Callout info>
 The user must be logged in for the Amplify Library to use the authenticated role from your Cognito identity pool.
</Callout>

```swift
do {
    let todo = Todo(content: "My new todo")
    let createdTodo = try await Amplify.API.mutate(request: .create(
        todo,
        authMode: .awsIAM)).get()
} catch {
    print("Failed to create todo", error)
}
```
</InlineFilter>

In addition, you can also use OpenID Connect with `authenticated` authorization. See [OpenID Connect as an authorization provider](/[platform]/build-a-backend/data/customize-authz/using-oidc-authorization-provider/).


Contents of build-a-backend_data_customize-authz_user-group-based-data-access_index.txt:
import { getCustomStaticPath } from '@/utils/getCustomStaticPath';

export const meta = {
  title: 'User group-based data access',
  description: "The user group authorization strategy allows restricting data access to specific user groups or groups defined dynamically on each data record. Both static and dynamic group authorization options are available, with some limitations around real-time subscriptions when using dynamic group authorization.",
  platforms: [
    'android',
    'angular',
    'flutter',
    'javascript',
    'nextjs',
    'react',
    'react-native',
    'swift',
    'vue'
  ]
};

export const getStaticPaths = async () => {
  return getCustomStaticPath(meta.platforms);
};

export function getStaticProps(context) {
  return {
    props: {
      platform: context.params.platform,
      meta
    }
  };
}

You can use the `group` authorization strategy to restrict access based on user groups. The user group authorization strategy allows restricting data access to specific user groups or groups defined dynamically on each data record.

## Add authorization rules for specific user groups

When you want to restrict access to a specific set of user groups, provide the group names in the `groups` parameter. In the example below, only users that are part of the "Admin" user group are granted access to the Salary model.

```ts title="amplify/data/resource.ts"
// allow one specific group
const schema = a.schema({
  Salary: a
    .model({
      wage: a.float(),
      currency: a.string(),
    })
    .authorization(allow => [allow.group('Admin')]),
});
```

<InlineFilter filters={["javascript", "angular", "react-native", "react", "nextjs", "vue", "android"]}>

In your application, you can perform CRUD operations against the model using `client.models.<model-name>` with the `userPool` auth mode.

```ts
import { generateClient } from 'aws-amplify/data';
import type { Schema } from '../amplify/data/resource'; // Path to your backend resource definition

const client = generateClient<Schema>();

// As a signed-in user that belongs to the 'Admin' User Pool Group
const { errors, data: newSalary } = await client.models.Salary.create(
  {
    wage: 50.25,
    currency: 'USD'
  },
  // highlight-start
  {
    authMode: 'userPool',
  }
  // highlight-end
);
```

</InlineFilter>

<InlineFilter filters={["flutter"]}>
In your application, you can perform CRUD operations against the model with the `userPools` auth mode.
  
```dart
try {
  final todo = Todo(content: 'My new todo');
  final request = ModelMutations.create(
    todo,  
    authorizationMode: APIAuthorizationType.userPools,
  );
  final createdTodo = await Amplify.API.mutations(request: request).response;

  if (createdTodo == null) {
    safePrint('errors: ${response.errors}');
    return;
  }
  safePrint('Mutation result: ${createdTodo.name}');

} on APIException catch (e) {
  safePrint('Failed to create todo', e);
}
```
</InlineFilter>

<InlineFilter filters={["swift"]}>

In your application, you can perform CRUD operations against the model with the `amazonCognitoUserPools` auth mode.

```swift
do {
    let salary = Salary(
        wage: 50.25,
        currency: "USD")
    let createdSalary = try await Amplify.API.mutate(request: .create(
        salary,
        authMode: .amazonCognitoUserPools)).get()
} catch {
    print("Failed to create salary", error)
}
```

</InlineFilter>

This can then be updated to allow access to multiple defined groups; in this example below we added access for "Leadership".

```ts
// allow multiple specific groups
const schema = a.schema({
  Salary: a
    .model({
      wage: a.float(),
      currency: a.string(),
    })
    .authorization(allow => [allow.groups(['Admin', 'Leadership'])]),
});
```

## Add authorization rules for dynamically set user groups

With dynamic group authorization, each record contains an attribute specifying what Cognito groups should be able to access it. Use the first argument to specify which attribute in the underlying data store holds this group information. To specify that a single group should have access, use a field of type `a.string()`. To specify that multiple groups should have access, use a field of type `a.string().array()`.

```ts
// Dynamic group authorization with multiple groups
const schema = a.schema({
  Post: a
    .model({
      title: a.string(),
      groups: a.string().array(),
    })
    .authorization(allow => [allow.groupsDefinedIn('groups')]),
});
```

```ts
// Dynamic group authorization with a single group
const schema = a.schema({
  Post: a
    .model({
      title: a.string(),
      group: a.string(),
    })
    .authorization(allow => [allow.groupDefinedIn('group')]),
});
```

By default, `group` authorization leverages Amazon Cognito user pool groups but you can also use OpenID Connect with `group` authorization. See [OpenID Connect as an authorization provider](/[platform]/build-a-backend/data/customize-authz/using-oidc-authorization-provider).

<Callout>
**Known limitations for real-time subscriptions when using dynamic group authorization:**

1. If you authorize based on a single group per record, then subscriptions are only supported if the user is part of 5 or fewer user groups
2. If you authorize via an array of groups (`groups: a.string().array()` used in the example above),
   - subscriptions are only supported if the user is part of 20 or fewer groups
   - you can only authorize 20 or fewer user groups per record
</Callout>

## Access user groups from the session

<InlineFilter filters={["javascript", "angular", "react-native", "react", "nextjs", "vue"]}>

You can access a user's groups from their session using the Auth category:

```ts
import { fetchAuthSession } from 'aws-amplify/auth';

const session = await fetchAuthSession();
const groups = session.tokens.accessToken.payload['cognito:groups'] || [];

console.log('User groups:', groups);
```
</InlineFilter>


Contents of build-a-backend_data_customize-authz_using-oidc-authorization-provider_index.txt:
import { getCustomStaticPath } from '@/utils/getCustomStaticPath';

export const meta = {
  title: 'Use OpenID Connect as an authorization provider',
  description: "Use OpenID Connect with `private`, `owner`, and `group` authorization strategies.",
  platforms: [
    'android',
    'angular',
    'flutter',
    'javascript',
    'nextjs',
    'react',
    'react-native',
    'swift',
    'vue'
  ]
};

export const getStaticPaths = async () => {
  return getCustomStaticPath(meta.platforms);
};

export function getStaticProps(context) {
  return {
    props: {
      platform: context.params.platform,
      meta
    }
  };
}

Private, owner, and group authorization can be configured with an OpenID Connect (OIDC) authorization mode. Add `"oidc"` to the authorization rule as the provider. Use the `oidcAuthorizationMode` property to configure the *OpenID Connect provider name*, *OpenID Connect provider domain*, *Client ID*, *Issued at TTL*, and *Auth Time TTL*.

The example below highlights the supported authorization strategies with a `oidc` authorization provider. For owner and group-based authorization, you also will need to [specify a custom identity and group claim](/[platform]/build-a-backend/data/customize-authz/configure-custom-identity-and-group-claim).

```ts title="amplify/data/resource.ts"
// amplify/data/resource.ts
import { a, defineData, type ClientSchema } from '@aws-amplify/backend';

const schema = a.schema({
  Todo: a
    .model({
      content: a.string(),
    })
    .authorization(allow => [
      allow.owner('oidc').identityClaim('user_id'),
      allow.authenticated('oidc'),
      allow
        .groups(['testGroupName'], 'oidc')
        .withClaimIn('user_groups'),
    ]),
});

export type Schema = ClientSchema<typeof schema>;

export const data = defineData({
  schema,
  authorizationModes: {
    defaultAuthorizationMode: 'oidc',
    oidcAuthorizationMode: {
      oidcProviderName: 'oidc-provider-name',
      oidcIssuerUrl: 'https://example.com',
      clientId: 'client-id',
      tokenExpiryFromAuthInSeconds: 300,
      tokenExpireFromIssueInSeconds: 600,
    },
  },
});
```

<InlineFilter filters={["javascript", "angular", "react-native", "react", "nextjs", "vue", "android", "swift"]}>

In your application, you can perform CRUD operations against the model using `client.models.<model-name>` by specifying the `oidc` auth mode.

```ts
import { generateClient } from 'aws-amplify/data';
import type { Schema } from '../amplify/data/resource'; // Path to your backend resource definition

const client = generateClient<Schema>();

const { errors, data: todos } = await client.models.Todo.list({
  // highlight-start
  authMode: "oidc",
  // highlight-end
});
```

</InlineFilter>

<InlineFilter filters={["flutter"]}>
In your application, you can perform CRUD operations against the model with the `oidc` auth mode.

```dart
try {
  final todo = Todo(content: 'My new todo');
  final request = ModelMutations.create(
    todo,  
    authorizationMode: APIAuthorizationType.oidc,
  );
  final createdTodo = await Amplify.API.mutations(request: request).response;

  if (createdTodo == null) {
    safePrint('errors: ${response.errors}');
    return;
  }
  safePrint('Mutation result: ${createdTodo.name}');

} on APIException catch (e) {
  safePrint('Failed to create todo', e);
}
```

</InlineFilter>


Contents of build-a-backend_data_data-modeling_add-fields_index.txt:
import { getCustomStaticPath } from '@/utils/getCustomStaticPath';

export const meta = {
  title: 'Add fields to data model',
  description:
    'Configure built-in and custom field types.',
  platforms: [
    'android',
    'angular',
    'flutter',
    'javascript',
    'nextjs',
    'react',
    'react-native',
    'swift',
    'vue'
  ]
};

export const getStaticPaths = async () => {
  return getCustomStaticPath(meta.platforms);
};

export function getStaticProps(context) {
  return {
    props: {
      meta
    }
  };

}

Amplify Data supports all AWS AppSync scalar types as field types. The following scalar types are available:

|Field type|Description|TypeScript validation|GraphQL Scalar Type|
|-|-|-|-|
|`a.id()`|A unique identifier for an object. This scalar is serialized like a String but isn't meant to be human-readable. If not specified on create operations, a UUID will be generated.|`string`|ID|
|`a.string()`|A UTF-8 character sequence.|`string`|String|
|`a.integer()`|An integer value between -(2^31) and 2^31-1.|`number` but rounded to closest integer value upon query/mutation|Int|
|`a.float()`|An IEEE 754 floating point value.|`number`|Float|
|`a.boolean()`|A Boolean value, either true or false.|`boolean`|Boolean|
|`a.date()`|An extended ISO 8601 date string in the format `YYYY-MM-DD`.|`string`|AWSDate|
|`a.time()`|An extended ISO 8601 time string in the format `hh:mm:ss.sss`.|`string`|AWSTime|
|`a.datetime()`|An extended ISO 8601 date and time string in the format `YYYY-MM-DDThh:mm:ss.sssZ`.|`string`|AWSDateTime|
|`a.timestamp()`|An integer value representing the number of seconds before or after 1970-01-01-T00:00Z.|`number`|AWSTimestamp|
|`a.email()`|An email address in the format local-part@domain-part as defined by RFC 822.|`string` with local-part and domain-part type enforcement|AWSEmail|
|`a.json()`|A JSON string. Any valid JSON construct is automatically parsed and loaded in the resolver code as maps, lists, or scalar values, rather than as the literal input strings. Unquoted strings or otherwise invalid JSON result in a validation error.|`any`|AWSJSON|
|`a.phone()`|A phone number. This value is stored as a string. Phone numbers can contain either spaces or hyphens to separate digit groups. Phone numbers without a country code are assumed to be US/North American numbers adhering to the North American Numbering Plan.|`string` validation only happening service-side|AWSPhone|
|`a.url()`|A URL as defined by RFC 1738. For example, https://www.amazon.com/dp/B000NZW3KC/ or mailto:example@example.com. URLs must contain a schema (http, mailto) and can't contain two forward slashes (//) in the path part.|`string` but with type enforcement on the schema part|AWSURL|
|`a.ipAddress()`|A valid IPv4 or IPv6 address. IPv4 addresses are expected in quad-dotted notation (123.12.34.56). IPv6 addresses are expected in non-bracketed, colon-separated format (1a2b:3c4b:1234:4567). You can include an optional CIDR suffix (123.45.67.89/16) to indicate subnet mask.|`string` with type enforcement for IPv4 and IPv6 pattern|AWSIPAddress|

## Specify a custom field type

Sometimes, the built-in types do not meet the needs of your application. In those cases, you can specify custom types. You can either define the custom types inline or explicitly define the custom type in the schema.

**Inline definition:** The "location" field will become a new non-model type that uses PascalCase, a naming convention in which the first letter of each word in a compound word is capitalized. If there are conflicts with another schema-level definition (model, custom type, enum), you will receive a Type error with a warning that you need to sift the value out as a separate item and use a "ref".

```ts
a.schema({
  Post: a.model({
    location: a.customType({
      lat: a.float(),
      long: a.float(),
    }),
    content: a.string(),
  }),
}).authorization((allow) => allow.publicApiKey());
```

**Explicit definition:** Specify the "Location" as `a.customType()` in your schema. To use the custom type, reference it through `a.ref()` in the respective field definitions.

```ts
a.schema({
  Location: a.customType({
      lat: a.float(),
      long: a.float(),
  }),

  Post: a.model({
    location: a.ref('Location'),
    content: a.string(),
  }),

  User: a.model({
    lastKnownLocation: a.ref('Location'),
  }),
}).authorization((allow) => allow.publicApiKey());
```

<InlineFilter filters={["javascript", "angular", "react-native", "react", "nextjs", "vue", "android", "flutter"]}>

To set or read the location field on the client side, you can expand a nested object and the type system will auto-infer the allowed values.

```ts
const { data: newPost, errors } = await client.models.Post.create({
  location: {
    lat: 48.837006,
    long: 8.28245,
  },
});

console.log(newPost?.location?.lat, newPost?.location?.long);
```

</InlineFilter>

<InlineFilter filters={["swift"]}>

To set or read the location field on the client side, you can create a Post object with the location values.

```swift
let post = Post(
    location: .init(
        lat: 48.837006,
        long: 8.28245))
let createdPost = try await Amplify.API.mutate(request: .create(post)).get()
print("\(createdPost)")
```

</InlineFilter>

## Specify an enum field type

Enum has a similar developer experience as custom types: short-hand and long-form approaches. 

Short-hand approach

```ts
a.schema({
  Post: a.model({
    privacySetting: a.enum(['PRIVATE', 'FRIENDS_ONLY', 'PUBLIC']),
    content: a.string(),
  }),
}).authorization((allow) => allow.publicApiKey());
```

Long-form approach

```ts
a.schema({
  PrivacySetting: a.enum([
    'PRIVATE',
    'FRIENDS_ONLY',
    'PUBLIC'
  ]),

  Post: a.model({
    content: a.string(),
    privacySetting: a.ref('PrivacySetting'),
  }),

  Video: a.model({
    privacySetting: a.ref('PrivacySetting'),
  }),
}).authorization((allow) => allow.publicApiKey());
```

<InlineFilter filters={["javascript", "angular", "react-native", "react", "nextjs", "vue", "android", "flutter"]}>

When creating a new item client-side, the enums are also type-enforced:
```ts
client.models.Post.create({
  content: 'hello',
  // WORKS - value auto-completed
  privacySetting: 'PRIVATE',

  // DOES NOT WORK - TYPE ERROR
  privacySetting: 'NOT_PUBLIC',
});
```

</InlineFilter>

<InlineFilter filters={["swift"]}>

Creating a new item client-side with the enum value:

```swift
let post = Post(
    content: "hello",
    privacySetting: .private)
let createdPost = try await Amplify.API.mutate(request: .create(post)).get()
```

</InlineFilter>

<InlineFilter filters={["javascript", "angular", "react-native", "react", "nextjs", "vue"]}>

### List enum values client-side

You can list available enum values client-side using the `client.enums.<ENUM_NAME>.values()` API. For example, this allows you to display the available enum values within a dropdown UI.

```ts
const availableSettings = client.enums.PrivacySetting.values()
// availableSettings returns ["PRIVATE", "FRIENDS_ONLY", "PUBLIC"]
```

</InlineFilter>

## Mark fields as required

By default, fields are optional. To mark a field as required, use the `.required()` modifier.

```ts
const schema = a.schema({
  Todo: a.model({
    content: a.string().required(),
  }),
}).authorization((allow) => allow.publicApiKey());
```

## Mark fields as arrays

Any field can be modified to be an array using the `.array()` modifier.

```ts
const schema = a.schema({
  Todo: a.model({
    content: a.string().required(),
    notes: a.string().array(),
  }),
}).authorization((allow) => allow.publicApiKey());
```

## Assign default values for fields

You can use the `.default(...)` modifier to specify a default value for optional [scalar type fields and enums](https://docs.aws.amazon.com/appsync/latest/devguide/scalars.html). The `.default(...)` modifier is not available for custom types, arrays, or relationships.

```ts
const schema = a.schema({
  Todo: a.model({
    content: a.string().default('My new Todo'),
  }),
}).authorization((allow) => allow.publicApiKey());
```
<Callout>
**Note:** The `.default(...)` modifier can't be applied to required fields.
</Callout>


Contents of build-a-backend_data_data-modeling_identifiers_index.txt:
import { getCustomStaticPath } from '@/utils/getCustomStaticPath';

export const meta = {
  title: 'Customize data model identifiers',
  description:
    'Define the primary key for a model using single-field or composite identifiers.',
  platforms: [
    'android',
    'angular',
    'flutter',
    'javascript',
    'nextjs',
    'react',
    'react-native',
    'swift',
    'vue'
  ]
};

export const getStaticPaths = async () => {
  return getCustomStaticPath(meta.platforms);
};

export function getStaticProps(context) {
  return {
    props: {
      platform: context.params.platform,
      meta
    }
  };
}

Identifiers are defined using the `.identifier()` method on a model definition. Usage of the `.identifier()` method is optional; when it's not present, the model will automatically have a field called `id` of type `ID` that is automatically generated unless manually specified.

```typescript
const schema = a.schema({
  Todo: a.model({
    content: a.string(),
    completed: a.boolean(),
  })
  .authorization(allow => [allow.publicApiKey()]),
});
```

<InlineFilter filters={["javascript", "angular", "react-native", "react", "nextjs", "vue", "android", "flutter"]}>

```ts
const client = generateClient<Schema>();

const todo = await client.models.Todo.create({ content: 'Buy Milk', completed: false });
console.log(`New Todo created: ${todo.id}`); // New Todo created: 5DB6B4CC-CD41-49F5-9844-57C0AB506B69
```

</InlineFilter>

<InlineFilter filters={["swift"]}>

```swift
let todo = Todo(
    content: "Buy Milk", 
    completed: false)
let createdTodo = try await Amplify.API.mutate(request: .create(todo)).get()
print("New Todo created: \(createdTodo)")
```

</InlineFilter>

If you want, you can use Amplify Data to define single-field and composite identifiers:
- Single-field identifier with a consumer-provided value (type: `id` or `string`, and must be marked `required`)
- Composite identifier with a set of consumer-provided values (type: `id` or `string`, and must be marked `required`)

## Single-field identifier

If the default `id` identifier field needs to be customized, you can do so by passing the name of another field.

```typescript
const schema = a.schema({
  Todo: a.model({
    todoId: a.id().required(),
    content: a.string(),
    completed: a.boolean(),
  })
  .identifier(['todoId'])
  .authorization(allow => [allow.publicApiKey()]),
});
```

<InlineFilter filters={["javascript", "angular", "react-native", "react", "nextjs", "vue", "android", "flutter"]}>
```ts
const client = generateClient<Schema>();

const { data: todo, errors } = await client.models.Todo.create({ todoId: 'MyUniqueTodoId', content: 'Buy Milk', completed: false });
console.log(`New Todo created: ${todo.todoId}`); // New Todo created: MyUniqueTodoId
```
</InlineFilter>

<InlineFilter filters={["swift"]}>

```swift
let todo = Todo(
    todoId: "MyUniqueTodoId",
    content: "Buy Milk",
    completed: false)
let createdTodo = try await Amplify.API.mutate(request: .create(todo)).get()
print("New Todo created: \(createdTodo)")
```

</InlineFilter>

## Composite identifier

For cases where items are uniquely identified by more than a single field, you can pass an array of the field names to the `identifier()` function:

```typescript
const schema = a.schema({
  StoreBranch: a.model({
    geoId: a.id().required(),
    name: a.string().required(),
    country: a.string(),
    state: a.string(),
    city: a.string(),
    zipCode: a.string(),
    streetAddress: a.string(),
  }).identifier(['geoId', 'name'])
  .authorization(allow => [allow.publicApiKey()]),
});
```
<InlineFilter filters={["javascript", "angular", "react-native", "react", "nextjs", "vue", "android", "flutter"]}>

```ts
const client = generateClient<Schema>();

const branch = await client.models.StoreBranch.get({ geoId: '123', name: 'Downtown' }); // All identifier fields are required when retrieving an item
```
</InlineFilter>

<InlineFilter filters={["swift"]}>
```swift
let queriedStoreBranch = try await Amplify.API.query(
  request: .get(
      StoreBranch.self,
      byIdentifier: .identifier(
          geoId: "123",
          name: "Downtown")))
```
</InlineFilter>


Contents of build-a-backend_data_data-modeling_index.txt:
import { getCustomStaticPath } from '@/utils/getCustomStaticPath';
import { getChildPageNodes } from '@/utils/getChildPageNodes';

export const meta = {
  title: 'Customize your data model',
  description: 'Learn how to customize your data model.',
  route: "/[platform]/build-a-backend/data/data-modeling",
  platforms: [
    'android',
    'angular',
    'flutter',
    'javascript',
    'nextjs',
    'react',
    'react-native',
    'swift',
    'vue'
  ]
};

export const getStaticPaths = async () => {
  return getCustomStaticPath(meta.platforms);
};

export function getStaticProps(context) {
  const childPageNodes = getChildPageNodes(meta.route);
  return {
    props: {
      meta,
      childPageNodes
    }
  };
}

## Data modeling capabilities

Every data model is defined as part of a data schema (`a.schema()`). You can enhance your data model with various fields, customize their identifiers, apply authorization rules, or model relationships. Every data model (`a.model()`) automatically provides create, read, update, and delete API operations as well as real-time subscription events. Below is a quick tour of the many functionalities you can add to your data model:

```ts
import { type ClientSchema, a, defineData } from '@aws-amplify/backend';

const schema = a
  .schema({
    Customer: a
      .model({
        customerId: a.id().required(),
        // fields can be of various scalar types,
        // such as string, boolean, float, integers etc.
        name: a.string(),
        // fields can be of custom types
        location: a.customType({
          // fields can be required or optional
          lat: a.float().required(),
          long: a.float().required(),
        }),
        // fields can be enums
        engagementStage: a.enum(["PROSPECT", "INTERESTED", "PURCHASED"]),
        collectionId: a.id(),
        collection: a.belongsTo("Collection", "collectionId")
        // Use custom identifiers. By default, it uses an `id: a.id()` field
      })
      .identifier(["customerId"]),
    Collection: a
      .model({
        customers: a.hasMany("Customer", "collectionId"), // setup relationships between types
        tags: a.string().array(), // fields can be arrays
        representativeId: a.id().required(),
        // customize secondary indexes to optimize your query performance
      })
      .secondaryIndexes((index) => [index("representativeId")]),
  })
  .authorization((allow) => [allow.publicApiKey()]);

export type Schema = ClientSchema<typeof schema>;

export const data = defineData({
  schema,
  authorizationModes: {
    defaultAuthorizationMode: "apiKey",
    apiKeyAuthorizationMode: {
      expiresInDays: 30,
    },
  },
});
```

<Overview childPageNodes={props.childPageNodes} />

## Gen 1 schema support 

If you are coming from Gen 1, you can continue to use the GraphQL Schema Definition Language (SDL) for defining your schema. However, we strongly recommend you use the TypeScript-first schema builder experience in your project as it provides type safety and is the recommended way of working with Amplify going forward.

<Callout>

**Note:** Some features available in Gen 1 GraphQL SDL are not available in Gen 2. See the [feature matrix](/[platform]/start/migrate-to-gen2/#gen-1-vs-gen-2-feature-matrix) for features supported in Gen 2.

</Callout>

```ts title="amplify/data/resource.ts"
import { defineData } from '@aws-amplify/backend';

const schema = /* GraphQL */`
  type Todo @model @auth(rules: [{ allow: owner }]) {
    content: String
    isDone: Boolean
  }
`;

export const data = defineData({
  schema,
  authorizationModes: {
    defaultAuthorizationMode: "apiKey",
    apiKeyAuthorizationMode: {
      expiresInDays: 30,
    },
  },
});
```


Contents of build-a-backend_data_data-modeling_relationships_index.txt:
import { getCustomStaticPath } from '@/utils/getCustomStaticPath';

export const meta = {
  title: 'Modeling relationships',
  description:
    'Learn about the types of model relationships and modeling relationships.',
  platforms: [
    'android',
    'angular',
    'flutter',
    'javascript',
    'nextjs',
    'react',
    'react-native',
    'swift',
    'vue'
  ]
};

export const getStaticPaths = async () => {
  return getCustomStaticPath(meta.platforms);
};

export function getStaticProps(context) {
  return {
    props: {

      meta
    }
  };
}

When modeling application data, you often need to establish relationships between different data models. In Amplify Data, you can create one-to-many, one-to-one, and many-to-many relationships in your Data schema. On the client-side, Amplify Data allows you to lazy or eager load of related data.

{/* This component contains approved messaging and cannot be removed or modified without prior approval */}

import { ProtectedRedactionGen2Message } from "@/protected/ProtectedRedactionMessage"

<ProtectedRedactionGen2Message />

 ## Types of relationships

|Relationship|Code|Description|Example|
|-|-|-|-|
|one to many|`a.hasMany(...)` & `a.belongsTo(...)`|Creates a one-to-many relationship between two models.|A **Team** has many **Members**. A **Member** belongs to a **Team**.|
|one to one|`a.hasOne(...)` & `a.belongsTo(...)`|Creates a one-to-one relationship between two models.|A **Customer** has one **Cart**. A **Cart** belongs to one **Customer**.|
|many to many| Two `a.hasMany(...)` & `a.belongsTo(...)` on join tables|Create two one-to-many relationships between the related models in a join table.|A **Post** has many **Tags**. A **Tag** has many **Posts**.|

## Model one-to-many relationships

Create a one-to-many relationship between two models using the `hasMany()` and `belongsTo()` method. In the example below, a Team has many Members and a Member belongs to exactly one Team.

1. Create a **reference field** called `teamId` on the **Member** model. This reference field's type **MUST** match the type of **Team**'s identifier. In this case, it's an auto-generated `id: a.id().required()` field.
2. Add a **relationship field** called `team` that references the `teamId` field. This allows you to query for the team information from the **Member** model.
3. Add a **relationship field** called `members` that references the `teamId` field on the **Member** model.

```typescript
const schema = a.schema({
  Member: a.model({
    name: a.string().required(),
    // 1. Create a reference field
    teamId: a.id(),
    // 2. Create a belongsTo relationship with the reference field
    team: a.belongsTo('Team', 'teamId'),
  }),

  Team: a.model({
    mantra: a.string().required(),
    // 3. Create a hasMany relationship with the reference field
    //    from the `Member`s model.
    members: a.hasMany('Member', 'teamId'),
  }),
}).authorization((allow) => allow.publicApiKey());
```

### Create a "Has Many" relationship between records

<InlineFilter filters={["javascript", "angular", "react-native", "react", "nextjs", "vue"]}>

```ts
const { data: team } = await client.models.Team.create({
  mantra: 'Go Frontend!',
});

const { data: member } = await client.models.Member.create({
  name: "Tim",
  teamId: team.id,
});
```

</InlineFilter>

<InlineFilter filters={["android"]}>

```kt
val team = Team.builder()
    .mantra("Go Frontend!")
    .build()

Amplify.API.mutate(ModelMutation.create(team),
    {
        Log.i("MyAmplifyApp", "Added team with id: ${it.data.id}")
        val member = Member.builder()
            .name("Tim")
            .team(it.data)
            .build()

        Amplify.API.mutate(ModelMutation.create(member),
            { Log.i("MyAmplifyApp", "Added Member with id: ${it.data.id}")},
            { Log.e("MyAmplifyApp", "Create failed", it)},
        )
    }, {
        Log.e("MyAmplifyApp", "Create failed", it)
    })
```

</InlineFilter>

<InlineFilter filters={["swift"]}>

```swift
do {
    let team = Team(mantra: "Go Frontend!")
    let createdTeam = try await Amplify.API.mutate(request: .create(team)).get()

    let member = Member(
        name: "Tim",
        team: createdTeam) // Directly pass in the team instance
    let createdMember = try await Amplify.API.mutate(request: .create(member))
} catch {
    print("Create team or member failed", error)
}
```

</InlineFilter>

<InlineFilter filters={["flutter"]}>

```dart
final team = Team(mantra: "Go Frontend!");
final teamRequest = ModelMutations.create(team);
final teamResponse = await Amplify.API.mutate(request: teamRequest).response;

final member = Member(name: "Tim", team: teamResponse.data);
final memberRequest = ModelMutations.create(member);
final memberResponse = await Amplify.API.mutate(request: memberRequest).response;
```

</InlineFilter>

### Update a "Has Many" relationship between records

<InlineFilter filters={["javascript", "angular", "react-native", "react", "nextjs", "vue"]}>

```ts
const { data: newTeam } = await client.models.Team.create({
  mantra: 'Go Fullstack',
});

await client.models.Member.update({
  id: "MY_MEMBER_ID",
  teamId: newTeam.id,
});
```

</InlineFilter>

<InlineFilter filters={["android"]}>

```kt
val newTeam = Team.builder()
    .mantra("Go Fullstack!")
    .build()

Amplify.API.mutate(ModelMutation.create(newTeam),
    {
        Log.i("MyAmplifyApp", "Added team with id: ${it.data.id}")

        val updatingMember = existingMember.copyOfBuilder().team(it.data).build()

        Amplify.API.mutate(ModelMutation.update(updatingMember),
            { Log.i("MyAmplifyApp", "Updated Member with id: ${it.data.id}")},
            { Log.e("MyAmplifyApp", "Create failed", it)},
        )
    }, {
        Log.e("MyAmplifyApp", "Create failed", it)
    })
```

</InlineFilter>

<InlineFilter filters={["swift"]}>

```swift
do {
    let newTeam = Team(mantra: "Go Fullstack!")
    let createdNewTeam = try await Amplify.API.mutate(request: .create(newTeam)).get()

    existingMember.setTeam(createdNewTeam)
    let updatedMember = try await Amplify.API.mutate(request: .update(existingMember)).get()
} catch {
    print("Create team or update member failed", error)
}
```

</InlineFilter>

<InlineFilter filters={["flutter"]}>

```dart
final newTeam = Team(mantra: "Go Fullstack!");
final newTeamRequest = ModelMutations.create(team);
final newTeamResponse = await Amplify.API.mutate(request: teamRequest).response;

final memberWithUpdatedTeam = existingMember.copyWith(team: newTeamResponse.data);
final memberUpdateRequest = ModelMutations.update(memberWithUpdatedTeam);
final memberUpdateResponse = await Amplify.API.mutate(request: memberUpdateRequest).response;
```

</InlineFilter>

### Delete a "Has Many" relationship between records

If your reference field is not required, then you can "delete" a one-to-many relationship by setting the relationship value to `null`.

<InlineFilter filters={["javascript", "angular", "react-native", "react", "nextjs", "vue"]}>

```ts
await client.models.Member.update({
  id: "MY_MEMBER_ID",
  teamId: null,
});
```

</InlineFilter>

<InlineFilter filters={["android"]}>

```kt
val memberWithRemovedTeam = existingMember.copyOfBuilder().team(null).build()

Amplify.API.mutate(ModelMutation.update(memberWithRemovedTeam),
    { Log.i("MyAmplifyApp", "Updated Member with id: ${it.data.id}")},
    { Log.e("MyAmplifyApp", "Create failed", it)},
)
```

</InlineFilter>

<InlineFilter filters={["swift"]}>

```swift
do {
    existingMember.setTeam(nil)
    let memberRemovedTeam = try await Amplify.API.mutate(request: .update(existingMember)).get()
} catch {
    print("Failed to remove team from member", error)
}
```

</InlineFilter>

<InlineFilter filters={["flutter"]}>

```dart
final memberWithRemovedTeam = existingMember.copyWith(team: null);
final memberRemoveRequest = ModelMutations.update(memberWithRemovedTeam);
final memberRemoveResponse = await Amplify.API.mutate(request: memberRemoveRequest).response;
```

</InlineFilter>

<InlineFilter filters={["flutter"]}>

### Load related data in a "Has Many" relationship

```dart
// Fetch the team with the team id.
final teamRequest = ModelQueries.get<Team>(
    Team.classType, TeamModelIdentifier(id: "YOUR_TEAM_ID"));
final teamResult = await Amplify.API.query(request: teamRequest).response;
final team = teamResult.data!;

// Define a limit for your pagination
const limit = 100;

// Do the initial call to get the initial items
final firstRequest = ModelQueries.list<Member>(Member.classType,
    limit: limit, where: Member.TEAMID.eq(team.id));
final firstResult = await Amplify.API.query(request: firstRequest).response;
final firstPageData = firstResult.data;

// If there are more than 100 items you can reiterate the following code to get next pages.
if (firstPageData?.hasNextResult ?? false) {
  final secondRequest = firstPageData!.requestForNextResult;
  final secondResult =
      await Amplify.API.query(request: secondRequest!).response;
  return secondResult.data?.items ?? <Member?>[];
} else {
  // You can return the page data by calling items property.
  return firstPageData?.items ?? <Member?>[];
}
```

</InlineFilter>

<InlineFilter filters={["javascript", "angular", "react-native", "react", "nextjs", "vue", "swift", "android"]}>

### Lazy load a "Has Many" relationship

<InlineFilter filters={["javascript", "angular", "react-native", "react", "nextjs", "vue"]}>

```ts
const { data: team } = await client.models.Team.get({ id: "MY_TEAM_ID"});

const { data: members } = await team.members();

members.forEach(member => console.log(member.id));
```

</InlineFilter>

<InlineFilter filters={["android"]}>

```kt
Amplify.API.query(
    ModelQuery.get(Team::class.java, Team.TeamIdentifier("YOUR_TEAM_ID")),
    {
        suspend {
            try {
                val members =
                    when (val membersModelList = it.data.members) {
                        is LoadedModelList -> {
                            // Eager loading loads the 1st page only.
                            membersModelList.items
                        }

                        is LazyModelList -> {
                            var page = membersModelList.fetchPage()
                            var loadedMembers =
                                mutableListOf(page.items) // initial page of members
                            // loop through all pages to fetch the full list of members
                            while (page.hasNextPage) {
                                val nextToken = page.nextToken
                                page =
                                    membersModelList.fetchPage(nextToken)
                                // add the page of members to the members variable
                                loadedMembers += page.items
                            }
                            loadedMembers
                        }
                    }
                Log.i("MyAmplifyApp", "members: $members")
            } catch (error: ApiException) {
                Log.e("MyAmplifyApp", "Failed to fetch members", error)
            }
        }
    },
    { Log.e("MyAmplifyApp", "Failed to fetch team")})
```

</InlineFilter>

<InlineFilter filters={["swift"]}>

```swift
do {
    let queriedTeam = try await Amplify.API.query(
        request: .get(
            Team.self,
            byIdentifier: team.identifier)).get()

    guard let queriedTeam, let members = queriedTeam.members else {
        print("Missing team or members")
        return
    }
    try await members.fetch()
    print("Number of members: \(members.count)")
} catch {
    print("Failed to fetch team or members", error)
}
```

</InlineFilter>

### Eagerly load a "Has Many" relationship

<InlineFilter filters={["javascript", "angular", "react-native", "react", "nextjs", "vue"]}>

```ts
const { data: teamWithMembers } = await client.models.Team.get(
  { id: "MY_TEAM_ID" },
  { selectionSet: ["id", "members.*"] },
);

teamWithMembers.members.forEach(member => console.log(member.id));
```

</InlineFilter>

<InlineFilter filters={["android"]}>

```kt
Amplify.API.query(
    ModelQuery.get<Team, TeamPath>(
        Team::class.java,
        Team.TeamIdentifier("YOUR_TEAM_ID")
    ) { teamPath -> includes(teamPath.members) },
    {
        val members = (it.data.members as? LoadedModelList<Member>)?.items
    },
    { Log.e("MyAmplifyApp", "Failed to fetch team")}
)
```

</InlineFilter>

<InlineFilter filters={["swift"]}>

```swift
do {
    let queriedTeamWithMembers = try await Amplify.API.query(
        request: .get(
            Team.self,
            byIdentifier: team.identifier,
            includes: { team in [team.members]}))
        .get()
    guard let queriedTeamWithMembers, let members = queriedTeamWithMembers.members else {
        print("Missing team or members")
        return
    }
    print("Number of members: \(members.count)")
} catch {
    print("Failed to fetch team with members", error)
}
```

</InlineFilter>

</InlineFilter>

<InlineFilter filters={["javascript", "angular", "react-native", "react", "nextjs", "vue"]}>

### Handling orphaned foreign keys on parent record deletion in "Has Many" relationship

```ts
// Get the IDs of the related members.
const { data: teamWithMembers } = await client.models.Team.get(
  { id: teamId },
  { selectionSet: ["id", "members.*"] },
);

// Delete Team
await client.models.Team.delete({ id: teamWithMembers.id });

// Delete all members in parallel
await Promise.all(
  teamWithMembers.members.map(member => 
  client.models.Member.delete({ id: member.id }) 
));
```

</InlineFilter>

## Model a "one-to-one" relationship

Create a one-to-one relationship between two models using the `hasOne()` and `belongsTo()` methods. In the example below, a **Customer** has a **Cart** and a *Cart* belongs to a **Customer**.

1. Create a **reference field** called `customerId` on the **Cart** model. This reference field's type **MUST** match the type of **Customer**'s identifier. In this case, it's an auto-generated `id: a.id().required()` field.
2. Add a **relationship field** called `customer` that references the `customerId` field. This allows you to query for the customer information from the **Cart** model.
3. Add a **relationship field** called `activeCart` that references the `customerId` field on the **Cart** model.

```typescript
const schema = a.schema({
  Cart: a.model({
    items: a.string().required().array(),
    // 1. Create reference field
    customerId: a.id(),
    // 2. Create relationship field with the reference field
    customer: a.belongsTo('Customer', 'customerId'),
  }),
  Customer: a.model({
    name: a.string(),
    // 3. Create relationship field with the reference field
    //    from the Cart model
    activeCart: a.hasOne('Cart', 'customerId')
  }),
}).authorization((allow) => allow.publicApiKey());
```

### Create a "Has One" relationship between records

To create a "has one" relationship between records, first create the parent item and then create the child item and assign the parent.

<InlineFilter filters={["javascript", "angular", "react-native", "react", "nextjs", "vue"]}>

```ts
const { data: customer, errors } = await client.models.Customer.create({
  name: "Rene",
});


const { data: cart } = await client.models.Cart.create({
  items: ["Tomato", "Ice", "Mint"],
  customerId: customer?.id,
});
```

</InlineFilter>

<InlineFilter filters={["android"]}>

```kt
val customer = Customer.builder()
    .name("Rene")
    .build()

Amplify.API.mutate(ModelMutation.create(customer),
    {
        Log.i("MyAmplifyApp", "Added customer with id: ${it.data.id}")
        val cart = Cart.builder()
            .items(listOf("Tomato", "Ice", "Mint"))
            .customer(customer)
            .build()

        Amplify.API.mutate(ModelMutation.create(cart),
            { Log.i("MyAmplifyApp", "Added Cart with id: ${it.data.id}")},
            { Log.e("MyAmplifyApp", "Create failed", it)},
        )
    }, {
        Log.e("MyAmplifyApp", "Create failed", it)
    })
```

</InlineFilter>

<InlineFilter filters={["swift"]}>

```swift
do {
    let customer = Customer(name: "Rene")
    let createdCustomer = try await Amplify.API.mutate(request: .create(customer)).get()

    let cart = Cart(
        items: ["Tomato", "Ice", "Mint"],
        customer: createdCustomer)
    let createdCart = try await Amplify.API.mutate(request: .create(cart)).get()
} catch {
    print("Create customer or cart failed", error)
}
```

</InlineFilter>

<InlineFilter filters={["flutter"]}>

```dart
final customer = Customer(name: "Rene");
final customerRequest = ModelMutations.create(customer);
final customerResponse = await Amplify.API.mutate(request: customerRequest).response;

final cart = Cart(items: ["Tomato", "Ice", "Mint"], customer: teamResponse.customer);
final cartRequest = ModelMutations.create(cart);
final cartResponse = await Amplify.API.mutate(request: cartRequest).response;
```

</InlineFilter>

### Update a "Has One" relationship between records

To update a "Has One" relationship between records, you first retrieve the child item and then update the reference to the parent to another parent. For example, to reassign a Cart to another Customer:

<InlineFilter filters={["javascript", "angular", "react-native", "react", "nextjs", "vue"]}>

```ts
const { data: newCustomer } = await client.models.Customer.create({
  name: 'Ian',
});

await client.models.Cart.update({
  id: cart.id,
  customerId: newCustomer?.id,
});
```

</InlineFilter>

<InlineFilter filters={["android"]}>

```kt
val newCustomer = Customer.builder()
    .mantra("Ian")
    .build()

Amplify.API.mutate(ModelMutation.create(newCustomer),
    {
        Log.i("MyAmplifyApp", "Added customer with id: ${it.data.id}")

        val updatingCart = existingCart.copyOfBuilder().customer(it.data).build()

        Amplify.API.mutate(ModelMutation.update(updatingCart),
            { Log.i("MyAmplifyApp", "Updated cart with id: ${it.data.id}")},
            { Log.e("MyAmplifyApp", "Create failed", it)},
        )
    }, {
        Log.e("MyAmplifyApp", "Create failed", it)
    })
```

</InlineFilter>

<InlineFilter filters={["swift"]}>

```swift
do {
    let newCustomer = Customer(name: "Rene")
    let newCustomerCreated = try await Amplify.API.mutate(request: .create(newCustomer)).get()
    existingCart.setCustomer(newCustomerCreated)
    let updatedCart = try await Amplify.API.mutate(request: .update(existingCart)).get()
} catch {
    print("Create customer or cart failed", error)
}
```

</InlineFilter>

<InlineFilter filters={["flutter"]}>

```dart
final newCustomer = Customer(name: "Ian");
final newCustomerRequest = ModelMutations.create(newCustomer);
final newCustomerResponse = await Amplify.API.mutate(request: newCustomerRequest).response;

final cartWithUpdatedCustomer = existingCart.copyWith(customer: newCustomerResponse.data);
final cartUpdateRequest = ModelMutations.update(cartWithUpdatedCustomer);
final cartUpdateResponse = await Amplify.API.mutate(request: cartUpdateRequest).response;
```

</InlineFilter>


### Delete a "Has One" relationship between records

<InlineFilter filters={["javascript", "angular", "react-native", "react", "nextjs", "vue"]}>

You can set the relationship field to `null` to delete a "Has One" relationship between records.

```ts
await client.models.Cart.update({
  id: project.id,
  customerId: null,
});
```

</InlineFilter>

<InlineFilter filters={["android"]}>

You can set the relationship field to `null` to delete a "Has One" relationship between records.

```kt
val cartWithRemovedCustomer = existingCart.copyOfBuilder().customer(null).build()

Amplify.API.mutate(ModelMutation.update(cartWithRemovedCustomer),
    { Log.i("MyAmplifyApp", "Updated cart with id: ${it.data.id}")},
    { Log.e("MyAmplifyApp", "Create failed", it)},
)
```

</InlineFilter>

<InlineFilter filters={["swift"]}>

You can set the relationship field to `nil` to delete a "Has One" relationship between records.

```swift
do {
    existingCart.setCustomer(nil)
    let cartWithCustomerRemoved = try await Amplify.API.mutate(request: .update(existingCart)).get()
} catch {
    print("Failed to remove customer from cart", error)
}
```

</InlineFilter>

<InlineFilter filters={["flutter"]}>

```dart
final cartWithRemovedCustomer = existingCart.copyWith(customer: null);
final cartRemoveRequest = ModelMutations.update(cartWithRemovedCustomer);
final cartRemoveResponse = await Amplify.API.mutate(request: cartRemoveRequest).response;
```

</InlineFilter>


<InlineFilter filters={["swift", "flutter"]}>

### Load related data in "Has One" relationships

<InlineFilter filters={["swift"]}>

```swift
do {
    guard let queriedCart = try await Amplify.API.query(
        request: .get(
            Cart.self,
            byIdentifier: existingCart.identifier)).get() else {
        print("Missing cart")
        return
    }

    let customer = try await queriedCart.customer
} catch {
    print("Failed to fetch cart or customer", error)
}
```

</InlineFilter>

<InlineFilter filters={["flutter"]}>

```dart
// Fetch the cart with the cart id.
final cartRequest = ModelQueries.get<Cart>(
    Cart.classType, CartModelIdentifier(id: "MY_CART_ID"));
final cartResult = await Amplify.API.query(request: cartRequest).response;
final cart = cartResult.data!;

// Do the customer call to with the id from cart
if (cart.customerId != null) {
  final customerRequest = ModelQueries.get<Customer>(
      Customer.classType, CustomerModelIdentifier(id: cart.customerId!));
  final customerResult =
      await Amplify.API.query(request: customerRequest).response;
  final customer = customerResult.data!;
}
```

</InlineFilter>

</InlineFilter>

<InlineFilter filters={["javascript", "angular", "react-native", "react", "nextjs", "vue", "android"]}>

### Lazy load a "Has One" relationship

<InlineFilter filters={["javascript", "angular", "react-native", "react", "nextjs", "vue"]}>

```ts
const { data: cart } = await client.models.Cart.get({ id: "MY_CART_ID"});
const { data: customer } = await cart.customer();
```

</InlineFilter>

<InlineFilter filters={["android"]}>

```kt
Amplify.API.query(
  ModelQuery.get(Team::class.java, Team.TeamIdentifier("YOUR_TEAM_ID")),
      {
          suspend {
              try {
                  val customer = when (val customerReference = cart.customer) {
                      is LoadedModelReference -> {
                          customerReference.value
                      }

                      is LazyModelReference -> {
                          customerReference.fetchModel()
                      }
                  }
                  Log.i("MyAmplifyApp", "customer: $customer")
              } catch (error: ApiException) {
                  Log.e("MyAmplifyApp", "Failed to fetch customer", error)
              }
          }
      },
      { Log.e("MyAmplifyApp", "Failed to get team")}
)
```

</InlineFilter>

### Eagerly load a "Has One" relationship

<InlineFilter filters={["javascript", "angular", "react-native", "react", "nextjs", "vue"]}>

```ts
const { data: cart } = await client.models.Cart.get(
  { id: "MY_CART_ID" },
  { selectionSet: ['id', 'customer.*'] },
);

console.log(cart.customer.id)
```

</InlineFilter>

<InlineFilter filters={["android"]}>

```kt
val cart = Amplify.API.query(
    ModelQuery.get<Cart, CartPath>(
        Cart::class.java,
        Cart.CartIdentifier("YOUR_CART_ID")
    ) { cartPath ->
        includes(cartPath.customer)
    },
{ val customer = (cart.customer as? LoadedModelReference)?.value },
{ Log.e("MyAmplifyApp", "Failed to fetch cart", it) })
```

</InlineFilter>

</InlineFilter>

<InlineFilter filters={["javascript", "angular", "react-native", "react", "nextjs", "vue"]}>

### Handling orphaned foreign keys on parent record deletion in "Has One" relationship

```ts
// Get the customer with their associated cart
const { data: customerWithCart } = await client.models.Customer.get(
  { id: customerId },
  { selectionSet: ["id", "activeCart.*"] },
);

// Delete Cart if exists
await client.models.Cart.delete({ id: customerWithCart.activeCart.id });

// Delete the customer
await client.models.Customer.delete({ id: customerWithCart.id });
```

</InlineFilter>


## Model a "many-to-many" relationship
In order to create a many-to-many relationship between two models, you have to create a model that serves as a "join table". This "join table" should contain two one-to-many relationships between the two related entities. For example, to model a **Post** that has many **Tags** and a **Tag** has many **Posts**, you'll need to create a new **PostTag** model that represents the relationship between these two entities.

```typescript
const schema = a.schema({
  PostTag: a.model({
    // 1. Create reference fields to both ends of
    //    the many-to-many relationship
    // highlight-start
    postId: a.id().required(),
    tagId: a.id().required(),
    // highlight-end
    // 2. Create relationship fields to both ends of
    //    the many-to-many relationship using their
    //    respective reference fields
    // highlight-start
    post: a.belongsTo('Post', 'postId'),
    tag: a.belongsTo('Tag', 'tagId'),
    // highlight-end
  }),
  Post: a.model({
    title: a.string(),
    content: a.string(),
    // 3. Add relationship field to the join model
    //    with the reference of `postId`
    // highlight-next-line
    tags: a.hasMany('PostTag', 'postId'),
  }),
  Tag: a.model({
    name: a.string(),
    // 4. Add relationship field to the join model
    //    with the reference of `tagId`
    // highlight-next-line
    posts: a.hasMany('PostTag', 'tagId'),
  }),
}).authorization((allow) => allow.publicApiKey());
```

## Model multiple relationships between two models

Relationships are defined uniquely by their reference fields. For example, a Post can have separate relationships with a Person model for `author` and `editor`.

```typescript
const schema = a.schema({
  Post: a.model({
    title: a.string().required(),
    content: a.string().required(),
    // highlight-start
    authorId: a.id(),
    author: a.belongsTo('Person', 'authorId'),
    editorId: a.id(),
    editor: a.belongsTo('Person', 'editorId'),
    // highlight-end
  }),
  Person: a.model({
    name: a.string(),
    // highlight-start
    editedPosts: a.hasMany('Post', 'editorId'),
    authoredPosts: a.hasMany('Post', 'authorId'),
    // highlight-end
  }),
}).authorization((allow) => allow.publicApiKey());
```

On the client-side, you can fetch the related data with the following code:

<InlineFilter filters={["javascript", "angular", "react-native", "react", "nextjs", "vue", "android", "flutter"]}>

```ts
const client = generateClient<Schema>();

const { data: post } = await client.models.Post.get({ id: "SOME_POST_ID" });

const { data: author } = await post?.author();
const { data: editor } = await post?.editor();
```

</InlineFilter>

<InlineFilter filters={["swift"]}>

```swift
 do {
    guard let queriedPost = try await Amplify.API.query(
        request: .get(
            Post.self,
            byIdentifier: post.identifier)).get() else {
        print("Missing post")
        return
    }

    let loadedAuthor = try await queriedPost.author
    let loadedEditor = try await queriedPost.editor
} catch {
    print("Failed to fetch post, author, or editor", error)
}
```
</InlineFilter>

## Model relationships for models with sort keys in their identifier

In cases where your data model uses sort keys in the identifier, you need to also add reference fields and store the sort key fields in the related data model:

```ts
const schema = a.schema({
  Post: a.model({
    title: a.string().required(),
    content: a.string().required(),
    // Reference fields must correspond to identifier fields.
    // highlight-start
    authorName: a.string(),
    authorDoB: a.date(),
    // Must pass references in the same order as identifiers.
    author: a.belongsTo('Person', ['authorName', 'authorDoB']),
    // highlight-end
  }),
  Person: a.model({
    name: a.string().required(),
    dateOfBirth: a.date().required(),
    // Must reference all reference fields corresponding to the
    // identifier of this model.
    authoredPosts: a.hasMany('Post', ['authorName', 'authorDoB']),
    // highlight-next-line
  }).identifier(['name', 'dateOfBirth']),
}).authorization((allow) => allow.publicApiKey());
```

## Make relationships required or optional

Amplify Data's relationships use reference fields to determine if a relationship is required or not. If you mark a reference field as required, then you can't "delete" a relationship between two models. You'd have to delete the related record as a whole.

```ts
const schema = a.schema({
  Post: a.model({
    title: a.string().required(),
    content: a.string().required(),
    // You must supply an author when creating the post
    // Author can't be set to `null`.
    // highlight-next-line
    authorId: a.id().required(),
    author: a.belongsTo('Person', 'authorId'),
    // You can optionally supply an editor when creating the post.
    // Editor can also be set to `null`.
    // highlight-next-line
    editorId: a.id(),
    editor: a.belongsTo('Person', 'editorId'),
  }),
  Person: a.model({
    name: a.string(),
    // highlight-start
    editedPosts: a.hasMany('Post', 'editorId'),
    authoredPosts: a.hasMany('Post', 'authorId'),
    // highlight-end
  }),
}).authorization((allow) => allow.publicApiKey());
```


Contents of build-a-backend_data_data-modeling_secondary-index_index.txt:
import { getCustomStaticPath } from '@/utils/getCustomStaticPath';

export const meta = {
  title: 'Customize secondary indexes',
  description:
    'Define the secondary indexes for your data model to optimize query performance',
  platforms: [
    'android',
    'angular',
    'flutter',
    'javascript',
    'nextjs',
    'react',
    'react-native',
    'swift',
    'vue'
  ]
};

export const getStaticPaths = async () => {
  return getCustomStaticPath(meta.platforms);
};

export function getStaticProps(context) {
  return {
    props: {
      platform: context.params.platform,
      meta
    }
  };
}

You can optimize your list queries based on "secondary indexes". For example, if you have a **Customer** model, you can query based on the customer's **id** identifier field by default but you can add a secondary index based on the **accountRepresentativeId** to get list customers for a given account representative.

A secondary index consists of a "hash key" and, optionally, a "sort key". Use the "hash key" to perform strict equality and the "sort key" for greater than (gt), greater than or equal to (ge), less than (lt), less than or equal to (le), equals (eq), begins with, and between operations.

```ts title="amplify/data/resource.ts"
export const schema = a.schema({
  Customer: a
    .model({
      name: a.string(),
      phoneNumber: a.phone(),
      accountRepresentativeId: a.id().required(),
    })
      // highlight-next-line
    .secondaryIndexes((index) => [index("accountRepresentativeId")])
    .authorization(allow => [allow.publicApiKey()]),
});
```

<InlineFilter filters={["javascript", "angular", "react-native", "react", "nextjs", "vue", "android", "flutter"]}>

The example client query below allows you to query for "Customer" records based on their `accountRepresentativeId`:

```ts title="src/App.tsx"
import { type Schema } from '../amplify/data/resource';
import { generateClient } from 'aws-amplify/data';

const client = generateClient<Schema>();

const { data, errors } =
  // highlight-start
  await client.models.Customer.listCustomerByAccountRepresentativeId({
    accountRepresentativeId: "YOUR_REP_ID",
  });
  // highlight-end
```

</InlineFilter>

<InlineFilter filters={["swift"]}>

The example client query below creates a custom GraphQL request that allows you to query for "Customer" records based on their `accountRepresentativeId`:

```swift
struct PaginatedList<ModelType: Model>: Decodable {
    let items: [ModelType]
    let nextToken: String?
}
let operationName = "listCustomer8ByAccountRepresentativeId"
let document = """
query ListCustomer8ByAccountRepresentativeId {
  \(operationName)(accountRepresentativeId: "\(accountRepresentativeId)") {
    items {
      createdAt
      accountRepresentativeId
      id
      name
      phoneNumber
      updatedAt
    }
    nextToken
  }
}
"""

let request = GraphQLRequest<PaginatedList<Customer>>(
    document: document,
    responseType: PaginatedList<Customer>.self,
    decodePath: operationName)

let queriedCustomers = try await Amplify.API.query(
    request: request).get()
```

</InlineFilter>
<Accordion title="Review how this works under the hood with Amazon DynamoDB">

Amplify uses Amazon DynamoDB tables as the default data source for `a.model()`. For key-value databases, it is critical to model your access patterns with "secondary indexes". Use the `.secondaryIndexes()` modifier to configure a secondary index.

**Amazon DynamoDB** is a key-value and document database that delivers single-digit millisecond performance at any scale but making it work for your access patterns requires a bit of forethought. DynamoDB query operations may use at most two attributes to efficiently query data. The first query argument passed to a query (the hash key) must use strict equality and the second attribute (the sort key) may use gt, ge, lt, le, eq, beginsWith, and between. DynamoDB can effectively implement a wide variety of access patterns that are powerful enough for the majority of applications.

</Accordion>

## Add sort keys to secondary indexes

You can define "sort keys" to add a set of flexible filters to your query, such as "greater than" (gt), "greater than or equal to" (ge), "less than" (lt), "less than or equal to" (le), "equals" (eq), "begins with" (beginsWith), and "between" operations.

```ts title="amplify/data/resource.ts"
export const schema = a.schema({
  Customer: a
    .model({
      name: a.string(),
      phoneNumber: a.phone(),
      accountRepresentativeId: a.id().required(),
    })
    .secondaryIndexes((index) => [
      index("accountRepresentativeId")
      // highlight-next-line
        .sortKeys(["name"]),
    ])
    .authorization(allow => [allow.owner()]),
});
```

<InlineFilter filters={["javascript", "angular", "react-native", "react", "nextjs", "vue", "android", "flutter"]}>

On the client side, you should find a new `listBy...` query that's named after hash key and sort keys. For example, in this case: `listByAccountRepresentativeIdAndName`. You can supply the filter as part of this new list query:

```ts title="src/App.tsx"
const { data, errors } =
  // highlight-next-line
  await client.models.Customer.listCustomerByAccountRepresentativeIdAndName({
    accountRepresentativeId: "YOUR_REP_ID",
    name: {
      beginsWith: "Rene",
    },
  });
```

</InlineFilter>

<InlineFilter filters={["swift"]}>

On the client side, you can create a custom GraphQL request based on the new `listBy...` query that's named after hash key and sort keys. You can supply the filter as part of this new list query:

```swift
struct PaginatedList<ModelType: Model>: Decodable {
    let items: [ModelType]
    let nextToken: String?
}
let operationName = "listCustomer9ByAccountRepresentativeIdAndName"
let document = """
query ListCustomer8ByAccountRepresentativeId {
  \(operationName)(accountRepresentativeId: "\(accountRepresentativeId)", name: {beginsWith: "\(name)"}) {
    items {
      accountRepresentativeId
      createdAt
      id
      name
      phoneNumber
      updatedAt
    }
    nextToken
  }
}
"""
let request = GraphQLRequest<PaginatedList<Customer>>(
    document: document,
    responseType: PaginatedList<Customer>.self,
    decodePath: operationName)

let queriedCustomers = try await Amplify.API.query(
    request: request).get()
```
</InlineFilter>

## Customize the query field for secondary indexes

You can also customize the auto-generated query name under `client.models.<MODEL_NAME>.listBy...` by setting the `queryField()` modifier.

```ts title="amplify/data/resource.ts"
const schema = a.schema({
  Customer: a
    .model({
      name: a.string(),
      phoneNumber: a.phone(),
      accountRepresentativeId: a.id().required(),
    })
    .secondaryIndexes((index) => [
      index("accountRepresentativeId")
        // highlight-next-line
        .queryField("listByRep"),
    ])
    .authorization(allow => [allow.owner()]),
});
```

<InlineFilter filters={["javascript", "angular", "react-native", "react", "nextjs", "vue", "android", "flutter"]}>

In your client app code, you'll see query updated under the Data client:

```ts title="src/App.tsx"
const {
  data,
  errors
  // highlight-next-line
} = await client.models.Customer.listByRep({
  accountRepresentativeId: 'YOUR_REP_ID',
})
```

</InlineFilter>

<InlineFilter filters={["swift"]}>

In your client app code, you can use the updated query name.

```swift
struct PaginatedList<ModelType: Model>: Decodable {
    let items: [ModelType]
    let nextToken: String?
}
let operationName = "listByRep"
let document = """
query ListByRep {
  \(operationName)(accountRepresentativeId: "\(accountRepresentativeId)") {
    items {
      accountRepresentativeId
      createdAt
      id
      name
      phoneNumber
      updatedAt
    }
    nextToken
  }
}
"""

let request = GraphQLRequest<PaginatedList<Customer>>(
    document: document,
    responseType: PaginatedList<Customer>.self,
    decodePath: operationName)

let queriedCustomers = try await Amplify.API.query(
    request: request).get()
```
</InlineFilter>


## Customize the name of secondary indexes

To customize the underlying DynamoDB's index name, you can optionally provide the `name()` modifier.

```ts title="amplify/data/resource.ts"
const schema = a.schema({
  Customer: a
    .model({
      name: a.string(),
      phoneNumber: a.phone(),
      accountRepresentativeId: a.id().required(),
    })
    .secondaryIndexes((index) => [
      index("accountRepresentativeId")
        // highlight-next-line
        .name("MyCustomIndexName"),
    ])
    .authorization(allow => [allow.owner()]),
});
```


Contents of build-a-backend_data_enable-logging_index.txt:
import { getCustomStaticPath } from '@/utils/getCustomStaticPath';

export const meta = {
  title: 'Enable logging',
  description: 'Learn how to enable logging for your Amplify data resource',
  platforms: [
    'android',
    'angular',
    'flutter',
    'javascript',
    'nextjs',
    'react',
    'react-native',
    'swift',
    'vue'
  ]
};

export function getStaticPaths() {
  return getCustomStaticPath(meta.platforms);
}

export function getStaticProps(context) {
  return {
    props: {
      platform: context.params.platform,
      meta
    }
  };
}

You can enable logging to debug your GraphQL API using Amazon CloudWatch logs. To learn more about logging and monitoring capabilities for your GraphQL API, visit the [AWS AppSync documentation for logging and monitoring](https://docs.aws.amazon.com/appsync/latest/devguide/monitoring.html).  

## Enable default logging configuration

Default logging can be enabled by setting the `logging` property to `true` in the call to `defineData`. For example:

```ts title="amplify/data/resource.ts"
export const data = defineData({
  // ...
  logging: true
});
```

Using `logging: true` applies the default configuration:
- `excludeVerboseContent: true` (see [AppSync's Request-level logs](https://docs.aws.amazon.com/appsync/latest/devguide/monitoring.html#cwl))
- `fieldLogLevel: 'none'` (see [AppSync's Field-level logs](https://docs.aws.amazon.com/appsync/latest/devguide/monitoring.html#cwl))
- `retention: '1 week'` (see [Enum RetentionDays](https://docs.aws.amazon.com/cdk/api/v2/docs/aws-cdk-lib.aws_logs.RetentionDays.html))

## Customize logging configuration

You can customize individual configuration values by providing a [`DataLogConfig`](#datalogconfig-fields) object. For example:  

```ts title="amplify/data/resource.ts"
export const data = defineData({
  // ...
  logging: {
    excludeVerboseContent: false,
    fieldLogLevel: 'all',
    retention: '1 month'
  }
});
```

<Callout warning>
**WARNING**: Setting `excludeVerboseContent` to `false` logs full queries and user parameters, which can contain sensitive data. We recommend limiting CloudWatch log access to only those roles or users (e.g., DevOps or developers) who genuinely require it, by carefully scoping your IAM policies.
</Callout>

## Configuration Properties

### `logging`
- `true`: Enables default logging.
- `DataLogConfig` object: Overrides one or more default fields.

### `DataLogConfig` Fields

- **`excludeVerboseContent?: boolean`**
  - Defaults to `true`
  - When `false`, logs can contain request-level logs. See [AppSync's Request-Level Logs](https://docs.aws.amazon.com/appsync/latest/devguide/monitoring.html#cwl).

- **`fieldLogLevel?: DataLogLevel`**
  - Defaults to `'none'`
  - Supported values of [AppSync's Field Log Levels](https://docs.aws.amazon.com/appsync/latest/devguide/monitoring.html#cwl):
    - `'none'`
    - `'error'`
    - `'info'`
    - `'debug'`
    - `'all'`

- **`retention?: LogRetention`**
  - Number of days to keep the logs
  - Defaults to `'1 week'`
  - Supported values of [Enum RetentionDays](https://docs.aws.amazon.com/cdk/api/v2/docs/aws-cdk-lib.aws_logs.RetentionDays.html):
    - `'1 day'`
    - `'3 days'`
    - `'5 days'`
    - `'1 week'`
    - `'2 weeks'`
    - `'1 month'`
    - `'2 months'`
    - `'3 months'`
    - `'4 months'`
    - `'5 months'`
    - `'6 months'`
    - `'1 year'`
    - `'13 months'`
    - `'18 months'`
    - `'2 years'`
    - `'5 years'`
    - `'10 years'`
    - `'infinite'`


Contents of build-a-backend_data_index.txt:
import { getCustomStaticPath } from '@/utils/getCustomStaticPath';
import { getChildPageNodes } from '@/utils/getChildPageNodes';

export const meta = {
  title: 'Data',
  description: 'Learn about the data capabilities of AWS Amplify.',
  route: '/[platform]/build-a-backend/data',
  platforms: [
    'android',
    'angular',
    'flutter',
    'javascript',
    'nextjs',
    'react',
    'react-native',
    'swift',
    'vue'
  ]
};

export const getStaticPaths = async () => {
  return getCustomStaticPath(meta.platforms);
};

export function getStaticProps(context) {
  const childPageNodes = getChildPageNodes(meta.route);
  return {
    props: {
      meta,
      childPageNodes
    }
  };
}

<Overview childPageNodes={props.childPageNodes} />


Contents of build-a-backend_data_manage-with-amplify-console_index.txt:
import { getCustomStaticPath } from '@/utils/getCustomStaticPath';

export const meta = {
  title: 'Manage Data with Amplify console',
  description:
    'Manage GraphQL data with Amplify console',
  platforms: [
    'android',
    'angular',
    'flutter',
    'javascript',
    'nextjs',
    'react',
    'react-native',
    'swift',
    'vue'
  ]
};

export function getStaticPaths() {
  return getCustomStaticPath(meta.platforms);
}

export function getStaticProps(context) {
  return {
    props: {
      platform: context.params.platform,
      meta
    }
  };
}

The **Data manager** page in the Amplify Console offers a user-friendly interface for managing the backend GraphQL API data of an application. It enables real-time creation and updates of application data, eliminating the need to build separate admin views.

If you have not yet created a **data** resource, visit the [Data setup guide](/[platform]/build-a-backend/data/set-up-data/).

## Access Data manager

After you've deployed your data resource, you can access the manager on Amplify console.

1. Log in to the [Amplify console](https://console.aws.amazon.com/amplify/home) and choose your app.
2. Select the branch you would like to access.
3. Select **Data** from the left navigation bar.
4. Then, select **Data manager**.

<Video src="/images/gen2/manage/data-manager.mp4" description="Video - Access data manager on Amplify console"/>

### To create a record

1. On the **Data manager** page, select a table from the **Select table** dropdown. For this example, we are using a *Todo* table.
2. Select **Create Todo**.
3. In the **Add Todo** pane, specify your custom values for the fields in the table. For example, enter *my first todo* for the *Content* field and toggle the *Is done* field.
4. Select **Submit**.

### To update a record

1. On the **Data manager** page, select a table from the **Select table** dropdown.
2. From the list of records, select a record you want to update.
3. In the **Edit Todo** pane, make any changes to your record, and then select **Submit**.

### To delete a record(s)

1. On the **Data manager** page, select a table from the **Select table** dropdown.
2. From the list of records, select the checkbox to the left of the record(s) you want to delete.
3. Select the **Actions** dropdown, and then select **delete item(s)** .

### To Seed records

1. On the **Data manager** page, select a table from the **Select table** dropdown.
2. Select the **Actions** dropdown and then select **Auto-generate data**.
3. In the **Auto-generate data** pane, specify how many rows of data you want to generate and constraints for the generated data.
4. Then select **Generate data**

You can generate up to 100 records at a time.

<Callout warning>

 Seed data cannot be generated for tables that have the following field types: AWSPhone, Enum, Custom Type, or Relationship

</Callout>

### To download records

1. On the **Data manager** page, select a table from the **Select table** dropdown.
2. Select the **Actions** dropdown. 
3. Here you have two options for downloading data.
    - Choose **Download selected items (.csv)** to download only the selected rows of data.
    - Choose **Download all items (.csv)** to download all rows of records on the currently selected table.
4. Once you have selected a download option, your data should immediately start downloading as a CSV file.


Contents of build-a-backend_data_mutate-data_index.txt:
import { getCustomStaticPath } from '@/utils/getCustomStaticPath';

export const meta = {
  title: 'Create, update, and delete application data',
  description: 'Mutate application data in an API by generating the client, adding items, updating existing items, deleting items, troubleshooting unauthorized errors, and canceling requests.',
  platforms: [
    'android',
    'angular',
    'flutter',
    'javascript',
    'nextjs',
    'react',
    'react-native',
    'swift',
    'vue'
  ]
};

export const getStaticPaths = async () => {
  return getCustomStaticPath(meta.platforms);
};

export function getStaticProps(context) {
  return {
    props: {
      meta
    }
  };

}

In this guide, you will learn how to create, update, and delete your data using Amplify Libraries' Data client.

Before you begin, you will need:

- An [application connected to the API](/[platform]/build-a-backend/data/connect-to-API/)

## Create an item

<InlineFilter filters={["javascript",  "react-native", "angular", "nextjs", "react", "vue"]}>

You can create an item by first generating the Data client with your backend Data schema. Then you can add an item:

```ts
import { generateClient } from 'aws-amplify/data';
import { type Schema } from '../amplify/data/resource'

const client = generateClient<Schema>();

const { errors, data: newTodo } = await client.models.Todo.create({
  content: "My new todo",
  isDone: true,
})
```

<Callout>

**Note:** You do not need to specify `createdAt` or `updatedAt` fields because Amplify automatically populates these fields for you.

</Callout>

</InlineFilter>

<InlineFilter filters={["swift"]}>

You can run a GraphQL mutation with `Amplify.API.mutate` to create an item.

<BlockSwitcher>

<Block name="Async/Await">

Make sure you have the following imports at the top of your file:

```swift
import Amplify
```

```swift
func createTodo() async {
    // Retrieve your Todo using Amplify.API.query
    var todo = Todo(name: "my first todo", description: "todo description")
    todo.description = "created description"
    do {
        let result = try await Amplify.API.mutate(request: .create(todo))
        switch result {
        case .success(let todo):
            print("Successfully created todo: \(todo)")
        case .failure(let error):
            print("Got failed result with \(error.errorDescription)")
        }
    } catch let error as APIError {
        print("Failed to create todo: ", error)
    } catch {
        print("Unexpected error: \(error)")
    }
}
```

</Block>

<Block name="Combine">

You can run a GraphQL mutation with `Amplify.API.mutate`. Make sure you have the following imports at the top of your file:

```swift
import Amplify
import Combine
```

```swift
func createTodo() -> AnyCancellable {
    // Retrieve your Todo using Amplify.API.query
    var todo = Todo(name: "my first todo", description: "todo description")
    todo.description = "created description"
    let todoCreated = todo
    let sink = Amplify.Publisher.create {
        try await Amplify.API.mutate(request: .create(todoCreated))
    }
    .sink {
        if case let .failure(error) = $0 {
            print("Got failed event with error \(error)")
        }
    }
    receiveValue: { result in
        switch result {
        case .success(let todo):
            print("Successfully created todo: \(todo)")
        case .failure(let error):
            print("Got failed result with \(error.errorDescription)")
        }
    }
    return sink
}
```

</Block>

</BlockSwitcher>

</InlineFilter>

<InlineFilter filters={["android"]}>

Now that the client is set up, you can run a GraphQL mutation with `Amplify.API.mutate` to create your data.

<BlockSwitcher>
<Block name="Java">

```java
Todo todo = Todo.builder()
    .name("My todo")
    .build();

Amplify.API.mutate(ModelMutation.create(todo),
    response -> Log.i("MyAmplifyApp", "Todo with id: " + response.getData().getId()),
    error -> Log.e("MyAmplifyApp", "Create failed", error)
);
```

</Block>
<Block name="Kotlin - Callbacks">

```kotlin
val todo = Todo.builder()
    .name("My todo")
    .build()

Amplify.API.mutate(ModelMutation.create(todo),
    { Log.i("MyAmplifyApp", "Todo with id: ${it.data.id}") }
    { Log.e("MyAmplifyApp", "Create failed", it) }
)
```

</Block>
<Block name="Kotlin - Coroutines">

```kotlin
val todo = Todo.builder()
    .name("My todo")
    .build()
try {
    val response = Amplify.API.mutate(ModelMutation.create(todo))
    Log.i("MyAmplifyApp", "Todo with id: ${response.data.id}")
} catch (error: ApiException) {
    Log.e("MyAmplifyApp", "Create failed", error)
}
```

</Block>
<Block name="RxJava">

```java
Todo todo = Todo.builder()
        .name("My todo")
        .build();

RxAmplify.API.mutate(ModelMutation.create(todo))
        .subscribe(
            response -> Log.i("MyAmplifyApp", "Todo with id: " + response.getData().getId()),
            error -> Log.e("MyAmplifyApp", "Create failed", error)
        );
```

</Block>
</BlockSwitcher>

</InlineFilter>

<InlineFilter filters={["flutter"]}>

You can run a GraphQL mutation with `Amplify.API.mutate` to create your data.

```dart
Future<void> createTodo() async {
  try {
    final todo = Todo(name: 'my first todo', description: 'todo description');
    final request = ModelMutations.create(todo);
    final response = await Amplify.API.mutate(request: request).response;

    final createdTodo = response.data;
    if (createdTodo == null) {
      safePrint('errors: ${response.errors}');
      return;
    }
    safePrint('Mutation result: ${createdTodo.name}');
  } on ApiException catch (e) {
    safePrint('Mutation failed: $e');
  }
}
```

</InlineFilter>


## Update an item

<InlineFilter filters={["javascript",  "react-native", "angular", "nextjs", "react", "vue"]}>

To update the item, use the `update` function:

```ts
import { generateClient } from 'aws-amplify/data';
import { type Schema } from '../amplify/data/resource';

const client = generateClient<Schema>();

const todo = {
  id: 'some_id',
  content: 'Updated content',
};

const { data: updatedTodo, errors } = await client.models.Todo.update(todo);
```

<Callout>

**Notes:**

- You do not need to specify the `updatedAt` field. Amplify will automatically populate this field for you.
- If you specify _extra_ input fields not expected by the API, this query will fail. You can see this in the `errors` field returned by the query. With Amplify Data, errors are not thrown like exceptions. Instead, any errors are captured and returned as part of the query result in the `errors` field.

</Callout>

</InlineFilter>

<InlineFilter filters={["swift"]}>

To update data, replace the request with `.update`.

```swift
try await Amplify.API.mutate(request: .update(todo))
```

</InlineFilter>

<InlineFilter filters={["android"]}>

To update data, use `ModelMutation.update(todo)` instead.

</InlineFilter>

<InlineFilter filters={["flutter"]}>

To update the `Todo` with a new name:

```dart
Future<void> updateTodo(Todo originalTodo) async {
  final todoWithNewName = originalTodo.copyWith(name: 'new name');

  final request = ModelMutations.update(todoWithNewName);
  final response = await Amplify.API.mutate(request: request).response;
  safePrint('Response: $response');
}
```

</InlineFilter>

## Delete an item

<InlineFilter filters={["javascript",  "react-native", "angular", "nextjs", "react", "vue"]}>

You can then delete the Todo by using the delete mutation. To specify which item to delete, you only need to provide the `id` of that item:

```js
import { generateClient } from 'aws-amplify/data';
import { type Schema } from '../amplify/data/resource'

const client = generateClient<Schema>();

const toBeDeletedTodo = {
  id: '123123213'
}

const { data: deletedTodo, errors } = await client.models.Todo.delete(toBeDeletedTodo)
```

<Callout>

**Note:** When deleting items in many-to-many relationships, the join table records must be deleted before deleting the associated records. For example, for a many-to-many relationship between Posts and Tags, delete the PostTags join record before deleting a Post or Tag. Review [Many-to-many relationships](/[platform]/build-a-backend/data/data-modeling/relationships/) for more details.

</Callout>

<Accordion title='Troubleshoot unauthorized errors' headingLevel='4' eyebrow='Troubleshooting'>

Each API request uses an authorization mode. If you get unauthorized errors, you may need to update your authorization mode. To override the default authorization mode defined in your **amplify/data/resource.ts** file, pass an `authMode` property to the request or the client. The following examples show how you can mutate data with a custom authorization mode:

```ts
import { generateClient } from 'aws-amplify/data';
import { type Schema } from '../amplify/data/resource';

const client = generateClient<Schema>();

const { errors, data: newTodo } = await client.models.Todo.create(
  {
    content: 'My new todo',
    isDone: true,
  },
  {
    authMode: 'apiKey',
  }
);
```

</Accordion>

</InlineFilter>

<InlineFilter filters={["swift"]}>

To delete data, replace the request with `.delete`.

```swift
try await Amplify.API.mutate(request: .delete(todo))
```

</InlineFilter>

<InlineFilter filters={["android"]}>

To delete data, use `ModelMutation.delete(todo)`.

</InlineFilter>

<InlineFilter filters={["flutter"]}>

To delete the `Todo`:

```dart
Future<void> deleteTodo(Todo todoToDelete) async {
  final request = ModelMutations.delete(todoToDelete);
  final response = await Amplify.API.mutate(request: request).response;
  safePrint('Response: $response');
}
```

Or you can delete by ID, which is ideal if you do not have the instance in memory yet:

```dart
Future<void> deleteTodoById(Todo todoToDelete) async {
  final request = ModelMutations.deleteById(
    Todo.classType,
    TodoModelIdentifier(id: '8e0dd2fc-2f4a-4dc4-b47f-2052eda10775'),
  );
  final response = await Amplify.API.mutate(request: request).response;
  safePrint('Response: $response');
}
```

</InlineFilter>

<InlineFilter filters={["javascript",  "react-native", "angular", "nextjs", "react", "vue"]}>

## Cancel create, update, and delete requests

You can cancel any mutation API request by calling `.cancel` on the mutation request promise that's returned by `.create(...)`, `.update(...)`, or `.delete(...)`.

```ts
const promise = client.models.Todo.create({ content: 'New Todo' });
//  ^ Note: we're not awaiting the request, we're returning the promise

try {
  await promise;
} catch (error) {
  console.log(error);
  // If the error is because the request was cancelled you can confirm here.
  if (client.isCancelError(error)) {
    console.log(error.message); // "my message for cancellation"
    // handle user cancellation logic
  }
}

//...

// To cancel the above request
client.cancel(promise, 'my message for cancellation');
```

You need to ensure that the promise returned from `.create()`, `.update()`, and `.delete()` has not been modified. Typically, async functions wrap the promise being returned into another promise. For example, the following will **not** work:

```ts
async function makeAPICall() {
  return client.models.Todo.create({ content: 'New Todo' });
}
const promise = makeAPICall();

// The following will NOT cancel the request.
client.cancel(promise, 'my error message');
```

</InlineFilter>

## Conclusion

Congratulations! You have finished the **Create, update, and delete application data** guide. In this guide, you created, updated, and deleted your app data.

### Next steps

Our recommended next steps include using the API to query data and subscribe to real-time events to look for mutations in your data. Some resources that will help with this work include:

- [Read application data](/[platform]/build-a-backend/data/query-data/)
- [Subscribe to real-time events](/[platform]/build-a-backend/data/subscribe-data/)


Contents of build-a-backend_data_optimistic-ui_index.txt:
import { getCustomStaticPath } from '@/utils/getCustomStaticPath';

export const meta = {
  title: 'Optimistic UI',
  description: 'Learn more about implementing optimistic UI with Amplify Data API.',
  platforms: [
    'javascript',
    'swift',
    'angular',
    'nextjs',
    'react',
    'vue'
  ],
};

export const getStaticPaths = async () => {
  return getCustomStaticPath(meta.platforms);
};

export function getStaticProps(context) {
  return {
    props: {
      platform: context.params.platform,
      meta
    }
  };
}

<InlineFilter filters={["javascript", "angular", "nextjs", "vue", "react"]}>

Amplify Data can be used with [TanStack Query](https://tanstack.com/query/latest/docs/react/overview) to implement optimistic UI, allowing CRUD operations to be rendered immediately on the UI before the request roundtrip has completed. Using Amplify Data with TanStack additionally makes it easy to render loading and error states, and allows you to rollback changes on the UI when API calls are unsuccessful.

In the following examples we'll create a list view that optimistically renders newly created items, and a detail view that optimistically renders updates and deletes.

<Callout>

For more details on TanStack Query, including requirements, supported browsers, and advanced usage, see the [TanStack Query documentation](https://tanstack.com/query/latest/docs/react/overview).
For complete guidance on how to implement optimistic updates with TanStack Query, see the [TanStack Query Optimistic UI Documentation](https://tanstack.com/query/latest/docs/react/guides/optimistic-updates).
For more on Amplify Data, see the [API documentation](/[platform]/build-a-backend/data/set-up-data/).

</Callout>

To get started, run the following command in an existing Amplify project with a React frontend:

```bash title="Terminal" showLineNumbers={false}
# Install TanStack Query
npm i @tanstack/react-query @tanstack/react-query-devtools
```

Modify your Data schema to use this "Real Estate Property" example:

```ts title="amplify/data/resource.ts"
const schema = a.schema({
  RealEstateProperty: a.model({
    name: a.string().required(),
    address: a.string(),
  }).authorization(allow => [allow.guest()])
})

export type Schema = ClientSchema<typeof schema>;

export const data = defineData({
  schema,
  authorizationModes: {
    defaultAuthorizationMode: 'iam',
  },
});
```

Save the file and run `npx ampx sandbox` to deploy the changes to your backend cloud sandbox. For the purposes of this guide, we'll build a Real Estate Property listing application.

Next, at the root of your project, add the required TanStack Query imports, and create a client:

```ts title="src/main.tsx"
import React from 'react'
import ReactDOM from 'react-dom/client'
import App from './App.tsx'
import './index.css'
import { Amplify } from 'aws-amplify'
import outputs from '../amplify_outputs.json'
// highlight-start
import { QueryClient, QueryClientProvider } from "@tanstack/react-query";
import { ReactQueryDevtools } from "@tanstack/react-query-devtools";
// highlight-end

Amplify.configure(outputs)

const queryClient = new QueryClient()

ReactDOM.createRoot(document.getElementById('root')!).render(
  <React.StrictMode>
    // highlight-start
    <QueryClientProvider client={queryClient}>
      <App />
      <ReactQueryDevtools initialIsOpen={false} />
    </QueryClientProvider>
    // highlight-end
  </React.StrictMode>,
)
```

<Callout>

TanStack Query Devtools are not required, but are a useful resource for debugging and understanding how TanStack works under the hood. By default, React Query Devtools are only included in bundles when `process.env.NODE_ENV === 'development'`, meaning that no additional configuration is required to exclude them from a production build.
For more information on the TanStack Query Devtools, visit the [TanStack Query Devtools docs](https://tanstack.com/query/latest/docs/react/devtools)

</Callout>

<Callout>

For the complete working example, including required imports and React component state management, see the [Complete Example](#complete-example) below.

</Callout>

## How to use TanStack Query query keys with the Amplify Data API

TanStack Query manages query caching based on the query keys you specify. A query key must be an array. The array can contain a single string or multiple strings and nested objects. The query key must be serializable, and unique to the query's data.

When using TanStack to render optimistic UI with Amplify Data, you must use different query keys depending on the API operation. When retrieving a list of items, a single string is used (e.g. `queryKey: ["realEstateProperties"]`). This query key is also used to optimistically render a newly created item. When updating or deleting an item, the query key must also include the unique identifier for the record being deleted or updated (e.g. `queryKey: ["realEstateProperties", newRealEstateProperty.id]`).

For more detailed information on query keys, see the [TanStack Query documentation](https://tanstack.com/query/v4/docs/react/guides/query-keys).

## Optimistically rendering a list of records

To optimistically render a list of items returned from the Amplify Data API, use the TanStack `useQuery` hook, passing in the Data API query as the `queryFn` parameter. The following example creates a query to retrieve all records from the API. We'll use `realEstateProperties` as the query key, which will be the same key we use to optimistically render a newly created item.

```ts title="src/App.tsx"
// highlight-start
import type { Schema } from '../amplify/data/resource'
import { generateClient } from 'aws-amplify/data'
import { useQuery } from '@tanstack/react-query'

const client = generateClient<Schema>();
// highlight-end

function App() {
  // highlight-start
  const {
    data: realEstateProperties,
    isLoading,
    isSuccess,
    isError: isErrorQuery,
  } = useQuery({
    queryKey: ["realEstateProperties"],
    queryFn: async () => {
      const response = await client.models.RealEstateProperty.list();

      const allRealEstateProperties = response.data;

      if (!allRealEstateProperties) return null;

      return allRealEstateProperties;
    },
  });
  // highlight-end
  // return ...
}
```

## Optimistically rendering a newly created record

To optimistically render a newly created record returned from the Amplify Data API, use the TanStack `useMutation` hook, passing in the Amplify Data API mutation as the `mutationFn` parameter. We'll use the same query key used by the `useQuery` hook (`realEstateProperties`) as the query key to optimistically render a newly created item.
We'll use the `onMutate` function to update the cache directly, as well as the `onError` function to rollback changes when a request fails.

```ts
import { generateClient } from 'aws-amplify/api'
import type { Schema } from '../amplify/data/resource'
// highlight-next-line
import { useQueryClient, useMutation } from '@tanstack/react-query'

const client = generateClient<Schema>()

function App() {
  // highlight-next-line
  const queryClient = useQueryClient();

  // highlight-start
  const createMutation = useMutation({
    mutationFn: async (input: { name: string, address: string }) => {
      const { data: newRealEstateProperty } = await client.models.RealEstateProperty.create(input)
      return newRealEstateProperty;
    },
    // When mutate is called:
    onMutate: async (newRealEstateProperty) => {
      // Cancel any outgoing refetches
      // (so they don't overwrite our optimistic update)
      await queryClient.cancelQueries({ queryKey: ["realEstateProperties"] });

      // Snapshot the previous value
      const previousRealEstateProperties = queryClient.getQueryData([
        "realEstateProperties",
      ]);

      // Optimistically update to the new value
      if (previousRealEstateProperties) {
        queryClient.setQueryData(["realEstateProperties"], (old: Schema["RealEstateProperty"]["type"][]) => [
          ...old,
          newRealEstateProperty,
        ]);
      }

      // Return a context object with the snapshotted value
      return { previousRealEstateProperties };
    },
    // If the mutation fails,
    // use the context returned from onMutate to rollback
    onError: (err, newRealEstateProperty, context) => {
      console.error("Error saving record:", err, newRealEstateProperty);
      if (context?.previousRealEstateProperties) {
        queryClient.setQueryData(
          ["realEstateProperties"],
          context.previousRealEstateProperties
        );
      }
    },
    // Always refetch after error or success:
    onSettled: () => {
      queryClient.invalidateQueries({ queryKey: ["realEstateProperties"] });
    },
  });
  // highlight-end
  // return ...
}
```

## Querying a single item with TanStack Query

To optimistically render updates on a single item, we'll first retrieve the item from the API. We'll use the `useQuery` hook, passing in the `get` query as the `queryFn` parameter. For the query key, we'll use a combination of `realEstateProperties` and the record's unique identifier.

```ts
import { generateClient } from 'aws-amplify/data'
import type { Schema } from '../amplify/data/resource'
import { useQuery } from '@tanstack/react-query'

const client = generateClient<Schema>()

function App() {
  const currentRealEstatePropertyId = "SOME_ID"
  // highlight-start
  const {
    data: realEstateProperty,
    isLoading,
    isSuccess,
    isError: isErrorQuery,
  } = useQuery({
    queryKey: ["realEstateProperties", currentRealEstatePropertyId],
    queryFn: async () => {
      if (!currentRealEstatePropertyId) { return }

      const { data: property } = await client.models.RealEstateProperty.get({
        id: currentRealEstatePropertyId,
      });
      return property;
    },
  });
  // highlight-end
}
```

## Optimistically render updates for a record

To optimistically render Amplify Data updates for a single record, use the TanStack `useMutation` hook, passing in the update mutation as the `mutationFn` parameter. We'll use the same query key combination used by the single record `useQuery` hook (`realEstateProperties` and the record's `id`) as the query key to optimistically render the updates.
We'll use the `onMutate` function to update the cache directly, as well as the `onError` function to rollback changes when a request fails.

<Callout>

When directly interacting with the cache via the `onMutate` function, the `newRealEstateProperty` parameter will only include fields that are being updated. When calling `setQueryData`, include the previous values for all fields in addition to the newly updated fields to avoid only rendering optimistic values for updated fields on the UI.

</Callout>

```ts title="src/App.tsx"
import { generateClient } from 'aws-amplify/data'
import type { Schema } from '../amplify/data/resource'
import { useQueryClient, useMutation } from "@tanstack/react-query";

const client = generateClient<Schema>()

function App() {
  // highlight-next-line
  const queryClient = useQueryClient();

  // highlight-start
   const updateMutation = useMutation({
    mutationFn: async (realEstatePropertyDetails: { id: string, name?: string, address?: string }) => {
      const { data: updatedProperty } = await client.models.RealEstateProperty.update(realEstatePropertyDetails);

      return updatedProperty;
    },
    // When mutate is called:
    onMutate: async (newRealEstateProperty: { id: string, name?: string, address?: string }) => {
      // Cancel any outgoing refetches
      // (so they don't overwrite our optimistic update)
      await queryClient.cancelQueries({
        queryKey: ["realEstateProperties", newRealEstateProperty.id],
      });

      await queryClient.cancelQueries({
        queryKey: ["realEstateProperties"],
      });

      // Snapshot the previous value
      const previousRealEstateProperty = queryClient.getQueryData([
        "realEstateProperties",
        newRealEstateProperty.id,
      ]);

      // Optimistically update to the new value
      if (previousRealEstateProperty) {
        queryClient.setQueryData(
          ["realEstateProperties", newRealEstateProperty.id],
          /**
           * `newRealEstateProperty` will at first only include updated values for
           * the record. To avoid only rendering optimistic values for updated
           * fields on the UI, include the previous values for all fields:
           */
          { ...previousRealEstateProperty, ...newRealEstateProperty }
        );
      }

      // Return a context with the previous and new realEstateProperty
      return { previousRealEstateProperty, newRealEstateProperty };
    },
    // If the mutation fails, use the context we returned above
    onError: (err, newRealEstateProperty, context) => {
      console.error("Error updating record:", err, newRealEstateProperty);
      if (context?.previousRealEstateProperty) {
        queryClient.setQueryData(
          ["realEstateProperties", context.newRealEstateProperty.id],
          context.previousRealEstateProperty
        );
      }
    },
    // Always refetch after error or success:
    onSettled: (newRealEstateProperty) => {
      if (newRealEstateProperty) {
        queryClient.invalidateQueries({
          queryKey: ["realEstateProperties", newRealEstateProperty.id],
        });
        queryClient.invalidateQueries({
          queryKey: ["realEstateProperties"],
        });
      }
    },
  });
  // highlight-end
}
```

## Optimistically render deleting a record

To optimistically render a deletion of a single record, use the TanStack `useMutation` hook, passing in the delete mutation as the `mutationFn` parameter. We'll use the same query key combination used by the single record `useQuery` hook (`realEstateProperties` and the record's `id`) as the query key to optimistically render the updates.
We'll use the `onMutate` function to update the cache directly, as well as the `onError` function to rollback changes when a delete fails.

```ts title="src/App.tsx"
import { generateClient } from 'aws-amplify/data'
import type { Schema } from '../amplify/data/resource'
import { useQueryClient, useMutation } from '@tanstack/react-query'

const client = generateClient<Schema>()

function App() {
  // highlight-next-line
  const queryClient = useQueryClient();

  // highlight-start
    const deleteMutation = useMutation({
    mutationFn: async (realEstatePropertyDetails: { id: string }) => {
      const { data: deletedProperty } = await client.models.RealEstateProperty.delete(realEstatePropertyDetails);
      return deletedProperty;
    },
    // When mutate is called:
    onMutate: async (newRealEstateProperty) => {
      // Cancel any outgoing refetches
      // (so they don't overwrite our optimistic update)
      await queryClient.cancelQueries({
        queryKey: ["realEstateProperties", newRealEstateProperty.id],
      });

      await queryClient.cancelQueries({
        queryKey: ["realEstateProperties"],
      });

      // Snapshot the previous value
      const previousRealEstateProperty = queryClient.getQueryData([
        "realEstateProperties",
        newRealEstateProperty.id,
      ]);

      // Optimistically update to the new value
      if (previousRealEstateProperty) {
        queryClient.setQueryData(
          ["realEstateProperties", newRealEstateProperty.id],
          newRealEstateProperty
        );
      }

      // Return a context with the previous and new realEstateProperty
      return { previousRealEstateProperty, newRealEstateProperty };
    },
    // If the mutation fails, use the context we returned above
    onError: (err, newRealEstateProperty, context) => {
      console.error("Error deleting record:", err, newRealEstateProperty);
      if (context?.previousRealEstateProperty) {
        queryClient.setQueryData(
          ["realEstateProperties", context.newRealEstateProperty.id],
          context.previousRealEstateProperty
        );
      }
    },
    // Always refetch after error or success:
    onSettled: (newRealEstateProperty) => {
      if (newRealEstateProperty) {
        queryClient.invalidateQueries({
          queryKey: ["realEstateProperties", newRealEstateProperty.id],
        });
        queryClient.invalidateQueries({
          queryKey: ["realEstateProperties"],
        });
      }
    },
  });
  // highlight-end
}
```

## Loading and error states for optimistically rendered data

Both `useQuery` and `useMutation` return `isLoading` and `isError` states that indicate the current state of the query or mutation. You can use these states to render loading and error indicators.

In addition to operation-specific loading states, TanStack Query provides a [`useIsFetching` hook](https://www.tanstack.com/query/v4/docs/react/guides/background-fetching-indicators#displaying-global-background-fetching-loading-state). For the purposes of this demo, we show a global loading indicator in the [Complete Example](#complete-example) when *any* queries are fetching (including in the background) in order to help visualize what TanStack is doing in the background:

```js
function GlobalLoadingIndicator() {
  const isFetching = useIsFetching();
  return isFetching ? <div style={styles.globalLoadingIndicator}></div> : null;
}
```

For more details on advanced usage of TanStack Query hooks, see the [TanStack documentation](https://tanstack.com/query/latest/docs/react/guides/mutations).

The following example demonstrates how to use the state returned by TanStack to render a loading indicator while a mutation is in progress, and an error message if the mutation fails. For additional examples, see the [Complete Example](#complete-example) below.

```ts
<>
  {updateMutation.isError &&
  updateMutation.error instanceof Error ? (
    <div>An error occurred: {updateMutation.error.message}</div>
  ) : null}

  {updateMutation.isSuccess ? (
    <div>Real Estate Property updated!</div>
  ) : null}

  <button
    onClick={() =>
      updateMutation.mutate({
        id: realEstateProperty.id,
        address: `${Math.floor(
          1000 + Math.random() * 9000
        )} Main St`,
      })
    }
  >
    Update Address
  </button>
</>
```

## Complete example

```tsx title="src/main.tsx"
import React from 'react'
import ReactDOM from 'react-dom/client'
import App from './App.tsx'
import './index.css'
import { Amplify } from 'aws-amplify'
import outputs from '../amplify_outputs.json'
import { QueryClient, QueryClientProvider } from "@tanstack/react-query";
import { ReactQueryDevtools } from "@tanstack/react-query-devtools";

Amplify.configure(outputs)

export const queryClient = new QueryClient()

ReactDOM.createRoot(document.getElementById('root')!).render(
  <React.StrictMode>
    <QueryClientProvider client={queryClient}>
      <App />
      <ReactQueryDevtools initialIsOpen={false} />
    </QueryClientProvider>
  </React.StrictMode>,
)
```

```tsx title="src/App.tsx"
import { generateClient } from 'aws-amplify/data'
import type { Schema } from '../amplify/data/resource'
import './App.css'
import { useIsFetching, useMutation, useQuery } from '@tanstack/react-query'
import { queryClient } from './main'
import { useState } from 'react'


const client = generateClient<Schema>({
  authMode: 'iam'
})

function GlobalLoadingIndicator() {
  const isFetching = useIsFetching();

  return isFetching ? <div style={styles.globalLoadingIndicator}></div> : null;
}


function App() {
  const [currentRealEstatePropertyId, setCurrentRealEstatePropertyId] =
  useState<string | null>(null);

  const {
    data: realEstateProperties,
    isLoading,
    isSuccess,
    isError: isErrorQuery,
  } = useQuery({
    queryKey: ["realEstateProperties"],
    queryFn: async () => {
      const response = await client.models.RealEstateProperty.list();

      const allRealEstateProperties = response.data;

      if (!allRealEstateProperties) return null;

      return allRealEstateProperties;
    },
  });

  const createMutation = useMutation({
    mutationFn: async (input: { name: string, address: string }) => {
      const { data: newRealEstateProperty } = await client.models.RealEstateProperty.create(input)
      return newRealEstateProperty;
    },
    // When mutate is called:
    onMutate: async (newRealEstateProperty) => {
      // Cancel any outgoing refetches
      // (so they don't overwrite our optimistic update)
      await queryClient.cancelQueries({ queryKey: ["realEstateProperties"] });

      // Snapshot the previous value
      const previousRealEstateProperties = queryClient.getQueryData([
        "realEstateProperties",
      ]);

      // Optimistically update to the new value
      if (previousRealEstateProperties) {
        queryClient.setQueryData(["realEstateProperties"], (old: Schema["RealEstateProperty"]["type"][]) => [
          ...old,
          newRealEstateProperty,
        ]);
      }

      // Return a context object with the snapshotted value
      return { previousRealEstateProperties };
    },
    // If the mutation fails,
    // use the context returned from onMutate to rollback
    onError: (err, newRealEstateProperty, context) => {
      console.error("Error saving record:", err, newRealEstateProperty);
      if (context?.previousRealEstateProperties) {
        queryClient.setQueryData(
          ["realEstateProperties"],
          context.previousRealEstateProperties
        );
      }
    },
    // Always refetch after error or success:
    onSettled: () => {
      queryClient.invalidateQueries({ queryKey: ["realEstateProperties"] });
    },
  });

  function RealEstatePropertyDetailView() {

    const {
      data: realEstateProperty,
      isLoading,
      isSuccess,
      isError: isErrorQuery,
    } = useQuery({
      queryKey: ["realEstateProperties", currentRealEstatePropertyId],
      queryFn: async () => {
        if (!currentRealEstatePropertyId) { return }

        const { data: property } = await client.models.RealEstateProperty.get({ id: currentRealEstatePropertyId });
        return property
      },
    });


    const updateMutation = useMutation({
      mutationFn: async (realEstatePropertyDetails: { id: string, name?: string, address?: string }) => {
        const { data: updatedProperty } = await client.models.RealEstateProperty.update(realEstatePropertyDetails);

        return updatedProperty;
      },
      // When mutate is called:
      onMutate: async (newRealEstateProperty: { id: string, name?: string, address?: string }) => {
        // Cancel any outgoing refetches
        // (so they don't overwrite our optimistic update)
        await queryClient.cancelQueries({
          queryKey: ["realEstateProperties", newRealEstateProperty.id],
        });

        await queryClient.cancelQueries({
          queryKey: ["realEstateProperties"],
        });

        // Snapshot the previous value
        const previousRealEstateProperty = queryClient.getQueryData([
          "realEstateProperties",
          newRealEstateProperty.id,
        ]);

        // Optimistically update to the new value
        if (previousRealEstateProperty) {
          queryClient.setQueryData(
            ["realEstateProperties", newRealEstateProperty.id],
            /**
             * `newRealEstateProperty` will at first only include updated values for
             * the record. To avoid only rendering optimistic values for updated
             * fields on the UI, include the previous values for all fields:
             */
            { ...previousRealEstateProperty, ...newRealEstateProperty }
          );
        }

        // Return a context with the previous and new realEstateProperty
        return { previousRealEstateProperty, newRealEstateProperty };
      },
      // If the mutation fails, use the context we returned above
      onError: (err, newRealEstateProperty, context) => {
        console.error("Error updating record:", err, newRealEstateProperty);
        if (context?.previousRealEstateProperty) {
          queryClient.setQueryData(
            ["realEstateProperties", context.newRealEstateProperty.id],
            context.previousRealEstateProperty
          );
        }
      },
      // Always refetch after error or success:
      onSettled: (newRealEstateProperty) => {
        if (newRealEstateProperty) {
          queryClient.invalidateQueries({
            queryKey: ["realEstateProperties", newRealEstateProperty.id],
          });
          queryClient.invalidateQueries({
            queryKey: ["realEstateProperties"],
          });
        }
      },
    });

    const deleteMutation = useMutation({
      mutationFn: async (realEstatePropertyDetails: { id: string }) => {
        const { data: deletedProperty } = await client.models.RealEstateProperty.delete(realEstatePropertyDetails);
        return deletedProperty;
      },
      // When mutate is called:
      onMutate: async (newRealEstateProperty) => {
        // Cancel any outgoing refetches
        // (so they don't overwrite our optimistic update)
        await queryClient.cancelQueries({
          queryKey: ["realEstateProperties", newRealEstateProperty.id],
        });

        await queryClient.cancelQueries({
          queryKey: ["realEstateProperties"],
        });

        // Snapshot the previous value
        const previousRealEstateProperty = queryClient.getQueryData([
          "realEstateProperties",
          newRealEstateProperty.id,
        ]);

        // Optimistically update to the new value
        if (previousRealEstateProperty) {
          queryClient.setQueryData(
            ["realEstateProperties", newRealEstateProperty.id],
            newRealEstateProperty
          );
        }

        // Return a context with the previous and new realEstateProperty
        return { previousRealEstateProperty, newRealEstateProperty };
      },
      // If the mutation fails, use the context we returned above
      onError: (err, newRealEstateProperty, context) => {
        console.error("Error deleting record:", err, newRealEstateProperty);
        if (context?.previousRealEstateProperty) {
          queryClient.setQueryData(
            ["realEstateProperties", context.newRealEstateProperty.id],
            context.previousRealEstateProperty
          );
        }
      },
      // Always refetch after error or success:
      onSettled: (newRealEstateProperty) => {
        if (newRealEstateProperty) {
          queryClient.invalidateQueries({
            queryKey: ["realEstateProperties", newRealEstateProperty.id],
          });
          queryClient.invalidateQueries({
            queryKey: ["realEstateProperties"],
          });
        }
      },
    });

    return (
      <div style={styles.detailViewContainer}>
        <h2>Real Estate Property Detail View</h2>
        {isErrorQuery && <div>{"Problem loading Real Estate Property"}</div>}
        {isLoading && (
          <div style={styles.loadingIndicator}>
            {"Loading Real Estate Property..."}
          </div>
        )}
        {isSuccess && (
          <div>
            <p>{`Name: ${realEstateProperty?.name}`}</p>
            <p>{`Address: ${realEstateProperty?.address}`}</p>
          </div>
        )}
        {realEstateProperty && (
          <div>
            <div>
              {updateMutation.isPending ? (
                "Updating Real Estate Property..."
              ) : (
                <>
                  {updateMutation.isError &&
                    updateMutation.error instanceof Error ? (
                    <div>An error occurred: {updateMutation.error.message}</div>
                  ) : null}

                  {updateMutation.isSuccess ? (
                    <div>Real Estate Property updated!</div>
                  ) : null}

                  <button
                    onClick={() =>
                      updateMutation.mutate({
                        id: realEstateProperty.id,
                        name: `Updated Home ${Date.now()}`,
                      })
                    }
                  >
                    Update Name
                  </button>
                  <button
                    onClick={() =>
                      updateMutation.mutate({
                        id: realEstateProperty.id,
                        address: `${Math.floor(
                          1000 + Math.random() * 9000
                        )} Main St`,
                      })
                    }
                  >
                    Update Address
                  </button>
                </>
              )}
            </div>

            <div>
              {deleteMutation.isPending ? (
                "Deleting Real Estate Property..."
              ) : (
                <>
                  {deleteMutation.isError &&
                    deleteMutation.error instanceof Error ? (
                    <div>An error occurred: {deleteMutation.error.message}</div>
                  ) : null}

                  {deleteMutation.isSuccess ? (
                    <div>Real Estate Property deleted!</div>
                  ) : null}

                  <button
                    onClick={() =>
                      deleteMutation.mutate({
                        id: realEstateProperty.id,
                      })
                    }
                  >
                    Delete
                  </button>
                </>
              )}
            </div>
          </div>
        )}
        <button onClick={() => setCurrentRealEstatePropertyId(null)}>
          Back
        </button>
      </div>
    );


  }
  return (
    <div>
      {!currentRealEstatePropertyId && (
        <div style={styles.appContainer}>
          <h1>Real Estate Properties:</h1>
          <div>
            {createMutation.isPending ? (
              "Adding Real Estate Property..."
            ) : (
              <>
                {createMutation.isError &&
                createMutation.error instanceof Error ? (
                  <div>An error occurred: {createMutation.error.message}</div>
                ) : null}

                {createMutation.isSuccess ? (
                  <div>Real Estate Property added!</div>
                ) : null}

                <button
                  onClick={() => {
                    createMutation.mutate({
                      name: `New Home ${Date.now()}`,
                      address: `${Math.floor(
                        1000 + Math.random() * 9000
                      )} Main St`,
                    });
                  }}
                >
                  Add RealEstateProperty
                </button>
              </>
            )}
          </div>
          <ul style={styles.propertiesList}>
            {isLoading && (
              <div style={styles.loadingIndicator}>
                {"Loading Real Estate Properties..."}
              </div>
            )}
            {isErrorQuery && (
              <div>{"Problem loading Real Estate Properties"}</div>
            )}
            {isSuccess &&
              realEstateProperties?.map((realEstateProperty, idx) => {
                if (!realEstateProperty) return null;
                return (
                  <li
                    style={styles.listItem}
                    key={`${idx}-${realEstateProperty.id}`}
                  >
                    <p>{realEstateProperty.name}</p>
                    <button
                      style={styles.detailViewButton}
                      onClick={() =>
                        setCurrentRealEstatePropertyId(realEstateProperty.id)
                      }
                    >
                      Detail View
                    </button>
                  </li>
                );
              })}
          </ul>
        </div>
      )}
      {currentRealEstatePropertyId && <RealEstatePropertyDetailView />}
      <GlobalLoadingIndicator />
    </div>
  );

}

export default App

const styles = {
  appContainer: {
    display: "flex",
    flexDirection: "column",
    alignItems: "center",
  },
  detailViewButton: { marginLeft: "1rem" },
  detailViewContainer: { border: "1px solid black", padding: "3rem" },
  globalLoadingIndicator: {
    position: "fixed",
    top: 0,
    left: 0,
    width: "100%",
    height: "100%",
    border: "4px solid blue",
    pointerEvents: "none",
  },
  listItem: {
    display: "flex",
    justifyContent: "space-between",
    border: "1px dotted grey",
    padding: ".5rem",
    margin: ".1rem",
  },
  loadingIndicator: {
    border: "1px solid black",
    padding: "1rem",
    margin: "1rem",
  },
  propertiesList: {
    display: "flex",
    flexDirection: "column",
    alignItems: "center",
    justifyContent: "start",
    width: "50%",
    border: "1px solid black",
    padding: "1rem",
    listStyleType: "none",
  },
} as const;
```

</InlineFilter>

<InlineFilter filters={["swift"]}>

Implementing optimistic UI with Amplify Data allows CRUD operations to be rendered immediately on the UI before the request roundtrip has completed, and allows you to rollback changes on the UI when API calls are unsuccessful.

In the following example, we'll create a list view that optimistically renders newly created items, updates and deletes.  Modify your Data schema to use this "Real Estate Property" example:

```ts title="amplify/data/resource.ts"
const schema = a.schema({
  RealEstateProperty: a.model({
    name: a.string().required(),
    address: a.string(),
  }).authorization(allow => [allow.guest()])
})

export type Schema = ClientSchema<typeof schema>;

export const data = defineData({
  schema,
  authorizationModes: {
    defaultAuthorizationMode: 'iam',
  },
});
```

Save the file and run `npx ampx sandbox` to deploy the changes to your backend cloud sandbox. For the purposes of this guide, we'll build a Real Estate Property listing application.

Once the backend has been provisioned, run `npx ampx generate graphql-client-code --format modelgen --model-target swift --out <path_to_swift_project>/AmplifyModels` to generate the Swift model types for the app.

Next, add the Amplify(`https://github.com/aws-amplify/amplify-swift.git`) package to your Xcode project and select the following modules to import when prompted:

- AWSAPIPlugin
- AWSCognitoAuthPlugin
- AWSS3StoragePlugin
- Amplify

<Callout>

For the complete working example see the [Complete Example](#complete-example) below.

</Callout>

## How to use a Swift Actor to perform optimistic UI updates

A Swift actor serializes access to its underlying properties. In this example, the actor will hold a list of items that will be published to the UI through a Combine publisher whenever the list is accessed. On a high level, the methods on the actor will perform the following:

- create a new model, add it to the list, remove the newly added item from the list if the API request is unsuccessful
- update the existing model in the list, revert the update on the list if the API request is unsuccessful
- delete the existing model from the list, add the item back into the list if the API request is unsuccessful

By providing these methods through an actor object, the underlying list will be accessed serially so that the entire operation can be rolled back if needed.

To create an actor object that allows optimistic UI updates, create a new file and add the following code.

```swift
import Amplify
import SwiftUI
import Combine

actor RealEstatePropertyList {

    private var properties: [RealEstateProperty?] = [] {
        didSet {
            subject.send(properties.compactMap { $0 })
        }
    }

    private let subject = PassthroughSubject<[RealEstateProperty], Never>()
    var publisher: AnyPublisher<[RealEstateProperty], Never> {
        subject.eraseToAnyPublisher()
    }

    func listProperties() async throws {
        let result = try await Amplify.API.query(request: .list(RealEstateProperty.self))
        guard case .success(let propertyList) = result else {
            print("Failed with error: ", result)
            return
        }
        properties = propertyList.elements
    }
}
```

Calling the `listProperties()` method will perform a query with Amplify Data API and store the results in the `properties` property. When this property is set, the list is sent back to the subscribers. In your UI, create a view model and subscribe to updates:

```swift
class RealEstatePropertyContainerViewModel: ObservableObject {
    @Published var properties: [RealEstateProperty] = []
    var sink: AnyCancellable?

    var propertyList = RealEstatePropertyList()
    init() {
        Task {
            sink = await propertyList.publisher
                .receive(on: DispatchQueue.main)
                .sink { properties in
                    print("Updating property list")
                    self.properties = properties
            }
        }
    }

    func loadList() {
        Task {
            try? await propertyList.listProperties()
        }
    }
}

struct RealEstatePropertyContainerView: View {
    @StateObject var vm = RealEstatePropertyContainerViewModel()
    @State private var propertyName: String = ""

    var body: some View {
        Text("Hello")
    }
}
```

## Optimistically rendering a newly created record

To optimistically render a newly created record returned from the Amplify Data API, add a method to the `actor RealEstatePropertyList`:

```swift
func createProperty(name: String, address: String? = nil) {
    let property = RealEstateProperty(name: name, address: address)
    // Optimistically send the newly created property, for the UI to render.
    properties.append(property)

    Task {
        do {
            // Create the property record
            let result = try await Amplify.API.mutate(request: .create(property))
            guard case .failure(let graphQLResponse) = result else {
                return
            }
            print("Failed with error: ", graphQLResponse)
            // Remove the newly created property
            if let index = properties.firstIndex(where: { $0?.id == property.id }) {
                properties.remove(at: index)
            }
        } catch {
            print("Failed with error: ", error)
            // Remove the newly created property
            if let index = properties.firstIndex(where: { $0?.id == property.id }) {
                properties.remove(at: index)
            }
        }
    }
}
```

## Optimistically rendering a record update

To optimistically render updates on a single item, use the code snippet like below:

```swift
func updateProperty(_ property: RealEstateProperty) async {
    guard let index = properties.firstIndex(where: { $0?.id == property.id }) else {
        print("No property to update")
        return
    }

    // Optimistically update the property, for the UI to render.
    let rollbackProperty = properties[index]
    properties[index] = property

    do {
        // Update the property record
        let result = try await Amplify.API.mutate(request: .update(property))
        guard case .failure(let graphQLResponse) = result else {
            return
        }
        print("Failed with error: ", graphQLResponse)
        properties[index] = rollbackProperty
    } catch {
        print("Failed with error: ", error)
        properties[index] = rollbackProperty
    }
}
```

## Optimistically render deleting a record

To optimistically render a Amplify Data API delete, use the code snippet like below:

```swift
func deleteProperty(_ property: RealEstateProperty) async {
  guard let index = properties.firstIndex(where: { $0?.id == property.id }) else {
      print("No property to remove")
      return
  }

  // Optimistically remove the property, for the UI to render.
  let rollbackProperty = properties[index]
  properties[index] = nil

  do {
      // Delete the property record
      let result = try await Amplify.API.mutate(request: .delete(property))
      switch result {
      case .success:
          // Finalize the removal
          properties.remove(at: index)
      case .failure(let graphQLResponse):
          print("Failed with error: ", graphQLResponse)
          // Undo the removal
          properties[index] = rollbackProperty
      }

  } catch {
      print("Failed with error: ", error)
      // Undo the removal
      properties[index] = rollbackProperty
  }
}
```

## Complete example

<BlockSwitcher>
<Block name="Main">

```swift
import SwiftUI
import Amplify
import AWSAPIPlugin

@main
struct OptimisticUIApp: App {

    init() {
        do {
            Amplify.Logging.logLevel = .verbose
            try Amplify.add(plugin: AWSAPIPlugin(modelRegistration: AmplifyModels()))
            try Amplify.configure(with: .amplifyOutputs)
            print("Amplify configured with API, Storage, and Auth plugins!")
        } catch {
            print("Failed to initialize Amplify with \(error)")
        }
    }

    var body: some Scene {
        WindowGroup {
            RealEstatePropertyContainerView()
        }
    }
}

// Extend the model to Identifiable to make it compatible with SwiftUI's `ForEach`.
extension RealEstateProperty: Identifiable { }

struct TappedButtonStyle: ButtonStyle {
    func makeBody(configuration: Configuration) -> some View {
        configuration.label
            .padding(10)
            .background(configuration.isPressed ? Color.teal.opacity(0.8) : Color.teal)
            .foregroundColor(.white)
            .clipShape(RoundedRectangle(cornerRadius: 10))
    }
}
```

</Block>

<Block name="Actor">

```swift
actor RealEstatePropertyList {

    private var properties: [RealEstateProperty?] = [] {
        didSet {
            subject.send(properties.compactMap { $0 })
        }
    }

    private let subject = PassthroughSubject<[RealEstateProperty], Never>()
    var publisher: AnyPublisher<[RealEstateProperty], Never> {
        subject.eraseToAnyPublisher()
    }

    func listProperties() async throws {
        let result = try await Amplify.API.query(request: .list(RealEstateProperty.self))
        guard case .success(let propertyList) = result else {
            print("Failed with error: ", result)
            return
        }
        properties = propertyList.elements
    }

    func createProperty(name: String, address: String? = nil) {
        let property = RealEstateProperty(name: name, address: address)
        // Optimistically send the newly created property, for the UI to render.
        properties.append(property)

        Task {
            do {
                // Create the property record
                let result = try await Amplify.API.mutate(request: .create(property))
                guard case .failure(let graphQLResponse) = result else {
                    return
                }
                print("Failed with error: ", graphQLResponse)
                // Remove the newly created property
                if let index = properties.firstIndex(where: { $0?.id == property.id }) {
                    properties.remove(at: index)
                }
            } catch {
                print("Failed with error: ", error)
                // Remove the newly created property
                if let index = properties.firstIndex(where: { $0?.id == property.id }) {
                    properties.remove(at: index)
                }
            }
        }
    }

    func updateProperty(_ property: RealEstateProperty) async {
        guard let index = properties.firstIndex(where: { $0?.id == property.id }) else {
            print("No property to update")
            return
        }

        // Optimistically update the property, for the UI to render.
        let rollbackProperty = properties[index]
        properties[index] = property

        do {
            // Update the property record
            let result = try await Amplify.API.mutate(request: .update(property))
            guard case .failure(let graphQLResponse) = result else {
                return
            }
            print("Failed with error: ", graphQLResponse)
            properties[index] = rollbackProperty
        } catch {
            print("Failed with error: ", error)
            properties[index] = rollbackProperty
        }
    }

    func deleteProperty(_ property: RealEstateProperty) async {
        guard let index = properties.firstIndex(where: { $0?.id == property.id }) else {
            print("No property to remove")
            return
        }

        // Optimistically remove the property, for the UI to render.
        let rollbackProperty = properties[index]
        properties[index] = nil

        do {
            // Delete the property record
            let result = try await Amplify.API.mutate(request: .delete(property))
            switch result {
            case .success:
                // Finalize the removal
                properties.remove(at: index)
            case .failure(let graphQLResponse):
                print("Failed with error: ", graphQLResponse)
                // Undo the removal
                properties[index] = rollbackProperty
            }

        } catch {
            print("Failed with error: ", error)
            // Undo the removal
            properties[index] = rollbackProperty
        }
    }
}

```

</Block>

<Block name="View">

```swift
class RealEstatePropertyContainerViewModel: ObservableObject {
    @Published var properties: [RealEstateProperty] = []
    var sink: AnyCancellable?

    var propertyList = RealEstatePropertyList()
    init() {
        Task {
            sink = await propertyList.publisher
                .receive(on: DispatchQueue.main)
                .sink { properties in
                    print("Updating property list")
                    self.properties = properties
            }
        }
    }

    func loadList() {
        Task {
            try? await propertyList.listProperties()
        }
    }
    func createPropertyButtonTapped(name: String) {
        Task {
            await propertyList.createProperty(name: name)
        }
    }

    func updatePropertyButtonTapped(_ property: RealEstateProperty) {
        Task {
            await propertyList.updateProperty(property)
        }
    }

    func deletePropertyButtonTapped(_ property: RealEstateProperty) {
        Task {
            await propertyList.deleteProperty(property)
        }
    }
}

struct RealEstatePropertyContainerView: View {
    @StateObject var viewModel = RealEstatePropertyContainerViewModel()
    @State private var propertyName: String = ""

    var body: some View {
        VStack {
            ScrollView {
                LazyVStack(alignment: .leading) {
                    ForEach($viewModel.properties) { $property in
                        HStack {
                            TextField("Update property name", text: $property.name)
                                .textFieldStyle(RoundedBorderTextFieldStyle())
                                .multilineTextAlignment(.center)
                            Button("Update") {
                                viewModel.updatePropertyButtonTapped(property)
                            }
                            Button {
                                viewModel.deletePropertyButtonTapped(property)
                            } label: {
                                Image(systemName: "xmark")
                                    .foregroundColor(.red)
                            }

                        }.padding(.horizontal)
                    }
                }
            }.refreshable {
                viewModel.loadList()
            }
            TextField("New property name", text: $propertyName)
                .textFieldStyle(RoundedBorderTextFieldStyle())
                .multilineTextAlignment(.center)

            Button("Save") {
                viewModel.createPropertyButtonTapped(name: propertyName)
                self.propertyName = ""
            }
            .buttonStyle(TappedButtonStyle())
        }.task {
            viewModel.loadList()
        }
    }
}

struct RealEstatePropertyContainerView_Previews: PreviewProvider {
    static var previews: some View {
        RealEstatePropertyContainerView()
    }
}
```

</Block>

</BlockSwitcher>

</InlineFilter>


Contents of build-a-backend_data_override-resources_index.txt:
import { getCustomStaticPath } from '@/utils/getCustomStaticPath';

export const meta = {
  title: 'Modify Amplify-generated AWS resources',
  description:
    'Modify and customize existing AWS resources generated by the Amplify GraphQL API.',
  platforms: [
    'android',
    'angular',
    'flutter',
    'javascript',
    'nextjs',
    'react',
    'react-native',
    'swift',
    'vue'
  ]
};

export const getStaticPaths = async () => {
  return getCustomStaticPath(meta.platforms);
};

export function getStaticProps(context) {
  return {
    props: {
      meta
    }
  };

}

Amplify GraphQL API uses a variety of auto-generated, underlying AWS services and resources. You can customize these underlying resources to optimize the deployed stack for your specific use case.

In your Amplify app, you can access every underlying resource using CDK ["L2"](https://docs.aws.amazon.com/cdk/v2/guide/constructs.html#constructs_using) or ["L1"](https://docs.aws.amazon.com/cdk/v2/guide/constructs.html#constructs_l1_using) constructs. Access the generated resources as L2 constructs via the `.resources` property on the returned stack or access the generated resources as L1 constructs using the `.resources.cfnResources` property.

```ts title="amplify/backend.ts"
import { defineBackend } from '@aws-amplify/backend';
import { data } from './data/resource';

const backend = defineBackend({
  data
});

const { cfnResources } = backend.data.resources;

for (const table of Object.values(cfnResources.amplifyDynamoDbTables)) {
  table.pointInTimeRecoveryEnabled = true;
}
```

## Customize Amplify-generated AppSync GraphQL API resources

Apply all the customizations on `backend.data.resources.graphqlApi` or `backend.data.resources.cfnResources.cfnGraphqlApi`. For example, to enable X-Ray tracing for the AppSync GraphQL API:

```ts title="amplify/backend.ts"
import { defineBackend } from '@aws-amplify/backend';
import { data } from './data/resource';

const backend = defineBackend({
  data
});

const { cfnResources } = backend.data.resources;

cfnResources.cfnGraphqlApi.xrayEnabled = true;
```

## Customize Amplify-generated resources for data models

Pass in the model type name into `backend.data.resources.amplifyDynamoDbTables["MODEL_NAME"]` to modify the resources generated for that particular model type. For example, to enable time-to-live on the Todo `@model` type's DynamoDB table:

```ts title="amplify/backend.ts"
import { defineBackend } from '@aws-amplify/backend';
import { data } from './data/resource';

const backend = defineBackend({
  data
});

const { cfnResources } = backend.data.resources;

cfnResources.amplifyDynamoDbTables["Todo"].timeToLiveAttribute = {
  attributeName: "ttl",
  enabled: true,
};
```

### Example - Configure billing mode on a DynamoDB table

Set the [DynamoDB billing mode](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-dynamodb-table.html#cfn-dynamodb-table-billingmode) for the DynamoDB table as either "PROVISIONED" or "PAY_PER_REQUEST".

```ts title="amplify/backend.ts"
import { defineBackend } from '@aws-amplify/backend';
import { BillingMode } from "aws-cdk-lib/aws-dynamodb";
import { data } from './data/resource';

const backend = defineBackend({
  data
});

const { cfnResources } = backend.data.resources;

cfnResources.amplifyDynamoDbTables['Todo'].billingMode = BillingMode.PAY_PER_REQUEST;
```

### Example - Configure provisioned throughput for a DynamoDB table

Override the default [ProvisionedThroughput](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-dynamodb-table.html#cfn-dynamodb-table-provisionedthroughput) provisioned for each model table and its Global Secondary Indexes (GSI). This override is only valid if the "DynamoDBBillingMode" is set to "PROVISIONED".

```ts title="amplify/backend.ts"
import { defineBackend } from '@aws-amplify/backend';
import { data } from './data/resource';

const backend = defineBackend({
  data
});

const { cfnResources } = backend.data.resources;

cfnResources.amplifyDynamoDbTables["Todo"].provisionedThroughput = {
  readCapacityUnits: 5,
  writeCapacityUnits: 5,
};
```

### Example - Enable point-in-time recovery for a DynamoDB table

Enable/disable [DynamoDB point-in-time recovery](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-dynamodb-table-pointintimerecoveryspecification.html) for each model table.

```ts title="amplify/backend.ts"
import { defineBackend } from '@aws-amplify/backend';
import { data } from './data/resource';

const backend = defineBackend({
  data
});

const { cfnResources } = backend.data.resources;

cfnResources.amplifyDynamoDbTables['Todo'].pointInTimeRecoveryEnabled = true;
```


Contents of build-a-backend_data_query-data_index.txt:
import { getCustomStaticPath } from '@/utils/getCustomStaticPath';

export const meta = {
  title: 'Read application data',
  description: 'Read application data using list and get queries. You can filter query results, paginate list queries, specify only the data fields needed, and cancel requests. This guide covers how to perform these tasks to optimize data access in your application.',
  platforms: [
    'android',
    'angular',
    'flutter',
    'javascript',
    'nextjs',
    'react',
    'react-native',
    'swift',
    'vue'
  ]
};

export const getStaticPaths = async () => {
  return getCustomStaticPath(meta.platforms);
};

export function getStaticProps(context) {
  return {
    props: {
      meta
    }
  };

}

<InlineFilter filters={["javascript",  "react-native", "angular", "nextjs", "react", "vue"]}>

You can read application data using the Amplify Data client. In this guide, we will review the difference between reading data and getting data, how to filter query results to get just the data you need, and how to paginate results to make your data more manageable. We will also show you how to cancel these requests when needed.

Before you begin, you will need:

- An [application connected to the API](/[platform]/build-a-backend/data/connect-to-API/)
- Data already created to view

## List and get your data

Queries are used to read data through the API and include the `list` and `get` operations. Amplify Data automatically creates `list` and `get` queries for any `a.model()` type in your schema. The `list` query retrieves multiple items, such as Todo items, without needing to specific an identifier for a particular record. This is best suited for getting an overview or summary of items, or for enhancing the `list` operation to filter the items by specific criteria. When you want to query a single entry by an identifier, you would use `get` to retrieve a specific Todo item.

<Callout>

**Note:** The cost structure of your underlying data source can impact the cost to run some queries. For example, the `list` operation uses Amazon DynamoDB "scan operations," which can use more read request units than the `get` operation. You will want to review the associated costs for these operations for your data source. In our example, we are using DynamoDB. You can learn more about how DynamoDB costs are calculated by visiting [Amazon DynamoDB pricing](https://aws.amazon.com/dynamodb/pricing/).

</Callout>

You can list items by first generating the Data client with your backend Data schema. Then you can list items of your desired model:

```ts
import { generateClient } from 'aws-amplify/data';
import { type Schema } from '@/amplify/data/resource';

const client = generateClient<Schema>();

// list all items
const { data: todos, errors } = await client.models.Todo.list();

// get a specific item
const { data: todo, errors } = await client.models.Todo.get({
  id: '...',
});
```

<Accordion title='Troubleshoot unauthorized errors' headingLevel='4' eyebrow='Troubleshooting'>

Each API request uses an authorization mode. If you get unauthorized errors, you may need to update your authorization mode. To override the default authorization mode defined in your **amplify/data/resource.ts** file, pass an `authMode` property to the request or the client. The following examples show how you can mutate data with a custom authorization mode:

```ts
import { generateClient } from 'aws-amplify/data';
import { type Schema } from '@/amplify/data/resource';

const client = generateClient<Schema>();

const { errors, data: todos } = await client.models.Todo.list({
  authMode: 'apiKey',
});
```

</Accordion>

## Filter list queries

As your data grows, you will need to paginate your list queries. Fortunately, this is already built in to Amplify Data.

```ts
import { generateClient } from 'aws-amplify/data';
import { type Schema } from '@/amplify/data/resource';

const client = generateClient<Schema>();

const { data: todos, errors } = await client.models.Todo.list({
  filter: {
    content: {
      beginsWith: 'hello'
    }
  }
});
```

### Compound filters

You can combine filters with `and`, `or`, and `not` Boolean logic. Observe that `filter` is recursive in respect to those fields. So if, for example, you wanted to filter for `priority` values of 1 _or_ 2, you would do this:

```ts
import { generateClient } from 'aws-amplify/data';
import { type Schema } from '@/amplify/data/resource';

const client = generateClient<Schema>();

const { data: todos, errors } = await client.models.Todo.list({
  filter: {
    or: [
      {
        priority: { eq: '1' }
      },
      {
        priority: { eq: '2' }
      }
    ]
  }
});
```

Note that querying for `priority` of 1 and 2 would return no results, because this is Boolean logic instead of natural language.

## Paginate list queries

To paginate your list query results, make a subsequent list query request with the `nextToken` and `limit` input variable set. The `limit` variable limits how many results are returned. The response will include a `nextToken` you can use to request the next page of data. A `nextToken` is a very long string that represents the cursor to the starting item of the next query made with these filters.

```ts
import { generateClient } from 'aws-amplify/data';
import { type Schema } from '@/amplify/data/resource';

const client = generateClient<Schema>();

const {
  data: todos,
  nextToken, // Repeat this API call with the nextToken until the returned nextToken is `null`
  errors
} = await client.models.Todo.list({
  limit: 100, // default value is 100
  nextToken: 'eyJ2ZXJzaW9uejE1a2...' // previous nextToken
});
```

<InlineFilter filters={["react", "javascript", "nextjs", "react-native"]}>

If you're building a React application, you can use the `usePagination` hook in Amplify UI to help with managing the pagination user experience.

```js
import * as React from 'react';
import { Pagination } from '@aws-amplify/ui-react';

export const PaginationHasMorePagesExample = () => {
  const [pageTokens, setPageTokens] = React.useState([null]);
  const [currentPageIndex, setCurrentPageIndex] = React.useState(1);
  const [hasMorePages, setHasMorePages] = React.useState(true);

  const handleNextPage = async () => {
    if (hasMorePages && currentPageIndex === pageTokens.length) {
      const { data: todos, nextToken } = await client.models.Todo.list({
        nextToken: pageTokens[pageTokens.length - 1]
      });

      if (!nextToken) {
        setHasMorePages(false);
      }

      setPageTokens([...pageTokens, nextToken]);
    }

    setCurrentPageIndex(currentPageIndex + 1);
  };

  return (
    <Pagination
      currentPage={currentPageIndex}
      totalPages={pageTokens.length}
      hasMorePages={hasMorePages}
      onNext={handleNextPage}
      onPrevious={() => setCurrentPageIndex(currentPageIndex - 1)}
      onChange={(pageIndex) => setCurrentPageIndex(pageIndex)}
    />
  );
};
```

</InlineFilter>

<Callout>

**Limitations:**

- There is no API to get a total page count at this time. Note that scanning all items is a [potentially expensive operation](https://github.com/aws-amplify/amplify-js/issues/2901).
- You [cannot query by `page` number](https://github.com/aws-amplify/amplify-cli/issues/5086); you have to query by `nextToken`.

</Callout>

## Fetch only the data you need with custom selection set

A business domain model may contain many models with numerous fields. However, apps typically only need subsets of the data or fields to meet the requirements of different components or screens. It is necessary to have a mechanism to retrieve subsets of models and their relationships. This mechanism would help optimize data usage for screens and components by only transferring needed data. Having this capability would improve the app's data efficiency, latency, and the end user's perceived performance.

A **custom selection set** allows consumers to specify, on a per-call basis, the fields the consumer wants to retrieve; this is possible for all operations that return data (CRUDL + `observeQuery`). The desired fields are specified in a strongly typed way (discoverable through IntelliSense) with a "dot notation".

```ts
// same way for all CRUDL: .create, .get, .update, .delete, .list, .observeQuery
const { data: blogWithSubsetOfData, errors } = await client.models.Blog.get(
  { id: blog.id },
  {
    selectionSet: ['author.email', 'posts.*'],
  }
);
```

## TypeScript type helpers for Amplify Data

When using TypeScript, you frequently need to specify data model types for type generics. 

<InlineFilter filters={["react", "javascript", "nextjs", "react-native"]}>

For instance, with React's `useState`, you provide a type in TypeScript to ensure type-safety in your component code using the state. Use the `Schema["MODEL_NAME"]["type"]` pattern to get TypeScript types for the shapes of data models returned from the backend API.

```ts
import { type Schema } from '@/amplify/data/resource';

type Post = Schema['Post']['type'];

const [posts, setPosts] = useState<Post[]>([]);
```

</InlineFilter>

<InlineFilter filters={["angular", "vue"]}>

```ts
import { type Schema } from '../../../amplify/data/resource';

type Post = Schema['Post']['type'];
```

</InlineFilter>

You can combine the `Schema["MODEL_NAME"]["type"]` type with the `SelectionSet` helper type to describe the return type of API requests using the `selectionSet` parameter:

<InlineFilter filters={["react", "javascript", "nextjs", "react-native"]}>
```ts
import type { SelectionSet } from 'aws-amplify/data';
import type { Schema } from '../amplify/data/resource';


const selectionSet = ['content', 'blog.author.*', 'comments.*'] as const;
type PostWithComments = SelectionSet<Schema['Post']['type'], typeof selectionSet>;

// ...
const [posts, setPosts] = useState<PostWithComments[]>([]);

const fetchPosts = async () => {
  const { data: postsWithComments } = await client.models.Post.list({
    selectionSet,
  });
  setPosts(postsWithComments);
}
```

</InlineFilter>

<InlineFilter filters={['vue']}>
```ts
<script setup lang="ts">
import type { Schema } from '../../../amplify/data/resource';
import { ref, onMounted } from 'vue';
import { generateClient, type SelectionSet } from 'aws-amplify/data';

const client = generateClient<Schema>();

const selectionSet = ['content', 'blog.author.*', 'comments.*'] as const;

type PostWithComments = SelectionSet<
  Schema['Post']['type'], 
  typeof selectionSet
>;

const posts = ref<PostWithComments[]>([]);

const fetchPosts = async (): Promise<void> => {
  const { data: postsWithComments } = await client.models.Post.list({
    selectionSet,
  });
  posts.value = postsWithComments;
};

onMounted(() => {
  fetchPosts();
});
</script>

<template v-for="post in posts" :key="post.id">
  <li>{{ post.content }}</li>
</template>
```
</InlineFilter>

<InlineFilter filters={["angular"]}>
```ts
import type { Schema } from '../../../amplify/data/resource';
import { Component, OnInit } from '@angular/core';
import { generateClient, type SelectionSet } from 'aws-amplify/data';
import { CommonModule } from '@angular/common';

const client = generateClient<Schema>();

const selectionSet = ['content', 'blog.author.*', 'comments.*'] as const;

type PostWithComments = SelectionSet<
  Schema['Post']['type'],
  typeof selectionSet
>;

@Component({
  selector: 'app-todos',
  standalone: true,
  imports: [CommonModule],
  templateUrl: './todos.component.html',
  styleUrls: ['./todos.component.css'],
})
export class TodosComponent implements OnInit {
  posts: PostWithComments[] = [];

  constructor() {}

  ngOnInit(): void {
    this.fetchPosts();
  }

  async fetchPosts(): Promise<void> {
    const { data: postsWithComments } = await client.models.Post.list({
      selectionSet,
    });
    this.posts = postsWithComments;
  }
}
```
</InlineFilter>

## Cancel read requests

You can cancel any query API request by calling `.cancel` on the query request promise that's returned by `.list(...)` or `.get(...)`.

```javascript
const promise = client.models.Todo.list();
//  ^ Note: we're not awaiting the request, we're returning the promise

try {
  await promise;
} catch (error) {
  console.log(error);
  // If the error is because the request was cancelled you can confirm here.
  if (client.isCancelError(error)) {
    console.log(error.message); // "my message for cancellation"
    // handle user cancellation logic
  }
}
...

// To cancel the above request
client.cancel(promise, "my message for cancellation");
```

You need to ensure that the promise returned from `.list()` or `.get()` has not been modified. Typically, async functions wrap the promise being returned into another promise. For example, the following will **not** work:

```javascript
async function makeAPICall() {
  return client.models.Todo.list();
}
const promise = makeAPICall();

// The following will NOT cancel the request.
client.cancel(promise, 'my error message');
```

## Conclusion

Congratulations! You have finished the **Read application data** guide. In this guide, you learned how to read your data through `get` and `list` queries.

### Next steps

Our recommended next steps include subscribing to real-time events to look for mutations in your data and continuing to build out and customize your information architecture for your data. Some resources that will help with this work include:

- [Subscribe to real-time events](/[platform]/build-a-backend/data/subscribe-data/)
- [Customize your auth rules](/[platform]/build-a-backend/data/customize-authz/)
- [Customize your data model](/[platform]/build-a-backend/data/data-modeling/)
- [Add custom business logic](/[platform]/build-a-backend/data/custom-business-logic/)

</InlineFilter>

<InlineFilter filters={["swift"]}>

## Query by Id

Now that you were able to make a mutation, take the `Id` that was printed out and use it in your query to retrieve data.

<BlockSwitcher>

<Block name="Async/Await">

```swift
func getTodo() async {
    do {
        let result = try await Amplify.API.query(
           request: .get(Todo.self, byId: "9FCF5DD5-1D65-4A82-BE76-42CB438607A0")
        )

        switch result {
        case .success(let todo):
            guard let todo = todo else {
                print("Could not find todo")
                return
            }
            print("Successfully retrieved todo: \(todo)")
        case .failure(let error):
            print("Got failed result with \(error.errorDescription)")
        }
    } catch let error as APIError {
        print("Failed to query todo: ", error)
    } catch {
        print("Unexpected error: \(error)")
    }
}
```

</Block>

<Block name="Combine">

```swift
func getTodo() -> AnyCancellable {
    let sink = Amplify.Publisher.create {
        try await Amplify.API.query(
            request: .get(Todo.self, byId: "9FCF5DD5-1D65-4A82-BE76-42CB438607A0")
        )
    }
    .sink {
        if case let .failure(error) = $0 {
            print("Got failed event with error \(error)")
        }
    }
    receiveValue: { result in
        switch result {
        case .success(let todo):
            guard let todo = todo else {
                print("Could not find todo")
                return
            }
            print("Successfully retrieved todo: \(todo)")
        case .failure(let error):
            print("Got failed result with \(error.errorDescription)")
        }
    }
    return sink
}
```

</Block>

</BlockSwitcher>

## List Query

You can get the list of items using `.list` with optional parameters `limit` and `where` to specify the page size and condition. By default, the page size is 1000.


<BlockSwitcher>

<Block name="Async/Await">

```swift
func listTodos() async {
    let todo = Todo.keys
    let predicate = todo.name == "my first todo" && todo.description == "todo description"
    let request = GraphQLRequest<Todo>.list(Todo.self, where: predicate, limit: 1000)
    do {
        let result = try await Amplify.API.query(request: request)
        switch result {
        case .success(let todos):
            print("Successfully retrieved list of todos: \(todos)")
        case .failure(let error):
            print("Got failed result with \(error.errorDescription)")
        }
    } catch let error as APIError {
        print("Failed to query list of todos: ", error)
    } catch {
        print("Unexpected error: \(error)")
    }
}
```

</Block>

<Block name="Combine">

```swift
func listTodos() -> AnyCancellable {
    let todo = Todo.keys
    let predicate = todo.name == "my first todo" && todo.description == "todo description"
    let request = GraphQLRequest<Todo>.list(Todo.self, where: predicate, limit: 1000)
    let sink = Amplify.Publisher.create {
        try await Amplify.API.query(request: request)
    }
    .sink {
        if case let .failure(error) = $0 {
            print("Got failed event with error \(error)")
        }
    }
    receiveValue: { result in
    switch result {
        case .success(let todos):
            print("Successfully retrieved list of todos: \(todos)")
        case .failure(let error):
            print("Got failed result with \(error.errorDescription)")
        }
    }
    return sink
}
```

</Block>

</BlockSwitcher>

### List subsequent pages of items

If you are using SwiftUI and have SwiftUI imported in the same code file, you will need to import the class `Amplify.List` to resolve name collision with `SwiftUI.List`:

```swift
import SwiftUI
import Amplify
import class Amplify.List
```

For large data sets, you'll need to paginate through the results. After receiving the first page of results, you can check if there is a subsequent page and obtain the next page.

```swift
var todos: [Todo] = []
var currentPage: List<Todo>?

func listFirstPage() async {
    let todo = Todo.keys
    let predicate = todo.name == "my first todo" && todo.description == "todo description"
    let request = GraphQLRequest<Todo>.list(Todo.self, where: predicate, limit: 1000)
    do {
        let result = try await Amplify.API.query(request: request)
        switch result {
        case .success(let todos):
            print("Successfully retrieved list of todos: \(todos)")
            self.currentPage = todos
            self.todos.append(contentsOf: todos)
        case .failure(let error):
            print("Got failed result with \(error.errorDescription)")
        }
    } catch let error as APIError {
        print("Failed to query list of todos: ", error)
    } catch {
        print("Unexpected error: \(error)")
    }
}

func listNextPage() async {
    if let current = self.currentPage, current.hasNextPage() {
        do {
            let todos = try await current.getNextPage()
            self.todos.append(contentsOf: todos)
            self.currentPage = todos
        } catch {
            print("Failed to get next page \(error)")
        }
    }
}
```

## List all pages

If you want to get all pages, retrieve the subsequent page when you have successfully retrieved the first or next page.

1. Update the above method `listFirstPage()` to `listAllPages()`
2. Call `listNextPageRecursively()` in the success block of the query in `listAllPages()`
2. Update the `listNextPage()` to `listNextPageRecursively()`
3. Call `listNextPageRecursively()` in the success block of the query in `listNextPageRecursively()`

The completed changes should look like this:

```swift
var todos: [Todo] = []
var currentPage: List<Todo>?

func listAllPages() async { // 1. Updated from `listFirstPage()`
    let todo = Todo.keys
    let predicate = todo.name == "my first todo" && todo.description == "todo description"
    let request = GraphQLRequest<Todo>.list(Todo.self, where: predicate, limit: 1000)
    do {
        let result = try await Amplify.API.query(request: request)
        switch result {
        case .success(let todos):
            print("Successfully retrieved list of todos: \(todos)")
            self.currentPage = todos
            self.todos.append(contentsOf: todos)
            await self.listNextPageRecursively() // 2. Added
        case .failure(let error):
            print("Got failed result with \(error.errorDescription)")
        }
    } catch let error as APIError {
        print("Failed to query list of todos: ", error)
    } catch {
        print("Unexpected error: \(error)")
    }
}

func listNextPageRecursively() async { // 3. Updated from `listNextPage()`
    if let current = currentPage, current.hasNextPage() {
        do {
            let todos = try await current.getNextPage()
            self.todos.append(contentsOf: todos)
            self.currentPage = todos
            await self.listNextPageRecursively() // 4. Added
        } catch {
            print("Failed to get next page \(error)")
        }
    }
}
```

</InlineFilter>

<InlineFilter filters={["android"]}>

## Query item

Now that you were able to make a mutation, take the `Id` that was printed out and use it in your query to retrieve data.

<BlockSwitcher>
<Block name="Java">

```java
private void getTodo(String id) {
    Amplify.API.query(
        ModelQuery.get(Todo.class, id),
        response -> Log.i("MyAmplifyApp", ((Todo) response.getData()).getName()),
        error -> Log.e("MyAmplifyApp", error.toString(), error)
    );
}
```

</Block>
<Block name="Kotlin - Callbacks">

```kotlin
private fun getTodo(id: String) {
    Amplify.API.query(ModelQuery.get(Todo::class.java, id),
        { Log.i("MyAmplifyApp", "Query results = ${(it.data as Todo).name}") },
        { Log.e("MyAmplifyApp", "Query failed", it) }
    );
}
```

</Block>
<Block name="Kotlin - Coroutines">

```kotlin
suspend fun getTodo(id: String) {
   try {
       val response = Amplify.API.query(ModelQuery.get(Todo::class.java, id))
       Log.i("MyAmplifyApp", response.data.name)
   } catch (error: ApiException) {
       Log.e("MyAmplifyApp", "Query failed", error)
   }
}
```

</Block>
<Block name="RxJava">

```java
private void getTodo(String id) {
  RxAmplify.API.query(ModelQuery.get(Todo.class, id))
          .subscribe(
              response -> Log.i("MyAmplifyApp", ((Todo) response.getData()).getName()),
              error -> Log.e("MyAmplifyApp", error.toString(), error)
          );
}
```

</Block>
</BlockSwitcher>

## List items

You can get the list of items that match a condition that you specify in `Amplify.API.query`:

<BlockSwitcher>
<Block name="Java">

```java
Amplify.API.query(
    ModelQuery.list(Todo.class, Todo.NAME.contains("first")),
    response -> {
        for (Todo todo : response.getData()) {
            Log.i("MyAmplifyApp", todo.getName());
        }
    },
    error -> Log.e("MyAmplifyApp", "Query failure", error)
);
```

</Block>
<Block name="Kotlin - Callbacks">

```kotlin
Amplify.API.query(
    ModelQuery.list(Todo::class.java, Todo.NAME.contains("first")),
    { response ->
        response.data.forEach { todo ->
            Log.i("MyAmplifyApp", todo.name)
        }
    },
    { Log.e("MyAmplifyApp", "Query failure", it) }
)
```

</Block>
<Block name="Kotlin - Coroutines">

```kotlin
try {
    Amplify.API
        .query(ModelQuery.list(Todo::class.java, Todo.NAME.contains("first")))
        .response.data
        .items.forEach { todo -> Log.i("MyAmplifyApp", todo.name) }
} catch (error: ApiException) {
    Log.e("MyAmplifyApp", "Query failure", error)
}
```

</Block>
<Block name="RxJava">

```java
RxAmplify.API.query(ModelQuery.list(Todo.class, Todo.NAME.contains("first"))
    .subscribe(
        response -> {
            for (Todo todo : response.getData()) {
                Log.i("MyAmplifyApp", todo.getName());
            }
        },
        error -> Log.e("MyAmplifyApp", "Query failure", error)
    ));
```

</Block>
</BlockSwitcher>

> **Note**: This approach will only return up to the first 1,000 items.  To change this limit or make requests for additional results beyond this limit, use *pagination* as discussed below.

## List subsequent pages of items

A list query only returns the first 1,000 items by default, so for large data sets, you'll need to paginate through the results.  After receiving a page of results, you can obtain a `GraphQLRequest` for requesting the next page, if there are more results available.  The page size is configurable as well, as in the example below.

<BlockSwitcher>
<Block name="Java">

```java
public void queryFirstPage() {
    query(ModelQuery.list(Todo.class, ModelPagination.limit(1_000)));
}

private static void query(GraphQLRequest<PaginatedResult<Todo>> request) {
    Amplify.API.query(
        request,
        response -> {
            if (response.hasData()) {
                for (Todo todo : response.getData()) {
                    Log.d("MyAmplifyApp", todo.getName());
                }
                if (response.getData().hasNextResult()) {
                    query(response.getData().getRequestForNextResult());
                }
            }
        },
        failure -> Log.e("MyAmplifyApp", "Query failed.", failure)
    );
}
```

</Block>
<Block name="Kotlin - Callbacks">

```kotlin
fun queryFirstPage() {
    query(ModelQuery.list(Todo::class.java, ModelPagination.limit(1_000)))
}

fun query(request: GraphQLRequest<PaginatedResult<Todo>>) {
    Amplify.API.query(request,
        { response ->
            if (response.hasData()) {
                response.data.items.forEach { todo ->
                    Log.d("MyAmplifyApp", todo.name)
                }
                if (response.data.hasNextResult()) {
                    query(response.data.requestForNextResult)
                }
            }
        },
        { Log.e("MyAmplifyApp", "Query failed", it) }
    )
}
```

</Block>
<Block name="Kotlin - Coroutines">

```kotlin
suspend fun queryFirstPage() {
    query(ModelQuery.list(Todo::class.java,
        ModelPagination.firstPage().withLimit(1_000)))
}

suspend fun query(request: GraphQLRequest<PaginatedResult<Todo>>) {
    try {
        val response = Amplify.API.query(request)
        response.data.items.forEach { todo ->
            Log.d("MyAmplifyApp", todo.name)
        }
        if (response.data.hasNextResult()) {
            query(response.data.requestForNextResult)
        }
    } catch (error: ApiException) {
        Log.e("MyAmplifyApp", "Query failed.", error)
    }
}
```

</Block>

<Block name="RxJava">

```java
BehaviorSubject<GraphQLRequest<PaginatedResult<Todo>>> subject =
        BehaviorSubject.createDefault(ModelQuery.list(Todo.class, ModelPagination.limit(1_000)));
subject.concatMap(request -> RxAmplify.API.query(request).toObservable())
    .doOnNext(response -> {
        if (response.hasErrors()) {
            subject.onError(new Exception(String.format("Query failed: %s", response.getErrors())));
        } else if (!response.hasData()) {
            subject.onError(new Exception("Empty response from AppSync."));
        } else if(response.getData().hasNextResult()) {
            subject.onNext(response.getData().getRequestForNextResult());
        } else {
            subject.onComplete();
        }
    })
    .concatMapIterable(GraphQLResponse::getData)
    .subscribe(
        todo -> Log.d(TAG, "Todo: " + todo),
        error -> Log.e(TAG, "Error: " + error)
    );
```

</Block>
</BlockSwitcher>


</InlineFilter>

<InlineFilter filters={["flutter"]}>

## Query item

Now that you were able to make a mutation, take the `id` from the created `Todo` instance and use it to retrieve data.

```dart
Future<Todo?> queryItem(Todo queriedTodo) async {
  try {
    final request = ModelQueries.get(
      Todo.classType,
      queriedTodo.modelIdentifier,
    );
    final response = await Amplify.API.query(request: request).response;
    final todo = response.data;
    if (todo == null) {
      safePrint('errors: ${response.errors}');
    }
    return todo;
  } on ApiException catch (e) {
    safePrint('Query failed: $e');
    return null;
  }
}
```

## List items

You can get the list of items in `Amplify.API.query`:

```dart
Future<List<Todo?>> queryListItems() async {
  try {
    final request = ModelQueries.list(Todo.classType);
    final response = await Amplify.API.query(request: request).response;

    final todos = response.data?.items;
    if (todos == null) {
      safePrint('errors: ${response.errors}');
      return const [];
    }
    return todos;
  } on ApiException catch (e) {
    safePrint('Query failed: $e');
    return const [];
  }
}
```

### List subsequent pages of items

For large data sets, you'll need to paginate through the results. After receiving the first page of results, you can check if there is a subsequent page and obtain the next page.

```dart
const limit = 100;

Future<List<Todo?>> queryPaginatedListItems() async {
  final firstRequest = ModelQueries.list<Todo>(Todo.classType, limit: limit);
  final firstResult = await Amplify.API.query(request: firstRequest).response;
  final firstPageData = firstResult.data;

  // Indicates there are > 100 todos and you can get the request for the next set.
  if (firstPageData?.hasNextResult ?? false) {
    final secondRequest = firstPageData!.requestForNextResult;
    final secondResult =
        await Amplify.API.query(request: secondRequest!).response;
    return secondResult.data?.items ?? <Todo?>[];
  } else {
    return firstPageData?.items ?? <Todo?>[];
  }
}
```

## Query Predicates

Models also support the use of query predicates for comparison. These are accessible from the Model's attributes, for example `Blog["attribute"]["operator"]`.

Supported operators:
- `eq` - equal
- `ne` - not equal
- `gt` - greater than
- `ge` - greater than or equal
- `lt` - less than
- `le` - less than or equal
- `beginsWith` - Matches models where the given field begins with the provided value.
- `between` - Matches models where the given field is between the provided start and end values.
- `contains` - Matches models where the given field contains the provided value.

### Basic Equality Operator

Query for equality on a model's attribute.

```dart
const blogTitle = 'Test Blog 1';
final queryPredicate = Blog.NAME.eq(blogTitle);

final request = ModelQueries.list<Blog>(
  Blog.classType,
  where: queryPredicate,
);
final response = await Amplify.API.query(request: request).response;
final blogFromResponse = response.data?.items.first;
```

### Fetch by Parent ID

Get all Posts by parent ID

```dart
final blogId = blog.id;

final request = ModelQueries.list(
  Post.classType,
  where: Post.BLOG.eq(blogId),
);
final response = await Amplify.API.query(request: request).response;
final data = response.data?.items ?? <Post?>[];
```

### Less than

Return Posts with a rating less than 5.

```dart
const rating = 5;

final request = ModelQueries.list(
  Post.classType,
  where: Post.RATING.lt(rating),
);
final response = await Amplify.API.query(request: request).response;

final data = response.data?.items ?? <Post?>[];
```

</InlineFilter>


Contents of build-a-backend_data_set-up-data_index.txt:
import { getCustomStaticPath } from '@/utils/getCustomStaticPath';

export const meta = {
  title: 'Set up Amplify Data',
  description:
    'Create a new cloud API that connects your app with new or existing data sources.',
  platforms: [
    'android',
    'angular',
    'flutter',
    'javascript',
    'nextjs',
    'react',
    'react-native',
    'swift',
    'vue'
  ]
};

export const getStaticPaths = async () => {
  return getCustomStaticPath(meta.platforms);
};

export function getStaticProps(context) {
  return {
    props: {
      meta
    }
  };

}

In this guide, you will learn how to set up Amplify Data. This includes building a real-time API and database using TypeScript to define your data model, and securing your API with authorization rules. We will also explore using AWS Lambda to scale to custom use cases.

Before you begin, you will need:

- [Node.js](https://nodejs.org/) v18.16.0 or later
- [npm](https://www.npmjs.com/) v6.14.4 or later
- [git](https://git-scm.com/) v2.14.1 or later

With Amplify Data, you can build a secure, real-time API backed by a database in minutes. After you define your data model using TypeScript, Amplify will deploy a real-time API for you. This API is powered by AWS AppSync and connected to an Amazon DynamoDB database. You can secure your API with authorization rules and scale to custom use cases with AWS Lambda.

## Building your data backend

If you've run `npm create amplify@latest` already, you should see an `amplify/data/resource.ts` file, which is the central location to configure your data backend. The most important element is the `schema` object, which defines your backend data models (`a.model()`) and custom queries (`a.query()`), mutations (`a.mutation()`), and subscriptions (`a.subscription()`).

```ts title="amplify/data/resource.ts"
import { a, defineData, type ClientSchema } from '@aws-amplify/backend';

const schema = a.schema({
  Todo: a.model({
      content: a.string(),
      isDone: a.boolean()
    })
    .authorization(allow => [allow.publicApiKey()])
});

// Used for code completion / highlighting when making requests from frontend
export type Schema = ClientSchema<typeof schema>;

// defines the data resource to be deployed
export const data = defineData({
  schema,
  authorizationModes: {
    defaultAuthorizationMode: 'apiKey',
    apiKeyAuthorizationMode: { expiresInDays: 30 }
  }
});
```

Every `a.model()` automatically creates the following resources in the cloud:

- a DynamoDB database table to store records
- query and mutation APIs to create, read (list/get), update, and delete records
- `createdAt` and `updatedAt` fields that help you keep track of when each record was initially created or when it was last updated
- real-time APIs to subscribe for create, update, and delete events of records

The `allow.publicApiKey()` rule designates that anyone authenticated using an API key can create, read, update, and delete todos.

To deploy these resources to your cloud sandbox, run the following CLI command in your terminal:

<InlineFilter filters={["react", "angular", "javascript", "vue", "nextjs", "react-native"]}>

```bash title="Terminal" showLineNumbers={false}
npx ampx sandbox
```

</InlineFilter>

<InlineFilter filters={["android"]}>

```bash title="Terminal" showLineNumbers={false}
npx ampx sandbox --outputs-out-dir <path_to_app/src/main/res/raw/>
```

</InlineFilter>

<InlineFilter filters={["swift"]}>

```bash title="Terminal" showLineNumbers={false}
npx ampx sandbox --outputs-out-dir <path_to_swift_project>
```

</InlineFilter>
<InlineFilter filters={["flutter"]}>

```bash title="Terminal" showLineNumbers={false}
npx ampx sandbox --outputs-format dart --outputs-out-dir lib
```

</InlineFilter>

## Connect your application code to the data backend

Once the cloud sandbox is up and running, it will also create an `amplify_outputs.json` file, which includes the relevant connection information to your data backend, like your API endpoint URL and API key.

To connect your frontend code to your backend, you need to:

1. Configure the Amplify library with the Amplify client configuration file (`amplify_outputs.json`)
2. Generate a new API client from the Amplify library
3. Make an API request with end-to-end type-safety

<InlineFilter filters={["react", "angular", "javascript", "vue", "nextjs", "react-native"]}>

First, install the Amplify client library to your project:

```bash title="Terminal" showLineNumbers={false}
npm add aws-amplify
```
</InlineFilter>

<InlineFilter filters={["react", "angular", "javascript", "nextjs", "react-native"]}>

In your app's entry point, typically **main.tsx** for React apps created using Vite, make the following edits:

```tsx title="src/main.tsx"
import { Amplify } from 'aws-amplify';
import outputs from '../amplify_outputs.json';

Amplify.configure(outputs);
```

</InlineFilter>

<InlineFilter filters={["vue"]}>

In your app's entry point, typically **main.ts** for Vue apps created using Vite, make the following edits:

```tsx title="src/main.ts"
import { Amplify } from 'aws-amplify';
import outputs from '../amplify_outputs.json';

Amplify.configure(outputs);
```

</InlineFilter>


<InlineFilter filters={["android"]}>

Under Gradle Scripts, open build.gradle (Module :app), add the following lines:

```kotlin title="app/build.gradle.kts"
android {
    compileOptions {
        // Support for Java 8 features
        isCoreLibraryDesugaringEnabled = true
        sourceCompatibility = JavaVersion.VERSION_1_8
        targetCompatibility = JavaVersion.VERSION_1_8
    }
}

dependencies {
    // Amplify API dependencies
    // highlight-start
    implementation("com.amplifyframework:aws-api:ANDROID_VERSION")
    // highlight-end
    // ... other dependencies
    coreLibraryDesugaring("com.android.tools:desugar_jdk_libs:2.0.3")
}
```

Click **Sync Now** in the notification bar above the file editor to sync these dependencies.

Next, configure the Amplify client library with the generated `amplify_outputs.json` file to make it aware of the backend API endpoint. *Note: verify that the **amplify_outputs.json** file is present in your **res/raw/** folder.

Create a new `MyAmplifyApp` class that inherits from `Application` with the following code:

<Callout warning>
Before calling the `Amplify.configure` function, make sure to either download the `amplify_outputs.json` file from the console, or generate it with the following command: 

```bash title="Terminal" showLineNumbers={false}
npx ampx generate outputs --app-id <app-id> --branch main --out-dir app/src/main/res/raw
```

Next, be sure the file you generated or downloaded is in the appropriate resource directory for your application (for example, `app/src/main/res/raw`) in your Android project. Otherwise, you will not be able to compile your application.
</Callout>

```kt
package com.example.myapplication

import android.app.Application
import android.util.Log
import com.amplifyframework.AmplifyException
import com.amplifyframework.api.aws.AWSApiPlugin
import com.amplifyframework.core.Amplify
import com.amplifyframework.core.configuration.AmplifyOutputs

class MyAmplifyApp : Application() {
    override fun onCreate() {
        super.onCreate()

        try {
            // Adds the API plugin that is used to issue queries and mutations
            // to your backend.
            Amplify.addPlugin(AWSApiPlugin())
            // Configures the client library to be aware of your backend API
            // endpoint and authorization modes.
            Amplify.configure(AmplifyOutputs(R.raw.amplify_outputs), applicationContext)
            Log.i("Tutorial", "Initialized Amplify")
        } catch (error: AmplifyException) {
            Log.e("Tutorial", "Could not initialize Amplify", error)
        }
    }
}
```

This overrides the `onCreate()` to initialize Amplify when your application is launched.

Next, configure your application to use your new custom Application class. Open **manifests** > **AndroidManifest.xml**, and add an `android:name` attribute with the value of your new class name:

```xml
<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools">
    <application
        // highlight-next-line
        android:name=".MyAmplifyApp"
        ...
    >
      <!-- ... -->
    </application>
</manifest>
```

Build and run the application. In Logcat, you'll see a log line indicating success:

```console title="Logcat" showLineNumbers={false}
com.example.MyAmplifyApp I/MyAmplifyApp: Initialized Amplify
```

Finally, let's generate the GraphQL client code for your Android application. Amplify Data uses GraphQL under the hood to make query, mutation, and subscription requests. The generated GraphQL client code helps you to author fully-typed API requests without needing to hand-author GraphQL requests and manually map them to Kotlin or Java code.

```bash title="Terminal" showLineNumbers={false}
npx ampx generate graphql-client-code --format modelgen --model-target java --out <path_to_app/src/main/java/>
```

</InlineFilter>

<InlineFilter filters={["swift"]}>

Drag and drop the **amplify_outputs.json** file from the Finder into Xcode.

Next, add Amplify Library for Swift through Swift Package Manager. In Xcode, select **File** > **Add Packages...**.

Then, enter the Amplify Library for Swift GitHub repo URL (https://github.com/aws-amplify/amplify-swift) into the search bar and hit **Enter**.

Once the result is loaded, choose Up to **Next Major Version** as the **Dependency Rule**, then click **Add Package**.

Choose which of the libraries you want added to your project. For this tutorial, select **AWSAPIPlugin** and **Amplify**, then click **Add Package**.

Now let's add the necessary plugins into the Swift application by customizing the `init()` function of your app:

```swift title="MyAmplifyApp"
import SwiftUI
// highlight-start
import Amplify
import AWSAPIPlugin
// highlight-end

@main
struct MyAmplifyApp: App {

    // highlight-start
    init() {
        let awsApiPlugin = AWSAPIPlugin(modelRegistration: AmplifyModels())
        do {
            try Amplify.add(plugin: awsApiPlugin)
            try Amplify.configure(with: .amplifyOutputs)
            print("Initialized Amplify");
        } catch {
            // simplified error handling for the tutorial
            print("Could not initialize Amplify: \(error)")
        }
    }
    // highlight-end

    var body: some Scene {
        WindowGroup {
            ContentView()
        }
    }
}
```

Finally, let's generate the GraphQL client code for your Swift application. Amplify Data uses GraphQL under the hood to make query, mutation, and subscription requests. The generated GraphQL client code helps you to author fully-typed API requests without needing to hand-author GraphQL requests and manually map them to Swift code.

```bash title="Terminal" showLineNumbers={false}
npx ampx generate graphql-client-code --format modelgen --model-target swift --out <path_to_swift_project>/AmplifyModels
```

Drag and drop the **AmplifyModels** folder into your Xcode project to add the generated files.

</InlineFilter>

<InlineFilter filters={["flutter"]}>

From your project root directory, find and modify your **pubspec.yaml** and add the Amplify plugins to the project dependencies.

```yaml title="pubspec.yaml"
dependencies:
  // highlight-start
  amplify_api: ^2.0.0
  amplify_flutter: ^2.0.0
  // highlight-end
  flutter:
    sdk: flutter
```

Install the dependencies by running the following command. Depending on your development environment, you may perform this step via your IDE (or it may even be performed for you automatically).

```bash title="Terminal" showLineNumbers={false}
flutter pub get
```

Now, let's generate the GraphQL client code for your Flutter application. Amplify Data uses GraphQL under the hood to make query, mutation, and subscription requests. The generated GraphQL client code helps you to author fully-typed API requests without needing to hand-author GraphQL requests and manually map them to Dart code.

```bash title="Terminal" showLineNumbers={false}
npx ampx generate graphql-client-code --format modelgen --model-target dart --out <path_to_flutter_project>/lib/models
```

Finally, let's add the necessary plugins into the Flutter application by customizing the `main()` function of the **lib/main.dart** file:

```dart title="lib/main.dart"
// highlight-start
import 'package:amplify_api/amplify_api.dart';
import 'package:amplify_flutter/amplify_flutter.dart';
// highlight-end
import 'package:flutter/material.dart';

// highlight-start
import 'amplify_outputs.dart';
import 'models/ModelProvider.dart';
// highlight-end

Future<void> main() async {
  // highlight-start
  try {
    final api = AmplifyAPI(
      options: APIPluginOptions(
        modelProvider: ModelProvider.instance
        )
      );
    await Amplify.addPlugins([api]);
    await Amplify.configure(amplifyConfig);

    safePrint('Successfully configured Amplify');
  } on Exception catch (e) {
    safePrint('Error configuring Amplify: $e');
  }
  // highlight-end

  runApp(const MyApp());
}
```

</InlineFilter>
## Write data to your backend

<InlineFilter filters={["react", "angular", "javascript", "nextjs", "react-native"]}>

Let's first add a button to create a new todo item. To make a "create Todo" API request, generate the data client using `generateClient()` in your frontend code, and then call `.create()` operation for the Todo model. The Data client is a fully typed client that gives you in-IDE code completion. To enable this in-IDE code completion capability, pass in the `Schema` type to the `generateClient` function.

</InlineFilter>

<InlineFilter filters={["react", "javascript", "nextjs", "react-native"]}>

```tsx title="src/TodoList.tsx"
import type { Schema } from '../amplify/data/resource'
import { generateClient } from 'aws-amplify/data'

const client = generateClient<Schema>()

export default function TodoList() {
  const createTodo = async () => {
    await client.models.Todo.create({
      content: window.prompt("Todo content?"),
      isDone: false
    })
  }

  return <div>
    <button onClick={createTodo}>Add new todo</button>
  </div>
}
```
</InlineFilter>


<InlineFilter filters={["vue"]}>

```html title="src/TodoList.vue"
<script setup lang="ts">
import type { Schema } from '../../amplify/data/resource'
import { generateClient } from 'aws-amplify/data'

const client = generateClient<Schema>()

async function createTodo() {
  await client.models.Todo.create({
    content: window.prompt("Todo content?"),
    isDone: false
  })
}
</script>

<template>
  <div>
    <button @click="createTodo">Add new todo</button>
  </div>
</template>
```
</InlineFilter>

<InlineFilter filters={["react", "angular", "javascript", "nextjs", "react-native"]}>
Run the application in local development mode with `npm run dev` and check your network tab after creating a todo. You should see a successful request to a `/graphql` endpoint.

<Callout>

Try playing around with the code completion of `.update(...)` and `.delete(...)` to get a sense of other mutation operations.

</Callout>
</InlineFilter>

<InlineFilter filters={["angular"]}>
```ts title="todo-list.component.ts"
import type { Schema } from '../amplify/data/resource';
import { Component } from '@angular/core';
import { generateClient } from 'aws-amplify/data';

const client = generateClient<Schema>();

@Component({
  selector: 'app-todo-list',
  template: `
    <button (click)="createTodo()">Add new todo</button>
  `
})
export class TodoListComponent {
  async createTodo() {
    await client.models.Todo.create({
      content: window.prompt("Todo content?"),
      isDone: false
    });
  }
}
```

Run the application in local development mode and check your network tab after creating a todo. You should see a successful request to a `/graphql` endpoint.

<Callout>

Try playing around with the code completion of `.update(...)` and `.delete(...)` to get a sense of other mutation operations.

</Callout>
</InlineFilter>

<InlineFilter filters={["android"]}>

In your MainActivity, add a button to create a new todo.

```kt title="MainActivity.kt"
// imports

class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            MyApplicationTheme {
                // A surface container using the 'background' color from the theme
                Surface(
                    modifier = Modifier.fillMaxSize(),
                    color = MaterialTheme.colorScheme.background
                ) {
                    // highlight-start
                    Column {
                        Button(onClick = {
                            val todo = Todo.builder()
                                .content("My first todo")
                                .isDone(false)
                                .build()

                            Amplify.API.mutate(ModelMutation.create(todo),
                                { Log.i("MyAmplifyApp", "Added Todo with id: ${it.data.id}")},
                                { Log.e("MyAmplifyApp", "Create failed", it)},
                            )
                        }) {
                            Text(text = "Create Todo")
                        }
                    }
                    // highlight-end
                }
            }
        }
    }
}
```

Build and run your app. Then, click on "Create Todo" on the app. Your Logcat should show you that a todo was successfully added:

```console title="Logcat" showLineNumbers={false}
com.example.MyAmplifyApp I/MyAmplifyApp: Added Todo with id: SOME_TODO_ID
```

</InlineFilter>

<InlineFilter filters={["swift"]}>

Create a new file called `TodoViewModel.swift` and the `createTodo` function with the following code:

```swift title="TodoViewModel.swift"
import Foundation
import Amplify

@MainActor
class TodoViewModel: ObservableObject {
    func createTodo() {
        let todo = Todo(
            content: "Build iOS Application",
            isDone: false
        )
        Task {
            do {
                let result = try await Amplify.API.mutate(request: .create(todo))
                switch result {
                case .success(let todo):
                    print("Successfully created todo: \(todo)")
                case .failure(let error):
                    print("Got failed result with \(error.errorDescription)")
                }
            } catch let error as APIError {
                print("Failed to create todo: ", error)
            } catch {
                print("Unexpected error: \(error)")
            }
        }
    }
}

```

Update `ContentView.swift` with the following code:

```swift title="ContentView.swift"
struct ContentView: View {

    // highlight-start
    // Create an observable object instance.
    @StateObject var vm = TodoViewModel()
    // highlight-end

    var body: some View {
        // highlight-start
        VStack {
            Button(action: {
                vm.createTodo()
            }) {
                HStack {
                    Text("Add a New Todo")
                    Image(systemName: "plus")
                }
            }
            .accessibilityLabel("New Todo")
        }
        // highlight-end
    }
}
```

Now if you run the application, and click on the "Add a New Todo" button, you should see a log indicating a todo was created:

```console title="Logs" showLineNumbers={false}
Successfully created todo: Todo(id: XYZ ...)
```

</InlineFilter>

<InlineFilter filters={['flutter']}>

In your page, let's add a floating action button that creates a new todo.

```dart title="lib/main.dart"
// ... main()
class MyApp extends StatelessWidget {
  const MyApp({super.key});

  @override
  Widget build(BuildContext context) {
    return const MaterialApp(
      home: MyHomePage(),
    );
  }
}

class MyHomePage extends StatefulWidget {
  const MyHomePage({super.key});

  @override
  State<MyHomePage> createState() => _MyHomePageState();
}

class _MyHomePageState extends State<MyHomePage> {

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      body: Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: <Widget>[
            const Text(
              'Your todos',
            ),
          ],
        ),
      ),
      floatingActionButton: FloatingActionButton(
        onPressed: () async {
          final newTodo = Todo(content: "New Flutter todo", isDone: false);
          final request = ModelMutations.create(newTodo);
          final response = await Amplify.API.mutate(request: request).response;
          if (response.hasErrors) {
            safePrint('Creating Todo failed.');
          } else {
            safePrint('Creating Todo successful.');
          }
        },
        tooltip: 'Add todo',
        child: const Icon(Icons.add),
      ), // This trailing comma makes auto-formatting nicer for build methods.
    );
  }
}
```

Now if you run the application, and click on the floating action button, you should see a log indicating a todo was created:

```console showLineNumbers={false}
Creating Todo successful.
```

</InlineFilter>

## Read data from your backend

Next, list all your todos and then refetch the todos after a todo has been added:

<InlineFilter filters={["react","javascript", "nextjs", "react-native"]}>
```tsx title="src/TodoList.tsx"
import { useState, useEffect } from "react";
import type { Schema } from "../amplify/data/resource";
import { generateClient } from "aws-amplify/data";

const client = generateClient<Schema>();

export default function TodoList() {
  const [todos, setTodos] = useState<Schema["Todo"]["type"][]>([]);

  const fetchTodos = async () => {
    const { data: items, errors } = await client.models.Todo.list();
    setTodos(items);
  };

  useEffect(() => {
    fetchTodos();
  }, []);

  const createTodo = async () => {
    await client.models.Todo.create({
      content: window.prompt("Todo content?"),
      isDone: false,
    });

    fetchTodos();
  }

  return (
    <div>
      <button onClick={createTodo}>Add new todo</button>
      <ul>
        {todos.map(({ id, content }) => (
          <li key={id}>{content}</li>
        ))}
      </ul>
    </div>
  );
}
```

</InlineFilter>

<InlineFilter filters={["vue"]}>
```html title="src/TodoList.vue"
<script setup lang="ts">
import { onMounted, ref } from 'vue';
import type { Schema } from '../../amplify/data/resource'
import { generateClient } from 'aws-amplify/data'

const client = generateClient<Schema>()

// create a reactive reference to the array of todos
const todos = ref<Array<Schema['Todo']['type']>>([]);

function fetchTodos() {
  const { data: items, errors } = await client.models.Todo.list();
  todos.value = items; 
}

async function createTodo() {
  await client.models.Todo.create({
    content: window.prompt("Todo content?"),
    isDone: false
  })
  fetchTodos();
}

 onMounted(() => {
  fetchTodos();
});

</script>

<template>
  <div>
    <button @click="createTodo">Add new todo</button>
    <ul>
     <li 
       v-for="todo in todos" 
       :key="todo.id">
       {{ todo.content }}
     </li>
    </ul>
  </div>
</template>
```

</InlineFilter>

<InlineFilter filters={["angular"]}>
```ts title="todo-list.component.ts"
import type { Schema } from '../amplify/data/resource';
import { Component, OnInit } from '@angular/core';
import { generateClient } from 'aws-amplify/data';

const client = generateClient<Schema>();

@Component({
  selector: 'app-todo-list',
  template: `
    <div>
      <button (click)="createTodo()">Add new todo</button>
      <ul>
        <li *ngFor="let todo of todos">{{ todo.content }}</li>
      </ul>
    </div>
  `
})
export class TodoListComponent implements OnInit {
  todos: Schema['Todo']['type'][] = [];

  async ngOnInit() {
    await this.fetchTodos();
  }

  async fetchTodos() {
    const { data: items } = await client.models.Todo.list();
    this.todos = items;
  }

  async createTodo() {
    await client.models.Todo.create({
      content: window.prompt('Todo content?'),
      isDone: false
    });
    await this.fetchTodos();
  }
}
```
</InlineFilter>

<InlineFilter filters={["android"]}>

Start by creating a new `TodoList` @Composable that fetches the data on the initial display of the TodoList:

```kt title="MainActivity.kt"
@Composable
fun TodoList() {
    var todoList by remember { mutableStateOf(emptyList<Todo>()) }

    LaunchedEffect(Unit) {
        // API request to list all Todos
        Amplify.API.query(ModelQuery.list(Todo::class.java),
            {
                todoList = it.data.items.toList()
            },
            { Log.e("MyAmplifyApp", "Failed to query.", it)})
    }

    LazyColumn {
        items(todoList) { todo ->
            Row {
                // Render your activity item here
                Checkbox(checked = todo.isDone, onCheckedChange = null)
                Text(text = todo.content)
            }
        }
    }
}
```

If you build and rerun the application, you should see the todo that was created in the previous build. But notice how when you click on the "create Todo" button, it doesn't add any new todos to the list below until the next time your app relaunches. To solve this, let's add real-time updates to the todo list.

</InlineFilter>
<InlineFilter filters={["swift"]}>

Update the `listTodos` function in the `TodoViewModel.swift` for listing to-do items:

```swift title="TodoViewModel.swift"
@MainActor
class TodoViewModel: ObservableObject {

    // highlight-next-line
    @Published var todos: [Todo] = []

    func createTodo() {
        /// ...
    }

    // highlight-start
    func listTodos() {
        Task {
            do {
                let result = try await Amplify.API.query(request: .list(Todo.self))
                switch result {
                case .success(let todos):
                    print("Successfully retrieved list of todos: \(todos)")
                    self.todos = todos.elements
                case .failure(let error):
                    print("Got failed result with \(error.errorDescription)")
                }
            } catch let error as APIError {
                print("Failed to query list of todos: ", error)
            } catch {
                print("Unexpected error: \(error)")
            }
        }
    }
    // highlight-end
}
```

Now let's update the UI code to observe the todos. 

```swift title="ContentView.swift"
import SwiftUI
import Amplify

struct ContentView: View {
    @StateObject var vm = TodoViewModel()

    var body: some View {
        VStack {
            // highlight-start
            List(vm.todos, id: \.id) { todo in
                Text(todo.content ?? "")
            }
            // highlight-end
            // .. Add a new Todo button
        }
        // highlight-start
        .task {
            await vm.listTodos()
        }
        // highlight-end
    }
}

```

</InlineFilter>

<InlineFilter filters={['flutter']}>

Start by adding a new list to track the todos and the ability to fetch the todo list when it first renders:

```dart title="lib/main.dart"
// ...main()

class MyApp extends StatelessWidget {
  const MyApp({super.key});

  @override
  Widget build(BuildContext context) {
    return const MaterialApp(
      home: MyHomePage(),
    );
  }
}

class MyHomePage extends StatefulWidget {
  const MyHomePage({super.key});

  @override
  State<MyHomePage> createState() => _MyHomePageState();
}

class _MyHomePageState extends State<MyHomePage> {
  List<Todo> _todos = [];

  @override
  void initState() {
    super.initState();
    _refreshTodos();
  }

  Future<void> _refreshTodos() async {
    try {
      final request = ModelQueries.list(Todo.classType);
      final response = await Amplify.API.query(request: request).response;

      final todos = response.data?.items;
      if (response.hasErrors) {
        safePrint('errors: ${response.errors}');
        return;
      }
      setState(() {
        safePrint(todos);
        _todos = todos!.whereType<Todo>().toList();
      });
    } on ApiException catch (e) {
      safePrint('Query failed: $e');
    }
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      body: Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: <Widget>[
            const Text(
              'Your todos',
            ),
            _todos.isEmpty == true
                ? const Center(
                    child: Text(
                      "The list is empty.\nAdd some items by clicking the floating action button.",
                      textAlign: TextAlign.center,
                    ),
                  )
                : ListView.builder(
                    scrollDirection: Axis.vertical,
                    shrinkWrap: true,
                    itemCount: _todos.length,
                    itemBuilder: (context, index) {
                      final todo = _todos[index];
                      return CheckboxListTile.adaptive(
                        value: todo.isDone,
                        title: Text(todo.content!),
                        onChanged: (isChecked) async {},
                      );
                    }),
          ],
        ),
      ),
      floatingActionButton: FloatingActionButton(
        onPressed: () async {
          final newTodo = Todo(content: "New Flutter todo", isDone: false);
          final request = ModelMutations.create(newTodo);
          final response = await Amplify.API.mutate(request: request).response;
          if (response.hasErrors) {
            safePrint('Creating Todo failed.');
          } else {
            safePrint('Creating Todo successful.');
          }
        },
        tooltip: 'Add todo',
        child: const Icon(Icons.add),
      ), // This trailing comma makes auto-formatting nicer for build methods.
    );
  }
}

```

</InlineFilter>

## Subscribe to real-time updates

<InlineFilter filters={["react", "javascript", "nextjs", "react-native"]}>

You can also use `observeQuery` to subscribe to a live feed of your backend data. Let's refactor the code to use a real-time observeQuery instead.

```tsx title="src/App.tsx"
import type { Schema } from "../amplify/data/resource";
import { useState, useEffect } from "react";
import { generateClient } from "aws-amplify/data";

const client = generateClient<Schema>();

export default function TodoList() {
  const [todos, setTodos] = useState<Schema["Todo"]["type"][]>([]);

  useEffect(() => {
    const sub = client.models.Todo.observeQuery().subscribe({
      next: ({ items }) => {
        setTodos([...items]);
      },
    });

    return () => sub.unsubscribe();
  }, []);

  const createTodo = async () => {
    await client.models.Todo.create({
      content: window.prompt("Todo content?"),
      isDone: false,
    });
    // no more manual refetchTodos required!
    // - fetchTodos()
  };

  return (
    <div>
      <button onClick={createTodo}>Add new todo</button>
      <ul>
        {todos.map(({ id, content }) => (
          <li key={id}>{content}</li>
        ))}
      </ul>
    </div>
  );
}
```
</InlineFilter>

<InlineFilter filters={["vue"]}>
You can also use `observeQuery` to subscribe to a live feed of your backend data. Let's refactor the code to use a real-time observeQuery instead.

```html title="src/TodoList.vue"
<script setup lang="ts">
import { onMounted, ref } from 'vue';
import type { Schema } from '../../amplify/data/resource'
import { generateClient } from 'aws-amplify/data'

const client = generateClient<Schema>()

// create a reactive reference to the array of todos
const todos = ref<Array<Schema['Todo']["type"]>>([]);

function fetchTodos() {
  client.models.Todo.observeQuery().subscribe({
    next: ({ items, isSynced }) => {
      todos.value = items
     },
  }); 
}

async function createTodo() {
  await client.models.Todo.create({
    content: window.prompt("Todo content?"),
    isDone: false
  })
  // no more manual refetchTodos required!
  // - fetchTodos()
}

 onMounted(() => {
  fetchTodos();
});

</script>

<template>
  <div>
    <button @click="createTodo">Add new todo</button>
    <ul>
     <li 
       v-for="todo in todos" 
       :key="todo.id">
       {{ todo.content }}
     </li>
    </ul>
  </div>
</template>
```
</InlineFilter>

<InlineFilter filters={["angular"]}>

You can also use `observeQuery` to subscribe to a live feed of your backend data. Let's refactor the code to use a real-time observeQuery instead.

```ts title="todo-list.component.ts"
import type { Schema } from '../../../amplify/data/resource';
import { Component, OnInit } from '@angular/core';
import { CommonModule } from '@angular/common';
import { generateClient } from 'aws-amplify/data';
import { Subscription } from 'rxjs';

const client = generateClient<Schema>();

@Component({
  selector: 'app-todos',
  standalone: true,
  imports: [CommonModule],
  template: `
    <main>
      <h1>My todos</h1>
      <button (click)="createTodo()">+ new</button>
      <ul>
        <li *ngFor="let todo of todos">
          {{ todo.content }}
        </li>
      </ul>
      <div>
        🥳 App successfully hosted. Try creating a new todo.
        <br />
        <a href="https://docs.amplify.aws/gen2/start/quickstart/">
          Review next steps of this tutorial.
        </a>
      </div>
    </main>
  `,
})
export class TodosComponent implements OnInit {
  todos: Schema['Todo']['type'][] = [];
  subscription?: Subscription;

  ngOnInit(): void {
    this.listTodos();
  }

  ngOnDestroy(): void {
    this.subscription?.unsubscribe();
  }

  listTodos() {
    try {
      this.subscription = client.models.Todo.observeQuery().subscribe({
        next: ({ items, isSynced }) => {
          this.todos = items;
        },
      });
    } catch (error) {
      console.error('error fetching todos', error);
    }
  }

  createTodo() {
    try {
      client.models.Todo.create({
        content: window.prompt('Todo content'),
      });
      this.listTodos();
    } catch (error) {
      console.error('error creating todos', error);
    }
  }
}
```

Now try to open your app in two browser windows and see how creating a todo in one window automatically adds the todo in the second window as well.

<Callout>

You can also use `.onCreate`, `.onUpdate`, or `.onDelete` to subscribe to specific events. Review [Subscribe to real-time events](/[platform]/build-a-backend/data/subscribe-data) to learn more about subscribing to specific mutation events.

</Callout>

</InlineFilter>

<InlineFilter filters={["android"]}>

To add real-time updates, you can use the subscription feature of Amplify Data. It allows to subscribe to `onCreate`, `onUpdate`, and `onDelete` events of the application. In our example, let's append the list every time a new todo is added.

```kt title="MainActivity.kt"
@Composable
fun TodoList() {
    var todoList by remember { mutableStateOf(emptyList<Todo>()) }

    LaunchedEffect(Unit) {
        Amplify.API.query(ModelQuery.list(Todo::class.java),
            {
                todoList = it.data.items.toList()
            },
            { Log.e("MyAmplifyApp", "Failed to query.", it)})
        // highlight-start
        Amplify.API.subscribe(ModelSubscription.onCreate(Todo::class.java),
            { Log.i("ApiQuickStart", "Subscription established") },
            { Log.i("ApiQuickStart", "Todo create subscription received: ${it.data}")
                todoList = todoList + it.data
            },
            { Log.e("ApiQuickStart", "Subscription failed", it) },
            { Log.i("ApiQuickStart", "Subscription completed") }

        )
        // highlight-end
    }

    LazyColumn {
        items(todoList) { todo ->
            Row {
                // Render your activity item here
                Checkbox(checked = todo.isDone, onCheckedChange = null)
                Text(text = todo.content)
            }
        }
    }
}
```
Now call `TodoList()` from the `onCreate()` function:

```kt title="MainActivity.kt"
setContent {
    MyAmplifyAppTheme {
        // A surface container using the 'background' color from the theme
        Surface(
            modifier = Modifier.fillMaxSize(), 
            color = MaterialTheme.colorScheme.background
        ) {
            Authenticator { state ->
                Column {
                    Text(
                        text = "Hello ${state.user.username}!",
                    )
                    ....
                    //highlight-next-line
                    TodoList()
```

</InlineFilter>

<InlineFilter filters={["swift"]}>

To add real-time updates, you can use the subscription feature of Amplify Data. It allows to subscribe to `onCreate`, `onUpdate`, and `onDelete` events of the application. In our example, let's append the list every time a new todo is added.

First, add a private variable to store the subscription. Then create the subscription on the `init()` initializer, and add the `subscribe()` and `cancel()` functions.


```swift title="TodoViewModel.swift"
@MainActor
class TodoViewModel: ObservableObject {
    @Published var todos: [Todo] = []

    // highlight-start
    private var subscription: AmplifyAsyncThrowingSequence<GraphQLSubscriptionEvent<Todo>>

    init() {
       self.subscription = Amplify.API.subscribe(request: .subscription(of: Todo.self, type: .onCreate))
    }

    func subscribe() {
        Task {
            do {
                for try await subscriptionEvent in subscription {
                    handleSubscriptionEvent(subscriptionEvent)
                }
            } catch {
                print("Subscription has terminated with \(error)")
            }
        }
    }

    private func handleSubscriptionEvent(_ subscriptionEvent: GraphQLSubscriptionEvent<Todo>) {
        switch subscriptionEvent {
        case .connection(let subscriptionConnectionState):
            print("Subscription connect state is \(subscriptionConnectionState)")
        case .data(let result):
            switch result {
            case .success(let createdTodo):
                print("Successfully got todo from subscription: \(createdTodo)")
                todos.append(createdTodo)
            case .failure(let error):
                print("Got failed result with \(error.errorDescription)")
            }
        }
    }

    func cancel() {
        self.subscription.cancel()
    }
    // highlight-end

    func createTodo() {
        /// ...
    }

    func listTodos() {
        /// ...
    }
}
```

Then in `ContentView.swift`, when the view appears, call `vm.subscribe()`. On disappear, cancel the subscription.


```swift title="ContentView.swift"
struct ContentView: View {
    @StateObject var vm = TodoViewModel()

    var body: some View {
        VStack {
            // ...
        }
        // highlight-start
        .onDisappear {
            vm.cancel()
        }
        .task {
            vm.listTodos()
            vm.subscribe()
        }
        // highlight-end
    }
}
```

Now if you rerun your app, a new todo should be appended to the list every time you create a new todo.

</InlineFilter>

<InlineFilter filters={["flutter"]}>

To add real-time updates, you can use the subscription feature of Amplify Data. It allows to subscribe to `onCreate`, `onUpdate`, and `onDelete` events of the application. In our example, let's append the list every time a new todo is added.

When the page renders, subscribe to `onCreate` events and then unsubscribe when the Widget is disposed.

```dart title="lib/main.dart"
// ...main()
// ...MyApp
// ...MyHomePage

class _MyHomePageState extends State<MyHomePage> {
  List<Todo> _todos = [];
  // highlight-next-line
  StreamSubscription<GraphQLResponse<Todo>>? subscription;

  @override
  void initState() {
    super.initState();
    _refreshTodos();
    // highlight-next-line
    _subscribe();
  }

  // highlight-start
  @override
  void dispose() {
    _unsubscribe();
    super.dispose();
  }
  // highlight-end

  // highlight-start
  void _subscribe() {
    final subscriptionRequest = ModelSubscriptions.onCreate(Todo.classType);
    final Stream<GraphQLResponse<Todo>> operation = Amplify.API.subscribe(
      subscriptionRequest,
      onEstablished: () => safePrint('Subscription established'),
    );
    subscription = operation.listen(
      (event) {
        safePrint('Subscription event data received: ${event.data}');
        setState(() {
          _todos.add(event.data!);
        });
      },
      onError: (Object e) => safePrint('Error in subscription stream: $e'),
    );
  }
  // highlight-end

  // highlight-start
  void _unsubscribe() {
    subscription?.cancel();
    subscription = null;
  }
  // highlight-end

  // ..._refreshTodos()
  // ...build()
}
```

</InlineFilter>

## Conclusion

Success! You've learned how to create your first real-time API and database with Amplify Data.

### Next steps

There's so much more to discover with Amplify Data. Learn more about:

- [How to model your database table and their access patterns](/[platform]/build-a-backend/data/data-modeling)
- [Secure your API with fine-grained authorization rules](/[platform]/build-a-backend/data/customize-authz)
- [Create relationships between different database model](/[platform]/build-a-backend/data/data-modeling/relationships)
- [Add custom business logic](/[platform]/build-a-backend/data/custom-business-logic)


Contents of build-a-backend_data_subscribe-data_index.txt:
import { getCustomStaticPath } from '@/utils/getCustomStaticPath';

export const meta = {
  title: 'Subscribe to real-time events',
  description: 'Set up real-time data subscriptions in your app to get live updates, filter those subscriptions on the server side, and unsubscribe when no longer needed.',
  platforms: [
    'android',
    'angular',
    'flutter',
    'javascript',
    'nextjs',
    'react',
    'react-native',
    'swift',
    'vue'
  ]
};

export const getStaticPaths = async () => {
  return getCustomStaticPath(meta.platforms);
};

export function getStaticProps(context) {
  return {
    props: {
      meta
    }
  };

}

<InlineFilter filters={["javascript",  "react-native", "angular", "nextjs", "react", "vue"]}>

In this guide, we will outline the benefits of enabling real-time data integrations and how to set up and filter these subscriptions. We will also cover how to unsubscribe from subscriptions.

Before you begin, you will need:

- An [application connected to the API](/[platform]/build-a-backend/data/connect-to-API/)
- Data already created to modify

{/* This component contains approved messaging and cannot be removed or modified without prior approval */}

import { ProtectedRedactionGen2Message } from "@/protected/ProtectedRedactionMessage"

<ProtectedRedactionGen2Message />

## Set up a real-time list query

The recommended way to fetch a list of data is to use `observeQuery` to get a real-time list of your app data at all times. You can integrate `observeQuery` with React's `useState` and `useEffect` hooks in the following way:

```ts
import { useState, useEffect } from 'react';
import { generateClient } from 'aws-amplify/data';
import type { Schema } from '../amplify/data/resource';

type Todo = Schema['Todo']['type'];

const client = generateClient<Schema>();

export default function MyComponent() {
  const [todos, setTodos] = useState<Todo[]>([]);

  useEffect(() => {
    const sub = client.models.Todo.observeQuery().subscribe({
      next: ({ items, isSynced }) => {
        setTodos([...items]);
      },
    });
    return () => sub.unsubscribe();
  }, []);

  return (
    <ul>
      {todos.map((todo) => (
        <li key={todo.id}>{todo.content}</li>
      ))}
    </ul>
  );
}
```

`observeQuery` fetches and paginates through all of your available data in the cloud. While data is syncing from the cloud, snapshots will contain all of the items synced so far and an `isSynced` status of `false`. When the sync process is complete, a snapshot will be emitted with all the records in the local store and an `isSynced` status of `true`.

<Accordion title='Missing real-time events and model fields' headingLevel='4' eyebrow='Troubleshooting'>

If you don't see all of the real-time events and model fields you expect to see, here are a few things to look for.

#### Authorization

The model's [authorization rules](/[platform]/build-a-backend/data/customize-authz/) must grant the appropriate rights to the user.

| Operation | Authorization |
| -- | -- |
| `onCreate` | `read` OR `listen` |
| `onUpdate` | `read` OR `listen` |
| `onDelete` | `read` OR `listen` |
| `observeQuery` | `read` OR (`listen` AND `list`) |

If the authorization rules are correct, also ensure the session is authenticated as expected.

#### Selection Set Parity

All of the fields you expect to see in a real-time update must be present in the selection set of the **mutation** that triggers it. A mutation essentially "provides" the fields via its selection set that the corresponding subscription can then select from.

One way to address this is to use a common selection set variable for both operations. For example:

```ts
// Defining your selection set `as const` ensures the types
// propagate through to the response objects.
const selectionSet = ['title', 'author', 'posts.*'] as const;

const sub = client.models.Blog.observeQuery(
  filter: { id: { eq: 'blog-id' } },
  selectionSet: [...selectionSet]
).subscribe({
  next(data) {
    handle(data.items)
  }
});

// The update uses the same selection set, ensuring all the
// required fields are provided to the subscriber.
const { data } = await client.models.Blog.update({
  id: 'blog-id',
  name: 'Updated Name'
}, {
  selectionSet: [...selectionSet]
});
```

This works well if all subscriptions to `Blog` require the same subset of fields. If multiple subscriptions are involved with various selection sets, you must ensure that all `Blog` mutations contain the superset of fields from all subscriptions.

Alternatively, you can skip the custom selection sets entirely. The internally generated selection set for any given model is identical across operations by default. The trade-off is that the default selection sets exclude related models. So, when related models are required, you would need to either lazy load them or construct a query to fetch them separately.

#### Related Model Mutations

Mutations do not trigger real-time updates for *related* models. This is true even when the subscription includes a related model in the selection set. For example, if we're subscribed to a particular `Blog` and wish to see updates when a `Post` is added or changed, it's tempting to create  a subscribe on `Blog` and assume it "just works":

```ts
// Notice how we're fetching a few `Blog` details, but mostly using
// the selection set to grab all the related posts.
const selectionSet = ['title', 'author', 'posts.*'] as const;

const sub = client.models.Blog.observeQuery(
  filter: { id: { eq: 'blog-id' } },
  selectionSet: [...selectionSet]
).subscribe({
  next(data) {
    handle(data.items)
  }
});
```

But, mutations on `Post` records won't trigger an real-time event for the related `Blog`. If you need `Blog` updates when a `Post` is added, you must manually "touch" the relevant `Blog` record.

```ts
async function addPostToBlog(
  post: Schema['Post']['createType'],
  blog: Schema['Blog']['type']
) {
  // Create the post first.
  await client.models.Post.create({
    ...post,
    blogId: blog.id
  });

  // "Touch" the blog, notifying subscribers to re-render.
  await client.models.Blog.update({
    id: blog.id
  }, {
    // Remember to include the selection set if the subscription
    // is looking for related-model fields!
    selectionSet: [...selectionSet]
  });
}
```

</Accordion>

## Set up a real-time event subscription

Subscriptions is a feature that allows the server to send data to its clients when a specific event happens. For example, you can subscribe to an event when a new record is created, updated, or deleted through the API. Subscriptions are automatically available for any `a.model()` in your Amplify Data schema.

```ts
import { generateClient } from 'aws-amplify/data';
import type { Schema } from '../amplify/data/resource';

const client = generateClient<Schema>();

// Subscribe to creation of Todo
const createSub = client.models.Todo.onCreate().subscribe({
  next: (data) => console.log(data),
  error: (error) => console.warn(error),
});

// Subscribe to update of Todo
const updateSub = client.models.Todo.onUpdate().subscribe({
  next: (data) => console.log(data),
  error: (error) => console.warn(error),
});

// Subscribe to deletion of Todo
const deleteSub = client.models.Todo.onDelete().subscribe({
  next: (data) => console.log(data),
  error: (error) => console.warn(error),
});

// Stop receiving data updates from the subscription
createSub.unsubscribe();
updateSub.unsubscribe();
deleteSub.unsubscribe();
```

## Set up server-side subscription filters

Subscriptions take an optional `filter` argument to define service-side subscription filters:

```ts
import { generateClient } from 'aws-amplify/data';
import type { Schema } from '../amplify/data/resource';

const client = generateClient<Schema>();

const sub = client.models.Todo.onCreate({
  filter: {
    content: {
      contains: 'groceries',
    },
  },
}).subscribe({
  next: (data) => console.log(data),
  error: (error) => console.warn(error),
});
```

If you want to get all subscription events, don't specify any `filter` parameters.

<Callout>

**Limitations:**

- Specifying an empty object `{}` as a filter is **not** recommended. Using `{}` as a filter might cause inconsistent behavior based on your data model's authorization rules.
- If you're using dynamic group authorization and you authorize based on a single group per record, subscriptions are only supported if the user is part of five or fewer user groups.
- Additionally, if you authorize by using an array of groups (`groups: [String]`),
  - subscriptions are only supported if the user is part of 20 or fewer groups
  - you can only authorize 20 or fewer user groups per record

</Callout>

### Subscription connection status updates

Now that your application is set up and using subscriptions, you may want to know when the subscription is finally established, or reflect to your users when the subscription isn't healthy. You can monitor the connection state for changes through the `Hub` local eventing system.

```ts
import { CONNECTION_STATE_CHANGE, ConnectionState } from 'aws-amplify/data';
import { Hub } from 'aws-amplify/utils';

Hub.listen('api', (data: any) => {
  const { payload } = data;
  if (payload.event === CONNECTION_STATE_CHANGE) {
    const connectionState = payload.data.connectionState as ConnectionState;
    console.log(connectionState);
  }
});
```

#### Subscription connection states

- **`Connected`** - Connected and working with no issues.
- **`ConnectedPendingDisconnect`** - The connection has no active subscriptions and is disconnecting.
- **`ConnectedPendingKeepAlive`** - The connection is open, but has missed expected keep-alive messages.
- **`ConnectedPendingNetwork`** - The connection is open, but the network connection has been disrupted. When the network recovers, the connection will continue serving traffic.
- **`Connecting`** - Attempting to connect.
- **`ConnectionDisrupted`** - The connection is disrupted and the network is available.
- **`ConnectionDisruptedPendingNetwork`** - The connection is disrupted and the network connection is unavailable.
- **`Disconnected`** - Connection has no active subscriptions and is disconnecting.

<Accordion title='Troubleshoot connection issues and automated reconnection' headingLevel='4' eyebrow='Troubleshooting'>

Connections between your application and backend subscriptions can be interrupted for various reasons, including network outages or the device entering sleep mode. Your subscriptions will automatically reconnect when it becomes possible to do so.

While offline, your application will miss messages and will not automatically catch up when reconnected. Depending on your use case, you may want to take action for your app to catch up when it comes back online.

```js
import { generateClient, CONNECTION_STATE_CHANGE, ConnectionState } from 'aws-amplify/data'
import { Hub } from 'aws-amplify/utils'
import { Schema } from '../amplify/data/resource';

const client = generateClient<Schema>()

const fetchRecentData = () => {
  const { data: allTodos } = await client.models.Todo.list();
}

let priorConnectionState: ConnectionState;

Hub.listen("api", (data: any) => {
  const { payload } = data;
  if (
    payload.event === CONNECTION_STATE_CHANGE
  ) {

    if (priorConnectionState === ConnectionState.Connecting && payload.data.connectionState === ConnectionState.Connected) {
      fetchRecentData();
    }
    priorConnectionState = payload.data.connectionState;
  }
});

const createSub = client.models.Todo.onCreate().subscribe({
  next: payload => // Process incoming messages
});

const updateSub = client.models.Todo.onUpdate().subscribe({
  next: payload => // Process incoming messages
});

const deleteSub = client.models.Todo.onDelete().subscribe({
  next: payload => // Process incoming messages
});

const cleanupSubscriptions = () => {
  createSub.unsubscribe();
  updateSub.unsubscribe();
  deleteSub.unsubscribe();
}
```

</Accordion>

## Unsubscribe from a subscription

You can also unsubscribe from events by using subscriptions by implementing the following:

```ts
// Stop receiving data updates from the subscription
sub.unsubscribe();
```

## Conclusion

Congratulations! You have finished the **Subscribe to real-time events** guide. In this guide, you set up subscriptions for real-time events and learned how to filter and cancel these subscriptions when needed.

### Next steps

Our recommended next steps include continuing to build out and customize your information architecture for your data. Some resources that will help with this work include:

- [Customize your auth rules](/[platform]/build-a-backend/data/customize-authz/)
- [Customize your data model](/[platform]/build-a-backend/data/data-modeling/)
- [Add custom business logic](/[platform]/build-a-backend/data/custom-business-logic/)

</InlineFilter>

<InlineFilter filters={["swift"]}>

Subscribe to mutations for creating real-time clients.

Because the lifetime of the subscription will last longer than the lifetime of a single function, you can create an instance variable at the top of your class:

<BlockSwitcher>

<Block name="Async/Await">

```swift
var subscription: AmplifyAsyncThrowingSequence<GraphQLSubscriptionEvent<Todo>>
```

</Block>

<Block name="Combine">

```swift
var subscription: AnyCancellable?
```

</Block>

</BlockSwitcher>

To listen to creation updates, you can use the following code sample:

<BlockSwitcher>

<Block name="Async/Await">

```swift
func createSubscription() {
    subscription = Amplify.API.subscribe(request: .subscription(of: Todo.self, type: .onCreate))
    Task {
        do {
            for try await subscriptionEvent in subscription {
                switch subscriptionEvent {
                case .connection(let subscriptionConnectionState):
                    print("Subscription connect state is \(subscriptionConnectionState)")
                case .data(let result):
                    switch result {
                    case .success(let createdTodo):
                        print("Successfully got todo from subscription: \(createdTodo)")
                    case .failure(let error):
                        print("Got failed result with \(error.errorDescription)")
                    }
                }
            }
        } catch {
            print("Subscription has terminated with \(error)")
        }
    }
}
```
</Block>

<Block name="Combine">

```swift
func createSubscription() {
    let sequence = Amplify.API.subscribe(request: .subscription(of: Todo.self, type: .onCreate))
    subscription = Amplify.Publisher.create(sequence)
        .sink {
        if case let .failure(apiError) = $0 {
            print("Subscription has terminated with \(apiError)")
        } else {
            print("Subscription has been closed successfully")
        }
    }
    receiveValue: { result in
        switch result {
            case .connection(let subscriptionConnectionState):
                print("Subscription connect state is \(subscriptionConnectionState)")
            case .data(let result):
                switch result {
                case .success(let createdTodo):
                    print("Successfully got todo from subscription: \(createdTodo)")
                case .failure(let error):
                    print("Got failed result with \(error.errorDescription)")
            }
        }
    }
}
```

</Block>

</BlockSwitcher>

## Unsubscribing from updates

### Async/Await

To unsubscribe from updates, you can call `cancel()` on the subscription.

```swift
func cancelSubscription() {
    // Cancel the subscription listener when you're finished with it
    subscription?.cancel()
}
```

### Combine

Calling `cancel()` on the sequence will disconnect the subscription from the backend. Any downstream subscribers will also be cancelled.

```swift
let sequence = Amplify.API.subscribe(...)
let subscription = Amplify.Publisher.create(sequence)
let allUpdates = subscription.sink(...)
let filteredUpdates = subscription.filter{...}.sink(...)
sequence.cancel()   // sequence is now disconnected
                    // allUpdates and filteredUpdates will no longer receive data
```

Similarly, calling `cancel()` on the Combine subscriber (e.g., the `AnyCancellable` returned from `sink()`) will cause the underlying sequence to cancel. This will cause all attached subscribers to stop receiving updates.

```swift
allUpdates.cancel() // sequence is disconnected
                    // filteredUpdates will no longer receive data
```

</InlineFilter>

<InlineFilter filters={["android"]}>

Subscribe to mutations for creating real-time clients:

<BlockSwitcher>
<Block name="Java">

```java
ApiOperation subscription = Amplify.API.subscribe(
    ModelSubscription.onCreate(Todo.class),
    onEstablished -> Log.i("ApiQuickStart", "Subscription established"),
    onCreated -> Log.i("ApiQuickStart", "Todo create subscription received: " + ((Todo) onCreated.getData()).getName()),
    onFailure -> Log.e("ApiQuickStart", "Subscription failed", onFailure),
    () -> Log.i("ApiQuickStart", "Subscription completed")
);

// Cancel the subscription listener when you're finished with it
subscription.cancel();
```

</Block>
<Block name="Kotlin - Callbacks">

```kotlin
val subscription = Amplify.API.subscribe(
    ModelSubscription.onCreate(Todo::class.java),
    { Log.i("ApiQuickStart", "Subscription established") },
    { Log.i("ApiQuickStart", "Todo create subscription received: ${(it.data as Todo).name}") },
    { Log.e("ApiQuickStart", "Subscription failed", it) },
    { Log.i("ApiQuickStart", "Subscription completed") }
)

// Cancel the subscription listener when you're finished with it
subscription.cancel();
```

</Block>
<Block name="Kotlin - Coroutines">

```kotlin
val job = activityScope.launch {
    try {
        Amplify.API.subscribe(ModelSubscription.onCreate(Todo::class.java))
            .catch { Log.e("ApiQuickStart", "Error on subscription", it) }
            .collect { Log.i("ApiQuickStart", "Todo created!  ${it.data.name}") }
    } catch (notEstablished: ApiException) {
        Log.e("ApiQuickStart", "Subscription not established", it)
    }
}

// When done with subscription
job.cancel()
```

</Block>
<Block name="RxJava">

```java
RxSubscriptionOperation<? extends GraphQLResponse<?>> subscription =
        RxAmplify.API.subscribe(request);

subscription
        .observeConnectionState()
        .subscribe(connectionStateEvent -> Log.i("ApiQuickStart", String.valueOf(connectionStateEvent)));

subscription
        .observeSubscriptionData()
        .subscribe(
            data -> Log.i("ApiQuickStart", data),
            exception -> Log.e("ApiQuickStart", "Subscription failed.", exception),
            () -> Log.i("ApiQuickStart", "Subscription completed.")
        );

// Cancel the subscription listener when you're finished with it
subscription.cancel();
```

</Block>
</BlockSwitcher>

</InlineFilter>

<InlineFilter filters={["flutter"]}>

Subscribe to mutations for creating real-time clients.

## Setup subscription with callbacks

When creating subscriptions, a [`Stream`](https://api.dart.dev/dart-async/Stream-class.html) object will be returned to you. This `Stream` will continue producing events until either the subscription encounters an error or you cancel the subscription. In the case of need for limiting the amount of data that is omitted, you can take advantage of the Stream's helper functions such as `take`. The cancellation occurs when the defined amount of event has occurred:

```dart
Stream<GraphQLResponse<Todo>> subscribe() {
  final subscriptionRequest = ModelSubscriptions.onCreate(Todo.classType);
  final Stream<GraphQLResponse<Todo>> operation = Amplify.API
      .subscribe(
        subscriptionRequest,
        onEstablished: () => safePrint('Subscription established'),
      )
      // Listens to only 5 elements
      .take(5)
      .handleError(
    (Object error) {
      safePrint('Error in subscription stream: $error');
    },
  );
  return operation;
}
```

Alternatively, you can call [`Stream.listen`](https://api.dart.dev/dart-async/Stream/listen.html) to create a [`StreamSubscription`](https://api.dart.dev/dart-async/StreamSubscription-class.html) object which can be programmatically canceled.

```dart
// Be sure to import this
import 'dart:async';

...

StreamSubscription<GraphQLResponse<Todo>>? subscription;

void subscribe() {
  final subscriptionRequest = ModelSubscriptions.onCreate(Todo.classType);
  final Stream<GraphQLResponse<Todo>> operation = Amplify.API.subscribe(
    subscriptionRequest,
    onEstablished: () => safePrint('Subscription established'),
  );
  subscription = operation.listen(
    (event) {
      safePrint('Subscription event data received: ${event.data}');
    },
    onError: (Object e) => safePrint('Error in subscription stream: $e'),
  );
}

void unsubscribe() {
  subscription?.cancel();
  subscription = null;
}
```

In addition to an `onCreate` subscription, you can also call `.onUpdate()` or `.onDelete()`.

```dart
final onUpdateSubscriptionRequest = ModelSubscriptions.onUpdate(Todo.classType);
// or
final onDeleteSubscriptionRequest = ModelSubscriptions.onDelete(Todo.classType);
```

## Subscription connection status

Now that you set up the application and are using subscriptions, you may want to know when the subscription is closed, or reflect to your users when the subscription isn’t healthy. You can monitor the subscription status for changes via `Amplify.Hub`

```dart
Amplify.Hub.listen(
  HubChannel.Api,
  (ApiHubEvent event) {
    if (event is SubscriptionHubEvent) {
      safePrint(event.status);
    }
  },
);
```

### SubscriptionStatus

- **`connected`** - Connected and working with no issues
- **`connecting`** - Attempting to connect (both initial connection and reconnection)
- **`pendingDisconnect`** - Connection has no active subscriptions and is shutting down
- **`disconnected`** - Connection has no active subscriptions and is disconnected
- **`failed`** - Connection had a failure and has been disconnected

## Automated Reconnection

Under the hood, we will attempt to maintain a healthy web socket connection through network changes. For example, if a device’s connection changes from Wi-Fi to 5g network, the plugin will attempt to reconnect using the new network.

Likewise, when disconnected from the internet unexpectedly, the subscription will attempt to reconnect using an exponential retry/back off strategy. By default, we will make 8 recovery attempts over about 50 seconds. If we cannot make a successful connection, then the web socket will be closed. You can customize this strategy when configuring the API plugin through `RetryOptions`.

```dart
Future<void> _configureAmplify() async {
  final apiPlugin = AmplifyAPI(
    options: APIPluginOptions(
      modelProvider: ModelProvider.instance,
      // Optional config
      subscriptionOptions: const GraphQLSubscriptionOptions(
        retryOptions: RetryOptions(maxAttempts: 10),
      ),
    )
  );
  await Amplify.addPlugin(apiPlugin);

  try {
    await Amplify.configure(outputs);
  } on AmplifyAlreadyConfiguredException {
    safePrint(
        "Tried to reconfigure Amplify; this can occur when your app restarts on Android.");
  }
}
```

<Callout>

**Important**: While offline, your application will miss messages and will not automatically catch up when reconnection happens. Depending on your use case, you may want to take action to catch up when your app comes back online. The following example solves this problem by retrieving all data on reconnection.

</Callout>

```dart
import 'package:amplify_flutter/amplify_flutter.dart';
import 'package:amplify_api/amplify_api.dart';
import './models/ModelProvider.dart'; // <--- Update import to reflect your project
import 'dart:async';

// ...

List<Todo?> allTodos = [];
SubscriptionStatus prevSubscriptionStatus = SubscriptionStatus.disconnected;
StreamSubscription<GraphQLResponse<Todo>>? subscription;

/// ...

// Init listeners
Amplify.Hub.listen(
  HubChannel.Api,
  (ApiHubEvent event) {
    if (event is SubscriptionHubEvent) {
      if (prevSubscriptionStatus == SubscriptionStatus.connecting &&
          event.status == SubscriptionStatus.connected) {
        getTodos(); // refetch todos
      }
      prevSubscriptionStatus = event.status;
    }
  },
);

subscribe();

/// ...

Future<void> getTodos() async {
  try {
    final request = ModelQueries.list(Todo.classType);
    final response = await Amplify.API.query(request: request).response;

    final todos = response.data?.items ?? [];
    if (response.errors.isNotEmpty) {
      safePrint('errors: ${response.errors}');
    }

    setState(() {
      allTodos = todos;
    });
  } on ApiException catch (e) {
    safePrint('Query failed: $e');
    return;
  }
}

void subscribe() {
  final subscriptionRequest = ModelSubscriptions.onCreate(Todo.classType);
  final Stream<GraphQLResponse<Todo>> operation = Amplify.API.subscribe(
    subscriptionRequest,
    onEstablished: () => safePrint('Subscription established'),
  );
  subscription = operation.listen(
    (event) {
      setState(() {
        allTodos.add(event.data);
      });
    },
    onError: (Object e) => safePrint('Error in subscription stream: $e'),
  );
}

```

</InlineFilter>


Contents of build-a-backend_data_working-with-files_index.txt:
import { getCustomStaticPath } from '@/utils/getCustomStaticPath';

export const meta = {
  title: 'Working with files/attachments',
  description:
    'Working with files/attachments.',
  platforms: [
    'android',
    'angular',
    'flutter',
    'javascript',
    'nextjs',
    'react',
    'react-native',
    'swift',
    'vue'
  ]
};

export const getStaticPaths = async () => {
  return getCustomStaticPath(meta.platforms);
};

export function getStaticProps() {
  return {
    props: {
      meta
    }
  };
}

The Storage and GraphQL API categories can be used together to associate a file, such as an image or video, with a particular record. For example, you might create a `User` model with a profile picture, or a `Post` model with an associated image. With Amplify's GraphQL API and Storage categories, you can reference the file within the model itself to create an association.

## Set up the project

Set up your project by following the instructions in the [Quickstart guide](/[platform]/start/quickstart/).

## Define the model

Open `amplify/data/resource.ts` and add the following model as shown below:

```ts title="amplify/data/resource.ts"
import { type ClientSchema, a, defineData } from "@aws-amplify/backend";

const schema = a.schema({
  Song: a
    .model({
      id: a.id().required(),
      name: a.string().required(),
      coverArtPath: a.string(),
    })
    .authorization((allow) => [allow.publicApiKey()]),
});

export type Schema = ClientSchema<typeof schema>;

export const data = defineData({
  schema,
  authorizationModes: {
    defaultAuthorizationMode: "apiKey",

    apiKeyAuthorizationMode: {
      expiresInDays: 30,
    },
  },
});
```
## Setup the Storage

Next, Let's configure Storage and allow access to all authenticated(signed in) users of your application. create a file `amplify/storage/resource.ts` and add the following code,This will restrict file access to only the signed-in user.

```ts title="amplify/storage/resource.ts"

import { defineStorage } from "@aws-amplify/backend";

export const storage = defineStorage({
  name: "amplify-gen2-files",
  access: (allow) => ({
    "images/*": [allow.authenticated.to(["read", "write", "delete"])],
  }),
});
```

Configure the storage in the `amplify/backend.ts` file as demonstrated below:

```ts title="amplify/backend.ts"
import { defineBackend } from "@aws-amplify/backend";
import { auth } from "./auth/resource";
import { data } from "./data/resource";
import { storage } from "./storage/resource";

export const backend = defineBackend({
  auth,
  data,
  storage,
});
```

## Configuring authorization

Your application needs authorization credentials for reading and writing to both Storage and the Data, except in the case where all data and files are intended to be publicly accessible.

The Storage and Data categories govern data access based on their own authorization patterns, meaning that it's necessary to configure appropriate auth roles for each individual category. Although both categories share the same access credentials set up through the Auth category, they work independently from one another. For instance, adding an `allow.authenticated()` to the Data does not guard against file access in the Storage category. Likewise, adding authorization rules to the Storage category does not guard against data access in the API.

When you configure Storage, Amplify will configure appropriate IAM policies on the bucket using a Cognito Identity Pool role. You will then have the option of adding CRUD (Create, Update, Read and Delete) based permissions as well, so that Authenticated and Guest users will be granted limited permissions within these levels. **Even after adding this configuration, all Storage access is still `guest` by default.** To guard against accidental public access, the Storage access levels must either be configured on the Storage object globally, or set within individual function calls. This guide uses the former approach, setting all Storage access to `authenticated` users.

The ability to independently configure authorization rules for each category allows for more granular control over data access, and adds greater flexibility. For scenarios where authorization patterns must be mixed and matched, configure the access level on individual Storage function calls. For example, you may want to use `entity_id` CRUD access on an individual Storage function call for files that should only be accessible by the owner (such as personal files), `authenticated` read access to allow all logged in users to view common files (such as images in a shared photo album), and `guest` read access to allow all users to view a file (such as a public profile picture).

For more details on how to configure Storage authorization levels, see the [Storage documentation](/[platform]/build-a-backend/storage/authorization/). For more on configuring Data authorization, see the [API documentation](/[platform]/build-a-backend/data/customize-authz/).

## Create a record with an associated file

You can create a record via the Amplify Data client, upload a file to Storage, and finally update the record to associate it with the uploaded file. Use the following example with the Amplify Data client and Amplify Storage library helpers, `uploadData` and `getUrl`, to create a record and associate it the file with the record.

<Callout>

The API record's `id` is prepended to the Storage file name to ensure uniqueness. If this is excluded, multiple API records could then be associated with the same file path unintentionally.

</Callout>

<InlineFilter filters={["swift"]}>
```swift title="ContentView"
let song = Song(name: name)

guard let imageData = artCover.pngData() else {
    print("Could not get data from image.")
    return
}

// Create the song record
var createdSong = try await Amplify.API.mutate(request: .create(song)).get()
let coverArtPath = "images/\(createdSong.id)"

// Upload the art cover image
_ = try await Amplify.Storage.uploadData(path: .fromString(coverArtPath), data: imageData).value

// Update the song record with the image path
createdSong.coverArtPath = coverArtPath
let updatedSong = try await Amplify.API.mutate(request: .update(createdSong)).get()
```
</InlineFilter>

<InlineFilter filters={["javascript",  "react-native", "angular", "nextjs", "react", "vue"]}>

```ts title="src/App.tsx"

import { generateClient } from "aws-amplify/api";
import { uploadData, getUrl } from "aws-amplify/storage";
import type { Schema } from "../amplify/data/resource";

// Generating the client
const client = generateClient<Schema>({
  authMode: "apiKey",
});

// Create the API record:
const response = await client.models.Song.create({
  name: `My first song`,
});

const song = response.data;

if (!song) return;

// Upload the Storage file:
const result = await uploadData({
  path: `images/${song.id}-${file.name}`,
  data: file,
  options: {
    contentType: "image/png", // contentType is optional
  },
}).result;

// Add the file association to the record:
const updateResponse = await client.models.Song.update({
  id: song.id,
  coverArtPath: result?.path,
});

const updatedSong = updateResponse.data;

setCurrentSong(updatedSong);

// If the record has no associated file, we can return early.
if (!updatedSong.coverArtPath) return;

// Retrieve the file's signed URL:
const signedURL = await getUrl({ path: updatedSong.coverArtPath });
```
</InlineFilter>

## Add or update a file for an associated record

To associate a file with a record, update the record with the path returned by the Storage upload. The following example uploads the file using Storage, updates the record with the file's path, then retrieves the signed URL to download the image. If an image is already associated with the record, this will update the record with the new image.

<InlineFilter filters={["swift"]}>
```swift title="ContentView"
guard var currentSong = currentSong else {
    print("There is no song to associated the image with. Create a Song first.")
    return
}
guard let imageData = artCover.pngData() else {
    print("Could not get data from UIImage.")
    return
}

let coverArtPath = "images/\(currentSong.id)"

// Upload the new art image
_ = try await Amplify.Storage.uploadData(path: .fromString(coverArtPath), data: imageData).value

// Update the song record
currentSong.coverArtPath = coverArtPath
let updatedSong = try await Amplify.API.mutate(request: .update(currentSong)).get()
```
</InlineFilter>

<InlineFilter filters={[
  "javascript", "react-native", "angular", "nextjs", "react", "vue"
]}>

```ts title="src/App.tsx"
import { generateClient } from "aws-amplify/api";
import { uploadData, getUrl } from "aws-amplify/storage";
import type { Schema } from "../amplify/data/resource";

// Generating the client
const client = generateClient<Schema>({
  authMode: "apiKey",
});

// Upload the Storage file:
const result = await uploadData({
  path: `images/${currentSong.id}-${file.name}`,
  data: file,
  options: {
    contentType: "image/png", // contentType is optional
  },
}).result;

// Add the file association to the record:
const response = await client.models.Song.update({
  id: currentSong.id,
  coverArtPath: result?.path,
});

const updatedSong = response.data;

setCurrentSong(updatedSong);

// If the record has no associated file, we can return early.
if (!updatedSong?.coverArtPath) return;

// Retrieve the file's signed URL:
const signedURL = await getUrl({ path: updatedSong.coverArtPath });
```

</InlineFilter>

## Query a record and retrieve the associated file

To retrieve the file associated with a record, first query the record, then use Storage to get the signed URL. The signed URL can then be used to download the file, display an image, etc:
<InlineFilter filters={["swift"]}>
```swift title="ContentView"
// Get the song record
guard let song = try await Amplify.API.query(request: .get(Song.self, byIdentifier: currentSong.id)).get() else {
    print("Song may have been deleted, no song by id: ", currentSong.id)
    return
}

// If the record has no associated file, we can return early.
guard let coverArtPath = song.coverArtPath else {
    print("Song does not contain cover art")
    return
}

// Download the art cover
print("coverArtPath: ", coverArtPath)
let imageData = try await Amplify.Storage.downloadData(path: .fromString(coverArtPath)).value

let image = UIImage(data: imageData)
```
</InlineFilter>

<InlineFilter filters={[
  "javascript", "react-native", "angular", "nextjs", "react", "vue"
]}>
```ts title="src/App.tsx"
import { generateClient } from "aws-amplify/api";
import { getUrl } from "aws-amplify/storage";
import type { Schema } from "../amplify/data/resource";

// Generating the client
const client = generateClient<Schema>({
  authMode: "apiKey",
});

const response = await client.models.Song.get({
  id: currentSong.id,
});

const song = response.data;

// If the record has no associated file, we can return early.
if (!song?.coverArtPath) return;

// Retrieve the signed URL:
const signedURL = await getUrl({ path: song.coverArtPath });
```
</InlineFilter>

## Delete and remove files associated with API records

There are three common deletion workflows when working with Storage files and the GraphQL API:

1. Remove the file association, continue to persist both file and record.
2. Remove the record association and delete the file.
3. Delete both file and record.

### Remove the file association, continue to persist both file and record

The following example removes the file association from the record, but does not delete the file from S3, nor the record from the database.

<InlineFilter filters={["swift"]}>
```swift title="ContentView"
// Get the song record
guard var song = try await Amplify.API.query(request: .get(Song.self, byIdentifier: currentSong.id)).get() else {
    print("Song may have been deleted, no song by id: ", currentSong.id)
    return
}

guard song.coverArtPath != nil else {
    print("There is no cover art path to remove image association")
    return
}

// Set the association to nil and update it
song.coverArtPath = nil

let updatedSong = try await Amplify.API.mutate(request: .update(song)).get()
```
</InlineFilter>

<InlineFilter filters={[
  "javascript", "react-native", "angular", "nextjs", "react", "vue"
]}>
```ts title="src/App.tsx"

import { generateClient } from "aws-amplify/api";
import type { Schema } from "../amplify/data/resource";

// Generating the client
const client = generateClient<Schema>({
  authMode: "apiKey",
});

const response = await client.models.Song.get({
  id: currentSong.id,
});

const song = response.data;

// If the record has no associated file, we can return early.
if (!song?.coverArtPath) return;

const updatedSong = await client.models.Song.update({
  id: song.id,
  coverArtPath: null,
});
```
</InlineFilter>

### Remove the record association and delete the file

The following example removes the file from the record, then deletes the file from S3:

<InlineFilter filters={["swift"]}>
```swift title="ContentView"
// Get the song record
guard var song = try await Amplify.API.query(request: .get(Song.self, byIdentifier: currentSong.id)).get() else {
    print("Song may have been deleted, no song by id: ", currentSong.id)
    return
}

guard let coverArtPath = song.coverArtPath else {
    print("There is no cover art path to remove image association")
    return
}

// Set the association to nil and update it
song.coverArtPath = nil
let updatedSong = try await Amplify.API.mutate(request: .update(song)).get()

// Remove the image
try await Amplify.Storage.remove(path: .fromString(coverArtPath))
```
</InlineFilter>

<InlineFilter filters={[
  "javascript", "react-native", "angular", "nextjs", "react", "vue"
]}>

```ts title="src/App.tsx"
import { generateClient } from "aws-amplify/api";
import { remove } from "aws-amplify/storage";
import type { Schema } from "../amplify/data/resource";

// Generating the client
const client = generateClient<Schema>({
  authMode: "apiKey",
});
const response = await client.models.Song.get({
  id: currentSong.id,
});
const song = response?.data;

// If the record has no associated file, we can return early.
if (!song?.coverArtPath) return;

// Remove associated file from record
const updatedSong = await client.models.Song.update({
  id: song.id,
  coverArtPath: null,
});

// Delete the file from S3:
await remove({ path: song.coverArtPath });

```
</InlineFilter>

### Delete both file and record

<InlineFilter filters={["swift"]}>
```swift title="ContentView"
// Get the song record
guard let song = try await Amplify.API.query(request: .get(Song.self, byId: currentSong.id)).get() else {
    print("Song may have been deleted, no song by id: ", currentSong.id)
    return
}

if let coverArt = song.coverArtPath {
    // Delete the file from S3
    try await Amplify.Storage.remove(path: .fromString(coverArt))
}

// Delete the song record
_ = try await Amplify.API.mutate(request: .delete(song)).get()
```
</InlineFilter>

<InlineFilter filters={[
  "javascript", "react-native", "angular", "nextjs", "react", "vue"
]}>
```ts title="src/App.tsx"
import { generateClient } from "aws-amplify/api";
import { remove } from "aws-amplify/storage";
import type { Schema } from "../amplify/data/resource";

// Generating the client
const client = generateClient<Schema>({
  authMode: "apiKey",
});
const response = await client.models.Song.get({
  id: currentSong.id,
});

const song = response.data;

// If the record has no associated file, we can return early.
if (!song?.coverArtPath) return;

await remove({ path: song.coverArtPath });

// Delete the record from the API:
await client.models.Song.delete({ id: song.id });

```
</InlineFilter>

## Working with multiple files

You may want to add multiple files to a single record, such as a user profile with multiple images. To do this, you can add a list of file keys to the record. The following example adds a list of file keys to a record:

### GraphQL schema to associate a data model with multiple files

Add the following model in `amplify/data/resource.ts" file.

```ts title="amplify/data/resource.ts"
const schema = a.schema({
  PhotoAlbum: a
    .model({
      id: a.id().required(),
      name: a.string().required(),
      imagePaths: a.string().array(),
    })
    .authorization((allow) => [allow.publicApiKey()]),
});
```

CRUD operations when working with multiple files is the same as when working with a single file, with the exception that we are now working with a list of image keys, as opposed to a single image key.

### Create a record with multiple associated files

First create a record via the GraphQL API, then upload the files to Storage, and finally add the associations between the record and files.

<InlineFilter filters={["swift"]}>
```swift title="ContentView"
// Create the photo album record
let album = PhotoAlbum(name: name)
var createdAlbum = try await Amplify.API.mutate(request: .create(album)).get()

// Upload the photo album images
let imagePaths = await withTaskGroup(of: String?.self) { group in
    for imageData in imagesData {
        group.addTask {
            let path = "images/\(album.id)-\(UUID().uuidString)"
            do {
                _ = try await Amplify.Storage.uploadData(path: .fromString(path), data: imageData).value
                return path
            } catch {
                print("Failed with error:", error)
                return nil
            }
        }
    }

    var imagePaths: [String?] = []
    for await imagePath in group {
        imagePaths.append(imagePath)
    }
    return imagePaths.compactMap { $0 }
}

// Update the album with the image paths
createdAlbum.imagePaths = imagePaths
let updatedAlbum = try await Amplify.API.mutate(request: .update(createdAlbum)).get()
```
</InlineFilter>

<InlineFilter filters={[
  "javascript", "react-native", "angular", "nextjs", "react", "vue"
]}>
```ts title="src/App.tsx"
import { generateClient } from "aws-amplify/api";
import { uploadData, getUrl } from "aws-amplify/storage";
import type { Schema } from "../amplify/data/resource";

// Generating the client
const client = generateClient<Schema>({
  authMode: "apiKey",
});

// Create the API record:
const response = await client.models.PhotoAlbum.create({
  name: `My first photoAlbum`,
});

const photoAlbum = response.data.createPhotoAlbum;

if (!photoAlbum) return;

// Upload all files to Storage:
const imagePaths = await Promise.all(
  Array.from(e.target.files).map(async (file) => {
    const result = await uploadData({
      path: `images/${photoAlbum.id}-${file.name}`,
      data: file,
      options: {
        contentType: "image/png", // contentType is optional
      },
    }).result;

    return result.path;
  })
);

const updatePhotoAlbumDetails = {
  id: photoAlbum.id,
  imagePaths: imagePaths,
};

// Add the file association to the record:
const updateResponse = await client.graphql({
  query: mutations.updatePhotoAlbum,
  variables: { input: updatePhotoAlbumDetails },
});

const updatedPhotoAlbum = updateResponse.data.updatePhotoAlbum;

// If the record has no associated file, we can return early.
if (!updatedPhotoAlbum.imageKeys?.length) return;

// Retrieve signed urls for all files:
const signedUrls = await Promise.all(
  updatedPhotoAlbum?.imagePaths.map(
    async (path) => await getUrl({ path: path! })
  )
);
```
</InlineFilter>

### Add new files to an associated record

To associate additional files with a record, update the record with the paths returned by the Storage uploads.

<InlineFilter filters={["swift"]}>
```swift title="ContentView"
// Upload the new photo album image
let path = "images/\(currentAlbum.id)-\(UUID().uuidString)"
_ = try await Amplify.Storage.uploadData(path: .fromString(path), data: imageData).value

// Get the latest album
guard var album = try await Amplify.API.query(request: .get(PhotoAlbum.self, byId: currentAlbum.id)).get() else {
    print("Album may have been deleted, no album by id: ", currentAlbum.id)
    return
}

guard var imagePaths = album.imagePaths else {
    print("Album does not contain images")
    await setCurrentAlbum(album)
    await setCurrentImages([])
    return
}

// Add new to the existing paths
imagePaths.append(path)

// Update the album with the image paths
album.imagePaths = imagePaths
let updatedAlbum = try await Amplify.API.mutate(request: .update(album)).get()
```
</InlineFilter>

<InlineFilter filters={[
  "javascript", "react-native", "angular", "nextjs", "react", "vue"
]}>
```ts title="src/App.tsx"

import { generateClient } from "aws-amplify/api";
import { uploadData, getUrl } from "aws-amplify/storage";
import type { Schema } from "../amplify/data/resource";

// Generating the client
const client = generateClient<Schema>({
  authMode: "apiKey",
});

// Upload all files to Storage:
const newimagePaths = await Promise.all(
  Array.from(e.target.files).map(async (file) => {
    const result = await uploadData({
      path: `images/${currentPhotoAlbum.id}-${file.name}`,
      data: file,
      options: {
        contentType: "image/png", // contentType is optional
      },
    }).result;

    return result.path;
  })
);

// Query existing record to retrieve currently associated files:
const queriedResponse = await client.models.PhotoAlbum.get({
  id: currentPhotoAlbum.id,
});

const photoAlbum = queriedResponse.data;

if (!photoAlbum?.imagePaths) return;

// Merge existing and new file paths:
const updatedimagePaths = [...newimagePaths, ...photoAlbum.imagePaths];

// Update record with merged file associations:
const response = await client.models.PhotoAlbum.update({
  id: currentPhotoAlbum.id,
  imagePaths: updatedimagePaths,
});

const updatedPhotoAlbum = response.data;

// If the record has no associated file, we can return early.
if (!updatedPhotoAlbum?.imageKeys) return;

// Retrieve signed urls for merged image paths:
const signedUrls = await Promise.all(
  updatedPhotoAlbum?.imagePaths.map(
    async (path) => await getUrl({ path: path! })
  )
);
```
</InlineFilter>

### Update the file for an associated record

Updating a file for an associated record is the same as updating a file for a single file record, with the exception that you will need to update the list of file keys.
<InlineFilter filters={[
  "swift"
]}>
```swift title="ContentView"
// Upload new file to Storage:
let path = "images/\(currentAlbum.id)-\(UUID().uuidString)"

_ = try await Amplify.Storage.uploadData(path: .fromString(path), data: imageData).value

// Update the album with the image keys
var album = currentAlbum

if var imagePaths = album.imagePaths {
    imagePaths.removeLast()
    imagePaths.append(path)
    album.imagePaths = imagePaths
} else {
    album.imagePaths = [path]
}

// Update record with updated file associations:
let updateResult = try await Amplify.API.mutate(request: .update(album)).get()
```
</InlineFilter>
<InlineFilter filters={[
  "javascript", "react-native", "angular", "nextjs", "react", "vue"
]}>
```ts title="src/App.tsx"
import { generateClient } from "aws-amplify/api";
import { uploadData, getUrl } from "aws-amplify/storage";
import type { Schema } from "../amplify/data/resource";

// Generating the client
const client = generateClient<Schema>({
  authMode: "apiKey",
});

// Upload new file to Storage:
const result = await uploadData({
  path: `images/${currentPhotoAlbum.id}-${file.name}`,
  data: file,
  options: {
    contentType: "image/png", // contentType is optional
  },
}).result;

const newFilePath = result.path;

// Query existing record to retrieve currently associated files:
const queriedResponse = await client.models.PhotoAlbum.get({
  id: currentPhotoAlbum.id,
});

const photoAlbum = queriedResponse.data;

if (!photoAlbum?.imagePaths?.length) return;

// Retrieve last image path:
const [lastImagePath] = photoAlbum.imagePaths.slice(-1);

// Remove last file association by path
const updatedimagePaths = [
  ...photoAlbum.imagePaths.filter((path) => path !== lastImagePath),
  newFilePath,
];

// Update record with updated file associations:
const response = await client.models.PhotoAlbum.update({
  id: currentPhotoAlbum.id,
  imagePaths: updatedimagePaths,
});

const updatedPhotoAlbum = response.data;

// If the record has no associated file, we can return early.
if (!updatedPhotoAlbum?.imagePaths) return;

// Retrieve signed urls for merged image paths:
const signedUrls = await Promise.all(
  updatedPhotoAlbum?.imagePaths.map(
    async (path) => await getUrl({ path: path! })
  )
);

```
</InlineFilter>
### Query a record and retrieve the associated files

To retrieve the files associated with a record, first query the record, then use Storage to retrieve all of the signed URLs.

<InlineFilter filters={["swift"]}>
```swift title="ContentView"
// Query the record to get the file paths:
guard let album = try await Amplify.API.query(
    request: .get(PhotoAlbum.self, byId: currentAlbum.id)).get() else {
    print("Album may have been deleted, no album by id: ", currentAlbum.id)
    return
}

guard let imagePathsOptional = album.imagePaths else {
    print("Album does not contain images")
    await setCurrentAlbum(album)
    await setCurrentImages([])
    return
}

let imagePaths = imagePathsOptional.compactMap { $0 }

// Download the photos
let images = await withTaskGroup(of: UIImage?.self) { group in
    for path in imagePaths {
        group.addTask {
            do {
                let imageData = try await Amplify.Storage.downloadData(path: .fromString(path)).value
                return UIImage(data: imageData)
            } catch {
                print("Failed with error:", error)
                return nil
            }
        }
    }

    var images: [UIImage?] = []
    for await image in group {
        images.append(image)
    }
    return images.compactMap { $0 }
}
```
</InlineFilter>
<InlineFilter filters={[
  "javascript", "react-native", "angular", "nextjs", "react", "vue"
]}>
```ts title="src/App.tsx"
async function getImagesForPhotoAlbum() {
import { generateClient } from "aws-amplify/api";
import { uploadData, getUrl } from "aws-amplify/storage";
import type { Schema } from "../amplify/data/resource";

// Generating the client
const client = generateClient<Schema>({
  authMode: "apiKey",
});

// Query the record to get the file paths:
const response = await client.models.PhotoAlbum.get({
  id: currentPhotoAlbum.id,
});

const photoAlbum = response.data;

// If the record has no associated files, we can return early.
if (!photoAlbum?.imagePaths) return;

// Retrieve the signed URLs for the associated images:
const signedUrls = await Promise.all(
  photoAlbum.imagePaths.map(async (imagePath) => {
    if (!imagePath) return;
    return await getUrl({ path: imagePath });
  })
);
}
```
</InlineFilter>

### Delete and remove files associated with API records

The workflow for deleting and removing files associated with API records is the same as when working with a single file, except that when performing a delete you will need to iterate over the list of file paths and call `Storage.remove()` for each file.

#### Remove the file association, continue to persist both files and record

<InlineFilter filters={[
  "swift"
]}>
```swift title="ContentView"
// Get the album record
guard var album = try await Amplify.API.query(request: .get(PhotoAlbum.self, byId: currentAlbum.id)).get() else {
    print("Album may have been deleted, no album by id: ", currentAlbum.id)
    return
}

guard let imagePaths = album.imagePaths, !imagePaths.isEmpty else {
    print("There are no images to remove association")
    return
}

// Set the association to nil and update it
album.imagePaths = nil
let updatedAlbum = try await Amplify.API.mutate(request: .update(album)).get()
```
</InlineFilter>

<InlineFilter filters={[
  "javascript", "react-native", "angular", "nextjs", "react", "vue"
]}>
```ts title="src/App.tsx"

import { generateClient } from "aws-amplify/api";
import type { Schema } from "../amplify/data/resource";

// Generating the client
const client = generateClient<Schema>({
  authMode: "apiKey",
});

const response = await client.models.PhotoAlbum.get({
  id: currentPhotoAlbum.id,
});

const photoAlbum = response.data;

// If the record has no associated file, we can return early.
if (!photoAlbum?.imagePaths) return;

const updatedPhotoAlbum = await client.models.PhotoAlbum.update({
  id: photoAlbum.id,
  imagePaths: null,
});
```
</InlineFilter>

#### Remove the record association and delete the files

<InlineFilter filters={[
  "swift"
]}>
```swift title="ContentView"
// Get the album record
guard var album = try await Amplify.API.query(request: .get(PhotoAlbum.self, byId: currentAlbum.id)).get() else {
    print("Album may have been deleted, no album by id: ", currentAlbum.id)
    return
}

guard let imagePathsOptional = album.imagePaths else {
    print("Album does not contain images")
    await setCurrentAlbum(album)
    await setCurrentImages([])
    return
}
let imagePaths = imagePathsOptional.compactMap { $0 }

// Set the associations to nil and update it
album.imagePaths = nil
let updatedAlbum = try await Amplify.API.mutate(request: .update(album)).get()

// Remove the photos
await withTaskGroup(of: Void.self) { group in
    for path in imagePaths {
        group.addTask {
            do {
                try await Amplify.Storage.remove(path: .fromString(path))
            } catch {
                print("Failed with error:", error)
            }
        }
    }

    for await _ in group {
    }
}
```
</InlineFilter>
<InlineFilter filters={[
  "javascript", "react-native", "angular", "nextjs", "react", "vue"
]}>
```ts title="src/App.tsx"
import { generateClient } from "aws-amplify/api";
import { remove } from "aws-amplify/storage";
import type { Schema } from "../amplify/data/resource";

// Generating the client
const client = generateClient<Schema>({
  authMode: "apiKey",
});

const response = await client.models.PhotoAlbum.get({
  id: currentPhotoAlbum.id,
});

const photoAlbum = response.data;

// If the record has no associated files, we can return early.
if (!photoAlbum?.imagePaths) return;

// Remove associated files from record
const updateResponse = await client.models.PhotoAlbum.update({
  id: photoAlbum.id,
  imagePaths: null, // Set the file association to `null`
});

const updatedPhotoAlbum = updateResponse.data;

// Delete the files from S3:
await Promise.all(
  photoAlbum?.imagePaths.map(async (imagePath) => {
    if (!imagePath) return;
    await remove({ path: imagePath });
  })
);
```
</InlineFilter>

#### Delete record and all associated files

<InlineFilter>
```swift title="ContentView"
// Get the album record
guard let album = try await Amplify.API.query(request: .get(PhotoAlbum.self, byId: currentAlbum.id)).get() else {
    print("Album may have been deleted, no album by id: ", currentAlbum.id)
    return
}

guard let imagePathsOptional = album.imagePaths else {
    print("Album does not contain images")

    // Delete the album record
    _ = try await Amplify.API.mutate(request: .delete(album))

    await setCurrentAlbum(nil)
    await setCurrentImages([])
    return
}

let imagePaths = imagePathsOptional.compactMap { $0 }

// Remove the photos
await withTaskGroup(of: Void.self) { group in
    for path in imagePaths {
        group.addTask {
            do {
                try await Amplify.Storage.remove(path: .fromString(path))
            } catch {
                print("Failed with error:", error)
            }
        }
    }

    for await _ in group {
    }
}

// Delete the album record
_ = try await Amplify.API.mutate(request: .delete(album)).get()
```
</InlineFilter>

<InlineFilter filters={[
  "javascript", "react-native", "angular", "nextjs", "react", "vue"
]}>
```ts title="src/App.tsx"

import { generateClient } from "aws-amplify/api";
import { remove } from "aws-amplify/storage";
import type { Schema } from "../amplify/data/resource";

// Generating the client
const client = generateClient<Schema>({
  authMode: "apiKey",
});

const response = await client.models.PhotoAlbum.get({
  id: currentPhotoAlbum.id,
});

const photoAlbum = response.data;

if (!photoAlbum) return;

await client.models.PhotoAlbum.delete({
  id: photoAlbum.id,
});

setCurrentPhotoAlbum(null);

// If the record has no associated file, we can return early.
if (!photoAlbum?.imagePaths) return;

await Promise.all(
  photoAlbum?.imagePaths.map(async (imagePath) => {
    if (!imagePath) return;
    await remove({ path: imagePath });
  })
);

```
</InlineFilter>

## Data consistency when working with records and files

The recommended access patterns in these docs attempt to remove deleted files, but favor leaving orphans over leaving records that point to non-existent files. This optimizes for read latency by ensuring clients _rarely_ attempt to fetch a non-existent file from Storage. However, any app that deletes files can inherently cause records _on-device_ to point to non-existent files.

One example is when we [create an API record, associate the Storage file with that record, and then retrieve the file's signed URL](#create-a-record-with-an-associated-file). "Device A" calls the GraphQL API to create `API_Record_1`, and then associates that record with `First_Photo`. Before "Device A" is about to retrieve the signed URL, "Device B" might query `API_Record_1`, delete `First_Photo`, and update the record accordingly. However, "Device A" is still using the old `API_Record_1`, which is now out-of-date. Even though the shared global state is correctly in sync at every stage, the individual device ("Device A") has an out-of-date record that points to a non-existent file. Similar issues can conceivably occur for updates. Depending on your app, some of these mismatches can be minimized _even more_ with [real-time data / GraphQL subscriptions](/[platform]/build-a-backend/data/subscribe-data/).

It is important to understand when these mismatches can occur and to add meaningful error handling around these cases. This guide does not include exhaustive error handling, real-time subscriptions, re-querying of outdated records, or attempts to retry failed operations. However, these are all important considerations for a production-level application.

## Complete examples
<InlineFilter filters={[
  "swift"
]}>
<BlockSwitcher>
<Block name="Main App">
```swift title="AmplifySwiftApp"
import SwiftUI
import Amplify
import AWSAPIPlugin
import AWSCognitoAuthPlugin
import AWSS3StoragePlugin
import Authenticator
import PhotosUI

@main
struct WorkingWithFilesApp: App {

    init() {
        do {
            Amplify.Logging.logLevel = .verbose
            try Amplify.add(plugin: AWSCognitoAuthPlugin())
            try Amplify.add(plugin: AWSAPIPlugin(modelRegistration: AmplifyModels()))
            try Amplify.add(plugin: AWSS3StoragePlugin())
            try Amplify.configure(with: .amplifyOutputs)
            print("Amplify configured with Auth, API, and Storage plugins")
        } catch {
            print("Unable to configure Amplify \(error)")
        }
    }

    var body: some Scene {
        WindowGroup {
            Authenticator { state in
                TabView {
                    SongView()
                        .tabItem {
                            Label("Song", systemImage: "music.note")
                        }

                    PhotoAlbumView()
                        .tabItem {
                            Label("PhotoAlbum", systemImage: "photo")
                        }
                }

            }
        }
    }
}

struct SignOutButton: View {
    var body: some View {
        Button("Sign out") {
            Task {
                await Amplify.Auth.signOut()
            }
        }.foregroundColor(.black)
    }
}

struct TappedButtonStyle: ButtonStyle {
    func makeBody(configuration: Configuration) -> some View {
        configuration.label
            .padding(10)
            .background(configuration.isPressed ? Color.teal.opacity(0.8) : Color.teal)
            .foregroundColor(.white)
            .clipShape(RoundedRectangle(cornerRadius: 10))
    }
}

extension Color {
    static let teal = Color(red: 45/255, green: 111/255, blue: 138/255)
}

struct DimmedBackgroundView: View {
    var body: some View {
        Color.gray.opacity(0.5)
            .ignoresSafeArea()
    }
}

struct ImagePicker: UIViewControllerRepresentable {
    @Binding var selectedImage: UIImage?
    @Environment(\.presentationMode) var presentationMode

    class Coordinator: NSObject, UINavigationControllerDelegate, UIImagePickerControllerDelegate {
        let parent: ImagePicker

        init(_ parent: ImagePicker) {
            self.parent = parent
        }

        func imagePickerController(_ picker: UIImagePickerController, didFinishPickingMediaWithInfo info: [UIImagePickerController.InfoKey: Any]) {
            if let uiImage = info[.originalImage] as? UIImage {
                parent.selectedImage = uiImage
            }
            parent.presentationMode.wrappedValue.dismiss()
        }

        func imagePickerControllerDidCancel(_ picker: UIImagePickerController) {
            parent.presentationMode.wrappedValue.dismiss()
        }
    }

    func makeCoordinator() -> Coordinator {
        Coordinator(self)
    }

    func makeUIViewController(context: UIViewControllerRepresentableContext<ImagePicker>) -> UIImagePickerController {
        let imagePicker = UIImagePickerController()
        imagePicker.delegate = context.coordinator
        return imagePicker
    }

    func updateUIViewController(_ uiViewController: UIImagePickerController, context: UIViewControllerRepresentableContext<ImagePicker>) {
    }
}

struct MultiImagePicker: UIViewControllerRepresentable {
    @Binding var selectedImages: [UIImage]

    func makeUIViewController(context: Context) -> PHPickerViewController {
        var configuration = PHPickerConfiguration()
        configuration.filter = .images
        configuration.selectionLimit = 0

        let picker = PHPickerViewController(configuration: configuration)
        picker.delegate = context.coordinator
        return picker
    }

    func updateUIViewController(_ uiViewController: PHPickerViewController, context: Context) {
        // No need for updates in this case
    }

    func makeCoordinator() -> Coordinator {
        Coordinator(parent: self)
    }

    class Coordinator: PHPickerViewControllerDelegate {
        private let parent: MultiImagePicker

        init(parent: MultiImagePicker) {
            self.parent = parent
        }

        func picker(_ picker: PHPickerViewController, didFinishPicking results: [PHPickerResult]) {
            picker.dismiss(animated: true, completion: nil)
            DispatchQueue.main.async {
                self.parent.selectedImages = []
            }
            for result in results {
                if result.itemProvider.canLoadObject(ofClass: UIImage.self) {
                    result.itemProvider.loadObject(ofClass: UIImage.self) { (image, error) in
                        if let image = image as? UIImage {
                            DispatchQueue.main.async {
                                self.parent.selectedImages.append(image)
                            }
                        }
                    }
                }
            }
        }
    }
}
```
</Block>
<Block name="Song">
```swift title="SongView"
import SwiftUI
import Amplify

class SongViewModel: ObservableObject {

    @Published var currentSong: Song? = nil
    @Published var currentImage: UIImage? = nil
    @Published var isLoading: Bool = false

    // Create a song with an associated image
    func createSong(name: String, artCover: UIImage) async throws {
        await setIsLoading(true)
        defer {
            Task {
                await setIsLoading(false)
            }
        }
                let song = Song(name: name)

        guard let imageData = artCover.pngData() else {
            print("Could not get data from image.")
            return
        }

        // Create the song record
        var createdSong = try await Amplify.API.mutate(request: .create(song)).get()
        let coverArtPath = "images/\(createdSong.id)"

        // Upload the art cover image
        _ = try await Amplify.Storage.uploadData(path: .fromString(coverArtPath), data: imageData).value

        // Update the song record with the image path
        createdSong.coverArtPath = coverArtPath
        let updatedSong = try await Amplify.API.mutate(request: .update(createdSong)).get()

        await setCurrentSong(updatedSong)
    }

    func getSongAndFile(currentSong: Song, imageData: Data) async throws {
        // Get the song record
        guard var song = try await Amplify.API.query(request: .get(Song.self, byIdentifier: currentSong.id)).get() else {
            print("Song may have been deleted, no song by id: ", currentSong.id)
            return
        }

        guard let coverArtPath = song.coverArtPath else {
            print("There is no cover art path to retrieve image")
            return
        }

        // Download the art cover
        let imageData = try await Amplify.Storage.downloadData(path: .fromString(coverArtPath)).value

        let image = UIImage(data: imageData)
    }

    // Add or update an image for an associated record
    func updateArtCover(artCover: UIImage) async throws {
        await setIsLoading(true)
        defer {
            Task {
                await setIsLoading(false)
            }
        }

        guard var currentSong = currentSong else {
            print("There is no song to associated the image with. Create a Song first.")
            return
        }

        guard let imageData = artCover.pngData() else {
            print("Could not get data from UIImage.")
            return
        }

        let coverArtPath = "images/\(currentSong.id)"

        // Upload the new art image
        _ = try await Amplify.Storage.uploadData(path: .fromString(coverArtPath), data: imageData).value

        // Update the song record
        currentSong.coverArtPath = coverArtPath
        let updatedSong = try await Amplify.API.mutate(request: .update(currentSong)).get()

        await setCurrentSong(updatedSong)
    }

    func refreshSongAndArtCover() async throws {
        await setIsLoading(true)
        defer {
            Task {
                await setIsLoading(false)
            }
        }
        guard let currentSong = currentSong else {
            print("There is no song to refresh the record and image. Create a song first.")
            return
        }
        await setCurrentSong(nil)
        await setCurrentImage(nil)

        // Get the song record
        guard let song = try await Amplify.API.query(request: .get(Song.self, byIdentifier: currentSong.id)).get() else {
            print("Song may have been deleted, no song by id: ", currentSong.id)
            return
        }

        guard let coverArtPath = song.coverArtPath else {
            print("Song does not contain cover art")
            await setCurrentSong(song)
            await setCurrentImage(nil)
            return
        }

        // Download the art cover
        let imageData = try await Amplify.Storage.downloadData(path: .fromString(coverArtPath)).value

        let image = UIImage(data: imageData)

        await setCurrentSong(song)
        await setCurrentImage(image)
    }

    func removeImageAssociationFromSong() async throws {
        await setIsLoading(true)
        defer {
            Task {
                await setIsLoading(false)
            }
        }
        guard let currentSong = currentSong else {
            print("There is no song to remove art cover from it. Create a song first.")
            return
        }

        // Get the song record
        guard var song = try await Amplify.API.query(request: .get(Song.self, byIdentifier: currentSong.id)).get() else {
            print("Song may have been deleted, no song by id: ", currentSong.id)
            return
        }

        guard song.coverArtPath != nil else {
            print("There is no cover art path to remove image association")
            return
        }

        // Set the association to nil and update it
        song.coverArtPath = nil

        let updatedSong = try await Amplify.API.mutate(request: .update(song)).get()

        await setCurrentSong(updatedSong)
    }

    func removeImageAssociationAndDeleteImage() async throws {
        await setIsLoading(true)
        defer {
            Task {
                await setIsLoading(false)
            }
        }
        guard let currentSong = currentSong else {
            print("There is no song to remove art cover from it. Create a song first.")
            return
        }

        // Get the song record
        guard var song = try await Amplify.API.query(request: .get(Song.self, byIdentifier: currentSong.id)).get() else {
            print("Song may have been deleted, no song by id: ", currentSong.id)
            return
        }

        guard let coverArtPath = song.coverArtPath else {
            print("There is no cover art path to remove image association")
            return
        }

        // Set the association to nil and update it
        song.coverArtPath = nil
        let updatedSong = try await Amplify.API.mutate(request: .update(song)).get()

        // Remove the image
        try await Amplify.Storage.remove(path: .fromString(coverArtPath))

        await setCurrentSong(updatedSong)
        await setCurrentImage(nil)
    }

    func deleteSongAndArtCover() async throws {
        await setIsLoading(true)
        defer {
            Task {
                await setIsLoading(false)
            }
        }
        guard let currentSong = currentSong else {
            print("There is no song to delete. Create a song first.")
            return
        }

        // Get the song record
        guard var song = try await Amplify.API.query(request: .get(Song.self, byId: currentSong.id)).get() else {
            print("Song may have been deleted, no song by id: ", currentSong.id)
            return
        }

        if let coverArt = song.coverArtPath {
            // Remove the image
            try await Amplify.Storage.remove(path: .fromString(coverArt))
        }

        // Delete the song record
        _ = try await Amplify.API.mutate(request: .delete(song)).get()

        await setCurrentSong(nil)
        await setCurrentImage(nil)
    }

    @MainActor
    func setCurrentSong(_ song: Song?) {
        self.currentSong = song
    }

    @MainActor
    func setCurrentImage(_ image: UIImage?) {
        self.currentImage = image
    }

    @MainActor
    func setIsLoading(_ isLoading: Bool) {
        self.isLoading = isLoading
    }
}

struct SongView: View {

    @State private var isImagePickerPresented = false
    @State private var songName: String = ""

    @StateObject var viewModel = SongViewModel()

    var body: some View {
        NavigationView {
            ZStack {
                VStack {
                    SongInformation()
                    DisplayImage()
                    OpenImagePickerButton()
                    SongNameTextField()
                    CreateOrUpdateSongButton()
                    AdditionalOperations()
                    Spacer()
                }
                .padding()
                .sheet(isPresented: $isImagePickerPresented) {
                    ImagePicker(selectedImage: $viewModel.currentImage)
                }
                VStack {
                    IsLoadingView()
                }
            }
            .navigationBarItems(trailing: SignOutButton())
        }
    }

    @ViewBuilder
    func SongInformation() -> some View {
        if let song = viewModel.currentSong {
            Text("Song Id: \(song.id)").font(.caption)
            if song.name != "" {
                Text("Song Name: \(song.name)").font(.caption)
            }
        }
    }

    @ViewBuilder
    func DisplayImage() -> some View {
        if let image = viewModel.currentImage {
            Image(uiImage: image)
                .resizable()
                .aspectRatio(contentMode: .fit)
        } else {
            Text("No Image Selected")
                .foregroundColor(.gray)
        }

    }

    func OpenImagePickerButton() -> some View {
        Button("Select \(viewModel.currentImage != nil ? "a new ": "" )song album cover") {
            isImagePickerPresented.toggle()
        }.buttonStyle(TappedButtonStyle())
    }

    @ViewBuilder
    func SongNameTextField() -> some View {
        TextField("\(viewModel.currentSong != nil ? "Update": "Enter") song name", text: $songName)
            .textFieldStyle(RoundedBorderTextFieldStyle())
            .multilineTextAlignment(.center)
    }

    @ViewBuilder
    func CreateOrUpdateSongButton() -> some View {
        if viewModel.currentSong == nil, let image = viewModel.currentImage {
            Button("Save") {
                Task {
                    try? await viewModel.createSong(name: songName,
                                                    artCover: image)
                }
            }
            .buttonStyle(TappedButtonStyle())
            .disabled(viewModel.isLoading)
        } else if viewModel.currentSong != nil, let image = viewModel.currentImage {
            Button("Update") {
                Task {
                    try? await viewModel.updateArtCover(artCover: image)
                }
            }
            .buttonStyle(TappedButtonStyle())
            .disabled(viewModel.isLoading)
        }
    }

    @ViewBuilder
    func AdditionalOperations() -> some View {
        if viewModel.currentSong != nil {
            VStack {
                Button("Refresh") {
                    Task {
                        try? await viewModel.refreshSongAndArtCover()
                    }
                }.buttonStyle(TappedButtonStyle())
                Button("Remove association from song") {
                    Task {
                        try? await viewModel.removeImageAssociationFromSong()
                    }
                }.buttonStyle(TappedButtonStyle())
                Button("Remove association and delete image") {
                    Task {
                        try? await viewModel.removeImageAssociationAndDeleteImage()
                    }
                }.buttonStyle(TappedButtonStyle())
                Button("Delete song and art cover") {
                    Task {
                        try? await viewModel.deleteSongAndArtCover()
                    }
                    songName = ""
                }.buttonStyle(TappedButtonStyle())
            }.disabled(viewModel.isLoading)
        }
    }

    @ViewBuilder
    func IsLoadingView() -> some View {
        if viewModel.isLoading {
            ZStack {
                DimmedBackgroundView()
                ProgressView()
            }
        }
    }
}

struct SongView_Previews: PreviewProvider {
    static var previews: some View {
        SongView()
    }
}
```
</Block>
<Block name="Photo Album">
```swift title="PhotoAlbumView"
import SwiftUI
import Amplify
import Photos

class PhotoAlbumViewModel: ObservableObject {
    @Published var currentImages: [UIImage] = []
    @Published var currentAlbum: PhotoAlbum? = nil
    @Published var isLoading: Bool = false

    // Create a record with multiple associated files
    func createPhotoAlbum(name: String, photos: [UIImage]) async throws {
        await setIsLoading(true)
        defer {
            Task {
                await setIsLoading(false)
            }
        }

        let imagesData = photos.compactMap { $0.pngData() }
        guard !imagesData.isEmpty else {
            print("Could not get data from [UIImage]")
            return
        }

        // Create the photo album record
        let album = PhotoAlbum(name: name)
        var createdAlbum = try await Amplify.API.mutate(request: .create(album)).get()

        // Upload the photo album images
        let imagePaths = await withTaskGroup(of: String?.self) { group in
            for imageData in imagesData {
                group.addTask {
                    let path = "images/\(album.id)-\(UUID().uuidString)"
                    do {
                        _ = try await Amplify.Storage.uploadData(path: .fromString(path), data: imageData).value
                        return path
                    } catch {
                        print("Failed with error:", error)
                        return nil
                    }
                }
            }

            var imagePaths: [String?] = []
            for await imagePath in group {
                imagePaths.append(imagePath)
            }
            return imagePaths.compactMap { $0 }
        }

        // Update the album with the image paths
        createdAlbum.imagePaths = imagePaths
        let updatedAlbum = try await Amplify.API.mutate(request: .update(createdAlbum)).get()

        await setCurrentAlbum(updatedAlbum)
    }

    // Create a record with a single associated file
    func createPhotoAlbum(name: String, photo: UIImage) async throws {
        await setIsLoading(true)
        defer {
            Task {
                await setIsLoading(false)
            }
        }

        guard let imageData = photo.pngData() else {
            print("Could not get data from UIImage")
            return
        }

        // Create the photo album record
        let album = PhotoAlbum(name: name)
        var createdAlbum = try await Amplify.API.mutate(request: .create(album)).get()

        // Upload the photo album image
        let path = "images/\(album.id)-\(UUID().uuidString)"
        _ = try await Amplify.Storage.uploadData(path: .fromString(path), data: imageData).value

        // Update the album with the image path
        createdAlbum.imagePaths = [path]
        let updatedAlbum = try await Amplify.API.mutate(request: .update(createdAlbum)).get()

        await setCurrentAlbum(updatedAlbum)
    }

    // Add new file to an associated record
    func addAdditionalPhotos(_ photo: UIImage) async throws {
        await setIsLoading(true)
        defer {
            Task {
                await setIsLoading(false)
            }
        }

        guard let currentAlbum = currentAlbum else {
            print("There is no album to associated the images with. Create an Album first.")
            return
        }

        guard let imageData = photo.pngData() else {
            print("Could not get data from UIImage.")
            return
        }

        // Upload the new photo album image
        let path = "images/\(currentAlbum.id)-\(UUID().uuidString)"
        _ = try await Amplify.Storage.uploadData(path: .fromString(path), data: imageData).value

        // Get the latest album
        guard var album = try await Amplify.API.query(request: .get(PhotoAlbum.self, byId: currentAlbum.id)).get() else {
            print("Album may have been deleted, no album by id: ", currentAlbum.id)
            return
        }

        guard var imagePaths = album.imagePaths else {
            print("Album does not contain images")
            await setCurrentAlbum(album)
            await setCurrentImages([])
            return
        }

        // Add new to the existing paths
        imagePaths.append(path)

        // Update the album with the image paths
        album.imagePaths = imagePaths
        let updatedAlbum = try await Amplify.API.mutate(request: .update(album)).get()

        await setCurrentAlbum(updatedAlbum)
    }

    func replaceLastImage(_ photo: UIImage) async throws {
        await setIsLoading(true)
        defer {
            Task {
                await setIsLoading(false)
            }
        }

        guard let currentAlbum = currentAlbum else {
            print("There is no album to associated the images with. Create an Album first.")
            return
        }

        guard let imageData = photo.pngData() else {
            print("Could not get data from UIImage")
            return
        }


        // Upload the new photo album image
        let path = "images/\(currentAlbum.id)-\(UUID().uuidString)"
        _ = try await Amplify.Storage.uploadData(path: .fromString(path), data: imageData).value

        // Update the album with the image paths
        var album = currentAlbum
        if var imagePaths = album.imagePaths {
            imagePaths.removeLast()
            imagePaths.append(path)
            album.imagePaths = imagePaths
        } else {
            album.imagePaths = [path]
        }

        let updatedAlbum = try await Amplify.API.mutate(request: .update(album)).get()

        await setCurrentAlbum(updatedAlbum)
    }

    // Query a record and retrieve the associated files
    func refreshAlbumAndPhotos() async throws {
        await setIsLoading(true)
        defer {
            Task {
                await setIsLoading(false)
            }
        }
        guard let currentAlbum = currentAlbum else {
            print("There is no album to associate the images with. Create an Album first.")
            return
        }

        await setCurrentAlbum(nil)
        await setCurrentImages([])

        // Get the song record
        guard let album = try await Amplify.API.query(
            request: .get(PhotoAlbum.self, byId: currentAlbum.id)).get() else {
            print("Album may have been deleted, no album by id: ", currentAlbum.id)
            return
        }

        guard let imagePathsOptional = album.imagePaths else {
            print("Album does not contain images")
            await setCurrentAlbum(album)
            await setCurrentImages([])
            return
        }

        let imagePaths = imagePathsOptional.compactMap { $0 }

        // Download the photos
        let images = await withTaskGroup(of: UIImage?.self) { group in
            for path in imagePaths {
                group.addTask {
                    do {
                        let imageData = try await Amplify.Storage.downloadData(path: .fromString(path)).value
                        return UIImage(data: imageData)
                    } catch {
                        print("Failed with error:", error)
                        return nil
                    }
                }
            }

            var images: [UIImage?] = []
            for await image in group {
                images.append(image)
            }
            return images.compactMap { $0 }
        }

        await setCurrentAlbum(album)
        await setCurrentImages(images)
    }

    // Remove the file association
    func removeStorageAssociationsFromAlbum() async throws {
        await setIsLoading(true)
        defer {
            Task {
                await setIsLoading(false)
            }
        }
        guard let currentAlbum = currentAlbum else {
            print("There is no album to associated the images with. Create an Album first.")
            return
        }

        // Get the album record
        guard var album = try await Amplify.API.query(request: .get(PhotoAlbum.self, byId: currentAlbum.id)).get() else {
            print("Album may have been deleted, no album by id: ", currentAlbum.id)
            return
        }

        guard let imagePaths = album.imagePaths, !imagePaths.isEmpty else {
            print("There are no images to remove association")
            return
        }

        // Set the association to nil and update it
        album.imagePaths = nil
        let updatedAlbum = try await Amplify.API.mutate(request: .update(album)).get()

        await setCurrentAlbum(updatedAlbum)
    }

    // Remove the record association and delete the files
    func removeStorageAssociationsAndDeletePhotos() async throws {
        await setIsLoading(true)
        defer {
            Task {
                await setIsLoading(false)
            }
        }

        guard let currentAlbum = currentAlbum else {
            print("There is no album to associated the images with. Create an Album first.")
            return
        }

        // Get the album record
        guard var album = try await Amplify.API.query(request: .get(PhotoAlbum.self, byId: currentAlbum.id)).get() else {
            print("Album may have been deleted, no album by id: ", currentAlbum.id)
            return
        }

        guard let imagePathsOptional = album.imagePaths else {
            print("Album does not contain images")
            await setCurrentAlbum(album)
            await setCurrentImages([])
            return
        }
        let imagePaths = imagePathsOptional.compactMap { $0 }

        // Set the associations to nil and update it
        album.imagePaths = nil
        let updatedAlbum = try await Amplify.API.mutate(request: .update(album)).get()

        // Remove the photos
        await withTaskGroup(of: Void.self) { group in
            for path in imagePaths {
                group.addTask {
                    do {
                        try await Amplify.Storage.remove(path: .fromString(path))
                    } catch {
                        print("Failed with error:", error)
                    }
                }
            }

            for await _ in group {
            }
        }

        await setCurrentAlbum(updatedAlbum)
        await setCurrentImages([])
    }

    // Delete record and all associated files
    func deleteAlbumAndPhotos() async throws {
        await setIsLoading(true)
        defer {
            Task {
                await setIsLoading(false)
            }
        }

        guard let currentAlbum = currentAlbum else {
            print("There is no album to associated the images with. Create an Album first.")
            return
        }

        // Get the album record
        guard let album = try await Amplify.API.query(request: .get(PhotoAlbum.self, byId: currentAlbum.id)).get() else {
            print("Album may have been deleted, no album by id: ", currentAlbum.id)
            return
        }

        guard let imagePathsOptional = album.imagePaths else {
            print("Album does not contain images")

            // Delete the album record
            _ = try await Amplify.API.mutate(request: .delete(album))

            await setCurrentAlbum(nil)
            await setCurrentImages([])
            return
        }

        let imagePaths = imagePathsOptional.compactMap { $0 }

        // Remove the photos
        await withTaskGroup(of: Void.self) { group in
            for path in imagePaths {
                group.addTask {
                    do {
                        try await Amplify.Storage.remove(path: .fromString(path))
                    } catch {
                        print("Failed with error:", error)
                    }
                }
            }

            for await _ in group {
            }
        }

        // Delete the album record
        _ = try await Amplify.API.mutate(request: .delete(album)).get()

        await setCurrentAlbum(nil)
        await setCurrentImages([])
    }

    @MainActor
    func setCurrentAlbum(_ album: PhotoAlbum?) {
        self.currentAlbum = album
    }

    @MainActor
    func setCurrentImages(_ images: [UIImage]) {
        self.currentImages = images
    }

    @MainActor
    func setIsLoading(_ isLoading: Bool) {
        self.isLoading = isLoading
    }
}

struct PhotoAlbumView: View {
    @State private var isImagePickerPresented: Bool = false
    @State private var albumName: String = ""
    @State private var isLastImagePickerPresented = false
    @State private var lastImage: UIImage? = nil
    @StateObject var viewModel = PhotoAlbumViewModel()

    var body: some View {
        NavigationView {
            ZStack {
                VStack {
                    AlbumInformation()
                    DisplayImages()
                    OpenImagePickerButton()
                    PhotoAlbumNameTextField()
                    CreateOrUpdateAlbumButton()
                    AdditionalOperations()
                }
                .padding()
                .sheet(isPresented: $isImagePickerPresented) {
                    MultiImagePicker(selectedImages: $viewModel.currentImages)
                }
                .sheet(isPresented: $isLastImagePickerPresented) {
                    ImagePicker(selectedImage: $lastImage)
                }
                VStack {
                    IsLoadingView()
                }
            }
            .navigationBarItems(trailing: SignOutButton())
        }
    }

    @ViewBuilder
    func AlbumInformation() -> some View {
        if let album = viewModel.currentAlbum {
            Text("Album Id: \(album.id)").font(.caption)
            if album.name != "" {
                Text("Album Name: \(album.name)").font(.caption)
            }
        }
    }

    @ViewBuilder
    func DisplayImages() -> some View {
        // Display selected images
        ScrollView(.horizontal) {
            HStack {
                ForEach($viewModel.currentImages, id: \.self) { image in
                    Image(uiImage: image.wrappedValue)
                        .resizable()
                        .aspectRatio(contentMode: .fit)
                        .frame(width: 100, height: 100)
                }
            }
        }
        if $viewModel.currentImages.isEmpty {
            Text("No Images Selected")
                .foregroundColor(.gray)
        }
    }

    func OpenImagePickerButton() -> some View {
        // Button to open the image picker
        Button("Select \(!viewModel.currentImages.isEmpty ? "new " : "")photo album images") {
            isImagePickerPresented.toggle()
        }.buttonStyle(TappedButtonStyle())
    }

    @ViewBuilder
    func PhotoAlbumNameTextField() -> some View {
        TextField("\(viewModel.currentAlbum != nil ? "Update": "Enter") album name", text: $albumName)
            .textFieldStyle(RoundedBorderTextFieldStyle())
            .multilineTextAlignment(.center)
    }

    @ViewBuilder
    func CreateOrUpdateAlbumButton() -> some View {
        if viewModel.currentAlbum == nil, !viewModel.currentImages.isEmpty {
            Button("Save") {
                Task {
                    try? await viewModel.createPhotoAlbum(name: albumName,
                                                          photos: viewModel.currentImages)
                }
            }
            .buttonStyle(TappedButtonStyle())
            .disabled(viewModel.isLoading)
        } else if viewModel.currentAlbum != nil {
            Button("Select \(lastImage != nil ? "another ": "")photo to replace last photo in the album") {
                isLastImagePickerPresented.toggle()
            }
            .buttonStyle(TappedButtonStyle())
            .disabled(viewModel.isLoading)

            if let lastImage = lastImage {
                Image(uiImage: lastImage)
                    .resizable()
                    .aspectRatio(contentMode: .fit)
                Button("Replace last image in album with above") {
                    Task {
                        try? await viewModel.replaceLastImage(lastImage)
                        self.lastImage = nil
                        try? await viewModel.refreshAlbumAndPhotos()
                    }
                }
                .buttonStyle(TappedButtonStyle())
                .disabled(viewModel.isLoading)
                Button("Append above image to album") {
                    Task {
                        try? await viewModel.addAdditionalPhotos(lastImage)
                        self.lastImage = nil
                        try? await viewModel.refreshAlbumAndPhotos()
                    }
                }
                .buttonStyle(TappedButtonStyle())
                .disabled(viewModel.isLoading)
            }
        }
    }

    @ViewBuilder
    func AdditionalOperations() -> some View {
        if viewModel.currentAlbum != nil {
            VStack {
                Button("Refresh") {
                    Task {
                        try? await viewModel.refreshAlbumAndPhotos()
                    }
                }.buttonStyle(TappedButtonStyle())
                Button("Remove associations from album") {
                    Task {
                        try? await viewModel.removeStorageAssociationsFromAlbum()
                        try? await viewModel.refreshAlbumAndPhotos()
                    }
                }.buttonStyle(TappedButtonStyle())
                Button("Remove association and delete photos") {
                    Task {
                        try? await viewModel.removeStorageAssociationsAndDeletePhotos()
                        try? await viewModel.refreshAlbumAndPhotos()
                    }
                }.buttonStyle(TappedButtonStyle())
                Button("Delete album and images") {
                    Task {
                        try? await viewModel.deleteAlbumAndPhotos()
                    }
                    albumName = ""
                }.buttonStyle(TappedButtonStyle())
            }.disabled(viewModel.isLoading)
        }
    }

    @ViewBuilder
    func IsLoadingView() -> some View {
        if viewModel.isLoading {
            ZStack {
                DimmedBackgroundView()
                ProgressView()
            }
        }
    }
}

struct PhotoAlbumView_Previews: PreviewProvider {
    static var previews: some View {
        PhotoAlbumView()
    }
}
```
</Block>
</BlockSwitcher>
</InlineFilter>

<InlineFilter filters={[
  "javascript", "react-native", "nextjs", "react"
]}>
<BlockSwitcher>
<Block name="Single File (TS)">

```ts title="src/App.tsx"

import "./App.css";
import { generateClient } from "aws-amplify/api";
import { uploadData, getUrl, remove } from "aws-amplify/storage";
import React, { useState } from "react";
import type { Schema } from "../amplify/data/resource";
import "@aws-amplify/ui-react/styles.css";
import {
  type WithAuthenticatorProps,
  withAuthenticator,
} from "@aws-amplify/ui-react";
import { Amplify } from "aws-amplify";
import outputs from "../amplify_outputs.json";

Amplify.configure(outputs);

// Generating the client
const client = generateClient<Schema>({
  authMode: "apiKey",
});

type Song = Schema["Song"]["type"];

function App({ signOut, user }: WithAuthenticatorProps) {

  const [currentSong, setCurrentSong] = useState<Song | null>(null);

  // Used to display image for current song:
  const [currentImageUrl, setCurrentImageUrl] = useState<
    string | null | undefined
    >("");

  async function createSongWithImage(e: React.ChangeEvent<HTMLInputElement>) {
    if (!e.target.files) return;
    const file = e.target.files[0];
    try {

      // Create the API record:
      const response = await client.models.Song.create({
        name: `My first song`,
      });

      const song = response.data;

      if (!song) return;

      // Upload the Storage file:
      const result = await uploadData({
        path: `images/${song.id}-${file.name}`,
        data: file,
        options: {
          contentType: "image/png", // contentType is optional
        },
      }).result;

      // Add the file association to the record:
      const updateResponse = await client.models.Song.update({
        id: song.id,
        coverArtPath: result?.path,
      });

      const updatedSong = updateResponse.data;
      setCurrentSong(updatedSong);

      // If the record has no associated file, we can return early.
      if (!updatedSong?.coverArtPath) return;

      // Retrieve the file's signed URL:
      const signedURL = await getUrl({ path: updatedSong.coverArtPath });

      setCurrentImageUrl(signedURL.url.toString());
    } catch (error) {
      console.error("Error create song / file:", error);
    }
  }

  // Upload image, add to song, retrieve signed URL and retrieve the image.
  // Also updates image if one already exists.
  async function addNewImageToSong(e: React.ChangeEvent<HTMLInputElement>) {

    if (!currentSong) return;

    if (!e.target.files) return;

    const file = e.target.files[0];

    try {
      // Upload the Storage file:
      const result = await uploadData({
        path: `images/${currentSong.id}-${file.name}`,
        data: file,
        options: {
          contentType: "image/png", // contentType is optional
        },
      }).result;

      // Add the file association to the record:
      const response = await client.models.Song.update({
        id: currentSong.id,
        coverArtPath: result?.path,
      });

      const updatedSong = response.data;

      setCurrentSong(updatedSong);

      // If the record has no associated file, we can return early.
      if (!updatedSong?.coverArtPath) return;

      // Retrieve the file's signed URL:
      const signedURL = await getUrl({ path: updatedSong.coverArtPath });
      setCurrentImageUrl(signedURL.url.toString());

    } catch (error) {
      console.error("Error uploading image / adding image to song: ", error);
    }
  }

  async function getImageForCurrentSong() {
    if (!currentSong) return;

    try {
      // Query the record to get the file path:
      const response = await client.models.Song.get({
        id: currentSong.id,
      });

      const song = response.data;

      // If the record has no associated file, we can return early.
      if (!song?.coverArtPath) return;

      // Retrieve the signed URL:
      const signedURL = await getUrl({ path: song.coverArtPath });
      setCurrentImageUrl(signedURL.url.toString());
    } catch (error) {
      console.error("Error getting song / image:", error);
    }
  }

  // Remove the file association, continue to persist both file and record
  async function removeImageFromSong() {

    if (!currentSong) return;

    try {
      const response = await client.models.Song.get({
        id: currentSong.id,
      });

      const song = response.data;

      // If the record has no associated file, we can return early.
      if (!song?.coverArtPath) return;

      const updatedSong = await client.models.Song.update({
        id: song.id,
        coverArtPath: null,
      });

      // If successful, the response here will be `null`:
      setCurrentSong(updatedSong.data);

      setCurrentImageUrl(updatedSong.data?.coverArtPath);

    } catch (error) {
      console.error("Error removing image from song: ", error);
    }
  }

  // Remove the record association and delete the file
  async function deleteImageForCurrentSong() {

    if (!currentSong) return;

    try {
      const response = await client.models.Song.get({
        id: currentSong.id,
      });

      const song = response?.data;

      // If the record has no associated file, we can return early.
      if (!song?.coverArtPath) return;

      // Remove associated file from record
      const updatedSong = await client.models.Song.update({
        id: song.id,
        coverArtPath: null,
      });

      // Delete the file from S3:
      await remove({ path: song.coverArtPath });

      // If successful, the response here will be `null`:
      setCurrentSong(updatedSong.data);

      setCurrentImageUrl(updatedSong.data?.coverArtPath);

    } catch (error) {
      console.error("Error deleting image: ", error);
    }
  }

  // Delete both file and record
  async function deleteCurrentSongAndImage() {

    if (!currentSong) return;
    try {
      const response = await client.models.Song.get({
        id: currentSong.id,
      });
      const song = response.data;

      // If the record has no associated file, we can return early.
      if (!song?.coverArtPath) return;

      await remove({ path: song.coverArtPath });

      // Delete the record from the API:
      await client.models.Song.delete({ id: song.id });

      clearLocalState();

    } catch (error) {
      console.error("Error deleting song: ", error);
    }
  }

  function clearLocalState() {
    setCurrentSong(null);
    setCurrentImageUrl("");
  }

  return (
    <>
      <h1>Hello {user?.username}</h1>
      <button onClick={signOut}>Sign out</button>
      <div>
        <label>
          <h2>{`Current Song: ${currentSong?.id}`}</h2>
          Create song with file:
          <input id="name" type="file" onChange={createSongWithImage} />
        </label>
        <label>
          Add / update song image:
          <input
            id="name"
            type="file"
            onChange={addNewImageToSong}
            disabled={!currentSong}
          />
        </label>
        <button
          onClick={getImageForCurrentSong}
          disabled={!currentSong || !currentImageUrl}
        >
          Get image for current song
        </button>
        <button
          onClick={removeImageFromSong}
          disabled={!currentSong || !currentImageUrl}
        >
          Remove image from current song (does not delete image)
        </button>
        <button
          onClick={deleteImageForCurrentSong}
          disabled={!currentSong || !currentImageUrl}
        >
          Remove image from current song, then delete image
        </button>
        <button onClick={deleteCurrentSongAndImage} disabled={!currentSong}>
          Delete current song (and image, if it exists)
        </button>
        <button onClick={signOut} className="app-button">
          Sign out
        </button>
      </div>
    </>
  );
}

export default withAuthenticator(App);


```
</Block>
<Block name="Multi-File (TS)">

```ts title="src/App.tsx"

import "./App.css";
import { generateClient } from "aws-amplify/api";
import { uploadData, getUrl, remove } from "aws-amplify/storage";
import React, { useState } from "react";
import type { Schema } from "../amplify/data/resource";
import "@aws-amplify/ui-react/styles.css";
import {
  type WithAuthenticatorProps,
  withAuthenticator,
} from "@aws-amplify/ui-react";
import { Amplify } from "aws-amplify";
import outputs from "../amplify_outputs.json";

Amplify.configure(outputs);

// Generating the client
const client = generateClient<Schema>({
  authMode: "apiKey",
});

type PhotoAlbum = Schema["PhotoAlbum"]["type"];

function App({ signOut, user }: WithAuthenticatorProps) {
  // State to hold the recognized text
  const [currentPhotoAlbum, setCurrentPhotoAlbum] = useState<PhotoAlbum | null>(
    null
  );

  // Used to display images for current photoAlbum:
  const [currentImages, setCurrentImages] = useState<
    (string | null | undefined)[] | null | undefined
  >([]);

  async function createPhotoAlbumWithFirstImage(
    e: React.ChangeEvent<HTMLInputElement>
  ) {
    if (!e.target.files) return;

    const file = e.target.files[0];

    try {
      // Create the API record:
      const response = await client.models.PhotoAlbum.create({
        name: `My first photoAlbum`,
      });

      const photoAlbum = response.data;

      if (!photoAlbum) return;

      // Upload the Storage file:
      const result = await uploadData({
        path: `images/${photoAlbum.id}-${file.name}`,
        data: file,
        options: {
          contentType: "image/png", // contentType is optional
        },
      }).result;

      const updatePhotoAlbumDetails = {
        id: photoAlbum.id,
        imagePaths: [result.path],
      };

      // Add the file association to the record:
      const updateResponse = await client.models.PhotoAlbum.update({
        id: photoAlbum.id,
        imagePaths: [result.path],
      });

      const updatedPhotoAlbum = updateResponse.data;

      setCurrentPhotoAlbum(updatedPhotoAlbum);

      // If the record has no associated file, we can return early.
      if (!updatedPhotoAlbum?.imagePaths?.length) return;

      // Retrieve the file's signed URL:
      const signedURL = await getUrl({
        path: updatedPhotoAlbum.imagePaths[0]!,
      });
      setCurrentImages([signedURL.url.toString()]);
    } catch (error) {
      console.error("Error create photoAlbum / file:", error);
    }
  }

  async function createPhotoAlbumWithMultipleImages(
    e: React.ChangeEvent<HTMLInputElement>
  ) {
    if (!e.target.files) return;

    try {
      const photoAlbumDetails = {
        name: `My first photoAlbum`,
      };

      // Create the API record:
      const response = await client.models.PhotoAlbum.create({
        name: `My first photoAlbum`,
      });

      const photoAlbum = response.data;

      if (!photoAlbum) return;

      // Upload all files to Storage:
      const imagePaths = await Promise.all(
        Array.from(e.target.files).map(async (file) => {
          const result = await uploadData({
            path: `images/${photoAlbum.id}-${file.name}`,
            data: file,
            options: {
              contentType: "image/png", // contentType is optional
            },
          }).result;

          return result.path;
        })
      );

      // Add the file association to the record:
      const updateResponse = await client.models.PhotoAlbum.update({
        id: photoAlbum.id,
        imagePaths: imagePaths,
      });
      const updatedPhotoAlbum = updateResponse.data;

      setCurrentPhotoAlbum(updatedPhotoAlbum);

      // If the record has no associated file, we can return early.
      if (!updatedPhotoAlbum?.imagePaths?.length) return;

      // Retrieve signed urls for all files:
      const signedUrls = await Promise.all(
        updatedPhotoAlbum.imagePaths.map(
          async (path) => await getUrl({ path: path! })
        )
      );

      if (!signedUrls) return;
      setCurrentImages(signedUrls.map((signedUrl) => signedUrl.url.toString()));
    } catch (error) {
      console.error("Error create photoAlbum / file:", error);
    }
  }

  async function addNewImagesToPhotoAlbum(
    e: React.ChangeEvent<HTMLInputElement>
  ) {
    if (!currentPhotoAlbum) return;

    if (!e.target.files) return;

    try {
      // Upload all files to Storage:
      const newimagePaths = await Promise.all(
        Array.from(e.target.files).map(async (file) => {
          const result = await uploadData({
            path: `images/${currentPhotoAlbum.id}-${file.name}`,
            data: file,
            options: {
              contentType: "image/png", // contentType is optional
            },
          }).result;

          return result.path;
        })
      );

      // Query existing record to retrieve currently associated files:
      const queriedResponse = await client.models.PhotoAlbum.get({
        id: currentPhotoAlbum.id,
      });

      const photoAlbum = queriedResponse.data;

      if (!photoAlbum?.imagePaths) return;

      // Merge existing and new file paths:
      const updatedimagePaths = [...newimagePaths, ...photoAlbum.imagePaths];

      // Update record with merged file associations:
      const response = await client.models.PhotoAlbum.update({
        id: currentPhotoAlbum.id,
        imagePaths: updatedimagePaths,
      });

      const updatedPhotoAlbum = response.data;
      setCurrentPhotoAlbum(updatedPhotoAlbum);

      // If the record has no associated file, we can return early.
      if (!updatedPhotoAlbum?.imagePaths) return;

      // Retrieve signed urls for merged image paths:
      const signedUrls = await Promise.all(
        updatedPhotoAlbum?.imagePaths.map(
          async (path) => await getUrl({ path: path! })
        )
      );

      if (!signedUrls) return;

      setCurrentImages(signedUrls.map((signedUrl) => signedUrl.url.toString()));
    } catch (error) {
      console.error(
        "Error uploading image / adding image to photoAlbum: ",
        error
      );
    }
  }

  // Replace last image associated with current photoAlbum:
  async function updateLastImage(e: React.ChangeEvent<HTMLInputElement>) {
    if (!currentPhotoAlbum) return;

    if (!e.target.files) return;

    const file = e.target.files[0];

    try {
      // Upload new file to Storage:
      const result = await uploadData({
        path: `images/${currentPhotoAlbum.id}-${file.name}`,
        data: file,
        options: {
          contentType: "image/png", // contentType is optional
        },
      }).result;

      const newFilePath = result.path;

      // Query existing record to retrieve currently associated files:
      const queriedResponse = await client.models.PhotoAlbum.get({
        id: currentPhotoAlbum.id,
      });

      const photoAlbum = queriedResponse.data;

      if (!photoAlbum?.imagePaths?.length) return;

      // Retrieve last image path:
      const [lastImagePath] = photoAlbum.imagePaths.slice(-1);

      // Remove last file association by path
      const updatedimagePaths = [
        ...photoAlbum.imagePaths.filter((path) => path !== lastImagePath),
        newFilePath,
      ];

      // Update record with updated file associations:
      const response = await client.models.PhotoAlbum.update({
        id: currentPhotoAlbum.id,
        imagePaths: updatedimagePaths,
      });

      const updatedPhotoAlbum = response.data;

      setCurrentPhotoAlbum(updatedPhotoAlbum);

      // If the record has no associated file, we can return early.
      if (!updatedPhotoAlbum?.imagePaths) return;

      // Retrieve signed urls for merged image paths:
      const signedUrls = await Promise.all(
        updatedPhotoAlbum?.imagePaths.map(
          async (path) => await getUrl({ path: path! })
        )
      );

      if (!signedUrls) return;

      setCurrentImages(signedUrls.map((signedUrl) => signedUrl.url.toString()));
    } catch (error) {
      console.error(
        "Error uploading image / adding image to photoAlbum: ",
        error
      );
    }
  }

  async function getImagesForPhotoAlbum() {
    if (!currentPhotoAlbum) {
      return;
    }
    try {
      // Query the record to get the file paths:
      const response = await client.models.PhotoAlbum.get({
        id: currentPhotoAlbum.id,
      });
      const photoAlbum = response.data;

      // If the record has no associated files, we can return early.
      if (!photoAlbum?.imagePaths) return;

      // Retrieve the signed URLs for the associated images:
      const signedUrls = await Promise.all(
        photoAlbum.imagePaths.map(async (imagePath) => {
          if (!imagePath) return;
          return await getUrl({ path: imagePath });
        })
      );

      setCurrentImages(
        signedUrls.map((signedUrl) => signedUrl?.url.toString())
      );
    } catch (error) {
      console.error("Error getting photoAlbum / image:", error);
    }
  }

  // Remove the file associations, continue to persist both files and record
  async function removeImagesFromPhotoAlbum() {
    if (!currentPhotoAlbum) return;

    try {
      const response = await client.models.PhotoAlbum.get({
        id: currentPhotoAlbum.id,
      });

      const photoAlbum = response.data;

      // If the record has no associated file, we can return early.
      if (!photoAlbum?.imagePaths) return;

      const updatedPhotoAlbum = await client.models.PhotoAlbum.update({
        id: photoAlbum.id,
        imagePaths: null,
      });

      // If successful, the response here will be `null`:
      setCurrentPhotoAlbum(updatedPhotoAlbum.data);
      setCurrentImages(updatedPhotoAlbum.data?.imagePaths);
    } catch (error) {
      console.error("Error removing image from photoAlbum: ", error);
    }
  }

  // Remove the record association and delete the file
  async function deleteImagesForCurrentPhotoAlbum() {
    if (!currentPhotoAlbum) return;

    try {
      const response = await client.models.PhotoAlbum.get({
        id: currentPhotoAlbum.id,
      });

      const photoAlbum = response.data;

      // If the record has no associated files, we can return early.
      if (!photoAlbum?.imagePaths) return;

      // Remove associated files from record
      const updateResponse = await client.models.PhotoAlbum.update({
        id: photoAlbum.id,
        imagePaths: null, // Set the file association to `null`
      });

      const updatedPhotoAlbum = updateResponse.data;

      // Delete the files from S3:
      await Promise.all(
        photoAlbum?.imagePaths.map(async (imagePath) => {
          if (!imagePath) return;
          await remove({ path: imagePath });
        })
      );

      // If successful, the response here will be `null`:
      setCurrentPhotoAlbum(updatedPhotoAlbum);
      setCurrentImages(null);
    } catch (error) {
      console.error("Error deleting image: ", error);
    }
  }

  // Delete both files and record
  async function deleteCurrentPhotoAlbumAndImages() {
    if (!currentPhotoAlbum) return;

    try {
      const response = await client.models.PhotoAlbum.get({
        id: currentPhotoAlbum.id,
      });

      const photoAlbum = response.data;

      if (!photoAlbum) return;

      await client.models.PhotoAlbum.delete({
        id: photoAlbum.id,
      });

      setCurrentPhotoAlbum(null);

      // If the record has no associated file, we can return early.
      if (!photoAlbum?.imagePaths) return;

      await Promise.all(
        photoAlbum?.imagePaths.map(async (imagePath) => {
          if (!imagePath) return;
          await remove({ path: imagePath });
        })
      );

      clearLocalState();
    } catch (error) {
      console.error("Error deleting photoAlbum: ", error);
    }
  }

  function clearLocalState() {
    setCurrentPhotoAlbum(null);
    setCurrentImages([]);
  }

  return (
    <main className="app-container">
      <h1 className="greeting">Hello {user?.username}!</h1>
      <h2 className="current-album">
        Current PhotoAlbum: {currentPhotoAlbum?.id}
      </h2>

      <div className="file-input-container">
        <label className="file-input-label">
          Create photoAlbum with one file:
          <input
            type="file"
            accept="image/*"
            onChange={createPhotoAlbumWithFirstImage}
            className="file-input"
          />
        </label>

        <label className="file-input-label">
          Create photoAlbum with multiple files:
          <input
            type="file"
            accept="image/*"
            onChange={createPhotoAlbumWithMultipleImages}
            multiple
            className="file-input"
          />
        </label>

        <label className="file-input-label">
          Add multiple images to current photoAlbum:
          <input
            type="file"
            accept="image/*"
            onChange={addNewImagesToPhotoAlbum}
            disabled={!currentPhotoAlbum}
            multiple
            className="file-input"
          />
        </label>

        <label className="file-input-label">
          Replace last image:
          <input
            type="file"
            accept="image/*"
            onChange={updateLastImage}
            disabled={!currentPhotoAlbum || !currentImages}
            className="file-input"
          />
        </label>
      </div>

      <div className="button-container">
        <button
          onClick={getImagesForPhotoAlbum}
          disabled={!currentPhotoAlbum || !currentImages}
          className="app-button"
        >
          Get Images for Current Photo Album
        </button>
        <button
          onClick={removeImagesFromPhotoAlbum}
          disabled={!currentPhotoAlbum || !currentImages}
          className="app-button"
        >
          Remove images from current PhotoAlbum (does not delete images)
        </button>
        <button
          onClick={deleteImagesForCurrentPhotoAlbum}
          disabled={!currentPhotoAlbum || !currentImages}
          className="app-button"
        >
          Remove images from current PhotoAlbum, then delete images
        </button>
        <button
          onClick={deleteCurrentPhotoAlbumAndImages}
          disabled={!currentPhotoAlbum}
          className="app-button"
        >
          Delete current PhotoAlbum (and images, if they exist)
        </button>
        <button onClick={signOut} className="app-button">
          Sign out
        </button>
      </div>

      <div className="image-container">
        {currentImages &&
          currentImages.map((url, idx) => {
            if (!url) return undefined;
            return (
              <img src={url} key={idx} alt="Storage file" className="image" />
            );
          })}
      </div>
    </main>
  );
}

export default withAuthenticator(App);

```
</Block>
</BlockSwitcher>
</InlineFilter>



Contents of build-a-backend_functions_add-lambda-layers_index.txt:
import { getCustomStaticPath } from '@/utils/getCustomStaticPath';

export const meta = {
  title: 'Lambda Layers',
  description:
    'Learn how to add layers to your function',
  platforms: [
    'android',
    'angular',
    'flutter',
    'javascript',
    'nextjs',
    'react',
    'react-native',
    'swift',
    'vue'
  ]
};

export function getStaticPaths() {
  return getCustomStaticPath(meta.platforms);
}

export function getStaticProps() {
  return {
    props: {
      meta
    }
  };
}

Amplify offers the ability to add layers to your functions which contain your library dependencies. Lambda layers allow you to separate your function code from its dependencies, enabling easier management of shared components across multiple functions and reducing deployment package sizes.

<Callout info>

**Note:** Configuring or adding layers in `defineFunction` is not supported for [Custom Functions](/[platform]/build-a-backend/functions/custom-functions/).

</Callout>

To add a Lambda layer to your function, follow these steps:

1. First, create and set up your Lambda layer in AWS. You can do this through the AWS Console or using the AWS CLI. For guidance on creating layers, refer to the [AWS documentation on creating Lambda layers](https://docs.aws.amazon.com/lambda/latest/dg/configuration-layers.html#configuration-layers-create).

2. Once your layer is created and available in AWS, you can reference it in your Amplify project as shown below.

   Specify the `layers` property in `defineFunction`, for example:

   ```ts title="amplify/functions/my-function/resource.ts"
   import { defineFunction } from "@aws-amplify/backend";

   export const myFunction = defineFunction({
     name: "my-function",
     layers: {
      "@aws-lambda-powertools/logger":
         "arn:aws:lambda:us-east-1:094274105915:layer:AWSLambdaPowertoolsTypeScriptV2:12",
     },
   });
   ```
   
   The Lambda layer is represented by an object of key/value pairs where the key is the module name that is exported from your layer and the value is the ARN of the layer. The key (module name) is used to externalize the module dependency so it doesn't get bundled with your Lambda function. A maximum of 5 layers can be attached to a function, and they must be in the same region as the function.
   
   <br/>Alternatively, you can specify the layer as `myLayer:1` where `myLayer` is the name of the layer and `1` is the version of the layer. For example:

   ```ts title="amplify/functions/my-function/resource.ts"
   import { defineFunction } from "@aws-amplify/backend";

   export const myFunction = defineFunction({
     name: "my-function",
     layers: {
      "some-module": "myLayer:1"
     },
   });
   ```

   Amplify will automatically convert this to the full layer ARN format `arn:aws:lambda:<region>:<account-id>:layer:myLayer:1` using your existing account ID and region.
  
   <Callout type="warning">

   When using layers, be mindful of versioning. The ARN includes a version number (e.g., `:12` in the example). Ensure you're using the appropriate version and have a strategy for updating layers when new versions are released.

   </Callout>

3. Then use the locally installed module in the function handler:
   ```ts title="amplify/functions/my-function/handler.ts"
   import { Logger } from "@aws-lambda-powertools/logger";
   import type { Handler } from "aws-lambda";

   const logger = new Logger({ serviceName: "serverlessAirline" });

   export const handler: Handler = async (event, context) => {
     logger.info("Hello World");
   };
   ```

For further information on creating and managing your layers refer to [AWS documentation for Lambda layers](https://docs.aws.amazon.com/lambda/latest/dg/chapter-layers.html)



Contents of build-a-backend_functions_configure-functions_index.txt:
import { getCustomStaticPath } from '@/utils/getCustomStaticPath';

export const meta = {
  title: 'Configure Functions',
  description:
    'Learn how to configure functions',
    route: '/gen2/build-a-backend/functions/configure-functions',
  platforms: [
    'android',
    'angular',
    'flutter',
    'javascript',
    'nextjs',
    'react',
    'react-native',
    'swift',
    'vue'
  ]
};

export function getStaticPaths() {
  return getCustomStaticPath(meta.platforms);
}

export function getStaticProps() {
  return {
    props: {
      meta
    }
  };
}

`defineFunction` comes out-of-the-box with sensible but minimal defaults. The following options are provided to tweak the function configuration.

<Callout info>

**Note:** The following options are not supported for [Custom Functions](/[platform]/build-a-backend/functions/custom-functions/) except for `resourceGroupName`.

</Callout>

## `name`

By default, functions are named based on the directory the `defineFunction` call is placed in. In the above example, defining the function in `amplify/functions/my-demo-function/resource.ts` will cause the function to be named `my-demo-function` by default.

If an entry is specified, then the name defaults to the basename of the entry path. For example, an `entry` of `./signup-trigger-handler.ts` would cause the function name to default to `signup-trigger-handler`.

This optional property can be used to explicitly set the name of the function.

```ts title="amplify/functions/my-demo-function/resource.ts"
export const myDemoFunction = defineFunction({
  entry: './demo-function-handler.ts',
  name: 'overrideName' // explicitly set the name to override the default naming behavior
});
```

## `timeoutSeconds`

By default, functions will time out after 3 seconds. This can be configured to any whole number of seconds up to 15 minutes.

```ts title="amplify/functions/my-demo-function/resource.ts"
export const myDemoFunction = defineFunction({
  // highlight-next-line
  timeoutSeconds: 60 // 1 minute timeout
});
```

## `memoryMB`

By default, functions have 512 MB of memory allocated to them. This can be configured from 128 MB up to 10240 MB. Note that this can increase the cost of function invocation. For more pricing information see [here](https://aws.amazon.com/lambda/pricing/).

```ts title="amplify/functions/my-demo-function/resource.ts"
export const myDemoFunction = defineFunction({
  // highlight-next-line
  memoryMB: 256 // allocate 256 MB of memory to the function.
});
```

## `ephemeralStorageSizeMB`

By default, functions have 512MB of ephemeral storage to them. This can be configured from 512 MB upto 10240 MB. Note that this can increase the cost of function invocation. For more pricing information visit the [Lambda pricing documentation](https://aws.amazon.com/lambda/pricing/).

```ts title="amplify/functions/my-demo-function/resource.ts"
export const myDemoFunction = defineFunction({
  // highlight-next-line
  ephemeralStorageSizeMB: 1024 // allocate 1024 MB of ephemeral storage to the function.
});
```

## `runtime`

Currently, only Node runtimes are supported by `defineFunction`. However, you can change the Node version that is used by the function. The default is the oldest Node LTS version that is supported by AWS Lambda (currently Node 18).

If you wish to use an older version of Node, keep an eye on the [Lambda Node version deprecation schedule](https://docs.aws.amazon.com/lambda/latest/dg/lambda-runtimes.html). As Lambda removes support for old Node versions, you will have to update to newer supported versions.

```ts title="amplify/functions/my-demo-function/resource.ts"
export const myDemoFunction = defineFunction({
  runtime: 20 // use Node 20
});
```

## `entry`

By default, Amplify will look for your function handler in a file called `handler.ts` in the same directory as the file where `defineFunction` is called. To point to a different handler location, specify an `entry` value.

```ts title="amplify/functions/my-demo-function/resource.ts"
export const myDemoFunction = defineFunction({
  entry: './path/to/handler.ts' // this path should either be absolute or relative to the current file
});
```

## `resourceGroupName`

By default, functions are grouped together in a resource group named `function`. You can override this to group related function with other Amplify resources like `auth`, `data`, `storage`, or separate them into your own custom group.
This is typically useful when you have resources that depend on each other and you want to group them together.

```ts title="amplify/functions/my-demo-function/resource.ts"
export const myDemoFunction = defineFunction({
  resourceGroupName: 'data'
});
```


Contents of build-a-backend_functions_custom-functions_index.txt:
import { getCustomStaticPath } from '@/utils/getCustomStaticPath';

export const meta = {
  title: 'Custom functions',
  description:
    'Use another AWS Lambda runtimes like Python, Golang to perform tasks and customize workflows.',
  platforms: [
    'android',
    'angular',
    'flutter',
    'javascript',
    'nextjs',
    'react',
    'react-native',
    'swift',
    'vue'
  ]
};

export function getStaticPaths() {
  return getCustomStaticPath(meta.platforms);
}

export function getStaticProps(context) {
  return {
    props: {
      platform: context.params.platform,
      meta
    }
  };
}

AWS Amplify Gen 2 functions are AWS Lambda functions that can be used to perform tasks and customize workflows in your Amplify app. Functions can be written in Node.js, Python, Go, or any [other language supported by AWS Lambda](https://docs.aws.amazon.com/lambda/latest/dg/lambda-runtimes.html).

<Callout warning>

**Note:** [Fullstack Git-based environments](https://docs.amplify.aws/react/how-amplify-works/concepts/#fullstack-git-based-environments) do not support Docker for functions bundling out of the box. To learn more [skip to the Docker section](#docker).

</Callout>

<Callout info>

**Note:** The following options in `defineFunction` are not supported for Custom Functions:
- [Environment variables and secrets](/[platform]/build-a-backend/functions/environment-variables-and-secrets/)
- [Scheduling configuration](/[platform]/build-a-backend/functions/scheduling-functions/) 
- [Lambda layers](/[platform]/build-a-backend/functions/add-lambda-layers/)
- [Function options](/[platform]/build-a-backend/functions/configure-functions/)

You'll need to configure these options directly in your CDK Function definition instead. However, `resourceGroupName` property is supported and can be used to group related resources together in your `defineFunction` definition.

</Callout>

In this guide, you will learn how to create Python and Go functions with Amplify functions. The examples shown in this guide do not use Docker to build functions. Instead, the examples use commands that run on your host system to build, and as such require the necessary tooling for the language you are using for your functions.

## Python

To get started, create a new directory and a resource file, `amplify/functions/say-hello/resource.ts`. Then, define the function with `defineFunction`:
```ts title="amplify/functions/say-hello/resource.ts"
import { execSync } from "node:child_process";
import * as path from "node:path";
import { fileURLToPath } from "node:url";
import { defineFunction } from "@aws-amplify/backend";
import { DockerImage, Duration } from "aws-cdk-lib";
import { Code, Function, Runtime } from "aws-cdk-lib/aws-lambda";

const functionDir = path.dirname(fileURLToPath(import.meta.url));

export const sayHelloFunctionHandler = defineFunction(
  (scope) =>
    new Function(scope, "say-hello", {
      handler: "index.handler",
      runtime: Runtime.PYTHON_3_9, // or any other python version
      timeout: Duration.seconds(20), //  default is 3 seconds
      code: Code.fromAsset(functionDir, {
        bundling: {
          image: DockerImage.fromRegistry("dummy"), // replace with desired image from AWS ECR Public Gallery
          local: {
            tryBundle(outputDir: string) {
              execSync(
                `python3 -m pip install -r ${path.join(functionDir, "requirements.txt")} -t ${path.join(outputDir)} --platform manylinux2014_x86_64 --only-binary=:all:`
              );
              execSync(`cp -r ${functionDir}/* ${path.join(outputDir)}`);
              return true;
            },
          },
        },
      }),
    }),
    {
      resourceGroupName: "auth" // Optional: Groups this function with auth resource
    }
);
```

Next, create the corresponding handler file at `amplify/functions/say-hello/index.py`. This is where your function code will go.

```ts title="amplify/functions/say-hello/index.py"
import json

def handler(event, context):
  return {
      "statusCode": 200,
      "body": json.dumps({
          "message": "Hello World",
      }),
  }
```

The handler file _must_ export a function named "handler". This is the entry point to your function. For more information on writing functions, refer to the [AWS documentation for Lambda function handlers using Python](https://docs.aws.amazon.com/lambda/latest/dg/python-handler.html).

If you need Python packages, you can add them to a `requirements.txt` file in the same directory as your handler file. The `bundling` option in the `Code.fromAsset` method will install these packages for you.
Create a `requirements.txt` file in the same directory as your handler file. This file should contain the names of the packages you want to install. For example:

```txt title="amplify/functions/say-hello/requirements.txt"
request==2.25.1
some-other-package>=1.0.0
```

You're now ready to deploy your python function. Next is the same process as the Node.js/TypeScript function. Go to [Common steps for all languages](#common-steps-for-all-languages) to continue.

## Go
To get started, Create a new directory and a resource file, `amplify/functions/say-hello/resource.ts`. Then, define the function with `defineFunction`:

```ts title="amplify/functions/say-hello/resource.ts"
import { execSync } from "node:child_process";
import * as path from "node:path";
import { fileURLToPath } from "node:url";
import { defineFunction } from "@aws-amplify/backend";
import { DockerImage, Duration } from "aws-cdk-lib";
import { Code, Function, Runtime } from "aws-cdk-lib/aws-lambda";

const functionDir = path.dirname(fileURLToPath(import.meta.url));

export const sayHelloFunctionHandler = defineFunction(
  (scope) =>
    new Function(scope, "say-hello", {
      handler: "bootstrap",
      runtime: Runtime.PROVIDED_AL2023,
      timeout: Duration.seconds(3), //  default is 3 seconds
      code: Code.fromAsset(functionDir, {
        bundling: {
          image: DockerImage.fromRegistry("dummy"),
          local: {
            tryBundle(outputDir: string) {
              execSync(`rsync -rLv ${functionDir}/* ${path.join(outputDir)}`);
              execSync(
                `cd ${path.join(outputDir)} && GOARCH=amd64 GOOS=linux go build -tags lambda.norpc -o ${path.join(outputDir)}/bootstrap ${functionDir}/main.go`
              );
              return true;
            },
          },
        },
      }),
    }),
    {
      resourceGroupName: "auth" // Optional: Groups this function with auth resource
    }
);
```

Next, create the corresponding handler file at `amplify/functions/say-hello/main.go`. This is where your function code will go.

```go title="amplify/functions/say-hello/main.go"
package main

import (
	"context"
	"fmt"

	"github.com/aws/aws-lambda-go/lambda"
)

type Event struct {
	Arguments Arguments `json:"arguments"`
}

type Arguments struct {
	Title string `json:"phone"`
	Msg   string `json:"msg"`
}

func HandleRequest(ctx context.Context, event Event) (string, error) {
	fmt.Println("Received event: ", event)

	// fmt.Println("Message sent to: ", event.Arguments.Msg)
	// You can use lambda arguments in your code

	return "Hello World!", nil
}

func main() {
	lambda.Start(HandleRequest)
}
```

Then you should run the following command to build the go function:
```bash title="terminal" showLineNumbers={false}
go mod init lambda
```
then run to install the dependencies.

```bash title="terminal" showLineNumbers={false}
go mod tidy
```

You're now ready to deploy your golang function. Next is the same process as the Node.js/TypeScript function.

## Common steps for all languages

Regardless of the language used, your function needs to be added to your backend.
```ts title="amplify/backend.ts"
// highlight-next-line
import { sayHelloFunctionHandler } from './functions/say-hello/resource';

defineBackend({
  // highlight-next-line
  sayHelloFunctionHandler,
});
```

Now when you run `npx ampx sandbox` or deploy your app on Amplify, it will include your function.

To invoke your function, we recommend adding your [function as a handler for a custom query with your Amplify Data resource](/[platform]/build-a-backend/data/custom-business-logic/). To get started, open your `amplify/data/resource.ts` file and specify a new query in your schema:

```ts title="amplify/data/resource.ts"
import { sayHelloFunctionHandler } from "../functions/say-hello/resource"

const schema = a.schema({
  // highlight-start
  sayHello: a
    .query()
    .arguments({
      name: a.string(),
    })
    .returns(a.string())
    .handler(a.handler.function(sayHelloFunctionHandler)),
  // highlight-end
})

export type Schema = ClientSchema<typeof schema>

export const data = defineData({
  schema,
  authorizationModes: {
    defaultAuthorizationMode: "iam",
  },
})
```

## Docker

Custom function may require [Docker](https://www.docker.com/) in order to build and bundle function's code. A deployment failing with `CustomFunctionProviderDockerError` error indicates that a custom function requires Docker but the Docker daemon was not found. In that case you need to provide a working Docker installation at runtime.

### Personal sandboxes

Ensure that Docker is installed on your computer and that Docker daemon is running. You can check if Docker daemon is running using the following command:
```bash title="terminal" showLineNumbers={false}
docker info
```

### Fullstack Git-based environments

Amplify does not provide Docker daemon out of the box in branch deployments. However, you have an option to provide [your own image that meets Amplify requirements](https://docs.aws.amazon.com/amplify/latest/userguide/custom-build-image.html) and includes a Docker installation.

For example, the `aws/codebuild/amazonlinux-x86_64-standard:5.0` image ([see definition](https://github.com/aws/aws-codebuild-docker-images)) meets Amplify requirements and includes Docker installation.


Contents of build-a-backend_functions_environment-variables-and-secrets_index.txt:
import { getCustomStaticPath } from '@/utils/getCustomStaticPath';

export const meta = {
  title: 'Environment variables and secrets',
  description:
    'Learn how to configure and consume environment variables and secrets',
  platforms: [
    'android',
    'angular',
    'flutter',
    'javascript',
    'nextjs',
    'react',
    'react-native',
    'swift',
    'vue'
  ]
};

export function getStaticPaths() {
  return getCustomStaticPath(meta.platforms);
}

export function getStaticProps() {
  return {
    props: {
      meta
    }
  };
}

Amplify Functions support setting environment variables and secrets on the `environment` property of `defineFunction`.

<Callout warning>

**Note:** do not store secret values in environment variables. Environment variables values are rendered in plaintext to the build artifacts located at `.amplify/artifacts` and may be emitted to CloudFormation stack event messages. To store secrets [skip to the secrets section](#secrets)

</Callout>

<Callout info>

**Note:** Environment variables and secrets configuration in `defineFunction` is not supported for [Custom Functions](/[platform]/build-a-backend/functions/custom-functions/).

</Callout>

## Environment variables

Environment variables can be configured in `defineFunction` using the `environment` property.

```ts title="amplify/functions/say-hello/resource.ts"
import { defineFunction } from '@aws-amplify/backend';

export const sayHello = defineFunction({
  environment: {
    NAME: 'World'
  }
});
```

Any environment variables specified here will be available to the function at runtime.

Some environment variables are constant across all branches and deployments. But many environment values differ between deployment environments. [Branch-specific environment variables can be configured for Amplify hosting deployments](/[platform]/deploy-and-host/fullstack-branching/secrets-and-vars/).

Suppose you created a branch-specific environment variable in hosting called "API_ENDPOINT" which had a different value for your "staging" vs "prod" branch. If you wanted that value to be available to your function you can pass it to the function using

```ts title="amplify/functions/say-hello/resource.ts"
export const sayHello = defineFunction({
  environment: {
    NAME: "World",
    API_ENDPOINT: process.env.API_ENDPOINT
  }
});
```

### Accessing environment variables

Within your function handler, you can access environment variables using the normal `process.env` global object provided by the Node runtime. However, this does not make it easy to discover what environment variables will be available at runtime. Amplify generates an `env` symbol that can be used in your function handler and provides typings for all variables that will be available at runtime. Copy the following code to use it.

```ts title="amplify/functions/say-hello/handler.ts"
// highlight-next-line
import { env } from '$amplify/env/say-hello'; // the import is '$amplify/env/<function-name>'

export const handler = async (event) => {
  // the env object has intellisense for all environment variables that are available to the function
  return `Hello, ${env.NAME}!`;
};
```

<Accordion title='Understanding the "env" symbol and how to manually configure your Amplify project to use it' headingLevel='4' eyebrow='Learn more'>

At the end of [AWS Cloud Development Kit's (AWS CDK)](https://aws.amazon.com/cdk/) synthesis, Amplify gathers names of environment variables that will be available to the function at runtime and generates the file `.amplify/generated/env/<function-name>.ts`.

If you created your project with [`create-amplify`](https://www.npmjs.com/package/create-amplify), then Amplify has already set up your project to use the `env` symbol.

If you did not, you will need to manually configure your project. Within your `amplify/tsconfig.json` file add a `paths` compiler option:

```json title="amplify/tsconfig.json"
{
  "compilerOptions": {
    "paths": {
      "$amplify/*": ["../.amplify/generated/*"]
    }
  }
}
```

</Accordion>

### Generated env files

When you configure your function with environment variables or secrets, Amplify's backend tooling generates a file using the function's `name` in `.amplify/generated` with references to your environment variables and secrets, as well as [environment variables predefined by the Lambda runtime](https://docs.aws.amazon.com/lambda/latest/dg/configuration-envvars.html#configuration-envvars-runtime). This provides a type-safe experience for working with environment variables that does not require typing `process.env` manually.

<Callout info>

**Note:** generated files are created before deployments when executing `ampx sandbox` or `ampx pipeline-deploy`

</Callout>

For example, if you have a function with the following definition:

```ts title="amplify/functions/say-hello/resource.ts"
import { defineFunction } from "@aws-amplify/backend";

export const sayHello = defineFunction({
  name: "say-hello",
  environment: {
    NAME: "World",
  },
});
```

Upon starting your next deployment, Amplify will create a file at the following location:

```
.amplify/generated/env/say-hello.ts
```

Using the TypeScript path alias, `$amplify`, you can import the file in your function's handler:

```ts title="amplify/functions/say-hello/handler.ts"
import { env } from "$amplify/env/say-hello"

export const handler = async (event) => {
  // the env object has intellisense for all environment variables that are available to the function
  return `Hello, ${env.NAME}!`;
};
```

Encountering issues with this file? [Visit the troubleshooting guide for `Cannot find module $amplify/env/<function-name>`](/[platform]/build-a-backend/troubleshooting/cannot-find-module-amplify-env/)

## Secrets

Sometimes it is necessary to provide a secret value to a function. For example, it may need a database password or an API key to perform some business use case. Environment variables should NOT be used for this because environment variable values are included in plaintext in the function configuration. Instead, secret access can be used.

Before using a secret in a function, you need to [define a secret](/[platform]/deploy-and-host/fullstack-branching/secrets-and-vars/#set-secrets). After you have defined a secret, you can reference it in your function config.

```ts title="amplify/functions/say-hello/resource.ts"
import { defineFunction, secret } from '@aws-amplify/backend';

export const sayHello = defineFunction({
  environment: {
    NAME: "World",
    API_ENDPOINT: process.env.API_ENDPOINT,
    API_KEY: secret('MY_API_KEY') // this assumes you created a secret named "MY_API_KEY"
  }
});
```

You can use this secret value at runtime in your function the same as any other environment variable. However, you will notice that the value of the environment variable is not stored as part of the function configuration. Instead, the value is fetched when your function runs and is provided in memory.

```ts title="amplify/functions/say-hello/handler.ts"
import { env } from '$amplify/env/say-hello';

export const handler = async (event) => {
  const request = new Request(env.API_ENDPOINT, {
    headers: {
      // this is the value of secret named "MY_API_KEY"
      Authorization: `Bearer ${env.API_KEY}`
    }
  })
  // ...
  return `Hello, ${env.NAME}!`;
};
```


Contents of build-a-backend_functions_examples_add-user-to-group_index.txt:
import { getCustomStaticPath } from '@/utils/getCustomStaticPath';

export const meta = {
  title: 'Add user to group',
  description:
    'Use an Auth Post Authentication trigger to automatically add new users to a group',
  platforms: [
    'android',
    'angular',
    'flutter',
    'javascript',
    'nextjs',
    'react',
    'react-native',
    'swift',
    'vue'
  ]
};

export function getStaticPaths() {
  return getCustomStaticPath(meta.platforms);
}

export function getStaticProps() {
  return {
    props: {
      meta
    }
  };
}

You can use `defineAuth` and `defineFunction` to create a [Cognito post confirmation Lambda trigger](https://docs.aws.amazon.com/cognito/latest/developerguide/user-pool-lambda-post-confirmation.html) that extends the behavior to perform some action when a user is confirmed.

<Callout info>

A user is "confirmed" when they verify their account. Typically this happens when the user confirms their email via the verification email. The post confirmation handler will _not_ be triggered for federated sign-ins (i.e. social sign-in).

</Callout>

To get started, install the AWS SDK v3 package, which will be used to perform actions against your auth resource, and the `@types/aws-lambda` package, which is used to define the handler type:

```bash title="Terminal"
npm add --save-dev @aws-sdk/client-cognito-identity-provider @types/aws-lambda
```

Next, create a new directory and a resource file, `amplify/auth/post-confirmation/resource.ts`. Then, define the Function with `defineFunction`:

```ts title="amplify/auth/post-confirmation/resource.ts"
import { defineFunction } from '@aws-amplify/backend';

export const postConfirmation = defineFunction({
  name: 'post-confirmation',
  // optionally define an environment variable for your group name
  environment: {
    GROUP_NAME: 'EVERYONE'
  },
  resourceGroupName: 'auth'
});
```

After creating the Function definition you will need to:

1. create the `EVERYONE` group
2. grant access to your auth resource to ensure it can perform the `addUserToGroup` action
3. set the Function as the post confirmation trigger

```ts title="amplify/auth/resource.ts"
import { defineAuth } from "@aws-amplify/backend";
import { postConfirmation } from "./post-confirmation/resource"

export const auth = defineAuth({
  loginWith: {
    email: true,
  },
  groups: ["EVERYONE"],
  triggers: {
    postConfirmation,
  },
  access: (allow) => [
    allow.resource(postConfirmation).to(["addUserToGroup"]),
  ],
})
```

Then create the Function's corresponding handler file, `amplify/auth/post-confirmation/handler.ts`, file with the following contents:

```ts title="amplify/auth/post-confirmation/handler.ts"
import type { PostConfirmationTriggerHandler } from 'aws-lambda';
import {
  CognitoIdentityProviderClient,
  AdminAddUserToGroupCommand
} from '@aws-sdk/client-cognito-identity-provider';
import { env } from '$amplify/env/post-confirmation';

const client = new CognitoIdentityProviderClient();

// add user to group
export const handler: PostConfirmationTriggerHandler = async (event) => {
  const command = new AdminAddUserToGroupCommand({
    GroupName: env.GROUP_NAME,
    Username: event.userName,
    UserPoolId: event.userPoolId
  });
  const response = await client.send(command);
  console.log('processed', response.$metadata.requestId);
  return event;
};
```

After deploying the changes, whenever a user signs up and verifies their account they are automatically added to the group named "EVERYONE".


Contents of build-a-backend_functions_examples_create-user-profile-record_index.txt:
import { getCustomStaticPath } from '@/utils/getCustomStaticPath';

export const meta = {
  title: 'Create a user profile record',
  description:
    'Use an Auth Post Authentication trigger to automatically a user profile record',
  platforms: [
    'android',
    'angular',
    'flutter',
    'javascript',
    'nextjs',
    'react',
    'react-native',
    'swift',
    'vue'
  ]
};

export function getStaticPaths() {
  return getCustomStaticPath(meta.platforms);
}

export function getStaticProps() {
  return {
    props: {
      meta
    }
  };
}


You can use `defineAuth` and `defineFunction` to create a [Cognito post confirmation Lambda trigger](https://docs.aws.amazon.com/cognito/latest/developerguide/user-pool-lambda-post-confirmation.html) to create a profile record when a user is confirmed.

<Callout info>

A user is "confirmed" when they verify their account. Typically this happens when the user confirms their email via the verification email. The post confirmation handler will _not_ be triggered for federated sign-ins (i.e. social sign-in).

</Callout>
To get started, install the `aws-lambda` package, which is used to define the handler type.

```bash title="Terminal" showLineNumbers={false}
npm add --save-dev @types/aws-lambda
```

Update the `amplify/data/resource.ts` file to define a data model for the user's profile:

<Callout warning>

Make sure to configure the authorization rule to allow the `postConfirmation` resource as highlighted below. Granting access to resources creates environment variables for your Function such as the GraphQL API endpoint. To learn more visit the [environment variables and secrets documentation for Functions](/[platform]/build-a-backend/functions/environment-variables-and-secrets/).

</Callout>

```ts title="amplify/data/resource.ts"
import { type ClientSchema, a, defineData } from "@aws-amplify/backend";
import { postConfirmation } from "../auth/post-confirmation/resource";

const schema = a
  .schema({
    UserProfile: a
      .model({
        email: a.string(),
        profileOwner: a.string(),
      })
      .authorization((allow) => [
        allow.ownerDefinedIn("profileOwner"),
      ]),
  })
  .authorization((allow) => [allow.resource(postConfirmation)]);
export type Schema = ClientSchema<typeof schema>;

export const data = defineData({
  schema,
  authorizationModes: {
    defaultAuthorizationMode: "apiKey",
    apiKeyAuthorizationMode: {
      expiresInDays: 30,
    },
  },
});

```


Create a new directory and a resource file, `amplify/auth/post-confirmation/resource.ts`. Then, define the Function with `defineFunction`:

```ts title="amplify/auth/post-confirmation/resource.ts"
import { defineFunction } from '@aws-amplify/backend';

export const postConfirmation = defineFunction({
  name: 'post-confirmation',
});
```

Then, create the corresponding handler file, `amplify/auth/post-confirmation/handler.ts`, file with the following contents:

```ts title="amplify/auth/post-confirmation/handler.ts"
import type { PostConfirmationTriggerHandler } from "aws-lambda";
import { type Schema } from "../../data/resource";
import { Amplify } from "aws-amplify";
import { generateClient } from "aws-amplify/data";
import { getAmplifyDataClientConfig } from '@aws-amplify/backend/function/runtime';
import { env } from "$amplify/env/post-confirmation";

const { resourceConfig, libraryOptions } = await getAmplifyDataClientConfig(
  env
);

Amplify.configure(resourceConfig, libraryOptions);

const client = generateClient<Schema>();

export const handler: PostConfirmationTriggerHandler = async (event) => {
  await client.models.UserProfile.create({
      email: event.request.userAttributes.email,
      profileOwner: `${event.request.userAttributes.sub}::${event.userName}`,
  });

  return event;
};

```

<Callout warning>
When configuring Amplify with `getAmplifyDataClientConfig`, your function consumes schema information from an S3 bucket created during backend deployment with grants for the access your function need to use it. Any changes to this bucket outside of backend deployment may break your function.
</Callout>


Lastly, set the newly created Function resource on your auth resource:

```ts title="amplify/auth/resource.ts"
import { defineAuth } from '@aws-amplify/backend';
import { postConfirmation } from './post-confirmation/resource';

export const auth = defineAuth({
  loginWith: {
    email: true,
  },
  triggers: {
    postConfirmation
  }
});
```

After deploying the changes, whenever a user signs up and verifies their account a profile record is automatically created.


Contents of build-a-backend_functions_examples_custom-auth-flows_index.txt:
import { getCustomStaticPath } from '@/utils/getCustomStaticPath';

export const meta = {
  title: 'Custom Auth Challenge',
  description:
    'Leverage Custom Auth with and without SRP, allowing for a series of challenge and response cycles that can be customized to meet different requirements during sign in.',
  platforms: [
    'android',
    'angular',
    'flutter',
    'javascript',
    'nextjs',
    'react',
    'react-native',
    'swift',
    'vue'
  ]
};

export function getStaticPaths() {
  return getCustomStaticPath(meta.platforms);
}

export function getStaticProps() {
  return {
    props: {
      meta
    }
  };
}

Secure Remote Password (SRP) is a cryptographic protocol enabling password-based authentication without transmitting the password over the network. In Amazon Cognito custom authentication flows, CUSTOM_WITH_SRP incorporates SRP steps for enhanced security, while CUSTOM_WITHOUT_SRP bypasses these for a simpler process. The choice between them depends on your application's security needs and performance requirements. 
This guide demonstrates how to implement both types of custom authentication flows using AWS Amplify with Lambda triggers.

You can use `defineAuth` and `defineFunction` to create an auth experience that uses `CUSTOM_WITH_SRP` and `CUSTOM_WITHOUT_SRP`. This can be accomplished by leveraging [Amazon Cognito's feature to define a custom auth challenge](https://docs.aws.amazon.com/cognito/latest/developerguide/amazon-cognito-user-pools-authentication-flow.html#Custom-authentication-flow-and-challenges) and 3 triggers:

1. [Create auth challenge](https://docs.aws.amazon.com/cognito/latest/developerguide/user-pool-lambda-create-auth-challenge.html)
2. [Define auth challenge](https://docs.aws.amazon.com/cognito/latest/developerguide/user-pool-lambda-define-auth-challenge.html)
3. [Verify auth challenge response](https://docs.aws.amazon.com/cognito/latest/developerguide/user-pool-lambda-verify-auth-challenge-response.html) 

To get started, install the `aws-lambda` package, which is used to define the handler type.

```bash title="Terminal" showLineNumbers={false}
npm add --save-dev @types/aws-lambda
```

## Create auth challenge trigger

To get started, create the first of the three triggers, `create-auth-challenge`. This is the trigger responsible for creating the reCAPTCHA challenge after a password is verified.

```ts title="amplify/auth/create-auth-challenge/resource.ts"
import { defineFunction } from "@aws-amplify/backend"

export const createAuthChallenge = defineFunction({
  name: "create-auth-challenge",
  resourceGroupName: 'auth'
})
```

After creating the resource file, create the handler with the following contents:

```ts title="amplify/auth/create-auth-challenge/handler.ts"
import type { CreateAuthChallengeTriggerHandler } from "aws-lambda";

export const handler: CreateAuthChallengeTriggerHandler = async (event) => {
  if (event.request.challengeName === "CUSTOM_CHALLENGE") {
    // Generate a random code for the custom challenge
    const challengeCode = "123456";

    event.response.challengeMetadata = "TOKEN_CHECK";

    event.response.publicChallengeParameters = {
      trigger: "true",
      code: challengeCode,
    };

    event.response.privateChallengeParameters = { trigger: "true" };
    event.response.privateChallengeParameters.answer = challengeCode;
  }
  return event;
};
```

## Define auth challenge trigger

Next, you will want to create the trigger responsible for _defining_ the auth challenge flow, `define-auth-challenge`.

```ts title="amplify/auth/define-auth-challenge/resource.ts"
import { defineFunction } from "@aws-amplify/backend"

export const defineAuthChallenge = defineFunction({
  name: "define-auth-challenge",
  resourceGroupName: 'auth'
})
```

After creating the resource file, create the handler with the following contents if you are using `CUSTOM_WITHOUT_SRP`:

```ts title="amplify/auth/define-auth-challenge/handler.ts"
import type { DefineAuthChallengeTriggerHandler } from "aws-lambda"

export const handler: DefineAuthChallengeTriggerHandler = async (event) => {
  // Check if this is the first authentication attempt
  if (event.request.session.length === 0) {
    // For the first attempt, we start with the custom challenge
    event.response.issueTokens = false;
    event.response.failAuthentication = false;
    event.response.challengeName = "CUSTOM_CHALLENGE";
  } else if (
    event.request.session.length === 1 &&
    event.request.session[0].challengeName === "CUSTOM_CHALLENGE" &&
    event.request.session[0].challengeResult === true
  ) {
    // If this is the second attempt (session length 1),
    // it was a CUSTOM_CHALLENGE, and the result was successful
    event.response.issueTokens = true;
    event.response.failAuthentication = false;
  } else {
    // If we reach here, it means either:
    // 1. The custom challenge failed
    // 2. We've gone through more attempts than expected
    // In either case, we fail the authentication
    event.response.issueTokens = false;
    event.response.failAuthentication = true;
  }

  return event;
};
```

Or if you are using `CUSTOM_WITH_SRP`:

```ts title="amplify/auth/define-auth-challenge/handler.ts"
import type { DefineAuthChallengeTriggerHandler } from "aws-lambda"

export const handler: DefineAuthChallengeTriggerHandler = async (event) => {
  // First attempt: Start with SRP_A (Secure Remote Password protocol, step A)
  if (event.request.session.length === 0) {
    event.response.issueTokens = false;
    event.response.failAuthentication = false;
    event.response.challengeName = "SRP_A";
  } else if (
    event.request.session.length === 1 &&
    event.request.session[0].challengeName === "SRP_A" &&
    event.request.session[0].challengeResult === true
  ) {
    // Second attempt: SRP_A was successful, move to PASSWORD_VERIFIER
    event.response.issueTokens = false;
    event.response.failAuthentication = false;
    event.response.challengeName = "PASSWORD_VERIFIER";
  } else if (
    event.request.session.length === 2 &&
    event.request.session[1].challengeName === "PASSWORD_VERIFIER" &&
    event.request.session[1].challengeResult === true
  ) {
    // Third attempt: PASSWORD_VERIFIER was successful, move to CUSTOM_CHALLENGE
    event.response.issueTokens = false;
    event.response.failAuthentication = false;
    event.response.challengeName = "CUSTOM_CHALLENGE";
  } else if (
    event.request.session.length === 3 &&
    event.request.session[2].challengeName === "CUSTOM_CHALLENGE" &&
    event.request.session[2].challengeResult === true
  ) {
    // Fourth attempt: CUSTOM_CHALLENGE was successful, authentication complete
    event.response.issueTokens = true;
    event.response.failAuthentication = false;
  } else {
    // If we reach here, it means one of the challenges failed or
    // we've gone through more attempts than expected
    event.response.issueTokens = false;
    event.response.failAuthentication = true;
  }

  return event;
};
```

## Verify auth challenge response trigger

Lastly, create the trigger responsible for _verifying_ the challenge response. For the purpose of this example, the verification check will always return true.

```ts title="amplify/auth/verify-auth-challenge-response/resource.ts"
import { defineFunction, secret } from "@aws-amplify/backend"

export const verifyAuthChallengeResponse = defineFunction({
  name: "verify-auth-challenge-response",
  resourceGroupName: 'auth'
})
```

After creating the resource file, create the handler with the following contents:

```ts title="amplify/auth/verify-auth-challenge-response/handler.ts"
import type { VerifyAuthChallengeResponseTriggerHandler } from "aws-lambda"

export const handler: VerifyAuthChallengeResponseTriggerHandler = async (
  event
) => {
  event.response.answerCorrect = true;
  return event;
};

```

## Configure auth resource

Finally, import and set the three triggers on your auth resource:

```ts title="amplify/auth/resource.ts"
import { defineAuth } from "@aws-amplify/backend"
import { createAuthChallenge } from "./create-auth-challenge/resource"
import { defineAuthChallenge } from "./define-auth-challenge/resource"
import { verifyAuthChallengeResponse } from "./verify-auth-challenge-response/resource"

/**
 * Define and configure your auth resource
 * @see https://docs.amplify.aws/gen2/build-a-backend/auth
 */
export const auth = defineAuth({
  loginWith: {
    email: true,
  },
  triggers: {
    createAuthChallenge,
    defineAuthChallenge,
    verifyAuthChallengeResponse,
  },
})
```

After deploying the changes, whenever a user attempts to sign in with `CUSTOM_WITH_SRP` or `CUSTOM_WITHOUT_SRP`, the Lambda challenges will be triggered.


Contents of build-a-backend_functions_examples_custom-message_index.txt:
import { getCustomStaticPath } from '@/utils/getCustomStaticPath';

export const meta = {
  title: 'Custom message',
  description:
    'Use an Auth custom message authentication trigger to customize the message sent to users',
  platforms: [
    'android',
    'angular',
    'flutter',
    'javascript',
    'nextjs',
    'react',
    'react-native',
    'swift',
    'vue'
  ]
};

export function getStaticPaths() {
  return getCustomStaticPath(meta.platforms);
}

export function getStaticProps() {
  return {
    props: {
      meta
    }
  };
}

You can use `defineAuth` and `defineFunction` to create an [Amazon Cognito custom message AWS Lambda trigger](https://docs.aws.amazon.com/cognito/latest/developerguide/user-pool-lambda-custom-message.html) thats sends an custom email or phone verification message, or a multi-factor authentication (MFA) code.

To get started, install `@types/aws-lambda` package that will be used to define the type of the handler:

```bash title="Terminal" showLineNumbers={false}
npm add --save-dev @types/aws-lambda
```


Next, create a new directory and a resource file, `amplify/auth/custom-message/resource.ts`. Then, define the function with defineFunction:

```ts title="amplify/auth/custom-message/resource.ts"
import { defineFunction } from '@aws-amplify/backend';

export const customMessage = defineFunction({
  name: "custom-message",
  resourceGroupName: 'auth'
});
```

Next, create the corresponding handler file, `amplify/auth/custom-message/handler.ts`, file with the following contents:

{/* spell-checker: disable */}
```ts title="amplify/auth/custom-message/handler.ts" 
import type { CustomMessageTriggerHandler } from "aws-lambda";

export const handler: CustomMessageTriggerHandler = async (event) => {
  if (event.triggerSource === "CustomMessage_ForgotPassword") {
    const locale = event.request.userAttributes["locale"];
    if (locale === "en") {
      event.response.emailMessage = `Your new one-time code is ${event.request.codeParameter}`;
      event.response.emailSubject = "Reset my password";
    } else if (locale === "es") {
      event.response.emailMessage = `Tu nuevo código de un solo uso es ${event.request.codeParameter}`;
      event.response.emailSubject = "Restablecer mi contraseña";
    }
  }

  return event;
};
```
{/* spellchecker: enable */} 


Lastly, set the newly created function resource on your auth resource:

```ts title="amplify/auth/resource.ts"
import { defineAuth } from '@aws-amplify/backend';
import { customMessage } from "./custom-message/resource";

export const auth = defineAuth({
  // ...
  triggers: {
    customMessage,
  }
});
```

After deploying the changes, whenever a user with user attribute `locale` set to `es` attempts to reset a password they will receive an email with a one-time code in Spanish.


Contents of build-a-backend_functions_examples_dynamo-db-stream_index.txt:
import { getCustomStaticPath } from '@/utils/getCustomStaticPath';

export const meta = {
  title: 'DynamoDB Streams',
  description:
    'Create a Lambda event source using Amazon DynamoDB Streams to trigger a Lambda function in response to real-time events.',
  platforms: [
    'android',
    'angular',
    'flutter',
    'javascript',
    'nextjs',
    'react',
    'react-native',
    'swift',
    'vue'
  ]
};

export function getStaticPaths() {
  return getCustomStaticPath(meta.platforms);
}

export function getStaticProps() {
  return {
    props: {
      meta
    }
  };
}

With AWS Lambda, you can seamlessly integrate various event sources, such as Amazon DynamoDB, Amazon SQS, and others, to trigger Lambda functions in response to real-time events. This feature enables you to build responsive, event-driven applications that react to changes in data or system state without the need for polling services.

In this guide, lets configure a Lambda function with an Amazon DynamoDB stream as an event source. The Lambda function is automatically triggered whenever an item is added, updated, or deleted from the table, enabling you to build real-time applications that react to changes in your data. In this example, we will use a `Todo` table created by a data model on the GraphQL API.

To get started, install the AWS Lambda Powertools Logger, which provides structured logging capabilities for your Lambda function, and the `aws-lambda` package, which is used to define the handler type.

```bash title="Terminal" showLineNumbers={false}
npm add --save-dev @aws-lambda-powertools/logger @types/aws-lambda
```

Second, create a new directory and a resource file, `amplify/functions/dynamoDB-function/resource.ts`. Then, define the function with `defineFunction`:

```ts title="amplify/functions/dynamoDB-function/resource.ts"
import { defineFunction } from "@aws-amplify/backend";

export const myDynamoDBFunction = defineFunction({
  name: "dynamoDB-function",
  resourceGroupName: "data",
});
```

Third, create the corresponding handler file, `amplify/functions/dynamoDB-function/handler.ts`, file with the following contents:

```ts title="amplify/functions/dynamoDB-function/handler.ts"
import type { DynamoDBStreamHandler } from "aws-lambda";
import { Logger } from "@aws-lambda-powertools/logger";

const logger = new Logger({
  logLevel: "INFO",
  serviceName: "dynamodb-stream-handler",
});

export const handler: DynamoDBStreamHandler = async (event) => {
  for (const record of event.Records) {
    logger.info(`Processing record: ${record.eventID}`);
    logger.info(`Event Type: ${record.eventName}`);

    if (record.eventName === "INSERT") {
      // business logic to process new records
      logger.info(`New Image: ${JSON.stringify(record.dynamodb?.NewImage)}`);
    }
  }
  logger.info(`Successfully processed ${event.Records.length} records.`);

  return {
    batchItemFailures: [],
  };
};
```

Lastly, create DynamoDB table as event source in the `amplify/backend.ts` file:

```ts title="amplify/backend.ts"
import { defineBackend } from "@aws-amplify/backend";
import { Stack } from "aws-cdk-lib";
import { Policy, PolicyStatement, Effect } from "aws-cdk-lib/aws-iam";
import { StartingPosition, EventSourceMapping } from "aws-cdk-lib/aws-lambda";
import { auth } from "./auth/resource";
import { data } from "./data/resource";
import { myDynamoDBFunction } from "./functions/dynamoDB-function/resource";

const backend = defineBackend({
  auth,
  data,
  myDynamoDBFunction,
});

const todoTable = backend.data.resources.tables["Todo"];
const policy = new Policy(
  Stack.of(todoTable),
  "MyDynamoDBFunctionStreamingPolicy",
  {
    statements: [
      new PolicyStatement({
        effect: Effect.ALLOW,
        actions: [
          "dynamodb:DescribeStream",
          "dynamodb:GetRecords",
          "dynamodb:GetShardIterator",
          "dynamodb:ListStreams",
        ],
        resources: ["*"],
      }),
    ],
  }
);
backend.myDynamoDBFunction.resources.lambda.role?.attachInlinePolicy(policy);

const mapping = new EventSourceMapping(
  Stack.of(todoTable),
  "MyDynamoDBFunctionTodoEventStreamMapping",
  {
    target: backend.myDynamoDBFunction.resources.lambda,
    eventSourceArn: todoTable.tableStreamArn,
    startingPosition: StartingPosition.LATEST,
  }
);

mapping.node.addDependency(policy);
```


Contents of build-a-backend_functions_examples_email-domain-filtering_index.txt:
import { getCustomStaticPath } from '@/utils/getCustomStaticPath';

export const meta = {
  title: 'Email domain filtering',
  description:
    'Use an Auth Pre Signup trigger to allow or deny sign-ups based on email domains',
  platforms: [
    'android',
    'angular',
    'flutter',
    'javascript',
    'nextjs',
    'react',
    'react-native',
    'swift',
    'vue'
  ]
};

export function getStaticPaths() {
  return getCustomStaticPath(meta.platforms);
}

export function getStaticProps() {
  return {
    props: {
      meta
    }
  };
}

You can use `defineAuth` and `defineFunction` to create a [Cognito pre sign-up Lambda trigger](https://docs.aws.amazon.com/cognito/latest/developerguide/user-pool-lambda-pre-sign-up.html) that performs filtering based on the user's email address. This can allow or deny user signups based on their email address.

To get started, install the `aws-lambda` package, which is used to define the handler type.

```bash title="Terminal" showLineNumbers={false}
npm add --save-dev @types/aws-lambda
```

Next, create a new directory and a resource file, `amplify/auth/pre-sign-up/resource.ts`. Then, define the Function with `defineFunction`:

```ts title="amplify/auth/pre-sign-up/resource.ts"
import { defineFunction } from '@aws-amplify/backend';

export const preSignUp = defineFunction({
  name: 'pre-sign-up',
  // optionally define an environment variable for your filter
  environment: {
    ALLOW_DOMAIN: 'amazon.com'
  }
});
```

Next, create the corresponding handler file, `amplify/auth/pre-sign-up/handler.ts`, file with the following contents:

```ts title="amplify/auth/pre-sign-up/handler.ts"
import type { PreSignUpTriggerHandler } from 'aws-lambda';
import { env } from '$amplify/env/pre-sign-up';

export const handler: PreSignUpTriggerHandler = async (event) => {
  const email = event.request.userAttributes['email'];

  if (!email.endsWith(env.ALLOW_DOMAIN)) {
    throw new Error('Invalid email domain');
  }

  return event;
};
```

Lastly, set the newly created Function resource on your auth resource:

```ts title="amplify/auth/resource.ts"
import { defineAuth } from '@aws-amplify/backend';
import { preSignUp } from './pre-sign-up/resource';

export const auth = defineAuth({
  // ...
  triggers: {
    preSignUp
  }
});
```

After deploying the changes, whenever a user attempts to sign up without an `amazon.com` email address they will receive an error.


Contents of build-a-backend_functions_examples_google-recaptcha-challenge_index.txt:
import { getCustomStaticPath } from '@/utils/getCustomStaticPath';

export const meta = {
  title: 'Google reCAPTCHA challenge',
  description:
    'Leverage Google reCAPTCHA to protect against spam',
  platforms: [
    'android',
    'angular',
    'flutter',
    'javascript',
    'nextjs',
    'react',
    'react-native',
    'swift',
    'vue'
  ]
};

export function getStaticPaths() {
  return getCustomStaticPath(meta.platforms);
}

export function getStaticProps() {
  return {
    props: {
      meta
    }
  };
}

You can use `defineAuth` and `defineFunction` to create an auth experience that requires a [reCAPTCHA v3](https://developers.google.com/recaptcha/docs/v3) token. This can be accomplished by leveraging [Amazon Cognito's feature to define a custom auth challenge](https://docs.aws.amazon.com/cognito/latest/developerguide/amazon-cognito-user-pools-authentication-flow.html#Custom-authentication-flow-and-challenges) and 3 triggers:

1. [Create auth challenge](https://docs.aws.amazon.com/cognito/latest/developerguide/user-pool-lambda-create-auth-challenge.html)
2. [Define auth challenge](https://docs.aws.amazon.com/cognito/latest/developerguide/user-pool-lambda-define-auth-challenge.html)
3. [Verify auth challenge response](https://docs.aws.amazon.com/cognito/latest/developerguide/user-pool-lambda-verify-auth-challenge-response.html) 

## Create auth challenge trigger

To get started, create the first of the three triggers, `create-auth-challenge`. This is the trigger responsible for creating the reCAPTCHA challenge after a password is verified.

```ts title="amplify/auth/create-auth-challenge/resource.ts"
import { defineFunction } from "@aws-amplify/backend"

export const createAuthChallenge = defineFunction({
  name: "create-auth-challenge",
  resourceGroupName: 'auth'
})
```

After creating the resource file, create the handler with the following contents:

```ts title="amplify/auth/create-auth-challenge/handler.ts"
import type { CreateAuthChallengeTriggerHandler } from "aws-lambda"

export const handler: CreateAuthChallengeTriggerHandler = async (event) => {
  const { request, response } = event

  if (
    // session will contain 3 "steps": SRP, password verification, custom challenge
    request.session.length === 2 &&
    request.challengeName === "CUSTOM_CHALLENGE"
  ) {
    response.publicChallengeParameters = { trigger: "true" }
    response.privateChallengeParameters = { answer: "" }
    // optionally set challenge metadata
    response.challengeMetadata = "CAPTCHA_CHALLENGE"
  }

  return event
}
```

## Define auth challenge trigger

Next, you will want to create the trigger responsible for _defining_ the auth challenge flow, `define-auth-challenge`.

```ts title="amplify/auth/define-auth-challenge/resource.ts"
import { defineFunction } from "@aws-amplify/backend"

export const defineAuthChallenge = defineFunction({
  name: "define-auth-challenge",
  resourceGroupName: 'auth'
})
```

After creating the resource file, create the handler with the following contents:

```ts title="amplify/auth/define-auth-challenge/handler.ts"
import type { DefineAuthChallengeTriggerHandler } from "aws-lambda"

export const handler: DefineAuthChallengeTriggerHandler = async (event) => {
  const { response } = event
  const [srp, password, captcha] = event.request.session

  // deny by default
  response.issueTokens = false
  response.failAuthentication = true

  if (srp?.challengeName === "SRP_A") {
    response.failAuthentication = false
    response.challengeName = "PASSWORD_VERIFIER"
  }

  if (
    password?.challengeName === "PASSWORD_VERIFIER" &&
    password.challengeResult === true
  ) {
    response.failAuthentication = false
    response.challengeName = "CUSTOM_CHALLENGE"
  }

  if (
    captcha?.challengeName === "CUSTOM_CHALLENGE" &&
    // check for the challenge metadata set in "create-auth-challenge"
    captcha?.challengeMetadata === "CAPTCHA_CHALLENGE" &&
    captcha.challengeResult === true
  ) {
    response.issueTokens = true
    response.failAuthentication = false
  }

  return event
}
```

## Verify auth challenge response trigger

Lastly, create the trigger responsible for _verifying_ the challenge response, which in this case is the reCAPTCHA token verification.

<Callout info>

If you have not done so already, you will need to register your application and retrieve a reCAPTCHA secret key. This can then be configured for use with your cloud sandbox using:

```bash title="Terminal" showLineNumbers={false}
npx ampx sandbox secret set GOOGLE_RECAPTCHA_SECRET_KEY
```

</Callout>

```ts title="amplify/auth/verify-auth-challenge-response/resource.ts"
import { defineFunction, secret } from "@aws-amplify/backend"

export const verifyAuthChallengeResponse = defineFunction({
  name: "verify-auth-challenge-response",
  environment: {
    GOOGLE_RECAPTCHA_SECRET_KEY: secret("GOOGLE_RECAPTCHA_SECRET_KEY"),
  },
  resourceGroupName: 'auth'
})
```

After creating the resource file, create the handler with the following contents:

```ts title="amplify/auth/verify-auth-challenge-response/handler.ts"
import type { VerifyAuthChallengeResponseTriggerHandler } from "aws-lambda"
import { env } from "$amplify/env/verify-auth-challenge-response"

/**
 * Google ReCAPTCHA verification response
 * @see https://developers.google.com/recaptcha/docs/v3#site_verify_response
 */
type GoogleRecaptchaVerifyResponse = {
  // whether this request was a valid reCAPTCHA token for your site
  success: boolean
  // the score for this request (0.0 - 1.0)
  score: number
  // the action name for this request (important to verify)
  action: string
  // timestamp of the challenge load (ISO format yyyy-MM-dd'T'HH:mm:ssZZ)
  challenge_ts: string
  // the hostname of the site where the reCAPTCHA was solved
  hostname: string
  // optional error codes
  "error-codes"?: unknown[]
}

export const handler: VerifyAuthChallengeResponseTriggerHandler = async (
  event
) => {
  if (!event.request.challengeAnswer) {
    throw new Error("Missing challenge answer")
  }

  // https://developers.google.com/recaptcha/docs/verify#api_request
  const url = new URL("https://www.google.com/recaptcha/api/siteverify")
  const params = new URLSearchParams({
    secret: env.GOOGLE_RECAPTCHA_SECRET_KEY,
    response: event.request.challengeAnswer,
  })
  url.search = params.toString()

  const request = new Request(url, {
    method: "POST",
  })

  const response = await fetch(request)
  const result = (await response.json()) as GoogleRecaptchaVerifyResponse

  if (!result.success) {
    throw new Error("Verification failed", { cause: result["error-codes"] })
  }

  // indicate whether the answer is correct
  event.response.answerCorrect = result.success

  return event
}
```

## Configure auth resource

Finally, import and set the three triggers on your auth resource:

```ts title="amplify/auth/resource.ts"
import { defineAuth } from "@aws-amplify/backend"
import { createAuthChallenge } from "./create-auth-challenge/resource"
import { defineAuthChallenge } from "./define-auth-challenge/resource"
import { verifyAuthChallengeResponse } from "./verify-auth-challenge-response/resource"

/**
 * Define and configure your auth resource
 * @see https://docs.amplify.aws/gen2/build-a-backend/auth
 */
export const auth = defineAuth({
  loginWith: {
    email: true,
  },
  triggers: {
    createAuthChallenge,
    defineAuthChallenge,
    verifyAuthChallengeResponse,
  },
})
```

{/* @TODO client-side samples */}


Contents of build-a-backend_functions_examples_index.txt:
import { getChildPageNodes } from '@/utils/getChildPageNodes';
import { getCustomStaticPath } from '@/utils/getCustomStaticPath';

export const meta = {
  title: 'Examples',
  description: 'Example use cases for Amplify Functions',
  route: '/[platform]/build-a-backend/functions/examples',
  platforms: [
    'android',
    'angular',
    'flutter',
    'javascript',
    'nextjs',
    'react',
    'react-native',
    'swift',
    'vue'
  ]
};

export function getStaticPaths() {
  return getCustomStaticPath(meta.platforms);
}

export function getStaticProps() {
  const childPageNodes = getChildPageNodes(meta.route);
  return {
    props: {
      meta,
      childPageNodes
    }
  };
}

<Overview childPageNodes={props.childPageNodes} />


Contents of build-a-backend_functions_examples_kinesis-stream_index.txt:
import { getCustomStaticPath } from '@/utils/getCustomStaticPath';

export const meta = {
  title: 'Amazon Kinesis Data Streams',
  description:
    'Create a Lambda event source for a Amazon Kinesis Data Stream to trigger Lambda functions in response to real-time events',
  platforms: [
    'android',
    'angular',
    'flutter',
    'javascript',
    'nextjs',
    'react',
    'react-native',
    'swift',
    'vue'
  ]
};

export function getStaticPaths() {
  return getCustomStaticPath(meta.platforms);
}

export function getStaticProps() {
  return {
    props: {
      meta
    }
  };
}

With AWS Lambda, you can seamlessly integrate various event sources, such as Amazon Kinesis, Amazon SQS, and others, to trigger Lambda functions in response to real-time events. This feature enables you to build responsive, event-driven applications that react to changes in data or system state without the need for polling services.

In this guide, let us configure a Lambda function with a Kinesis data stream as an event source. The Lambda function is automatically triggered whenever new data is published to the stream - whether you're processing streaming data, reacting to application events, or automating workflows.

To get started, install the AWS Lambda Powertools Logger, which provides structured logging capabilities for your Lambda function, and the `aws-lambda` package, which is used to define the handler type.

```bash title="Terminal" showLineNumbers={false}
npm add @aws-lambda-powertools/logger @types/aws-lambda
```

Second, create a new directory and a resource file, `amplify/functions/kinesis-function/resource.ts`. Then, define the function with `defineFunction`:

```ts title="amplify/functions/kinesis-function/resource.ts"
import { defineFunction } from "@aws-amplify/backend";

export const myKinesisFunction = defineFunction({
  name: "kinesis-function",
});
```

Third, create the corresponding handler file, `amplify/functions/kinesis-function/handler.ts`, file with the following contents:

```ts title="amplify/functions/kinesis-function/handler.ts"
import type {
  KinesisStreamBatchResponse,
  KinesisStreamHandler,
  KinesisStreamRecordPayload,
} from "aws-lambda";
import { Buffer } from "node:buffer";
import { Logger } from "@aws-lambda-powertools/logger";

const logger = new Logger({
  logLevel: "INFO",
  serviceName: "kinesis-stream-handler",
});

export const handler: KinesisStreamHandler = async (
  event,
  context
): Promise<KinesisStreamBatchResponse> => {
  for (const record of event.Records) {
    try {
      logger.info(`Processed Kinesis Event - EventID: ${record.eventID}`);
      const recordData = await getRecordDataAsync(record.kinesis);
      logger.info(`Record Data: ${recordData}`);
    } catch (err) {
      logger.error(`An error occurred ${err}`);
      /*
      When processing stream data, if any item fails, returning the failed item's position immediately
      prompts Lambda to retry from this item forward, ensuring continuous processing without skipping data.
      */
      return {
        batchItemFailures: [{ itemIdentifier: record.kinesis.sequenceNumber }],
      };
    }
  }
  logger.info(`Successfully processed ${event.Records.length} records.`);
  return { batchItemFailures: [] };
};

async function getRecordDataAsync(
  payload: KinesisStreamRecordPayload
): Promise<string> {
  const data = Buffer.from(payload.data, "base64").toString("utf-8");
  await Promise.resolve(1); // Placeholder for an async process
  return data;
}
```

Lastly, create the Kinesis stream and add it as a event source in the `amplify/backend.ts` file:

```ts title="amplify/backend.ts"
import { defineBackend } from "@aws-amplify/backend";
import { Stream } from "aws-cdk-lib/aws-kinesis";
import { StartingPosition } from "aws-cdk-lib/aws-lambda";
import { KinesisEventSource } from "aws-cdk-lib/aws-lambda-event-sources";
import { auth } from "./auth/resource";
import { data } from "./data/resource";
import { myKinesisFunction } from "./functions/kinesis-function/resource";

const backend = defineBackend({
  auth,
  data,
  myKinesisFunction,
});

const kinesisStack = backend.createStack("kinesis-stack");

const kinesisStream = new Stream(kinesisStack, "KinesisStream", {
  streamName: "myKinesisStream",
  shardCount: 1,
});

const eventSource = new KinesisEventSource(kinesisStream, {
  startingPosition: StartingPosition.LATEST,
  reportBatchItemFailures: true,
});

backend.myKinesisFunction.resources.lambda.addEventSource(eventSource);
```
<InlineFilter filters={["javascript", "react-native", "angular", "nextjs", "react", "vue"]}>
For examples on streaming analytics data to the Kinesis stream from your frontend, see the [Streaming analytics data](/[platform]/build-a-backend/add-aws-services/analytics/streaming-data/) documentation.
</InlineFilter>


Contents of build-a-backend_functions_examples_override-token_index.txt:
import { getCustomStaticPath } from '@/utils/getCustomStaticPath';

export const meta = {
  title: 'Override ID token claims',
  description:
    'Use an Auth Pre token generation trigger to override ID token claims',
  platforms: [
    'android',
    'angular',
    'flutter',
    'javascript',
    'nextjs',
    'react',
    'react-native',
    'swift',
    'vue'
  ]
};

export function getStaticPaths() {
  return getCustomStaticPath(meta.platforms);
}

export function getStaticProps() {
  return {
    props: {
      meta
    }
  };
}


You can use `defineAuth` and `defineFunction` to create an [Amazon Cognito Pre token generation AWS Lambda trigger](https://docs.aws.amazon.com/cognito/latest/developerguide/user-pool-lambda-pre-token-generation.html) to override the token by adding a new claim or modifying the user's group membership.

To get started, install the `aws-lambda` package, which is used to define the handler type.

```bash title="Terminal" showLineNumbers={false}
npm add --save-dev @types/aws-lambda
```

Create a new directory and a resource file, `amplify/auth/pre-token-generation/resource.ts`. Then, define the function with `defineFunction`:

```ts title="amplify/auth/pre-token-generation/resource.ts"
import { defineFunction } from '@aws-amplify/backend';

export const preTokenGeneration = defineFunction({
  name: 'pre-token-generation',
  resourceGroupName: 'auth'
});
```

Then, create the corresponding handler file, `amplify/auth/post-confirmation/pre-token-generation/handler.ts`, file with the following contents:

{/* cSpell:disable */}
```ts title="amplify/auth/pre-token-generation/handler.ts"
import type { PreTokenGenerationTriggerHandler } from "aws-lambda";

export const handler: PreTokenGenerationTriggerHandler = async (event) => {
  event.response = {
    claimsOverrideDetails: {
      groupOverrideDetails: {
        // This will add the user to the cognito group "amplify_group_1" 
        groupsToOverride: ["amplify_group_1"],
      },
      claimsToAddOrOverride: {
        // This will add the custom claim "amplfy_attribute" to the id token
        amplfy_attribute: "amplify_gen_2",
      },
    },
  };
  return event;
};

```
{/* cSpell:enable */}

Lastly, set the newly created function resource on your auth resource:

```ts title="amplify/auth/resource.ts"
import { defineAuth } from '@aws-amplify/backend';
import { preTokenGeneration } from './pre-token-generation/resource';

export const auth = defineAuth({
  loginWith: {
    email: true,
  },
  triggers: {
    preTokenGeneration
  }
});
```

After deploying the changes, The idToken of the user will be modified as per the trigger above.

{/* cSpell:disable */}
```json showLineNumbers={false}
{
  "cognito:groups": [
    "amplify_group_1"
  ],
  "email_verified": true,
  "iss": "...",
  "cognito:username": "...",
  "origin_jti": "...",
  "amplfy_attribute": "amplify_gen_2",
  "aud": "...",
}

```
{/* cSpell:disable */}


Contents of build-a-backend_functions_examples_s3-upload-confirmation_index.txt:
import { getCustomStaticPath } from '@/utils/getCustomStaticPath';

export const meta = {
  title: 'S3 Upload confirmation',
  description:
    'Use a trigger to confirm uploading files',
  platforms: [
    'android',
    'angular',
    'flutter',
    'javascript',
    'nextjs',
    'react',
    'react-native',
    'swift',
    'vue'
  ]
};

export function getStaticPaths() {
  return getCustomStaticPath(meta.platforms);
}

export function getStaticProps() {
  return {
    props: {
      meta
    }
  };
}

You can use `defineStorage` and `defineFunction` to create a function trigger to confirm uploading a file.

To get started, install the `@types/aws-lambda` [package](https://www.npmjs.com/package/@types/aws-lambda), which contains types for different kinds of Lambda handlers, events, and responses.

```bash title="Terminal" showLineNumbers={false}
npm add --save @types/aws-lambda
```

Update your storage definition to define the onUpload trigger as below:

```ts title="amplify/storage/resource.ts"
import { defineFunction, defineStorage } from "@aws-amplify/backend";

export const storage = defineStorage({
  name: 'myProjectFiles',
  triggers: {
    onUpload: defineFunction({
      entry: './on-upload-handler.ts'
      resourceGroupName: 'storage',
    })
  }
});
```

Next, create a file named `amplify/storage/on-upload-handler.ts` and use the following code to log the object keys whenever an object is uploaded to the bucket. You can add your custom logic to this function as needed.

```ts title="amplify/storage/on-upload-handler.ts"
import type { S3Handler } from 'aws-lambda';

export const handler: S3Handler = async (event) => {
  const objectKeys = event.Records.map((record) => record.s3.object.key);
  console.log(`Upload handler invoked for objects [${objectKeys.join(', ')}]`);
};
```

Now, when you deploy your backend, this function will be invoked whenever an object is uploaded to the bucket.


Contents of build-a-backend_functions_examples_user-attribute-validation_index.txt:
import { getCustomStaticPath } from '@/utils/getCustomStaticPath';

export const meta = {
  title: 'User attribute validation',
  description:
    'Validate user attributes with an Auth trigger',
  platforms: [
    'android',
    'angular',
    'flutter',
    'javascript',
    'nextjs',
    'react',
    'react-native',
    'swift',
    'vue'
  ]
};

export function getStaticPaths() {
  return getCustomStaticPath(meta.platforms);
}

export function getStaticProps() {
  return {
    props: {
      meta
    }
  };
}

You can use `defineAuth` and `defineFunction` to create a [Cognito pre sign-up Lambda trigger](https://docs.aws.amazon.com/cognito/latest/developerguide/user-pool-lambda-pre-sign-up.html) that extends the behavior of sign-up to validate attribute values.

To get started, create a new directory and a resource file, `amplify/auth/pre-sign-up/resource.ts`. Then, define the function with `defineFunction`:

```ts title="amplify/auth/pre-sign-up/resource.ts"
import { defineFunction } from '@aws-amplify/backend';

export const preSignUp = defineFunction({
  name: "pre-sign-up",
  resourceGroupName: 'auth'
});
```

Next, create the corresponding handler file, `amplify/auth/pre-sign-up/handler.ts`, file with the following contents:

```ts title="amplify/auth/pre-sign-up/handler.ts"
import type { PreSignUpTriggerHandler } from "aws-lambda"

function isOlderThan(date: Date, age: number) {
  const comparison = new Date()
  comparison.setFullYear(comparison.getFullYear() - age)
  return date.getTime() > comparison.getTime()
}

export const handler: PreSignUpTriggerHandler = async (event) => {
  const birthdate = new Date(event.request.userAttributes["birthdate"])

  // you must be 13 years or older
  if (!isOlderThan(birthdate, 13)) {
    throw new Error("You must be 13 years or older to use this site")
  }

  return event
}
```

Lastly, set the newly created function resource on your auth resource:

```ts title="amplify/auth/resource.ts"
import { defineAuth } from '@aws-amplify/backend';
import { preSignUp } from './pre-sign-up/resource';

export const auth = defineAuth({
  // ...
  triggers: {
    preSignUp
  }
});
```

After deploying the changes, whenever a user attempts to sign up this handler will verify the submitter's age is above 13 years.


Contents of build-a-backend_functions_grant-access-to-other-resources_index.txt:
import { getCustomStaticPath } from '@/utils/getCustomStaticPath';

export const meta = {
  title: 'Grant access to other resources',
  description:
    'Extend the capabilities of your Function by granting access to other resources',
  platforms: [
    'android',
    'angular',
    'flutter',
    'javascript',
    'nextjs',
    'react',
    'react-native',
    'swift',
    'vue'
  ]
};

export function getStaticPaths() {
  return getCustomStaticPath(meta.platforms);
}

export function getStaticProps() {
  return {
    props: {
      meta
    }
  };
}

In order for Amplify Functions to interact with other resources they must be given access. There are two ways to grant Amplify Functions access to other resources:

1. [Using the `access` property](#using-the-access-property)
2. [Using the AWS Cloud Development Kit (CDK)](#using-cdk)

## Using the `access` property

The `access` property is a property found in each of the `define*` functions for defining Amplify resources. It allows you specify the necessary actions using common language.

<Callout>

When you grant a function access to another resource in your Amplify backend ([such as granting access to storage](/[platform]/build-a-backend/storage/#resource-access)), it will configure environment variables for that function to make SDK calls to the AWS services it has access to. Those environment variables are typed and available as part of the `env` object.

</Callout>

Say you have a function that generates reports each month from your Data resource and needs to store the generated reports in Storage:

```ts title="amplify/storage/resource.ts"
import { defineStorage } from '@aws-amplify/backend';
import { generateMonthlyReports } from '../functions/generate-monthly-reports/resource';

export const storage = defineStorage({
  name: 'myReports',
  access: (allow) => ({
    'reports/*': [
      allow.resource(generateMonthlyReports).to(['read', 'write', 'delete'])
    ]
  })
});
```

This access definition will add the environment variable `myReports_BUCKET_NAME` to the function. This environment variable can be accessed on the `env` object.

Here's an example of how it can be used to upload some content to S3.

```ts title="amplify/functions/generate-monthly-reports/handler.ts"
import { S3Client, PutObjectCommand } from '@aws-sdk/client-s3';
import { env } from '$amplify/env/generate-monthly-reports';

const s3Client = new S3Client();

export const handler = async () => {
  const command = new PutObjectCommand({
    Bucket: env.MY_REPORTS_BUCKET_NAME,
    Key: `reports/${new Date().toISOString()}.csv`,
    Body: new Blob([''], { type: 'text/csv;charset=utf-8;' })
  });

  await s3Client.send(command);
};
```

## Using CDK

When permissions are needed to access resources beyond the capabilities of the `access` property, you must use CDK.

Functions are created with an [_execution role_](https://docs.aws.amazon.com/lambda/latest/dg/lambda-intro-execution-role.html), which is an IAM role that contains policies that dictate what resources your Function can interact with when it executes. This role can be extended using the [`addToRolePolicy()`](https://docs.aws.amazon.com/cdk/api/v2/docs/aws-cdk-lib.aws_lambda.IFunction.html#addwbrtowbrrolewbrpolicystatement) method:

```ts title="amplify/backend.ts"
import { defineBackend } from "@aws-amplify/backend"
import * as iam from "aws-cdk-lib/aws-iam"
import * as sns from "aws-cdk-lib/aws-sns"
import { weeklyDigest } from "./functions/weekly-digest/resource"

const backend = defineBackend({
  weeklyDigest,
})

const weeklyDigestLambda = backend.weeklyDigest.resources.lambda

const topicStack = backend.createStack("WeeklyDigest")
const topic = new sns.Topic(topicStack, "Topic", {
  displayName: "digest",
})

// highlight-start
const statement = new iam.PolicyStatement({
  sid: "AllowPublishToDigest",
  actions: ["sns:Publish"],
  resources: [topic.topicArn],
})

weeklyDigestLambda.addToRolePolicy(statement)
  // highlight-end
```

However some constructs provide a `grant*` method to grant access to common policy actions. Revisiting the example above you can grant the same access with `grantPublish`:

```ts title="amplify/backend.ts"
import { defineBackend } from "@aws-amplify/backend"
import * as sns from "aws-cdk-lib/aws-sns"
import { weeklyDigest } from "./functions/weekly-digest/resource"

const backend = defineBackend({
  weeklyDigest,
})

const weeklyDigestLambda = backend.weeklyDigest.resources.lambda

const topicStack = backend.createStack("WeeklyDigest")
const topic = new sns.Topic(topicStack, "Topic", {
  displayName: "digest"
})

// highlight-next-line
topic.grantPublish(weeklyDigestLambda)
```


Contents of build-a-backend_functions_index.txt:
import { getChildPageNodes } from '@/utils/getChildPageNodes';
import { getCustomStaticPath } from '@/utils/getCustomStaticPath';

export const meta = {
  title: 'Functions',
  description:
    'Use AWS Lambda functions to perform tasks and customize workflows.',
  platforms: [
    'android',
    'angular',
    'flutter',
    'javascript',
    'nextjs',
    'react',
    'react-native',
    'swift',
    'vue'
  ],
  route: '/[platform]/build-a-backend/functions'
};

export function getStaticPaths() {
  return getCustomStaticPath(meta.platforms);
}

export function getStaticProps() {
  const childPageNodes = getChildPageNodes(meta.route);
  return {
    props: {
      meta,
      childPageNodes
    }
  };
}

<Overview childPageNodes={props.childPageNodes} />


Contents of build-a-backend_functions_modify-resources-with-cdk_index.txt:
import { getCustomStaticPath } from '@/utils/getCustomStaticPath';

export const meta = {
  title: 'Modify Amplify-generated Lambda resources with CDK',
  description:
    'Learn how to extend the underlying Function resources',
  platforms: [
    'android',
    'angular',
    'flutter',
    'javascript',
    'nextjs',
    'react',
    'react-native',
    'swift',
    'vue'
  ]
};

export function getStaticPaths() {
  return getCustomStaticPath(meta.platforms);
}

export function getStaticProps(context) {
  return {
    props: {
      platform: context.params.platform,
      meta
    }
  };
}

Amplify Functions utilize the [`NodejsFunction`](https://docs.aws.amazon.com/cdk/api/v2/docs/aws-cdk-lib.aws_lambda_nodejs.NodejsFunction.html) construct from the [AWS Cloud Development Kit (CDK)](https://aws.amazon.com/cdk/). The underlying resources can be modified, overridden, or extended using CDK after setting the resource on your backend.

```ts title="amplify/backend.ts"
import { defineBackend } from '@aws-amplify/backend';
import { myFunction } from './functions/my-function';

const backend = defineBackend({
  myFunction
})

// CDK constructs can be accessed via
backend.myFunction.resources

// where the Lambda function can be found on
backend.myFunction.resources.lambda
```

The Lambda resource available is a representation of [`IFunction`](https://docs.aws.amazon.com/cdk/api/v2/docs/aws-cdk-lib.aws_lambda.IFunction.html). 

## Adding IAM Policies

To learn how to add IAM policies to a Function's execution role, visit the [documentation for granting access to other resources](/[platform]/build-a-backend/functions/grant-access-to-other-resources#using-cdk).

{/* ## Lambda Layers */}


Contents of build-a-backend_functions_scheduling-functions_index.txt:
import { getCustomStaticPath } from '@/utils/getCustomStaticPath';

export const meta = {
  title: 'Scheduling Functions',
  description:
    'Learn how to schedule functions to run at specific intervals',
  platforms: [
    'android',
    'angular',
    'flutter',
    'javascript',
    'nextjs',
    'react',
    'react-native',
    'swift',
    'vue'
  ]
};

export function getStaticPaths() {
  return getCustomStaticPath(meta.platforms);
}

export function getStaticProps() {
  return {
    props: {
      meta
    }
  };
}

Amplify offers the ability to schedule Functions to run on specific intervals using natural language or [cron expressions](https://en.wikipedia.org/wiki/Cron). To get started, specify the `schedule` property in `defineFunction`:

<Callout info>

**Note:** Configuring the schedule in `defineFunction` is not supported for [Custom Functions](/[platform]/build-a-backend/functions/custom-functions/).

</Callout>

```ts title="amplify/jobs/weekly-digest/resource.ts"
import { defineFunction } from "@aws-amplify/backend";

export const weeklyDigest = defineFunction({
  name: "weekly-digest",
  schedule: "every week",
});
```

Function schedules are powered by [Amazon EventBridge rules](https://docs.aws.amazon.com/eventbridge/latest/userguide/eb-rules.html), and can be leveraged to address use cases such as:

- generating a "front page" of top-performing posts
- generating a weekly digest of top-performing posts
- generating a monthly report of warehouse inventory

Their handlers can be typed using the `EventBridgeHandler` type:

```ts title="amplify/jobs/weekly-digest/handler.ts"
import type { EventBridgeHandler } from "aws-lambda";

export const handler: EventBridgeHandler<"Scheduled Event", null, void> = async (event) => {
  console.log("event", JSON.stringify(event, null, 2))
}
```

<Callout info>

**Note**: AWS Lambda types can be installed with

```bash title="Terminal" showLineNumbers={false}
npm install --save-dev @types/aws-lambda
```

</Callout>

Schedules can either be a single interval, or multiple intervals:

```ts title="amplify/jobs/generate-report/resource.ts"
import { defineFunction } from "@aws-amplify/backend";

export const generateReport = defineFunction({
  name: "generate-report",
  schedule: ["every week", "every month", "every year"],
});
```

Schedules can also be defined to execute using minutes or hours with a shorthand syntax:

```ts title="amplify/jobs/drink-some-water/resource.ts"
import { defineFunction } from "@aws-amplify/backend";

export const drinkSomeWater = defineFunction({
  name: "drink-some-water",
  schedule: "every 1h"
})
```

Or combined to create complex schedules:

```ts title="amplify/jobs/remind-me/resource.ts"
import { defineFunction } from "@aws-amplify/backend";

export const remindMe = defineFunction({
  name: "remind-me",
  schedule: [
    // every sunday at midnight
    "every week",
    // every tuesday at 5pm
    "0 17 ? * 3 *",
    // every wednesday at 5pm
    "0 17 ? * 4 *",
    // every thursday at 5pm
    "0 17 ? * 5 *",
    // every friday at 5pm
    "0 17 ? * 6 *",
  ]
})
```

## Using natural language

Schedules can be written using natural language, using terms you use every day. Amplify supports the following time periods:

- `day` will always start at midnight
- `week` will always start on Sunday at midnight
- `month` will always start on the first of the month at midnight
- `year` will always start on the first of the year at midnight
- `m` for minutes
- `h` for hours

Natural language expressions are prefixed with "every":

```ts title="amplify/jobs/drink-some-water/resource.ts"
import { defineFunction } from "@aws-amplify/backend";

export const drinkSomeWater = defineFunction({
  name: "drink-some-water",
  schedule: "every 1h"
})
```

## Using cron expressions

Schedules can be written using cron expressions.

```ts title="amplify/jobs/remind-me/resource.ts"
import { defineFunction } from "@aws-amplify/backend";

export const remindMe = defineFunction({
  name: "remind-me-to-take-the-trash-out",
  schedule: [
    // every tuesday at 9am
    "0 9 ? * 3 *",
    // every friday at 9am
    "0 9 ? * 6 *",
  ]
})
```


Contents of build-a-backend_functions_set-up-function_index.txt:
import { getCustomStaticPath } from '@/utils/getCustomStaticPath';

export const meta = {
  title: 'Set up a Function',
  description:
    'Use AWS Lambda functions to perform tasks and customize workflows.',
  platforms: [
    'android',
    'angular',
    'flutter',
    'javascript',
    'nextjs',
    'react',
    'react-native',
    'swift',
    'vue'
  ]
};

export function getStaticPaths() {
  return getCustomStaticPath(meta.platforms);
}

export function getStaticProps(context) {
  return {
    props: {
      platform: context.params.platform,
      meta
    }
  };
}

Amplify Functions are powered by [AWS Lambda](https://aws.amazon.com/lambda/), and allow you to perform a wide variety of customization through self-contained _functions_. Functions can respond to events from other resources, execute some logic in-between events like an authentication flow, or act as standalone jobs. They are used in a variety of settings and use cases:

- Authentication flow customizations (e.g. attribute validations, allowlisting email domains)
- Resolvers for GraphQL APIs
- Handlers for individual REST API routes, or to host an entire API
- Scheduled jobs

To get started, create a new directory and a resource file, `amplify/functions/say-hello/resource.ts`. Then, define the Function with `defineFunction`:

```ts title="amplify/functions/say-hello/resource.ts"
import { defineFunction } from '@aws-amplify/backend';

export const sayHello = defineFunction({
  // optionally specify a name for the Function (defaults to directory name)
  name: 'say-hello',
  // optionally specify a path to your handler (defaults to "./handler.ts")
  entry: './handler.ts'
});
```

Next, create the corresponding handler file at `amplify/functions/say-hello/handler.ts`. This is where your function code will go.

```ts title="amplify/functions/say-hello/handler.ts"
import type { Handler } from 'aws-lambda';

export const handler: Handler = async (event, context) => {
  // your function code goes here
  return 'Hello, World!';
};
```

The handler file _must_ export a function named "handler". This is the entry point to your function. For more information on writing functions, refer to the [AWS documentation for Lambda function handlers using Node.js](https://docs.aws.amazon.com/lambda/latest/dg/nodejs-handler.html).

Lastly, this function needs to be added to your backend.

```ts title="amplify/backend.ts"
import { defineBackend } from '@aws-amplify/backend';
// highlight-next-line
import { sayHello } from './functions/say-hello/resource';

defineBackend({
  // highlight-next-line
  sayHello
});
```

Now when you run `npx ampx sandbox` or deploy your app on Amplify, it will include your Function.

To invoke your Function, we recommend adding your [Function as a handler for a custom query with your Amplify Data resource](/[platform]/build-a-backend/data/custom-business-logic/). This will enable you to strongly type Function arguments and the return statement, and use this to author your Function's business logic. To get started, open your `amplify/data/resource.ts` file and specify a new query in your schema:

```ts title="amplify/data/resource.ts"
import { type ClientSchema, a, defineData } from "@aws-amplify/backend"
import { sayHello } from "../functions/say-hello/resource"

const schema = a.schema({
  // highlight-start
  sayHello: a
    .query()
    .arguments({
      name: a.string(),
    })
    .returns(a.string())
    .handler(a.handler.function(sayHello)),
  // highlight-end
})

export type Schema = ClientSchema<typeof schema>

export const data = defineData({
  schema,
  authorizationModes: {
    defaultAuthorizationMode: "iam",
  },
})
```

Now you can use this query from the `Schema` export to strongly type your Function handler:

```ts title="amplify/functions/say-hello/handler.ts"
import type { Schema } from "../../data/resource"

export const handler: Schema["sayHello"]["functionHandler"] = async (event) => {
  // arguments typed from `.arguments()`
  const { name } = event.arguments
  // return typed from `.returns()`
  return `Hello, ${name}!`
}
```

Finally, use the data client to invoke your Function by calling its associated query.

<InlineFilter filters={["angular", "javascript", "nextjs", "react", "react-native", "vue"]}>

```ts title="src/main.ts"
import type { Schema } from "./amplify/data/resource"
import { Amplify } from "aws-amplify"
import { generateClient } from "aws-amplify/api"
import outputs from "./amplify_outputs.json"

Amplify.configure(outputs)

const client = generateClient<Schema>()

// highlight-start
client.queries.sayHello({
  name: "Amplify",
})
// highlight-end
```

</InlineFilter>
<InlineFilter filters={["android"]}>

```kt
data class SayHelloDetails(
    val name: String,
)

data class SayHelloResponse(
    val sayHello: SayHelloDetails
)

val document = """
    query SayHelloQuery(${'$'}name: String!) {
        sayHello(name: ${'$'}name) {
            name
            executionDuration
        }
    }
""".trimIndent()
val sayHelloQuery = SimpleGraphQLRequest<String>(
    document,
    mapOf("name" to "Amplify"),
    String::class.java,
    GsonVariablesSerializer())

Amplify.API.query(
    sayHelloQuery,
    {
        var gson = Gson()
        val response = gson.fromJson(it.data, SayHelloResponse::class.java)
        Log.i("MyAmplifyApp", "${response.sayHello.name}")
    },
    { Log.e("MyAmplifyApp", "$it")}
)
```

</InlineFilter>
<InlineFilter filters={["flutter"]}>

First define a class that matches your response shape:

```dart
class SayHelloResponse {
  final SayHello sayHello;

  SayHelloResponse({required this.sayHello});

  factory SayHelloResponse.fromJson(Map<String, dynamic> json) {
    return SayHelloResponse(
      sayHello: SayHello.fromJson(json['sayHello']),
    );
  }
}

class SayHello {
  final String name;
  final double executionDuration;

  SayHello({required this.name, required this.executionDuration});

  factory SayHello.fromJson(Map<String, dynamic> json) {
    return SayHello(
      name: json['name'],
      executionDuration: json['executionDuration'],
    );
  }
}
```

Next, make the request and map the response to the classes defined above:

```dart
// highlight-next-line
import 'dart:convert';

// highlight-start
const graphQLDocument = '''
  query SayHello(\$name: String!) {
    sayHello(name: \$name) {
      name
      executionDuration
    }
  }
''';

final echoRequest = GraphQLRequest<String>(
  document: graphQLDocument,
  variables: <String, String>{"name": "Amplify"},
);

final response =
    await Amplify.API.query(request: echoRequest).response;
safePrint(response);

Map<String, dynamic> jsonMap = json.decode(response.data!);
SayHelloResponse SayHelloResponse = SayHelloResponse.fromJson(jsonMap);
safePrint(SayHelloResponse.sayHello.name);
// highlight-end
```

</InlineFilter>
<InlineFilter filters={["swift"]}>

```swift
struct SayHelloResponse: Codable {
    public let sayHello: SayHello
    
    struct SayHello: Codable {
        public let name: String
        public let executionDuration: Float
    }
}

let document = """
    query EchoQuery($name: String!) {
        sayHello(name: $name) {
            name
            executionDuration
        }
    }
    """

let result = try await Amplify.API.query(request: GraphQLRequest<SayHelloResponse>(
    document: document,
    variables: [
        "name": "Amplify"
    ],
    responseType: SayHelloResponse.self
))
switch result {
case .success(let response):
    print(response.sayHello)
case .failure(let error):
    print(error)
}
```

</InlineFilter>

## Next steps

Now that you have completed setting up your first Function, you may also want to add some additional features or modify a few settings. We recommend you learn more about:

- [Environment variables and secrets](/[platform]/build-a-backend/functions/environment-variables-and-secrets/)
- [Grant access to other resources](/[platform]/build-a-backend/functions/grant-access-to-other-resources/)
- [Explore example use cases](/[platform]/build-a-backend/functions/examples/)
- [Modifying underlying resources with CDK](/[platform]/build-a-backend/functions/modify-resources-with-cdk/)


Contents of build-a-backend_functions_streaming-logs_index.txt:
import { getCustomStaticPath } from '@/utils/getCustomStaticPath';

export const meta = {
  title: 'Streaming logs',
  description:
    'Stream execution logs directly to your terminal while Sandbox is running',
  platforms: [
    'android',
    'angular',
    'flutter',
    'javascript',
    'nextjs',
    'react',
    'react-native',
    'swift',
    'vue'
  ]
};

export function getStaticPaths() {
  return getCustomStaticPath(meta.platforms);
}

export function getStaticProps(context) {
  return {
    props: {
      platform: context.params.platform,
      meta
    }
  };
}

Amplify enables you to stream logs from your Function directly to your terminal while running [`ampx sandbox`](/[platform]/reference/cli-commands/#npx-ampx-sandbox). To get started, specify the `--stream-function-logs` option when starting sandbox:

```bash title="Terminal" showLineNumbers={false}
npx ampx sandbox --stream-function-logs
```

<Callout info>

**Note**: this feature is only available for [Sandbox](/[platform]/deploy-and-host/sandbox-environments/)

</Callout>

Streaming Function logs directly to your terminal enable faster debug iterations, and greater insight into your Functions' executions.

## Filtering

By default, Amplify will stream all of your Functions' logs. If you wish to only stream a subset of Functions you can specify a filter by Function name or a regular expression for Function names. For example, if you have a collection of [Auth triggers](/[platform]/build-a-backend/auth/customize-auth-lifecycle/triggers/) where the Function names include "auth"

```bash title="Terminal" showLineNumbers={false}
npx ampx sandbox --stream-function-logs --logs-filter auth
```

After you successfully deploy your personal cloud sandbox, start your frontend application, and sign up for the first time, you will see logs from your triggers' executions printed to the terminal where sandbox is running.

```console title="Terminal"
> npx ampx sandbox --stream-function-logs --logs-filter auth
...

✨  Total time: 158.44s

[Sandbox] Watching for file changes...
File written: amplify_outputs.json
[auth-pre-sign-up] 3:36:34 PM INIT_START Runtime Version: nodejs:18.v30	Runtime Version ARN: arn:aws:lambda:us-east-1::runtime:f89c264158db39a1cfcbb5f9b3741413df1cfce4d550c9a475a67d923e19e2f4
[auth-pre-sign-up] 3:36:34 PM START RequestId: 685be2bd-5df1-4dd5-9eb1-24f5f6337f91 Version: $LATEST
[auth-pre-sign-up] 3:36:34 PM END RequestId: 685be2bd-5df1-4dd5-9eb1-24f5f6337f91
[auth-pre-sign-up] 3:36:34 PM REPORT RequestId: 685be2bd-5df1-4dd5-9eb1-24f5f6337f91	Duration: 4.12 ms	Billed Duration: 5 ms	Memory Size: 512 MB	Max Memory Used: 67 MB	Init Duration: 173.67 ms
[auth-post-confirmation] 3:38:40 PM INIT_START Runtime Version: nodejs:18.v30	Runtime Version ARN: arn:aws:lambda:us-east-1::runtime:f89c264158db39a1cfcbb5f9b3741413df1cfce4d550c9a475a67d923e19e2f4
[auth-post-confirmation] 3:38:40 PM START RequestId: fce69b9f-b257-4af8-8a6e-821f84a39ce7 Version: $LATEST
[auth-post-confirmation] 3:38:41 PM 2024-07-19T22:38:41.209Z	fce69b9f-b257-4af8-8a6e-821f84a39ce7	INFO	processed 412f8911-acfa-41c7-9605-fa0c40891ea9
[auth-post-confirmation] 3:38:41 PM END RequestId: fce69b9f-b257-4af8-8a6e-821f84a39ce7
[auth-post-confirmation] 3:38:41 PM REPORT RequestId: fce69b9f-b257-4af8-8a6e-821f84a39ce7	Duration: 264.38 ms	Billed Duration: 265 ms	Memory Size: 512 MB	Max Memory Used: 93 MB	Init Duration: 562.19 ms
[auth-pre-authentication] 3:38:41 PM INIT_START Runtime Version: nodejs:18.v30	Runtime Version ARN: arn:aws:lambda:us-east-1::runtime:f89c264158db39a1cfcbb5f9b3741413df1cfce4d550c9a475a67d923e19e2f4
[auth-pre-authentication] 3:38:41 PM START RequestId: 9210ca3a-1351-4826-8544-123684765710 Version: $LATEST
[auth-pre-authentication] 3:38:41 PM END RequestId: 9210ca3a-1351-4826-8544-123684765710
[auth-pre-authentication] 3:38:41 PM REPORT RequestId: 9210ca3a-1351-4826-8544-123684765710	Duration: 3.47 ms	Billed Duration: 4 ms	Memory Size: 512 MB	Max Memory Used: 67 MB	Init Duration: 180.24 ms
[auth-post-authentication] 3:38:42 PM INIT_START Runtime Version: nodejs:18.v30	Runtime Version ARN: arn:aws:lambda:us-east-1::runtime:f89c264158db39a1cfcbb5f9b3741413df1cfce4d550c9a475a67d923e19e2f4
[auth-post-authentication] 3:38:42 PM START RequestId: 60c1d680-ea24-4a8b-93de-02d085859140 Version: $LATEST
[auth-post-authentication] 3:38:42 PM END RequestId: 60c1d680-ea24-4a8b-93de-02d085859140
[auth-post-authentication] 3:38:42 PM REPORT RequestId: 60c1d680-ea24-4a8b-93de-02d085859140	Duration: 4.61 ms	Billed Duration: 5 ms	Memory Size: 512 MB	Max Memory Used: 68 MB	Init Duration: 172.66 ms
```

## Writing to a file

By default, Amplify will print logs to the terminal where sandbox is running, however you can alternatively write logs to a file by specifying `--logs-out-file`:

```bash title="Terminal" showLineNumbers={false}
npx ampx sandbox --stream-function-logs --logs-out-file sandbox.log
```

This can be combined with `--logs-filter` to create a log file of just your Auth-related Functions, for example:

```bash title="Terminal" showLineNumbers={false}
npx ampx sandbox --stream-function-logs --logs-filter auth --logs-out-file sandbox-auth.log
```

However it cannot be combined multiple times to write logs to multiple files.


Contents of build-a-backend_index.txt:
import { getChildPageNodes } from '@/utils/getChildPageNodes';
import { getCustomStaticPath } from '@/utils/getCustomStaticPath';

export const meta = {
  title: 'Build & connect backend',
  description: 'Configure and customize authentication, data, storage, and functions to build a backend for your application.',
  route: '/[platform]/build-a-backend',
  platforms: [
    'android',
    'angular',
    'flutter',
    'javascript',
    'nextjs',
    'react',
    'react-native',
    'swift',
    'vue'
  ]
};

export const getStaticPaths = async () => {
  return getCustomStaticPath(meta.platforms);
};

export function getStaticProps(context) {
  const childPageNodes = getChildPageNodes(meta.route);
  return {
    props: {
      meta,
      childPageNodes
    }
  };
}

<Overview childPageNodes={props.childPageNodes} />


Contents of build-a-backend_q-developer_index.txt:
import { getCustomStaticPath } from "@/utils/getCustomStaticPath";

export const meta = {
  title: "Use Amazon Q Developer with Amplify",
  description:
    "Learn how to use Amazon Q Developer - inline code suggestions with Amplify",
  platforms: [
    "javascript",
    "react-native",
    "angular",
    "nextjs",
    "react",
    "vue",
  ],
};

export const getStaticPaths = async () => {
  return getCustomStaticPath(meta.platforms);
};

export function getStaticProps(context) {
  return {
    props: {
      platform: context.params.platform,
      meta,
    },
  };
}

[Amazon Q Developer](https://aws.amazon.com/q/developer/) is a generative artificial intelligence (AI) powered conversational assistant that can help you understand, build, extend, and operate AWS applications. You can ask questions about AWS architecture, your AWS resources, best practices, documentation, support, and more. Amazon Q is constantly updating its capabilities so your questions get the most contextually relevant and actionable answers. When used in an integrated development environment (IDE), Amazon Q provides software development assistance. Amazon Q can chat about code, provide inline code completions, generate net new code, scan your code for security vulnerabilities, and make code upgrades and improvements, such as language updates, debugging, and optimizations.

Q Developer in the IDE provides [inline code suggestions](https://docs.aws.amazon.com/amazonq/latest/qdeveloper-ug/inline-suggestions.html) in real time. As you write code, Amazon Q automatically generates suggestions based on your existing code and comments. When you start typing out single lines of code or comments, Amazon Q makes suggestions based on your current and previous inputs. Inline suggestions are automatically enabled when you download the Amazon Q extension.

## Setting up Q Developer

Amazon Q is available as an extension in Visual Studio Code and a plugin in JetBrains. Amazon Q is also available in the AWS Toolkit for Visual Studio. To get started, please visit [Install Amazon Q Developer](https://docs.aws.amazon.com/amazonq/latest/qdeveloper-ug/q-in-IDE-setup.html).

## Use Q Developer - Inline code suggestions in your Amplify project

Amplify generates two folders in your backend directory, `auth` and `data`, which contain TypeScript AWS CDK definitions for each of these resources. We’ll build out the schema for our API through the help of Amazon Q Developer's inline code suggestion capabilities.

**Step 1:** Open `amplify/data/resource.ts` and comment out the default schema for Todo provided.

```ts title="amplify/data/resource.ts"
import { type ClientSchema, a, defineData } from "@aws-amplify/backend";

// ...

// const schema = a.schema({
//   Todo: a
//     .model({
//       content: a.string(),
//     })
//     .authorization(allow => [allow.publicApiKey()]),
// });

// ...
```

**Step 2:** In a new line below the commented schema, enter a comment to generate the schema using natural language. For example, `generate a restaurant model with the following fields: id, name, description, address, image, rating, style. Rating can be a float value. Authorization should allow public.` Press `Enter` for a new line and wait for Amazon Q Developer to generate inline code suggestion for your schema.

```ts title="amplify/data/resource.ts"
import { type ClientSchema, a, defineData } from "@aws-amplify/backend";

// ...

// const schema = a.schema({
//   Todo: a
//     .model({
//       content: a.string(),
//     })
//     .authorization(allow => [allow.publicApiKey()]),
// });

// highlight-start
// generate a restaurant model with the following fields: id, name, description, address, image, rating, style. Rating can be a float value. Authorization should allow public.
// highlight-end

// ...
```

**Step 3:** Select the inline code suggestion generated by Amazon Q developer. The inline code suggestion feature assists you in defining the schema and hover over the output to select from other options.

<Video src="/images/gen2/q-developer/Amplify-Gen2-Q-Developer.mp4" description="Video - Q Developer" />

<Callout informational>

**Note:** You can also trigger inline code suggestion feature by invoking Amazon Q Developer manually using Option+C keyboard shortcut in VS Code. For more commands, please refer to the Commands tab in the Amazon Q extension.

</Callout>

**Step 4:** Make any required changes to the schema and save the `amplify/data/resource.ts` file. This will trigger a sandbox deployment and your new data model will be deployed

## Use Q Developer - workspace in your Amplify project


Adding `@workspace` to your question in Amazon Q automatically incorporates the most relevant parts of your workspace code as context, using an index that updates periodically. For more information on `@workspace` functionality, please visit [Amazon Q Developer - Workspace Context](https://docs.aws.amazon.com/amazonq/latest/qdeveloper-ug/workspace-context.html). 

The files below provide detailed guides that can be included as context with the `@workspace` command, enhancing Amazon Q's accuracy in generating AWS Amplify Gen 2 code.

Download the files and follow the steps below to use the `@workspace` in your Amplify project

- <a href="/images/gen2/q-developer/general.md" download>general.md</a>
- <a href="/images/gen2/q-developer/authentication.md" download>authentication.md</a>
- <a href="/images/gen2/q-developer/modeling-relationships.md" download>modeling-relationships.md</a>
- <a href="/images/gen2/q-developer/modeling-schema.md" download>modeling-schema.md</a>


**Step 1:** Create a folder in the root of your project and give a descriptive name such as `context`. Add the files downloaded above to this folder.

**Step 2:** Open Amazon Q Developer Chat in your IDE and type `@workspace` to enable workspace indexing. Follow Amazon Q's prompts to set up indexing for your project directory.

**Step 3:** After successful indexing, reference the markdown file content in your queries to Amazon Q. Examples:

```bash title="Terminal" 

@workspace follow AMPLIFYRULES to develop a data model schema for a freelance marketplace using Amplify Gen 2. Include models for freelancers, clients, projects, bids, and reviews. Use Amplify Gen 2 to fetch a list of projects

```

```bash title="Terminal" 

@workspace follow AMPLIFYRULES to design a data schema for an event management application using Amplify Gen 2. Include models for users, events, and tickets. Show me how to use Amplify Gen 2 to fetch a list of events.

```


Contents of build-a-backend_server-side-rendering_index.txt:
import { getCustomStaticPath } from '@/utils/getCustomStaticPath';

export const meta = {
  title: 'Server-Side Rendering',
  description: 'Use Amplify Auth and Data APIs from Next.js server-side runtimes.',
  platforms: [
    'angular',
    'javascript',
    'nextjs',
    'react',
    'react-native',
    'vue'
  ]
};

export const getStaticPaths = async () => {
  return getCustomStaticPath(meta.platforms);
};

export function getStaticProps(context) {
  return {
    props: {
      platform: context.params.platform,
      meta
    }
  };
}

This guide walks through how to use Amplify Auth and Data APIs from Next.js server-side runtimes.

<InlineFilter filters={["nextjs", "javascript"]}>

Before you begin:

- [Follow the Next.js App Router tutorial](/[platform]/build-a-backend/server-side-rendering/nextjs-app-router-server-components)

</InlineFilter>

## Install the Amplify Next.js adapter

To use Amplify APIs server-side, you need to install the Amplify Next.js adapter in addition to the Amplify libraries:

```bash title="Terminal" showLineNumbers={false}
npm add aws-amplify @aws-amplify/adapter-nextjs
```

## Configure Amplify APIs for server-side usage

You will need to create a `runWithAmplifyServerContextRunner` function to use Amplify APIs on the server-side of your Next.js app.

You can create an `amplifyServerUtils.ts` file under a `utils` folder in your codebase. In this file, you will import the Amplify backend outputs from the `amplify_outputs.json` file that is generated by the Amplify CLI, and use the `createServerRunner` function to create the `runWithAmplifyServerContextRunner` function.

For example, the `utils/amplifyServerUtils.ts` file may contain the following content:

```typescript
import { createServerRunner } from '@aws-amplify/adapter-nextjs';
import outputs from '@/amplify_outputs.json';

export const { runWithAmplifyServerContext } = createServerRunner({
  config: outputs
});
```

You can use the exported `runWithAmplifyServerContext` function to call Amplify APIs within isolated request contexts. You can review examples under the [Calling Amplify category APIs on the server side](#calling-amplify-category-apis-on-the-server-side) section.

<Callout>
**TIP:** You only need to call the `createServerRunner` function once and reuse the `runWithAmplifyServerContext` function throughout.
</Callout>

## Configure Amplify library for client-side usage

When you use the Amplify library on the client-side of your Next.js app, you will need to configure Amplify by calling the `Amplify.configure` as you would to use Amplify in a single-page application.

<Callout>

**NOTE:** To use the Amplify library on the client side in a Next.js app, you will need to set `ssr` to `true` when calling `Amplify.configure`. This instructs the Amplify library to store tokens in the cookie store of a browser. Cookies will be sent along with requests to your Next.js server for authentication.

</Callout>

```typescript
'use client';

import outputs from '@/amplify_outputs.json';
import { Amplify } from 'aws-amplify';

Amplify.configure(outputs, {
  ssr: true // required when using Amplify with Next.js
});

export default function RootLayoutThatConfiguresAmplifyOnTheClient({
  children
}: {
  children: React.ReactNode;
}) {
  return children;
}
```

<Callout>

To avoid repetitive calls to `Amplify.configure`, you can call it once in a top-level client-side rendered layout component.

</Callout>

<Accordion title='Configure Amplify in a Next.js App Router application' headingLevel='4' eyebrow='Learn more'>

If you're using the Next.js App Router, you can create a client component to configure Amplify and import it into your root layout.

`ConfigureAmplifyClientSide.ts`:

```typescript
'use client';

import { Amplify } from 'aws-amplify';
import outputs from '../amplify_outputs.json';

Amplify.configure(outputs, { ssr: true });

export default function ConfigureAmplifyClientSide() {
  return null;
}
```

`layout.tsx`:

```jsx
import ConfigureAmplifyClientSide from '@/components/ConfigureAmplifyClientSide';
import './globals.css';

import type { Metadata } from 'next';

export const metadata: Metadata = {
  title: 'Create Next App',
  description: 'Generated by create next app',
};

export default function RootLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  return (
    <html lang="en">
      <body className="container pb-6">
        <>
          <ConfigureAmplifyClientSide />
          {children}
        </>
      </body>
    </html>
  );
}
```

</Accordion>

## Authentication with Next.js server-side runtime

You can use the Amplify Auth category APIs to sign up and sign in your end users on the client side. When you set `ssr: true` when calling `Amplify.configure`, the Amplify library uses cookies to store tokens which will be sent along with HTTP requests to your Next.js app server.

### Manage Auth session with the Next.js Middleware

You can use the `fetchAuthSession` API to check the auth sessions that are attached to the incoming requests in the middleware of your Next.js app to protect your routes. For example:

```typescript
import { fetchAuthSession } from 'aws-amplify/auth/server';
import { NextRequest, NextResponse } from 'next/server';
import { runWithAmplifyServerContext } from '@/utils/amplifyServerUtils';

export async function middleware(request: NextRequest) {
  const response = NextResponse.next();

  const authenticated = await runWithAmplifyServerContext({
    nextServerContext: { request, response },
    operation: async (contextSpec) => {
      try {
        const session = await fetchAuthSession(contextSpec);
        return (
          session.tokens?.accessToken !== undefined &&
          session.tokens?.idToken !== undefined
        );
      } catch (error) {
        console.log(error);
        return false;
      }
    }
  });

  if (authenticated) {
    return response;
  }

  return NextResponse.redirect(new URL('/sign-in', request.url));
}

export const config = {
  matcher: [
    /*
     * Match all request paths except for the ones starting with:
     * - api (API routes)
     * - _next/static (static files)
     * - _next/image (image optimization files)
     * - favicon.ico (favicon file)
     */
    '/((?!api|_next/static|_next/image|favicon.ico|sign-in).*)'
  ]
};
```

In this example, if the incoming request is not associated with a valid user session the request will be redirected to the `/sign-in` route.

<Callout>

**NOTE:** When calling `fetchAuthSession` with a `response` context, it will send the refreshed tokens (if any) back to the client via the `Set-Cookie` header in the response.

</Callout>

## Calling Amplify category APIs on the server side

For the **Auth** categories to use Amplify APIs on the server in your Next.js app, you will need to:

1. Import the API from the `/server` sub path.
2. Use the `runWithAmplifyServerContext` helper function created by calling the `createServerRunner` function exported from `@aws-amplify/adapter-nextjs` to call the Amplify API in an isolated server context.

For the **GraphQL API** category, review [Connect to data from Server-side Runtimes](/[platform]/build-a-backend/data/connect-from-server-runtime/).

<Callout>

**NOTE:** A subset of Amplify APIs can now be called on the server side of a Next.js app. These APIs are exported from the `/server` sub paths. See [the full list](#supported-apis-for-nextjs-server-side-usage) of supported APIs.

</Callout>

<Callout>

**Note:** If you use the Amplify server-side APIs in a [server action](https://nextjs.org/docs/app/building-your-application/data-fetching/server-actions-and-mutations) and encounter the following error running `next build`:

> ./node_modules/@aws-amplify/core/node_modules/@aws-crypto/sha256-js/build/module/index.js + 12 modules

> Cannot get final name for export 'fromUtf8' of ./node_modules/@smithy/util-utf8/dist-es/index.js

You can add the following to your `next.config.js`:

```ts title="next.config.js"
/** @type {import('next').NextConfig} */
const nextConfig = {
  // highlight-start
    serverComponentsPackages: ['@aws-crypto'],
  // highlight-end
};
```

See Next.js documentation on [`serverComponentsPackages`](https://nextjs.org/docs/app/api-reference/config/next-config-js/serverExternalPackages) for more details.
</Callout>

### With Next.js App Router

#### Dynamic rendering in React server component

Dynamic rendering is based on a user session extracted from an incoming request.

```jsx
import { cookies } from 'next/headers';
import { getCurrentUser } from 'aws-amplify/auth/server';
import { runWithAmplifyServerContext } from '@/utils/amplifyServerUtils';

// This page always dynamically renders per request
export const dynamic = 'force-dynamic';

export default async function AuthGetCurrentUserServer() {
  try {
    const currentUser = await runWithAmplifyServerContext({
      nextServerContext: { cookies },
      operation: (contextSpec) => getCurrentUser(contextSpec)
    });

    return (
      <AuthFetchResult
        description="The API is called on the server side."
        data={currentUser}
      />
    );
  } catch (error) {
    console.error(error);
    return <p>Something went wrong...</p>;
  }
}
```

#### Static rendering in React server component

Static rendering does not require a user session, so you can specify the `nextServerContext` parameter as `null`. This is useful for some use cases; for example, when you are using the Storage API with guest access (if you have enabled it in your backend).

```jsx
import { getUrl } from 'aws-amplify/storage/server';
import Image from 'next/image';
import { runWithAmplifyServerContext } from '@/utils/amplifyServerUtils';

// Re-render this page every 60 minutes
export const revalidate = 60 * 60; // in seconds

export default async function StaticallyRenderedPage() {
  try {
    const splashUrl = await runWithAmplifyServerContext({
      nextServerContext: null,
      operation: (contextSpec) =>
        getUrl(contextSpec, {
          key: 'splash.png'
        })
    });

    return (
      <Image
        src={splashUrl.url.toString()}
        alt="Splash Image"
        width={500}
        height={500}
      />
    );
  } catch (error) {
    console.error(error);
    return <p>Something went wrong...</p>;
  }
}
```

<Callout>

**NOTE:** The URL returned by the `getUrl` API expires in the above example. You may want to specify the `revalidate` parameter to rerender the page as required to ensure the URL gets regenerated.

</Callout>

#### In Route Handlers

In route handlers require implementing an API route that enables `GET /apis/get-current-user`.

```typescript
import { getCurrentUser } from 'aws-amplify/auth/server';
import { cookies } from 'next/headers';
import { NextResponse } from 'next/server';
import { runWithAmplifyServerContext } from '@/utils/amplifyServerUtils';

export async function GET() {
  const user = await runWithAmplifyServerContext({
    nextServerContext: { cookies },
    operation: (contextSpec) => getCurrentUser(contextSpec)
  });

  return NextResponse.json({ user });
}
```

When you call `fetch('/apis/get-current-user')` it returns a payload that contains the `user` data for the current signed-in user.

### With Next.js Pages Router

#### In `getServerSideProps`

The following example extracts current user data from the request and provides them to a page react component via its props.

```typescript
export const getServerSideProps: GetServerSideProps = async ({ req, res }) => {
  const currentUser = await runWithAmplifyServerContext({
    nextServerContext: { request: req, response: res },
    operation: (contextSpec) => getCurrentUser(contextSpec)
  });

  return { props: { currentUser } };
};
```

#### In `getStaticProps`

Similar to static rendering with the App Router, you can pass `null` as the value of the `nextServerContext` parameter to use the Amplify Storage API with guest access.

```typescript
export async function getStaticProps() {
  const splashUrl = await runWithAmplifyServerContext({
    nextServerContext: null,
    operation: (contextSpec) => getUrl(contextSpec, { key: 'splash.png' })
  });

  return {
    props: { imageUrl: splashUrl.url.toString() },
    revalidate: (splashUrl.expiresAt.getTime() - Date.now()) / 1000 // in seconds
  };
}
```

## Supported APIs for Next.js server-side usage

All APIs that support use on the server are exported from the `aws-amplify/<category>/server` sub paths. You **must** use these APIs for any server-side use cases.

| Category | APIs | Server (Node.js) Amplify Hosting/Vercel | Vercel Edge Runtime (middleware) |
| --- | --- | --- | --- |
| Auth | `fetchAuthSession` | ✅ | ✅ |
| Auth | `fetchUserAttributes` | ✅ | ✅ |
| Auth | `getCurrentUser` | ✅ | ✅ |
| Data | `generateServerClientUsingCookies` | ✅ |  |
| Data | `generateServerClientUsingReqRes` | ✅ |  |
| Storage | `getUrl` | ✅ |  |
| Storage | `getProperties` | ✅ |  |
| Storage | `list` | ✅ |  |
| Storage | `remove` | ✅ |  |
| Storage | `copy` | ✅ |  |

<Callout info>

Have a server-side use case that isn't currently supported in Amplify JS? Consider using the [AWS SDK for JavaScript](https://aws.amazon.com/sdk-for-javascript/).

</Callout>


Contents of build-a-backend_server-side-rendering_nextjs-app-router-server-components_index.txt:
import { getCustomStaticPath } from '@/utils/getCustomStaticPath';

export const meta = {
  title: 'Next.js App Router (Server Components)',
  description: 'Get started with AWS Amplify Gen 2 using the Next.js App Router using Server Components.',
  platforms: [
    'javascript',
    'nextjs'
  ]
};

export const getStaticPaths = async () => {
  return getCustomStaticPath(meta.platforms);
};

export function getStaticProps(context) {
  return {
    props: {
      platform: context.params.platform,
      meta
    }
  };
}

This Quickstart guide will walk you through how to build a task list application with TypeScript, Next.js **App Router with Server Components**, and React. If you are new to these technologies, we recommend you go through the official [React](https://react.dev/learn/tutorial-tic-tac-toe), [Next.js](https://nextjs.org/docs/app/getting-started), and [TypeScript](https://www.typescriptlang.org/docs/handbook/typescript-from-scratch.html) tutorials first.

import prerequisites from 'src/fragments/gen2/quickstart/prerequisites.mdx';

<Fragments fragments={{ javascript: prerequisites, nextjs: prerequisites }} />

import createProject from 'src/fragments/gen2/quickstart/create-nextjs-app-router-project.mdx';

<Fragments fragments={{ javascript: createProject, nextjs: createProject }} />

import createAmplify from 'src/fragments/gen2/quickstart/create-amplify.mdx';

<Fragments fragments={{ javascript: createAmplify, nextjs: createAmplify}} />

import buildABackend from 'src/fragments/gen2/quickstart/build-a-backend.mdx';

<Fragments fragments={{ javascript: buildABackend, nextjs: buildABackend }} />


## Build UI

Let's add UI that connects to the backend data and auth resources.


### Configure Amplify Client Side

First, install the Amplify UI component library:

```bash showLineNumbers={false}
npm add @aws-amplify/ui-react
```

Next, create a `components` folder in the root of your project and copy the contents below to a file called `ConfigureAmplify.tsx`.

```ts title="components/ConfigureAmplify.tsx"
// components/ConfigureAmplify.tsx
"use client";

import { Amplify } from "aws-amplify";

import outputs from "@/amplify_outputs.json";

Amplify.configure(outputs, { ssr: true });

export default function ConfigureAmplifyClientSide() {
  return null;
}
```

Update `app/layout.tsx` to import and render `<ConfigureAmplifyClientSide />`. This client component will configure Amplify for client pages in our application.

```ts title="app/layout.tsx"
// app/layout.tsx
import "@aws-amplify/ui-react/styles.css";
import type { Metadata } from "next";
import { Inter } from "next/font/google";
import "./globals.css";

import ConfigureAmplifyClientSide from "@/components/ConfigureAmplify";

const inter = Inter({ subsets: ["latin"] });

export const metadata: Metadata = {
  title: "Create Next App",
  description: "Generated by create next app",
};

export default function RootLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  return (
    <html lang="en">
      <body className={inter.className}>
        <ConfigureAmplifyClientSide />
        {children}
      </body>
    </html>
  );
}
```

### Configure Amplify Server Side

First, install the Amplify Next.js adapter:

```bash showLineNumbers={false}
npm add @aws-amplify/adapter-nextjs
```

Next, create a `utils/amplify-utils.ts` file from the root of the project and paste the code below.  `runWithAmplifyServerContext`,  `cookiesClient`, and `AuthGetCurrentUserServer` are declared here and will be used to gain access to Amplify assets from the server.

```ts title="utils/amplify-utils.ts"
// utils/amplify-utils.ts
import { cookies } from "next/headers";

import { createServerRunner } from "@aws-amplify/adapter-nextjs";
import { generateServerClientUsingCookies } from "@aws-amplify/adapter-nextjs/api";
import { getCurrentUser } from "aws-amplify/auth/server";

import { type Schema } from "@/amplify/data/resource";
import outputs from "@/amplify_outputs.json";

export const { runWithAmplifyServerContext } = createServerRunner({
  config: outputs,
});

export const cookiesClient = generateServerClientUsingCookies<Schema>({
  config: outputs,
  cookies,
});

export async function AuthGetCurrentUserServer() {
  try {
    const currentUser = await runWithAmplifyServerContext({
      nextServerContext: { cookies },
      operation: (contextSpec) => getCurrentUser(contextSpec),
    });
    return currentUser;
  } catch (error) {
    console.error(error);
  }
}
```


### Add server authentication routes

First, create a client-side `Login` component in the `components` folder that will be wrapped in `withAuthenticator`. If the user is logged in, they will be redirected to the index route; otherwise, the [Amplify UI Authenticator component](https://ui.docs.amplify.aws/react/connected-components/authenticator) will be rendered.

```ts title="components/Login.tsx"
// components/Login.tsx
"use client";

import { withAuthenticator } from "@aws-amplify/ui-react";
import { AuthUser } from "aws-amplify/auth";
import { redirect } from "next/navigation";
import { useEffect } from "react";

function Login({ user }: { user?: AuthUser }) {
  useEffect(() => {
    if (user) {
      redirect("/");
    }
  }, [user]);
  return null;
}

export default withAuthenticator(Login);
```

Next, create a new route under `app/login/page.tsx` to render the `Login` component.

```ts title="app/login/page.tsx"
// app/login/page.tsx

import Login from "@/components/Login";

export default function LoginPage() {
  return <Login />;
}
```

<Accordion title="Custom <Authenticator> example">

Some applications require more customization for the `<Authenticator>` component. The following example shows how to add a custom Header to the `<Authenticator>`. For this use, you will not need the `Login` file in the `components` folder, but can do everything through the `page` file in the `app/login/` folder. For more customization options, see [Authenticator Customization](https://ui.docs.amplify.aws/react/connected-components/authenticator/customization).

```ts title="app/login/page.tsx"
// app/login/page.tsx - Custom <Authenticator>

"use client";

import {
  Authenticator,
  Text,
  View,
  useAuthenticator,
} from "@aws-amplify/ui-react";
import { redirect } from "next/navigation";
import { useEffect } from "react";

const components = {
  Header() {
    return (
      <View textAlign="center">
        <Text><span style={{color: "white"}}>Authenticator Header</span></Text>
      </View>
    );
  },
};

function CustomAuthenticator() {
  const { user } = useAuthenticator((context) => [context.user]);

  useEffect(() => {
    if (user) {
      redirect("/");
    }
  }, [user]);

  return <Authenticator components={components} />;
}

export default function Login() {
  return (
    <Authenticator.Provider>
      <CustomAuthenticator />
    </Authenticator.Provider>
  );
}

```

</Accordion>


Finally, create a `Logout` component to be used later.

```ts title="components/Logout.tsx"
// components/Logout.tsx

"use client";

import { signOut } from "aws-amplify/auth";
import { useRouter } from "next/navigation";

export default function Logout() {
  const router = useRouter();

  return (
    <button
      onClick={async () => {
        await signOut();
        router.push("/login");
      }}
      className="px-2 bg-white text-black"
    >
      Sign out
    </button>
  );
}
```

<Callout info>

**Note**: If using [Amplify UI Social Providers](https://ui.docs.amplify.aws/react/connected-components/authenticator/configuration#social-providers), set the `callbackUrls` for the `/login` route when [configuring social sign-in for your Gen 2 backend](https://docs.amplify.aws/gen2/build-a-backend/auth/add-social-provider/#configure-social-sign-in-backend), as shown below.

```ts title="amplify/auth/resource.ts"
import { defineAuth, secret } from '@aws-amplify/backend';

export const auth = defineAuth({
  loginWith: {
    externalProviders: {
      // ...
      callbackUrls: [
        'http://localhost:3000/login',
        'https://mywebsite.com/login'
      ],
      logoutUrls: ['http://localhost:3000/logout', 'https://mywebsite.com/logout']
    }
  }
});
```

</Callout>

### Add middleware for server-side redirect

Create `middleware.ts` in the root of the project with the contents below.

This middleware runs `fetchAuthSession` wrapped in `runWithAmplifyServerContext` and will redirect to `/login` when a user is not logged in.


```ts title="middleware.ts"
// middleware.ts
import { NextRequest, NextResponse } from "next/server";

import { fetchAuthSession } from "aws-amplify/auth/server";

import { runWithAmplifyServerContext } from "@/utils/amplify-utils";

export async function middleware(request: NextRequest) {
  const response = NextResponse.next();

  const authenticated = await runWithAmplifyServerContext({
    nextServerContext: { request, response },
    operation: async (contextSpec) => {
      try {
        const session = await fetchAuthSession(contextSpec, {});
        return session.tokens !== undefined;
      } catch (error) {
        console.log(error);
        return false;
      }
    },
  });

  if (authenticated) {
    return response;
  }

  return NextResponse.redirect(new URL("/login", request.url));
}

export const config = {
  matcher: [
    /*
     * Match all request paths except for the ones starting with:
     * - api (API routes)
     * - _next/static (static files)
     * - _next/image (image optimization files)
     * - favicon.ico (favicon file)
     * - login
     */
    "/((?!api|_next/static|_next/image|favicon.ico|login).*)",
  ],
};
```

Run your application with `npm run dev` and navigate to `http://localhost:3000`. You should now see the authenticator, which is already configured and ready for your first sign-up! Create a new user account, confirm the account through email, and then sign in.

### View list of to-do items

Now, let's display data on our app's frontend.

The code below uses the `cookiesClient` to provide access to the `Todo` model defined in the backend.

Modify your app's home page file, `app/page.tsx`, with the following code:

```ts title="app/page.tsx"
// app/page.tsx

import { cookiesClient } from "@/utils/amplify-utils";

async function App() {
  const { data: todos } = await cookiesClient.models.Todo.list();

  return (
    <>
      <h1>Hello, Amplify 👋</h1>
      <ul>
        {todos && todos.map((todo) => <li key={todo.id}>{todo.content}</li>)}
      </ul>
    </>
  );
}

export default App;
```

Once you save the file and navigate back to `http://localhost:3000`, you should see "Hello, Amplify" with a blank page for now because you have only an empty list of to-dos.

### Create a new to-do item

Let's update the component to have a form for prompting the user for the title for creating a new to-do list item and run the `addTodo` method on form submission. In a production app, the additional fields of the `Todo` model would be added to the form.

After creating a to-do, `revalidatePath` is run to clear the Next.js cache for this route to instantly update the results from the server without a full page reload.

```ts title="app/page.tsx"
// app/page.tsx

import { revalidatePath } from "next/cache";

import { AuthGetCurrentUserServer, cookiesClient } from "@/utils/amplify-utils";

import Logout from "@/components/Logout";

async function App() {
  const user = await AuthGetCurrentUserServer();
  const { data: todos } = await cookiesClient.models.Todo.list();

  async function addTodo(data: FormData) {
    "use server";
    const title = data.get("title") as string;
    await cookiesClient.models.Todo.create({
      content: title,
      done: false,
      priority: "medium",
    });
    revalidatePath("/");
  }

  return (
    <>
      <h1>Hello, Amplify 👋</h1>
      {user && <Logout />}
      <form action={addTodo}>
        <input type="text" name="title" />
        <button type="submit">Add Todo</button>
      </form>

      <ul>
        {todos && todos.map((todo) => <li key={todo.id}>{todo.content}</li>)}
      </ul>
    </>
  );
}

export default App;
```

### Terminate dev server

Go to `localhost` in the browser to make sure you can now log in and create and list to-dos. You can end your development session by shutting down the frontend dev server and cloud sandbox. The sandbox prompts you to delete your backend resources. While you can retain your backend, we recommend deleting all resources so you can start clean again next time.

import deployAndHost from 'src/fragments/gen2/quickstart/deploy-and-host.mdx';

<Fragments fragments={{ javascript: deployAndHost, nextjs: deployAndHost }} />


Contents of build-a-backend_server-side-rendering_nuxt_index.txt:
import { getCustomStaticPath } from '@/utils/getCustomStaticPath';
import { getChildPageNodes } from '@/utils/getChildPageNodes';

export const meta = {
  title: 'Use Amplify categories APIs from Nuxt 3',
  description: 'Use Amplify categories APIs from Nuxt 3',
  platforms: [
    'javascript',
    'vue'
  ],
};

export const getStaticPaths = async () => {
  return getCustomStaticPath(meta.platforms);
};

export function getStaticProps(context) {
  const childPageNodes = getChildPageNodes(meta.route);
  return {
    props: {
      platform: context.params.platform,
      meta,
      childPageNodes
    }
  };
}

If you have not already done so, please read the introduction documentation, [Use Amplify Categories APIs in Server-Side Rendering](/gen1/[platform]/build-a-backend/server-side-rendering/), to learn about how to use Amplify categories' APIs in server-side rendering.

This documentation provides a getting started guide to using the generic `runWithAmplifyServerContext` adapter (exported from `aws-amplify/adapter-core`) to enable Amplify in a Nuxt 3 project. The examples in this documentation may not present best practices for your Nuxt project. You are welcome to provide suggestions and contributions to improve this documentation or to create a Nuxt adapter package for Amplify and let others use it.

<Callout>

**Note:** This guide assumes that you have deep knowledge of Nuxt 3.

</Callout>

## Start using Amplify in your Nuxt 3 project

You can install relevant Amplify libraries by following the [manual installation](/[platform]/start/manual-installation/) guide.

## Set up the AmplifyAPIs plugin

Nuxt 3 offers universal rendering by default, where your data fetching logic may be executed in both client and server runtimes. Amplify offers APIs that are capable of running within a server context to support use cases such as server-side rendering (SSR) and static site generation (SSG), though Amplify's client-side APIs and server-side APIs are slightly different. You can set up an `AmplifyAPIs` plugin to make your data fetching logic run smoothly across the client and server.

1. If you haven’t already done so, create a `plugins` directory under the root of your Nuxt project
2. Create two files `01.amplifyApis.client.ts` and `01.amplifyApis.server.ts` under the `plugins` directory

<Callout>

**Note:** the leading number in the filenames indicates the plugin loading order, details see https://nuxt.com/docs/guide/directory-structure/plugins#registration-order. The `.client` and `.server` indicate the runtime that the logic contained in the file will run on, client or server. For details see: https://nuxt.com/docs/guide/directory-structure/plugins

</Callout>

In these files, you will register both client-specific and server-specific Amplify APIs that you will use in your Nuxt project as a plugin. You can then access these APIs via the `useNuxtApp` composable.

### Implement `01.amplifyApis.client.ts`

Example implementation:

```ts title="plugins/01.amplifyApis.client.ts"
import type { Schema } from '~/amplify/data/resource';
import { Amplify } from 'aws-amplify';
import {
  fetchAuthSession,
  fetchUserAttributes,
  signIn,
  signOut
} from 'aws-amplify/auth';
import { list } from 'aws-amplify/storage';
import { generateClient } from 'aws-amplify/api';
import outputs from '../amplify_outputs.json';

const client = generateClient<Schema>();

export default defineNuxtPlugin({
  name: 'AmplifyAPIs',
  enforce: 'pre',

  setup() {
    // This configures Amplify on the client side of your Nuxt app
    Amplify.configure(config, { ssr: true });

    return {
      provide: {
        // You can add the Amplify APIs that you will use on the client side
        // of your Nuxt app here.
        //
        // You can call the API by via the composable `useNuxtApp()`. For example:
        // `useNuxtApp().$Amplify.Auth.fetchAuthSession()`
        Amplify: {
          Auth: {
            fetchAuthSession,
            fetchUserAttributes,
            signIn,
            signOut
          },
          Storage: {
            list
          },
          GraphQL: {
            client
          }
        }
      }
    };
  }
});
```

<Callout warning="true">

Make sure you call `Amplify.configure` as early as possible in your application’s lifecycle. A missing configuration or `NoCredentials` error is thrown if `Amplify.configure` has not been called before other Amplify JavaScript APIs. Review the [Library Not Configured Troubleshooting guide](/gen1/[platform]/build-a-backend/troubleshooting/library-not-configured/) for possible causes of this issue.

</Callout>

### Implement `01.amplifyApis.server.ts`

Example implementation:

```ts title="plugins/01.amplifyApis.server.ts"
import type { CookieRef } from 'nuxt/app';
import type { Schema } from '~/amplify/data/resource';
import type { ListPaginateWithPathInput } from 'aws-amplify/storage';
import type {
  LibraryOptions,
  FetchAuthSessionOptions
} from '@aws-amplify/core';
import {
  createKeyValueStorageFromCookieStorageAdapter,
  createUserPoolsTokenProvider,
  createAWSCredentialsAndIdentityIdProvider,
  runWithAmplifyServerContext
} from 'aws-amplify/adapter-core';
import { parseAmplifyConfig } from 'aws-amplify/utils';
import {
  fetchAuthSession,
  fetchUserAttributes,
  getCurrentUser
} from 'aws-amplify/auth/server';
import { list } from 'aws-amplify/storage/server';
import { generateClient } from 'aws-amplify/api/server';

import outputs from '../amplify_outputs.json';

// parse the content of `amplify_outputs.json` into the shape of ResourceConfig
const amplifyConfig = parseAmplifyConfig(outputs);

// create the Amplify used token cookies names array
const userPoolClientId = amplifyConfig.Auth!.Cognito.userPoolClientId;
const lastAuthUserCookieName = `CognitoIdentityServiceProvider.${userPoolClientId}.LastAuthUser`;

// create a GraphQL client that can be used in a server context
const gqlServerClient = generateClient<Schema>({ config: amplifyConfig });

// extract the model operation function types for creating wrapper function later
type RemoveFirstParam<Params extends any[]> = Params extends [infer _, ...infer Rest] ? Rest : never; 
type TodoListInput = RemoveFirstParam<Parameters<typeof gqlServerClient.models.Todo.list>>;
type TodoCreateInput = RemoveFirstParam<Parameters<typeof gqlServerClient.models.Todo.create>>;
type TodoUpdateInput = RemoveFirstParam<Parameters<typeof gqlServerClient.models.Todo.update>>;

const getAmplifyAuthKeys = (lastAuthUser: string) =>
  ['idToken', 'accessToken', 'refreshToken', 'clockDrift']
    .map(
      (key) =>
        `CognitoIdentityServiceProvider.${userPoolClientId}.${lastAuthUser}.${key}`
    )
    .concat(lastAuthUserCookieName);

// define the plugin
export default defineNuxtPlugin({
  name: 'AmplifyAPIs',
  enforce: 'pre',
  setup() {
    // The Nuxt composable `useCookie` is capable of sending cookies to the
    // client via the `SetCookie` header. If the `expires` option is left empty,
    // it sets a cookie as a session cookie. If you need to persist the cookie
    // on the client side after your end user closes your Web app, you need to
    // specify an `expires` value.
    //
    // We use 30 days here as an example (the default Cognito refreshToken
    // expiration time).
    const expires = new Date();
    expires.setDate(expires.getDate() + 30);

    // Get the last auth user cookie value
    //
    // We use `sameSite: 'lax'` in this example, which allows the cookie to be
    // sent to your Nuxt server when your end user gets redirected to your Web
    // app from a different domain. You should choose an appropriate value for
    // your own use cases.
    const lastAuthUserCookie = useCookie(lastAuthUserCookieName, {
      sameSite: 'lax',
      expires,
      secure: true
    });

    // Get all Amplify auth token cookie names
    const authKeys = lastAuthUserCookie.value
      ? getAmplifyAuthKeys(lastAuthUserCookie.value)
      : [];

    // Create a key-value map of cookie name => cookie ref
    //
    // Using the composable `useCookie` here in the plugin setup prevents
    // cross-request pollution.
    const amplifyCookies = authKeys
      .map((name) => ({
        name,
        cookieRef: useCookie(name, { sameSite: 'lax', expires, secure: true })
      }))
      .reduce<Record<string, CookieRef<string | null | undefined>>>(
        (result, current) => ({
          ...result,
          [current.name]: current.cookieRef
        }),
        {}
      );

    // Create a key value storage based on the cookies
    //
    // This key value storage is responsible for providing Amplify Auth tokens to
    // the APIs that you are calling.
    //
    // If you implement the `set` method, when Amplify needed to refresh the Auth
    // tokens on the server side, the new tokens would be sent back to the client
    // side via `SetCookie` header in the response. Otherwise the refresh tokens
    // would not be propagate to the client side, and Amplify would refresh
    // the tokens when needed on the client side.
    //
    // In addition, if you decide not to implement the `set` method, you don't
    // need to pass any `CookieOptions` to the `useCookie` composable.
    const keyValueStorage = createKeyValueStorageFromCookieStorageAdapter({
      get(name) {
        const cookieRef = amplifyCookies[name];

        if (cookieRef && cookieRef.value) {
          return { name, value: cookieRef.value };
        }

        return undefined;
      },
      getAll() {
        return Object.entries(amplifyCookies).map(([name, cookieRef]) => {
          return { name, value: cookieRef.value ?? undefined };
        });
      },
      set(name, value) {
        const cookieRef = amplifyCookies[name];
        if (cookieRef) {
          cookieRef.value = value;
        }
      },
      delete(name) {
        const cookieRef = amplifyCookies[name];

        if (cookieRef) {
          cookieRef.value = null;
        }
      }
    });

    // Create a token provider
    const tokenProvider = createUserPoolsTokenProvider(
      amplifyConfig.Auth!,
      keyValueStorage
    );

    // Create a credentials provider
    const credentialsProvider = createAWSCredentialsAndIdentityIdProvider(
      amplifyConfig.Auth!,
      keyValueStorage
    );

    // Create the libraryOptions object
    const libraryOptions: LibraryOptions = {
      Auth: {
        tokenProvider,
        credentialsProvider
      }
    };

    return {
      provide: {
        // You can add the Amplify APIs that you will use on the server side of
        // your Nuxt app here. You must only use the APIs exported from the
        // `aws-amplify/<category>/server` subpaths.
        //
        // You can call the API by via the composable `useNuxtApp()`. For example:
        // `useNuxtApp().$Amplify.Auth.fetchAuthSession()`
        //
        // Recall that Amplify server APIs are required to be called in a isolated
        // server context that is created by the `runWithAmplifyServerContext`
        // function.
        Amplify: {
          Auth: {
            fetchAuthSession: (options: FetchAuthSessionOptions) =>
              runWithAmplifyServerContext(
                amplifyConfig,
                libraryOptions,
                (contextSpec) => fetchAuthSession(contextSpec, options)
              ),
            fetchUserAttributes: () =>
              runWithAmplifyServerContext(
                amplifyConfig,
                libraryOptions,
                (contextSpec) => fetchUserAttributes(contextSpec)
              ),
            getCurrentUser: () =>
              runWithAmplifyServerContext(
                amplifyConfig,
                libraryOptions,
                (contextSpec) => getCurrentUser(contextSpec)
              )
          },
          Storage: {
            list: (input: ListPaginateWithPathInput) =>
              runWithAmplifyServerContext(
                amplifyConfig,
                libraryOptions,
                (contextSpec) => list(contextSpec, input)
              )
          },
          GraphQL: {
            client: {
              models: {
                Todo: {
                  list(...input: TodoListInput) {
                    return runWithAmplifyServerContext(
                      amplifyConfig,
                      libraryOptions,
                      (contextSpec) => gqlServerClient.models.Todo.list(contextSpec, ...input)
                    )
                  },
                  create(...input: TodoCreateInput) {
                    return runWithAmplifyServerContext(
                      amplifyConfig,
                      libraryOptions,
                      (contextSpec) => gqlServerClient.models.Todo.create(contextSpec, ...input)
                    )
                  },
                  update(...input: TodoUpdateInput) {
                    return runWithAmplifyServerContext(
                      amplifyConfig,
                      libraryOptions,
                      (contextSpec) => gqlServerClient.models.Todo.update(contextSpec, ...input)
                    )
                  }
                }
              }
            }
          }
        }
      }
    };
  }
});
```

#### Usage example

Using the Storage `list` API in `pages/storage-list.vue`:

```ts title="pages/storage-list.vue"

// `useAsyncData` and `useNuxtApp` are Nuxt composables
// `$Amplify` is generated by Nuxt according to the `provide` key in the plugins
// we've added above
<script setup lang="ts">
const { data, error } = useAsyncData(async () => {
  const listResult = await useNuxtApp().$Amplify.Storage.list({
    path: 'album'
  });
  return listResult.items;
});
</script>

<template>
  <h3>Files under path: album</h3>
  <pre>{{ data }}</pre>
</template>
```

Using the GraphQL API in `pages/todos-list.vue`:

```ts title="pages/todos-list.vue"
<script setup lang="ts">
const { data, error } = useAsyncData(async () => {
  const { data } = await useNuxtApp().$Amplify.GraphQL.client.models.Todo.list();
  return data;
});
</script>

<template>
  <h3>Todos</h3>
  <pre>{{ data }}</pre>
</template>
```

The above two pages can be rendered on both the client and server by default. `useNuxtApp().$Amplify` will pick up the correct implementation of `01.amplifyApis.client.ts` and `01.amplifyApis.server.ts` to use, depending on the runtime.

<Callout warning>

Only a subset of Amplify APIs are usable on the server side, and as the libraries evolve, `amplify-apis.client` and `amplify-apis.server` may diverge further. You can guard your API calls to ensure an API is available in the context where you use it (e.g., you can use `if (process.client)` to ensure that a client-only API isn't executed on the server).

</Callout>

## Set up Auth middleware to protect your routes

The auth middleware will use the plugin configured in the previous step as a dependency; therefore you can add the auth middleware via another plugin that will be loaded after the previous one.

1. Create a `02.authRedirect.ts` file under plugins directory

<Callout>

**Note:** This file will run on both client and server, details see: https://nuxt.com/docs/guide/directory-structure/middleware#when-middleware-runs. The `02` name prefix ensures this plugin loads after the previous so `useNuxtApp().$Amplify` becomes available.

</Callout>

### Implement `02.authRedirect.ts`

Example implementation:

```ts title="plugins/02.authRedirect.ts"
import { Amplify } from 'aws-amplify';
import outputs from '~/amplify_outputs.json';

// Amplify.configure() only needs to be called on the client side
if (process.client) {
  Amplify.configure(config, { ssr: true });
}

export default defineNuxtPlugin({
  name: 'AmplifyAuthRedirect',
  enforce: 'pre',
  setup() {
    addRouteMiddleware(
      'AmplifyAuthMiddleware',
      defineNuxtRouteMiddleware(async (to) => {
        try {
          const session = await useNuxtApp().$Amplify.Auth.fetchAuthSession();

          // If the request is not associated with a valid user session
          // redirect to the `/sign-in` route.
          // You can also add route match rules against `to.path`
          if (session.tokens === undefined && to.path !== '/sign-in') {
            return navigateTo('/sign-in');
          }

          if (session.tokens !== undefined && to.path === '/sign-in') {
            return navigateTo('/');
          }
        } catch (e) {
          if (to.path !== '/sign-in') {
            return navigateTo('/sign-in');
          }
        }
      }),
      { global: true }
    );
  }
});
```

<Callout warning="true">

Make sure you call `Amplify.configure` as early as possible in your application’s life-cycle. A missing configuration or `NoCredentials` error is thrown if `Amplify.configure` has not been called before other Amplify JavaScript APIs. Review the [Library Not Configured Troubleshooting guide](/gen1/[platform]/build-a-backend/troubleshooting/library-not-configured/) for possible causes of this issue.

</Callout>

## Set Up Amplify for API Route Use Cases

Following the specification of Nuxt, your API route handlers will live under `~/server`, which is a separate environment from other parts of your Nuxt app; hence, the plugins created in the previous sections are not usable here, and extra work is required.

### Set up Amplify server context utility

1. If you haven’t already done so, create a `utils` directory under the server directory of your Nuxt project
2. Create an `amplifyUtils.ts` file under the `utils` directory

In this file, you will create a helper function to call Amplify APIs that are capable of running on the server side with context isolation.

Example implementation:


```ts title="utils/amplifyUtils.ts"
import type { H3Event, EventHandlerRequest } from 'h3';
import {
  createKeyValueStorageFromCookieStorageAdapter,
  createUserPoolsTokenProvider,
  createAWSCredentialsAndIdentityIdProvider,
  runWithAmplifyServerContext,
  AmplifyServer,
  CookieStorage
} from 'aws-amplify/adapter-core';
import { parseAmplifyConfig } from 'aws-amplify/utils';

import type { LibraryOptions } from '@aws-amplify/core';
import outputs from '~/amplify_outputs.json';

const amplifyConfig = parseAmplifyConfig(config);

const createCookieStorageAdapter = (
  event: H3Event<EventHandlerRequest>
): CookieStorage.Adapter => {
  // `parseCookies`, `setCookie` and `deleteCookie` are Nuxt provided functions
  const readOnlyCookies = parseCookies(event);

  return {
    get(name) {
      if (readOnlyCookies[name]) {
        return { name, value: readOnlyCookies[name] };
      }
    },
    set(name, value, options) {
      setCookie(event, name, value, options);
    },
    delete(name) {
      deleteCookie(event, name);
    },
    getAll() {
      return Object.entries(readOnlyCookies).map(([name, value]) => {
        return { name, value };
      });
    }
  };
};

const createLibraryOptions = (
  event: H3Event<EventHandlerRequest>
): LibraryOptions => {
  const cookieStorage = createCookieStorageAdapter(event);
  const keyValueStorage =
    createKeyValueStorageFromCookieStorageAdapter(cookieStorage);
  const tokenProvider = createUserPoolsTokenProvider(
    amplifyConfig.Auth!,
    keyValueStorage
  );
  const credentialsProvider = createAWSCredentialsAndIdentityIdProvider(
    amplifyConfig.Auth!,
    keyValueStorage
  );

  return {
    Auth: {
      tokenProvider,
      credentialsProvider
    }
  };
};

export const runAmplifyApi = <Result>(
  // we need the event object to create a context accordingly
  event: H3Event<EventHandlerRequest>,
  operation: (
    contextSpec: AmplifyServer.ContextSpec
  ) => Result | Promise<Result>
) => {
  return runWithAmplifyServerContext<Result>(
    amplifyConfig,
    createLibraryOptions(event),
    operation
  );
};
```

You can then use `runAmplifyApi` function to call Amplify APIs in an isolated server context.

#### Usage example

Take implementing an API route `GET /api/current-user` , in `server/api/current-user.ts`:

```ts title="server/api/current-user.ts"
import { getCurrentUser } from 'aws-amplify/auth/server';
import { runAmplifyApi } from '~/server/utils/amplifyUtils';

export default defineEventHandler(async (event) => {
  const user = await runAmplifyApi(event, (contextSpec) =>
    getCurrentUser(contextSpec)
  );

  return user;
});
```

Then you can fetch data from this route, for example, `fetch('http://localhost:3000/api/current-user')`.

## Set up server middleware to protect your API routes

Similar to API routes, the previously added auth middleware are not usable under `/server`, hence extra work is required to set up a auth middleware to protect your routes.

1. If you haven’t already done so, create a `middleware` directory under the `server` directory of your Nuxt project
2. Create an `amplifyAuthMiddleware.ts` file under the `middleware` directory

This middleware will be executed before a request reach your API route.

Example implementation:

```ts title="middleware/amplifyAuthMiddleware.ts"
import { fetchAuthSession } from 'aws-amplify/auth/server';

export default defineEventHandler(async (event) => {
  if (event.path.startsWith('/api/')) {
    try {
      const session = await runAmplifyApi(event, (contextSpec) =>
        fetchAuthSession(contextSpec)
      );

      // You can add extra logic to match the requested routes to apply
      // the auth protection
      if (session.tokens === undefined) {
        setResponseStatus(event, 403);
        return {
          error: 'Access denied!'
        };
      }
    } catch (error) {
      return {
        error: 'Access denied!'
      };
    }
  }
});
```

With this middleware, when executing `fetch('http://localhost:3000/api/current-user')` without signing in a user on the client side, the `fetch` will receive a 403 error, and the request won’t reach route `/api/current-user`.


Contents of build-a-backend_storage_authorization_index.txt:
import { getCustomStaticPath } from '@/utils/getCustomStaticPath';

export const meta = {
  title: 'Customize authorization rules',
  description:
    'Define granular authorization rules for storage buckets',
  platforms: [
    'angular',
    'javascript',
    'nextjs',
    'react',
    'vue',
    'swift',
    'android',
    'flutter',
    'react-native'
  ]
};

export const getStaticPaths = async () => {
  return getCustomStaticPath(meta.platforms);
};

export function getStaticProps(context) {
  return {
    props: {
      platform: context.params.platform,
      meta
    }
  };
}

Customize authorization for your storage bucket by defining access to file paths for guests, authenticated users, and user groups. Access can also be defined for functions that require access to the storage bucket.

Refer to the following examples to understand how you can further customize authorization against different user types.

## Access Types

Authentication is required to continue using Amplify Storage, please make sure you set it up if you haven't already - [documentation to set up Auth](/[platform]/build-a-backend/auth/set-up-auth/).

<Callout>

**Note:** Paths in access definitions cannot have a '/' at the beginning of the string.

By default, all paths are denied to all types of users unless explicitly granted within `defineStorage` using the `access` callback as shown below.

</Callout>

<BlockSwitcher>
<Block name="Guest Users">
To grant all guest (i.e. not signed in) users of your application read access to files under `media/`, use the following `access` values.

```ts title="amplify/storage/resource.ts"
export const storage = defineStorage({
  name: 'myProjectFiles',
  access: (allow) => ({
    'media/*': [
      allow.guest.to(['read']) // additional actions such as "write" and "delete" can be specified depending on your use case
    ]
  })
});
```

</Block>
<Block name="Authenticated Users">
<Callout>

**Note:** When a user is part of a group, they are assigned the group role, which means permissions defined for the authenticated role will not apply for this user.

To grant access to users within a group, you must explicitly define access permissions for the group against the desired prefix.

</Callout>

To grant all authenticated (i.e. signed in) users of your application read access to files under `media/`, use the following `access` configuration.

```ts title="amplify/storage/resource.ts"
export const storage = defineStorage({
  name: 'myProjectFiles',
  access: (allow) => ({
    'media/*': [
      allow.authenticated.to(['read']) // additional actions such as "write" and "delete" can be specified depending on your use case
    ]
  })
});
```
</Block>
<Block name="User Groups">

<Callout>

**Note:** When a user is part of a group, they are assigned the group role, which means permissions defined for the authenticated role will not apply for this user.

To grant access to users within a group, you must explicitly define access permissions for the group against the desired prefix.

</Callout>

If you have configured user groups when setting up auth in your `defineAuth` object, you can scope storage access to specific groups. In this example, assume you have a `defineAuth` config with `admin` and `auditor` groups.

```ts title="amplify/auth/resource.ts"
import { defineAuth } from '@aws-amplify/backend';

export const auth = defineAuth({
  loginWith: {
    email: true
  },
  groups: ['admin', 'auditor']
});
```

With the following `access` definition, you can configure permissions such that auditors have read only permissions to `media/*` while admin has full permissions.

```ts title="amplify/storage/resource.ts"
export const storage = defineStorage({
  name: 'myProjectFiles',
  access: (allow) => ({
    'media/*': [
      allow.groups(['auditor']).to(['read']),
      allow.groups(['admin']).to(['read', 'write', 'delete'])
    ]
  })
});
```

If multiple groups require the same set of actions, this can be combined into a single rule.

```ts title="amplify/storage/resource.ts"
export const storage = defineStorage({
  name: 'myProjectFiles',
  access: (allow) => ({
    'media/*': [
      allow.groups(['auditor', 'admin']).to(['read', 'write'])
    ]
  })
});
```

</Block>
<Block name="Owners">
In some use cases, you may want just the uploader of a file to be able to perform actions on it. For example, in a music sharing app anyone can listen to a song, but only the person who uploaded that song could delete it. 

In Amplify Storage, you can do this by using the `entity_id` to represent the user which scopes files to individual users.

The `entity_id` is a reserved token that will be replaced with the users' identifier when the file is being uploaded. You can specify the method of identification when defining access to the path like `allow.entity(<identification_method>).to([..])`. 

Currently, Identity Pool is the only identification method available  - `allow.entity('identity').to([..])`

The following policy would allow authenticated users full access to `media/` that matches their identity id.

```ts title="amplify/storage/resource.ts"
export const storage = defineStorage({
  name: 'myProjectFiles',
  access: (allow) => ({
    'media/{entity_id}/*': [
      // {entity_id} is the token that is replaced with the user identity id
      allow.entity('identity').to(['read', 'write', 'delete'])
    ]
  })
});
```

A user with identity id `user123` would be able to perform read/write/delete operations on files within `media/user123/*` but would not be able to perform actions on files with any other path.

Likewise, a user with identity ID `userABC` would be able to perform read/write/delete operation on files only within `media/userABC/*`. In this way, each user can be granted access to a storage path that is not accessible to any other user.

The following example shows how you can define access to profile pictures where anyone can view them but only the owner can modify/delete them.

```ts title="amplify/storage/resource.ts"
export const storage = defineStorage({
  name: 'myProjectFiles',
  access: (allow) => ({
    'media/profile-pictures/{entity_id}/*': [
      allow.entity('identity').to(['read', 'write', 'delete']),
      allow.guest.to(['read']),
      allow.authenticated.to(['read'])
    ]
  })
});
```

When a rule for guests, authenticated users, user groups, or resources is applied to a path with the `{entity_id}` token, the token is replaced with a wildcard (`*`). This means that the access will apply to files uploaded by _any_ user. In the above policy, write and delete is scoped to just the owner, but read is allowed for guest and authenticated users for any file within `media/profile-pictures/*/*`.

</Block>
<Block name="Functions">
In addition to granting application users access to storage files, you may also want to grant a backend function access to storage files. This could be used to enable a use case like resizing images or automatically deleting old files. The following configuration is used to define function access.

```ts title="amplify/storage/resource.ts"
import { defineStorage, defineFunction } from '@aws-amplify/backend';

const demoFunction = defineFunction({});

export const storage = defineStorage({
  name: 'myProjectFiles',
  access: (allow) => ({
    'media/*': [allow.resource(demoFunction).to(['read', 'write', 'delete'])]
  })
});
```

This would grant the function `demoFunction` the ability to read write and delete files within `media/*`.

When a function is granted access to storage, it also receives an environment variable that contains the name of the Amazon S3 bucket configured by storage. This environment variable can be used in the function to make AWS SDK calls to the storage bucket. The environment variable is named `<storage-name>_BUCKET_NAME`. In the above example, it would be named `myProjectFiles_BUCKET_NAME`.

[Learn more about function resource access environment variables](/[platform]/build-a-backend/functions/#resource-access)

</Block>
</BlockSwitcher>

### Access definition rules

There are some rules for the types of paths that can be specified at the same time in the storage access definition.

1. All paths must end with `/*`.
2. Only one level of nesting is allowed. For example, you can define access controls on `media/*` and `media/albums/*` but not on `media/albums/photos/*` because there are two other definitions along the same path.
3. Wildcards cannot conflict with the `{entity_id}` token. For example, you cannot have both `media/*` and `media/{entity_id}/*` defined because the wildcard in the first path conflicts with the `{entity_id}` token in the second path.
4. A path cannot be a prefix of another path with an `{entity_id}` token. For example `media/*` and `media/albums/{entity_id}/*` is not allowed.

When one path is a subpath of another, the permissions on the subpath _always override_ the permissions from the parent path. Permissions are not "inherited" from a parent path. Consider the following access definition example:

```ts
export const storage = defineStorage({
  name: 'myProjectFiles',
  access: (allow) => ({
    'media/*': [allow.authenticated.to(['read', 'write', 'delete'])],
    'media/profile-pictures/*': [allow.guest.to(['read'])],
    'media/albums/*': [allow.authenticated.to(['read'])],
    'other/*': [
      allow.guest.to(['read']),
      allow.authenticated.to(['read', 'write'])
    ]
  })
});
```

The access control matrix for this configuration is

| Path | media/\* | media/profile-pictures/\* | media/albums/\* | other/\* |
| --- | --- | --- | --- | --- |
| **Authenticated Users** | read, write, delete | NONE | read | read, write |
| **Guest users** | NONE | read | NONE | read |

Authenticated users have access to read, write, and delete everything under `media/*` EXCEPT `media/profile-pictures/*` and `media/albums/*`. For those subpaths, the scoped down access overrides the access granted on the parent `media/*`

### Available actions

When you configure access to a particular path, you can scope the access to one or more CRUDL actions.

| Access   | Corresponding Library APIs                            |
| -------- | ----------------------------------------------------- |
| `read`   | `getUrl`, `downloadData`, `list`, and `getProperties` |
| `get`    | `getUrl` and `downloadData`                           |
| `list`   | `list`, and `getProperties`                           |
| `write`  | `uploadData`, `copy`                                  |
| `delete` | `remove`                                              |

<Callout>

**Note:** `read` is a combination of `get` and `list` access definitions and hence cannot be defined in the presence of `get` or `list`.

</Callout>


## For Gen 1 public, protected, and private access pattern
{/* I don't think I'd include this, if you do I'd do it in an accordion component */}
To configure `defineStorage` in Amplify Gen 2 to behave the same way as the storage category in Gen 1, the following definition can be used.

```ts title="amplify/storage/resource.ts"
export const storage = defineStorage({
  name: 'myProjectFiles',
  access: (allow) => ({
    'public/*': [
      allow.guest.to(['read']),
      allow.authenticated.to(['read', 'write', 'delete']),
    ],
    'protected/{entity_id}/*': [
      allow.authenticated.to(['read']),
      allow.entity('identity').to(['read', 'write', 'delete'])
    ],
    'private/{entity_id}/*': [
      allow.entity('identity').to(['read', 'write', 'delete'])
    ]
  })
});
```


Contents of build-a-backend_storage_copy-files_index.txt:
import { getCustomStaticPath } from '@/utils/getCustomStaticPath';

export const meta = {
  title: 'Copy files',
  description: 'Copy files using Amplify Storage',
  platforms: [
    'angular',
    'javascript',
    'nextjs',
    'react',
    'vue',
    'flutter',
    'react-native'
  ]
};

export const getStaticPaths = async () => {
  return getCustomStaticPath(meta.platforms);
};

export function getStaticProps(context) {
  return {
    props: {
      platform: context.params.platform,
      meta
    }
  };
}

<Callout>

**Note:** You can only copy files up to 5GB in a single operation

</Callout>

You can copy an existing file to a different path within the storage bucket using the copy API.

<InlineFilter filters={["angular","javascript","nextjs","react","vue", "react-native"]}>

The `copy` method duplicates an existing file to a designated path and returns an object `{path: 'destPath'}` upon successful completion.

```javascript
import { copy } from 'aws-amplify/storage';

const copyFile = async () => {
  try {
    const response = await copy({
      source: {
        path: `album/2024/${encodeURIComponent('#1.jpg')}`,
        // Alternatively, path: ({identityId}) => `album/${identityId}/${encodeURIComponent('#1.jpg')`
      },
      destination: {
        path: 'shared/2024/#1.jpg',
        // Alternatively, path: ({identityId}) => `shared/${identityId}/#1.jpg`
      },
    });
  } catch (error) {
    console.error('Error', err);
  }
};
```
<Callout>

The operation can fail if there's a special character in the `source` path. You should URI encode the source
path with special character. You **don't** need to encode the `destination` path.

</Callout>

<Callout>

Cross identity ID copying is only allowed if the destination path has the the right access rules to allow other authenticated users writing to it.

</Callout>

## Specify a bucket or copy across buckets / regions

You can also perform an `copy` operation to a specific bucket by providing the `bucket` option. This option can either be a string representing the target bucket's assigned name in Amplify Backend or an object specifying the bucket name and region from the console.

```javascript
import { copy } from 'aws-amplify/storage';

const copyFile = async () => {
  try {
    const response = await copy({
      source: {
        path: 'album/2024/1.jpg',
        // Specify a target bucket using name assigned in Amplify Backend
        // or bucket name from console and associated region
        bucket: 'assignedNameInAmplifyBackend',
        expectedBucketOwner: '123456789012'
      },
      destination: {
        path: 'shared/2024/1.jpg',
        // Specify a target bucket using name assigned in Amplify Backend
        // or bucket name from console and associated region
        bucket: {
          bucketName: 'generated-second-bucket-name',
          region: 'us-east-2'
        },
        expectedBucketOwner: '123456789013'
      }
    });
  } catch (error) {
    console.error('Error', err);
  }
};
```

<Callout>
In order to copy to or from a bucket other than your default, both source and destination must have `bucket` explicitly defined.
</Callout>

## Copy `source` and `destination` options

Option | Type | Default | Description |
| -- | :--: | :--: | ----------- |
| path | string \| <br/>(\{ identityId \}) => string | Required | A string or callback that represents the path in source and destination bucket to copy the object to or from. <br /> **Each segment of the path in `source` must by URI encoded.** |
| bucket | string \| <br />\{ bucketName: string;<br/> region: string; \} | Default bucket and region from Amplify configuration | A string representing the target bucket's assigned name in Amplify Backend or an object specifying the bucket name and region from the console.<br/><br/>Read more at [Configure additional storage buckets](/[platform]/build-a-backend/storage/set-up-storage/#configure-additional-storage-buckets). |
| eTag | string | Optional | The copy **source object** entity tag (ETag) value. Only Copies the object if its ETag matches the specified tag. |
| notModifiedSince | Date | Optional | Copies the **source object** if it hasn't been modified since the specified time.  <br /><br/> **This is evaluated only when `eTag` is NOT supplied**|
| expectedBucketOwner | string | Optional | `source.expectedBucketOwner`: The account ID that owns the source bucket. <br /><br /> `destination.expectedBucketOwner`: The account ID that owns the destination bucket. |

</InlineFilter>

<InlineFilter filters={["flutter"]}>

User who initiates a copy operation should have read permission on the copy source file.

```dart
Future<void> copy() async {
  try {
    final result = await Amplify.Storage.copy(
      source: const StoragePath.fromString('album/2024/1.jpg'),
      destination: const StoragePath.fromString('shared/2024/1.jpg'),
    ).result;
    safePrint('Copied file: ${result.copiedItem.path}');
  } on StorageException catch (e) {
    safePrint(e);
  }
}
```
## Specify a bucket or copy across buckets / regions

You can also perform a `copy` operation to a specific bucket by providing the `CopyBuckets` option. 
This option is an object that takes two `StorageBucket` parameters, which can be constructed by the specified name in the Amplify Backend, or the bucket name and region from the console.

```dart
final mainBucket = StorageBucket.fromOutputs(
  'mainBucket',
);
final bucket2 = StorageBucket.fromBucketInfo(
  BucketInfo(
    bucketName: 'second-bucket-name-from-console',
    region: 'us-east-2',
  ),
),
try {
  final result = await Amplify.Storage.copy(
    source: const StoragePath.fromString('album/2024/1.jpg'),
    destination: const StoragePath.fromString('shared/2024/1.jpg'),
    options: StorageCopyOptions(
      buckets: CopyBuckets(
        source: bucket1,
        destination: bucket2,
      ),
    ),
  ).result;
  safePrint('Copied file: ${result.copiedItem.path}');
} on StorageException catch (e) {
  print('Error: $e');
}
```

<Callout>
In order to copy to or from a bucket other than your default, the source and/or destination paths must exist in that bucket
</Callout>

## `copy` options

Option | Type | Description |
| -- | -- | ----------- |
| getProperties | boolean | Whether to retrieve properties for the copied object using theAmplify.Storage.getProperties() after the operation completes. When set to true the returned item will contain additional info such as metadata and content type. |
| buckets | CopyBuckets | An object that accepts two `StorageBucket` parameters. To copy to and from the same bucket, use the `CopyBuckets.sameBucket(targetBucket)` method, where `targetBucket` is a `StorageBucket`. Read more at [Configure additional storage buckets](/[platform]/build-a-backend/storage/set-up-storage/#configure-additional-storage-buckets)|

Example of `copy` with options:

```dart
final result = Amplify.Storage.copy(
  source: const StoragePath.fromString('album/2024/1.jpg'),
  destination: const StoragePath.fromString('shared/2024/1.jpg'),
  options: const StorageCopyOptions(
    pluginOptions: S3CopyPluginOptions(
      getProperties: true,
    ),
    buckets: CopyBuckets.sameBucket(
      StorageBucket.fromOutputs('secondBucket'),
    ),
  ),
);
```

</InlineFilter>


Contents of build-a-backend_storage_data-usage_index.txt:
import { getCustomStaticPath } from '@/utils/getCustomStaticPath';

export const meta = {
  title: 'Data usage policy',
  description: "Review the data types gathered by the Amplify library that Apple requires you to disclose in your app's data usage policy when submitting the app to the App Store.",
  platforms: ['swift',
              'flutter']
};

export const getStaticPaths = async () => {
  return getCustomStaticPath(meta.platforms);
};

export function getStaticProps(context) {
  return {
    props: {
      platform: context.params.platform,
      meta
    }
  };
}

Apple requires app developers to provide the data usage policy of the app when they submit their app to the App Store. See Apple's [User privacy and data use](https://developer.apple.com/app-store/user-privacy-and-data-use/) for more details. Amplify Library is used to interact with AWS resources under the developer’s ownership and management. The library cannot predict the usage of its APIs and it is up to the developer to provide the privacy manifest that accurately reflects the data collected by the app. Below are the different categories identified by Apple and the corresponding data type used by the Amplify Library.

By utilizing the library, Amplify gathers API usage metrics from the AWS services accessed. This process involves adding a user agent to the request made to your AWS service. The user-agent header is included with information about the Amplify Library version, operating system name, and version. AWS collects this data to generate metrics related to our library usage. This information is not linked to the user’s identity and not used for tracking purposes as described in Apple's privacy and data use guidelines.

Should you have any specific concerns or require additional information for the enhancement of your privacy manifest, please don't hesitate to reach out.

## Contact info

| Data Type                        | Amplify Category   | Purpose             | Linked To Identity   | Tracking   | Provided by developer   |
| ------------------------------   | ------------------ | ------------------- | :------------------: | :--------: | :---------------------: |
| **Name**                         |                    |                     |                      |            |                         |
|                                  | Auth               | App Functionality   | ✅                   | ❌        | ✅                      |
| **Email Address**                |                    |                     |                      |            |                         |
|                                  | Auth               | App Functionality   | ✅                   | ❌        | ✅                      |
| **Phone Number**                 |                    |                     |                      |            |                         |
|                                  | Auth               | App Functionality   | ✅                   | ❌        | ✅                      |

## User Content

| Data Type                        | Amplify Category   | Purpose             | Linked To Identity   | Tracking   | Provided by developer   |
| ------------------------------   | ------------------ | ------------------- | :------------------: | :--------: | :---------------------: |
| **Photos or Videos**             |                    |                     |                      |            |                         |
|                                  | Storage            | App Functionality   | ❌                   | ❌        | ✅                      |
|                                  | Predictions        | App Functionality   | ❌                   | ❌        | ✅                      |
| **Audio Data**                   |                    |                     |                      |            |                         |
|                                  | Predictions        | App Functionality   | ❌                   | ❌        | ✅                      |

## Identifiers

| Data Type                        | Amplify Category   | Purpose             | Linked To Identity   | Tracking   | Provided by developer   |
| ------------------------------   | ------------------ | ------------------- | :------------------: | :--------: | :---------------------: |
| **User ID**                      |                    |                     |                      |            |                         |
|                                  | Auth               | App Functionality   | ✅                   | ❌        | ❌                      |
|                                  | Analytics          | Analytics           | ✅                   | ❌        | ❌                      |
| **Device ID**                    |                    |                     |                      |            |                         |
|                                  | Auth               | App Functionality   | ✅                   | ❌        | ❌                      |
|                                  | Analytics          | Analytics           | ✅                   | ❌        | ❌                      |

## Other Data

| Data Type                        | Amplify Category   | Purpose             | Linked To Identity   | Tracking   | Provided by developer   |
| ------------------------------   | ------------------ | ------------------- | :------------------: | :--------: | :---------------------: |
| **OS Version**                   |                    |                     |                      |            |                         |
|                                  | All categories     | Analytics           | ❌                   | ❌        | ❌                      |
| **OS Name**                      |                    |                     |                      |            |                         |
|                                  | All categories     | Analytics           | ❌                   | ❌        | ❌                      |
| **Locale Info**                  |                    |                     |                      |            |                         |
|                                  | All categories     | Analytics           | ❌                   | ❌        | ❌                      |
| **App Version**                  |                    |                     |                      |            |                         |
|                                  | Auth               | App Functionality   | ✅                   | ❌        | ❌                      |
| **Min OS target of the app**     |                    |                     |                      |            |                         |
|                                  | Auth               | App Functionality   | ✅                   | ❌        | ❌                      |
| **Timezone information**         |                    |                     |                      |            |                         |
|                                  | Auth               | App Functionality   | ✅                   | ❌        | ❌                      |
| **Network information**          |                    |                     |                      |            |                         |
|                                  | Auth               | App Functionality   | ✅                   | ❌        | ❌                      |
| **Has SIM card**                 |                    |                     |                      |            |                         |
|                                  | Auth               | App Functionality   | ✅                   | ❌        | ❌                      |
| **Cellular Carrier Name**        |                    |                     |                      |            |                         |
|                                  | Auth               | App Functionality   | ✅                   | ❌        | ❌                      |
| **Device Model**                 |                    |                     |                      |            |                         |
|                                  | Auth               | App Functionality   | ✅                   | ❌        | ❌                      |
| **Device Name**                  |                    |                     |                      |            |                         |
|                                  | Auth               | App Functionality   | ✅                   | ❌        | ❌                      |
| **Device OS Version**            |                    |                     |                      |            |                         |
|                                  | Auth               | App Functionality   | ✅                   | ❌        | ❌                      |
| **Device Height and Width**      |                    |                     |                      |            |                         |
|                                  | Auth               | App Functionality   | ✅                   | ❌        | ❌                      |
| **Device Language**              |                    |                     |                      |            |                         |
|                                  | Auth               | App Functionality   | ✅                   | ❌        | ❌                      |
| **identifierForVendor**          |                    |                     |                      |            |                         |
|                                  | Auth               | App Functionality   | ✅                   | ❌        | ❌                      |


## Health and Fitness	
No data is collected

## Financial Info
No data is collected

## Location							
No data is collected

## Sensitive Info							
No data is collected

## Contacts							
No data is collected

## Browsing History
No data is collected

## Search History
No data is collected

## Diagnostics
No data is collected

## Clearing data

Some Amplify categories such as Analytics, Auth, and DataStore persist data to the local device. Some of that data is automatically removed when a user uninstalls the app from the device.

Amplify stores Auth information in the local [system keychain](https://developer.apple.com/documentation/security/keychain_services), which does not guarantee any particular behavior around whether data is removed when an app is uninstalled.

Deciding on when to clear this auth information is not something that the SDK can do in a generic way, so App developers should decide when to clear the data by signing out. One strategy for accomplishing this would be to use [UserDefaults](https://developer.apple.com/documentation/foundation/userdefaults) to detect whether or not the app is launching for the first time, and invoking [`Auth.signOut()`](/[platform]/build-a-backend/auth/connect-your-frontend/sign-out/) if the app has not been launched before.


Contents of build-a-backend_storage_download-files_index.txt:
import { getCustomStaticPath } from '@/utils/getCustomStaticPath';

export const meta = {
  title: 'Download files',
  description: 'Download files using Amplify Storage',
  platforms: [
    'angular',
    'javascript',
    'nextjs',
    'react',
    'vue',
    'android',
    'swift',
    'flutter',
    'react-native'
  ]
};

export const getStaticPaths = async () => {
  return getCustomStaticPath(meta.platforms);
};

export function getStaticProps(context) {
  return {
    props: {
      platform: context.params.platform,
      meta
    }
  };
}

<InlineFilter filters={["react", "javascript", "nextjs"]}>

## Storage Image React UI Component

You can easily display images in your app by using the cloud-connected Storage Image React UI component. This component fetches images securely from your storage resource and displays it on the web page.

```bash title="Terminal" showLineNumbers={false}
npm add @aws-amplify/ui-react-storage aws-amplify
```
```tsx
import { StorageImage } from '@aws-amplify/ui-react-storage';

export const DefaultStorageImageExample = () => {
  return <StorageImage alt="cat" path="your-path/cat.jpg" />;
};
```

Learn more about how you can further customize the UI component by referring to the [Storage Image documentation](https://ui.docs.amplify.aws/react/connected-components/storage/storageimage).

</InlineFilter>

To further customize your in-app experience, you can use the `getUrl` or `downloadData` API from the Amplify Library for Storage.

<Callout>

**Note:** Refer to [the Transfer Acceleration documentation](/[platform]/build-a-backend/storage/extend-s3-resources/#example---enable-transfer-acceleration) to learn how to enable transfer acceleration for storage APIs.

</Callout>

## Get or download file from a URL

With the `getUrl` API, you can get a presigned URL which is valid for 900 seconds or 15 minutes by default. You can use this URL to create a download link for users to click on. The `expiresAt` property is a `Date` object that represents the time at which the URL will expire.

<InlineFilter filters={["react", "angular", "javascript", "vue", "nextjs", "react-native"]}>

```typescript
import { getUrl } from 'aws-amplify/storage';

const linkToStorageFile = await getUrl({
  path: "album/2024/1.jpg",
  // Alternatively, path: ({identityId}) => `album/{identityId}/1.jpg`
});
console.log('signed URL: ', linkToStorageFile.url);
console.log('URL expires at: ', linkToStorageFile.expiresAt);
```
Inside your template or JSX code, you can use the `url` property to create a link to the file:

```tsx
<a href={linkToStorageFile.url.toString()} target="_blank" rel="noreferrer">
  {fileName} 
</a>
```

<Callout>

This function does not check if the file exists by default. As result, the signed URL may fail if the file to be downloaded does not exist.
  
</Callout>

### More getUrl options

The behavior of the `getUrl` API can be customized by passing in options.

```typescript
import { getUrl } from 'aws-amplify/storage';

const linkToStorageFile = await getUrl({
  path: "album/2024/1.jpg",
  options: {
    // specify a target bucket using name assigned in Amplify Backend
    bucket: 'assignedNameInAmplifyBackend',
    // ensure object exists before getting url
    validateObjectExistence: true, 
    // url expiration time in seconds.
    expiresIn: 300,
    // whether to use accelerate endpoint
    useAccelerateEndpoint: true,
    // The account ID that owns the requested bucket.
    expectedBucketOwner: '123456789012',
  }
});
```

Option | Type | Default | Description |
| :--: | :--: | :--: | ----------- |
| bucket | string \| <br />\{ bucketName: string;<br/> region: string; \} | Default bucket and region from Amplify configuration | A string representing the target bucket's assigned name in Amplify Backend or an object specifying the bucket name and region from the console.<br/><br/>Read more at [Configure additional storage buckets](/[platform]/build-a-backend/storage/set-up-storage/#configure-additional-storage-buckets) 
| validateObjectExistence | boolean | false | Whether to head object to make sure the object existence before downloading. |
| expiresIn | number | 900 | Number of seconds till the URL expires. <br/><br/> The expiration time of the presigned url is dependent on the session and will max out at 1 hour. |
| useAccelerateEndpoint | boolean | false | Whether to use accelerate endpoint. <br/><br/> Read more at [Transfer Acceleration](/[platform]/build-a-backend/storage/extend-s3-resources/#example---enable-transfer-acceleration) |
| expectedBucketOwner | string | Optional | The account ID that owns requested bucket. |

</InlineFilter>

<InlineFilter filters={["android"]}>
<BlockSwitcher>
<Block name="Java">

```java
Amplify.Storage.getUrl(
    StoragePath.fromString("public/example"),
    result -> Log.i("MyAmplifyApp", "Successfully generated: " + result.getUrl()),
    error -> Log.e("MyAmplifyApp", "URL generation failure", error)
);
```

</Block>
<Block name="Kotlin - Callbacks">

```kotlin
Amplify.Storage.getUrl(
    StoragePath.fromString("public/example"),
    { Log.i("MyAmplifyApp", "Successfully generated: ${it.url}") },
    { Log.e("MyAmplifyApp", "URL generation failure", it) }
)
```

</Block>
<Block name="Kotlin - Coroutines">

```kotlin
try {
    val url = Amplify.Storage.getUrl(StoragePath.fromString("public/example")).url
    Log.i("MyAmplifyApp", "Successfully generated: $url")
} catch (error: StorageException) {
    Log.e("MyAmplifyApp", "URL generation failure", error)
}
```

</Block>
<Block name="RxJava">

```java
RxAmplify.Storage.getUrl(StoragePath.fromString("public/example")).subscribe(
    result -> Log.i("MyAmplifyApp", "Successfully generated: " + result.getUrl()),
    error -> Log.e("MyAmplifyApp", "URL generation failure", error)
);
```

</Block>
</BlockSwitcher>

### Check the existence of a file

When creating a downloadable URL, you can choose to check if the file exists by setting `validateObjectExistence` to
`true` in `AWSS3StorageGetPresignedUrlOptions`. If the file is inaccessible or does not exist, a `StorageException` is thrown.
This allows you to check if an object exists when generating the presigned URL, which you can then use to download
that object.

<BlockSwitcher>
<Block name="Java">

```java
AWSS3StorageGetPresignedUrlOptions options = AWSS3StorageGetPresignedUrlOptions
  .builder()
  .setValidateObjectExistence(true)
  .build();

Amplify.Storage.getUrl(
    StoragePath.fromString("public/example"),
    options,
    result -> Log.i("MyAmplifyApp", "Successfully generated: " + result.getUrl()),
    error -> Log.e("MyAmplifyApp", "URL generation failure", error)
);
```

</Block>
<Block name="Kotlin - Callbacks">
```kotlin
val options = AWSS3StorageGetPresignedUrlOptions
  .builder()
  .setValidateObjectExistence(true)
  .build()
  
Amplify.Storage.getUrl(
    StoragePath.fromString("public/example"),
    options,
    { Log.i("MyAmplifyApp", "Successfully generated: ${it.url}") },
    { Log.e("MyAmplifyApp", "URL generation failure", it) }
)
```
</Block>
<Block name="Kotlin - Coroutines">
```kotlin
try {
    val options = AWSS3StorageGetPresignedUrlOptions
      .builder()
      .setValidateObjectExistence(true)
      .build()

    val url = Amplify.Storage.getUrl(StoragePath.fromString("public/example"), options).url
    Log.i("MyAmplifyApp", "Successfully generated: $url")
} catch (error: StorageException) {
    Log.e("MyAmplifyApp", "URL generation failure", error)
}
```
</Block>
<Block name="RxJava">
```java
AWSS3StorageGetPresignedUrlOptions options = AWSS3StorageGetPresignedUrlOptions
  .builder()
  .setValidateObjectExistence(true)
  .build();

RxAmplify.Storage.getUrl(StoragePath.fromString("public/example"), options).subscribe(
    result -> Log.i("MyAmplifyApp", "Successfully generated: " + result.getUrl()),
    error -> Log.e("MyAmplifyApp", "URL generation failure", error)
);
```
</Block>
</BlockSwitcher>

### All `getURL` options

Option | Type | Description |
| -- | -- | ----------- |
| bucket | StorageBucket | The bucket in which the object is stored. |
| expires | Integer | Number of seconds before the URL expires. |
| useAccelerateEndpoint | Boolean | Flag to configure use of acceleration mode. |
| validateObjectExistence | Boolean | Flag to check if the file exists. |

</InlineFilter>

<InlineFilter filters={["swift"]}>
```swift
let url = try await Amplify.Storage.getURL(
    path: .fromString("public/example/path")
)
print("Completed: \(url)")
```

### Check the existence of a file

When creating a downloadable URL, you can choose to check if the file exists by setting `validateObjectExistence` to
`true` in `AWSStorageGetURLOptions`. If the file is inaccessible or does not exist, a `StorageError` is thrown.
This allows you to check if an object exists during generating the presigned URL, which you can then use to download
that object.

```swift
let url = try await Amplify.Storage.getURL(
    path: .fromString("public/example/path"),
    options: .init(
        pluginOptions: AWSStorageGetURLOptions(
            validateObjectExistence: true
        )
    )
)
```

### All `getURL` options

Option | Type | Description |
| -- | -- | ----------- |
| expires | Int | Number of seconds before the URL expires |
| bucket | StorageBucket | The bucket in which the object is stored |

</InlineFilter>

<InlineFilter filters={["flutter"]}>

When creating a downloadable URL, you can choose to check if the file exists by setting `validateObjectExistence` to
`true` in `S3GetUrlPluginOptions`. If the file is inaccessible or does not exist, a `StorageException` is thrown.
This allows you to check if an object exists during generating the presigned URL, which you can then use to download
that object. You may also pass in a bucket to target into `StorageGetUrlOptions` from either the chosen name in the 
backend or the console name and region. If no bucket is provided, the default bucket defined in the backend will be used. 
Read more at [Configure additional storage buckets](/[platform]/build-a-backend/storage/set-up-storage/#configure-additional-storage-buckets) 

```dart
Future<void> getDownloadUrl() async {
  try {
    final result = await Amplify.Storage.getUrl(
      path: const StoragePath.fromString('public/example.txt'),
      /* 
      // targeting a specific bucket by the name defined in the backend 
      options: StorageGetUrlOptions(
        bucket: StorageBucket.fromOutputs('secondBucket'),
      ),
      */
    ).result;
    safePrint('url: ${result.url}');
  } on StorageException catch (e) {
    safePrint(e.message);
  }
}
```

</InlineFilter>

<InlineFilter filters={["react", "angular", "javascript", "vue", "nextjs", "react-native"]}>
## Download to a file

Use the `downloadData` API to download the file locally.

```javascript
import { downloadData } from 'aws-amplify/storage';

// Downloads file content to memory
const { body, eTag } = await downloadData({
  path: "album/2024/1.jpg"
}).result;
```
</InlineFilter>

<InlineFilter filters={["android"]}>
## Download to a file

Use the `downloadFile` API to download the file locally on the client.

<BlockSwitcher>
<Block name="Java">

```java
Amplify.Storage.downloadFile(
        StoragePath.fromString("public/example"),
        new File(getApplicationContext().getFilesDir() + "/download.txt"),
        result -> Log.i("MyAmplifyApp", "Successfully downloaded: " + result.getFile().getName()),
        error -> Log.e("MyAmplifyApp",  "Download Failure", error)
);
```

</Block>
<Block name="Kotlin - Callbacks">

```kotlin
val file = File("${applicationContext.filesDir}/download.txt")
Amplify.Storage.downloadFile(StoragePath.fromString("public/example"), file,
    { Log.i("MyAmplifyApp", "Successfully downloaded: ${it.file.name}") },
    { Log.e("MyAmplifyApp",  "Download Failure", it) }
)
```

</Block>
<Block name="Kotlin - Coroutines">

```kotlin
try {
    val file = File("${applicationContext.filesDir}/download.txt")
    val download = Amplify.Storage.downloadFile(StoragePath.fromString("public/example"), file)
    try {
        val fileName = download.result().file.name
        Log.i("MyAmplifyApp", "Successfully downloaded: $fileName")
    } catch (error: StorageException) {
        Log.e("MyAmplifyApp", "Download Failure", error)
    }
}
```

</Block>
<Block name="RxJava">

```java
RxProgressAwareSingleOperation<StorageDownloadFileResult> download =
        RxAmplify.Storage.downloadFile(
            StoragePath.fromString("public/example"),
            new File(getApplicationContext().getFilesDir() + "/download.txt")
        );

download
    .observeResult()
    .subscribe(
        result -> Log.i("MyAmplifyApp", "Successfully downloaded: " + result.getFile().getName()),
        error -> Log.e("MyAmplifyApp",  "Download Failure", error)
    );
```

</Block>
</BlockSwitcher>
</InlineFilter>

<InlineFilter filters={["swift"]}>
## Download files
### Download to a local file

Use the `downloadFile` API to download the file locally on the client.

You can download to a file [URL](https://developer.apple.com/documentation/foundation/url) with `Amplify.Storage.downloadFile`:

<BlockSwitcher>

<Block name="Async/Await">
```swift
let downloadToFileUrl = FileManager.default.urls(
    for: .documentDirectory,
    in: .userDomainMask
)[0].appendingPathComponent("myFile.txt")

let downloadTask = Amplify.Storage.downloadFile(
    path: .fromString("public/example/path"),
    local: downloadToFileUrl,
    options: nil
)
Task {
    for await progress in await downloadTask.progress {
        print("Progress: \(progress)")
    }
}
try await downloadTask.value
print("Completed")
```
</Block>
<Block name="Combine">
```swift
let downloadToFileUrl = FileManager.default.urls(
    for: .documentDirectory,
    in: .userDomainMask
)[0].appendingPathComponent("myFile.txt")

let downloadTask = Amplify.Storage.downloadFile(
    path: .fromString("public/example/path"),
    local: downloadToFileUrl,
    options: nil
)
let progressSink = downloadTask
    .inProcessPublisher
    .sink { progress in
        print("Progress: \(progress)")
    }

let resultSink = downloadTask
    .resultPublisher
    .sink {
        if case let .failure(storageError) = $0 {
            print("Failed: \(storageError.errorDescription). \(storageError.recoverySuggestion)")
        }
    }
    receiveValue: {
        print("Completed")
    }
```
</Block>
</BlockSwitcher>

### Download to data in memory

You can download to in-memory buffer [Data](https://developer.apple.com/documentation/foundation/data) object with `Amplify.Storage.downloadData`:

<BlockSwitcher>

<Block name="Async/Await">

```swift
let downloadTask = Amplify.Storage.downloadData(
    path: .fromString("public/example/path")
)
Task {
    for await progress in await downloadTask.progress {
        print("Progress: \(progress)")
    }
}
let data = try await downloadTask.value
print("Completed: \(data)")
```

</Block>

<Block name="Combine">

```swift
let downloadTask = Amplify.Storage.downloadData(
    path: .fromString("public/example/path")
)
let progressSink = downloadTask
    .inProcessPublisher
    .sink { progress in
        print("Progress: \(progress)")
    }

let resultSink = downloadTask
    .resultPublisher
    .sink {
        if case let .failure(storageError) = $0 {
            print("Failed: \(storageError.errorDescription). \(storageError.recoverySuggestion)")
        }
    }
    receiveValue: { data in
        print("Completed: \(data)")
    }
```

</Block>

</BlockSwitcher>

### Download from a specified bucket

You can also perform a download operation from a specific bucket by providing the `bucket` option

<BlockSwitcher>
<Block name="From Outputs">
You can use `.fromOutputs(name:)` to provide a string representing the target bucket's assigned name in the Amplify Backend.

```swift
// Download to File
let downloadTask = Amplify.Storage.downloadFile(
    path: .fromString("public/example/path"),
    local: downloadToFileUrl,
    options: .init(
        bucket: .fromOutputs(name: "secondBucket")
    )
)

// Download to Data
let downloadTask = Amplify.Storage.downloadData(
    path: .fromString("public/example/path"),
    options: .init(
        bucket: .fromOutputs(name: "secondBucket")
    )
)
```
</Block>

<Block name="From Bucket Info">
You can also use `.fromBucketInfo(_:)` to provide a bucket name and region directly.

```swift
// Download to File
let downloadTask = Amplify.Storage.downloadFile(
    path: .fromString("public/example/path"),
    local: downloadToFileUrl,
    options: .init(
        bucket: .fromBucketInfo(.init(
            bucketName: "another-bucket-name",
            region: "another-bucket-region")
        )    
    )
)

// Download to Data
let downloadTask = Amplify.Storage.downloadData(
    path: .fromString("public/example/path"),
    options: .init(
        bucket: .fromBucketInfo(.init(
            bucketName: "another-bucket-name",
            region: "another-bucket-region")
        )    
    )
)
```
</Block>
</BlockSwitcher>

</InlineFilter>

<InlineFilter filters={["flutter"]}>
## Download to a file

You can download a file to a local directory using `Amplify.Storage.downloadFile`.

You can use the [path_provider](https://pub.dev/packages/path_provider) package to create a local file in the user's documents directory where you can store the downloaded data.

<BlockSwitcher>
<Block name="Mobile & Desktop">

```dart
import 'package:amplify_flutter/amplify_flutter.dart';
import 'package:path_provider/path_provider.dart';

Future<void> downloadFile() async {
  final documentsDir = await getApplicationDocumentsDirectory();
  final filepath = '${documentsDir.path}/example.txt';
  try {
    final result = await Amplify.Storage.downloadFile(
      path: const StoragePath.fromString('public/example.txt'),
      localFile: AWSFile.fromPath(filepath),
    ).result;
    safePrint('Downloaded file is located at: ${result.localFile.path}');
  } on StorageException catch (e) {
    safePrint(e.message);
  }
}
```

</Block>

<Block name="Web">

On Web, the download process will be handled by the browser. You can provide the downloaded file name by specifying the `path` parameter of `AWSFile.fromPath`. E.g. this instructs the browser to download the file `download.txt`.

```dart
import 'package:amplify_flutter/amplify_flutter.dart';

Future<void> downloadFile() async {
  try {
    final result = await Amplify.Storage.downloadFile(
      path: const StoragePath.fromString('public/example.txt'),
      localFile: AWSFile.fromPath('download.txt'),
    ).result;
    safePrint('Downloaded file: ${result.downloadedItem.path}');
  } on StorageException catch (e) {
    safePrint(e.message);
  }
}
```

</Block>

</BlockSwitcher>

</InlineFilter>

<InlineFilter filters={["react", "angular", "javascript", "vue", "nextjs", "react-native"]}>
### Get the text value of downloaded File

You can get the value of file in any of the three formats: `blob`, `json`, or `text`. You can call the respective method on the `body` property to consume the set data in the respective format.

```javascript
import { downloadData } from 'aws-amplify/storage';

try {
  const downloadResult = await downloadData({
    path: "album/2024/1.jpg"
  }).result;
  const text = await downloadResult.body.text();
  // Alternatively, you can use `downloadResult.body.blob()`
  // or `downloadResult.body.json()` get read body in Blob or JSON format.
  console.log('Succeed: ', text);
} catch (error) {
  console.log('Error : ', error);
}
```
</InlineFilter>

<InlineFilter filters={["react", "angular", "javascript", "vue", "nextjs", "react-native"]}>

### Download from a specified bucket

You can also perform an upload operation to a specific bucket by providing the `bucket` option. You can pass in a string representing the target bucket's assigned name in Amplify Backend.

```ts
import { downloadData } from 'aws-amplify/storage';

const result = await downloadData({
  path: 'album/2024/1.jpg',
  options: {
    // highlight-start
    // Specify a target bucket using name assigned in Amplify Backend
    bucket: 'assignedNameInAmplifyBackend'
    // highlight-end
  }
}).result;

```
Alternatively, you can also pass in an object by specifying the bucket name and region from the console.

```ts
import { downloadData } from 'aws-amplify/storage';

const result = await downloadData({
  path: 'album/2024/1.jpg',
  options: {
    // highlight-start
    // Alternatively, provide bucket name from console and associated region
    bucket: {
      bucketName: 'bucket-name-from-console',
      region: 'us-east-2'
    }
    // highlight-end
  }
}).result;

```
### Monitor download progress

```javascript
import { downloadData } from 'aws-amplify/storage';

// Download a file from S3 bucket
const { body, eTag } = await downloadData(
  {
    path: 'album/2024/1.jpg',
    options: {
      onProgress: (progress) {
        console.log(`Download progress: ${(progress.transferredBytes/progress.totalBytes) * 100}%`);
      }
    }
  }
).result;
```

### Cancel download

```javascript
import { downloadData, isCancelError } from 'aws-amplify/storage';

const downloadTask = downloadData({ path: 'album/2024/1.jpg' });
downloadTask.cancel();
try {
  await downloadTask.result;
} catch (error) {
  if (isCancelError(error)) {
    // Handle error thrown by task cancellation.
  }
}
```

</InlineFilter>
<InlineFilter filters={["android"]}>

### Download from a specified bucket

You can also perform a download operation to a specific bucket by providing the `bucket` option. You can pass in a string representing the target bucket's assigned name in Amplify Backend.

<BlockSwitcher>
<Block name="Java">

```java
StorageBucket secondBucket = StorageBucket.fromOutputs("secondBucket");
StorageDownloadFileOptions options = StorageDownloadFileOptions.builder().bucket(secondBucket).build();
Amplify.Storage.downloadFile(
        StoragePath.fromString("public/example"),
        new File(getApplicationContext().getFilesDir() + "/download.txt"),
        options,
        result -> Log.i("MyAmplifyApp", "Successfully downloaded: " + result.getFile().getName()),
        error -> Log.e("MyAmplifyApp",  "Download Failure", error)
);
```

</Block>
<Block name="Kotlin - Callbacks">

```kotlin
val secondBucket = StorageBucket.fromOutputs("secondBucket")
val options = StorageDownloadFileOptions.builder().bucket(secondBucket).build()
val file = File("${applicationContext.filesDir}/download.txt")
Amplify.Storage.downloadFile(StoragePath.fromString("public/example"), file, option,
    { Log.i("MyAmplifyApp", "Successfully downloaded: ${it.file.name}") },
    { Log.e("MyAmplifyApp",  "Download Failure", it) }
)
```

</Block>
<Block name="Kotlin - Coroutines">

```kotlin
val secondBucket = StorageBucket.fromOutputs("secondBucket")
val options = StorageDownloadFileOptions.builder().bucket(secondBucket).build()
val file = File("${applicationContext.filesDir}/download.txt")
val download = Amplify.Storage.downloadFile(StoragePath.fromString("public/example"), file, options)
try {
    val fileName = download.result().file.name
    Log.i("MyAmplifyApp", "Successfully downloaded: $fileName")
} catch (error: StorageException) {
    Log.e("MyAmplifyApp", "Download Failure", error)
}
```

</Block>
<Block name="RxJava">

```java      
StorageBucket secondBucket = StorageBucket.fromOutputs("secondBucket");
StorageDownloadFileOptions options = StorageDownloadFileOptions.builder().bucket(secondBucket).build();
RxProgressAwareSingleOperation<StorageDownloadFileResult> download =
        RxAmplify.Storage.downloadFile(
            StoragePath.fromString("public/example"),
            new File(getApplicationContext().getFilesDir() + "/download.txt"),
            options
        );

download
    .observeResult()
    .subscribe(
        result -> Log.i("MyAmplifyApp", "Successfully downloaded: " + result.getFile().getName()),
        error -> Log.e("MyAmplifyApp",  "Download Failure", error)
    );
```

</Block>
</BlockSwitcher>

Alternatively, you can also pass in an object by specifying the bucket name and region from the console.

<BlockSwitcher>
<Block name="Java">

```java
BucketInfo bucketInfo = new BucketInfo("second-bucket-name-from-console", "us-east-2");
StorageBucket secondBucket = StorageBucket.fromBucketInfo(bucketInfo);
StorageDownloadFileOptions options = StorageDownloadFileOptions.builder().bucket(secondBucket).build();
Amplify.Storage.downloadFile(
        StoragePath.fromString("public/example"),
        new File(getApplicationContext().getFilesDir() + "/download.txt"),
        options,
        result -> Log.i("MyAmplifyApp", "Successfully downloaded: " + result.getFile().getName()),
        error -> Log.e("MyAmplifyApp",  "Download Failure", error)
);
```

</Block>
<Block name="Kotlin - Callbacks">

```kotlin
val bucketInfo = BucketInfo("second-bucket-name-from-console", "us-east-2")
val secondBucket = StorageBucket.fromBucketInfo(bucketInfo)
val options = StorageDownloadFileOptions.builder().bucket(secondBucket).build()
val file = File("${applicationContext.filesDir}/download.txt")
Amplify.Storage.downloadFile(StoragePath.fromString("public/example"), file, options,
    { Log.i("MyAmplifyApp", "Successfully downloaded: ${it.file.name}") },
    { Log.e("MyAmplifyApp",  "Download Failure", it) }
)
```

</Block>
<Block name="Kotlin - Coroutines">

```kotlin
val bucketInfo = BucketInfo("second-bucket-name-from-console", "us-east-2")
val secondBucket = StorageBucket.fromBucketInfo(bucketInfo)
val options = StorageDownloadFileOptions.builder().bucket(secondBucket).build()
val file = File("${applicationContext.filesDir}/download.txt")
val download = Amplify.Storage.downloadFile(StoragePath.fromString("public/example"), file, options)
try {
    val fileName = download.result().file.name
    Log.i("MyAmplifyApp", "Successfully downloaded: $fileName")
} catch (error: StorageException) {
    Log.e("MyAmplifyApp", "Download Failure", error)
}
```

</Block>
<Block name="RxJava">

```java
BucketInfo bucketInfo = new BucketInfo("second-bucket-name-from-console", "us-east-2");
StorageBucket secondBucket = StorageBucket.fromBucketInfo(bucketInfo);
StorageDownloadFileOptions options = StorageDownloadFileOptions.builder().bucket(secondBucket).build();
RxProgressAwareSingleOperation<StorageDownloadFileResult> download =
        RxAmplify.Storage.downloadFile(
            StoragePath.fromString("public/example"),
            new File(getApplicationContext().getFilesDir() + "/download.txt"),
            options,
        );

download
    .observeResult()
    .subscribe(
        result -> Log.i("MyAmplifyApp", "Successfully downloaded: " + result.getFile().getName()),
        error -> Log.e("MyAmplifyApp",  "Download Failure", error)
    );
```

</Block>
</BlockSwitcher>

### Monitor download progress

<BlockSwitcher>
<Block name="Java">

```java
Amplify.Storage.downloadFile(
        StoragePath.fromString("public/example"),
        new File(getApplicationContext().getFilesDir() + "/download.txt"),
        StorageDownloadFileOptions.defaultInstance(),
        progress -> Log.i("MyAmplifyApp", "Fraction completed: " + progress.getFractionCompleted()),
        result -> Log.i("MyAmplifyApp", "Successfully downloaded: " + result.getFile().getName()),
        error -> Log.e("MyAmplifyApp",  "Download Failure", error)
);
```

</Block>
<Block name="Kotlin - Callbacks">

```kotlin
val file = File("${applicationContext.filesDir}/download.txt")
val options = StorageDownloadFileOptions.defaultInstance()
Amplify.Storage.downloadFile(StoragePath.fromString("public/example"), file, options,
    { Log.i("MyAmplifyApp", "Fraction completed: ${it.fractionCompleted}") },
    { Log.i("MyAmplifyApp", "Successfully downloaded: ${it.file.name}") },
    { Log.e("MyAmplifyApp", "Download Failure", it) }
)
```

</Block>
<Block name="Kotlin - Coroutines">

```kotlin
val file = File("${applicationContext.filesDir}/download.txt")
val options = StorageDownloadFileOptions.defaultInstance()
val download = Amplify.Storage.downloadFile(StoragePath.fromString("public/example"), file, options)
val progressJob = activityScope.async {
    download.progress().collect { progress ->
        Log.i("MyAmplifyApp", "Fraction completed: ${progress.fractionCompleted}")
    }
}
try {
    val fileName = download.result().file.name
    Log.i("MyAmplifyApp", "Successfully downloaded: $fileName")
} catch (error: StorageException) {
    Log.e("MyAmplifyApp", "Download Failure", error)
}
progressJob.cancel()
```

</Block>
<Block name="RxJava">

```java
RxProgressAwareSingleOperation<StorageDownloadFileResult> download =
        RxAmplify.Storage.downloadFile(StoragePath.fromString("public/example"), localFile);

download
    .observeProgress()
    .subscribe(
      progress -> Log.i("MyAmplifyApp", progress.getFractionCompleted())
    );
```

</Block>
</BlockSwitcher>

</InlineFilter>

<InlineFilter filters={["flutter"]}>

### Monitor download progress

```dart
final operation = Amplify.Storage.downloadData(
  path: const StoragePath.fromString('public/example.txt'),
  onProgress: (progress) {
    safePrint('fraction totalBytes: ${progress.totalBytes}');
    safePrint('fraction transferredBytes: ${progress.transferredBytes}');
    safePrint('fraction completed: ${progress.fractionCompleted}');
  },
);
```

</InlineFilter>

<InlineFilter filters={["flutter"]}>

### Pause, resume, and cancel downloads

```dart

Future<void> upload() async {
  final operation = Amplify.Storage.downloadFile(
    localFile: AWSFile.fromPath('/path/to/local/file'),
    path: const StoragePath.fromString('public/example.txt'),
  );

  // pause operation
  await operation.pause();

  // resume operation
  await operation.resume();

  // cancel operation
  await operation.cancel();
}

```

</InlineFilter>

<InlineFilter filters={["android"]}>

### Query transfers

When an upload or download operation is requested using the Amplify Android library, the request is first persisted in the local SQLite Database and then queued for execution. You can query the transfer operation queued in the local database using the transfer ID returned by an upload or download API. Get-Transfer API could retrieve a pending transfer previously en-queued and enable attaching a listener to receive updates on progress change, on-error or on-success, or pause, cancel or resume it.
<BlockSwitcher>
<Block name="Java">

```java
Amplify.Storage.getTransfer("TRANSFER_ID",
    operation -> {
        Log.i("MyAmplifyApp", "Current State" + operation.getTransferState());
        // set listener to receive updates
        operation.setOnProgress( progress -> {});
        operation.setOnSuccess( result -> {});
        operation.setOnError(error -> {});

        // possible actions
        operation.pause();
        operation.resume();
        operation.start();
        operation.cancel();
    },
    {
        error -> Log.e("MyAmplifyApp", "Failed to query transfer", error)
    }
);
```

</Block>
<Block name="Kotlin - Callbacks">

```kotlin
Amplify.Storage.getTransfer("TRANSFER_ID",
    { operation ->
        Log.i("MyAmplifyApp", "Current State" + operation.transferState)
        // set listener to receive updates
        operation.setOnProgress {  }
        operation.setOnSuccess {  }
        operation.setOnError {  }

        // possible actions
        operation.pause()
        operation.resume()
        operation.start()
        operation.cancel()
    },
    {
        Log.e("MyAmplifyApp", "Failed to query transfer", it)
    }
)
```

</Block>
<Block name="Kotlin - Coroutines">

```kotlin
try {
    val operation = Amplify.Storage.getTransfer("TRANSFER_ID")
    Log.i("MyAmplifyApp", "Current State" + operation.transferState)
    // set listener to receive updates
    operation.setOnProgress {  }
    operation.setOnSuccess {  }
    operation.setOnError {  }

    // possible actions
    operation.pause()
    operation.resume()
    operation.start()
    operation.cancel()
} catch (error: StorageException) {
    Log.e("MyAmplifyApp", "Failed to query transfer", error)
}
```

</Block>
<Block name="RxJava">

```java
RxAmplify.Storage.getTransfer("TRANSFER_ID")
    .subscribe(
        operation -> {
            Log.i("MyAmplifyApp", "Current State" + operation.getTransferState());
            // set listener to receive updates
            operation.setOnProgress( progress -> {});
            operation.setOnSuccess( result -> {});
            operation.setOnError(error -> {});

            // possible actions
            operation.pause();
            operation.resume();
            operation.start();
            operation.cancel();
        },
        error -> Log.e("MyAmplifyApp", "Failed to query transfer", error);
    );
```

</Block>
</BlockSwitcher>

</InlineFilter>

<InlineFilter filters={["flutter"]}>

## API to download data in memory

You can download a file to in-memory buffer with `Amplify.Storage.downloadData`:

```dart
Future<void> download() async {
  try {
    final result = await Amplify.Storage.downloadData(
      path: const StoragePath.fromString('public/example.txt'),
    ).result;
    safePrint('Downloaded data: ${result.bytes}');
  } on StorageException catch (e) {
    safePrint(e.message);
  }
}
```

## More download options

Option | Type | Description |
| -- | -- | ----------- |
| bucket | StorageBucket | The target bucket from the assigned name in the Amplify Backend or from the bucket name and region in the console<br/><br/>Defaults to the default bucket and region from the Amplify configuration if this option is not provided.<br/><br/>Read more at [Configure additional storage buckets](/[platform]/build-a-backend/storage/set-up-storage/#configure-additional-storage-buckets) |
| getProperties | boolean | Whether to retrieve properties for the downloaded object using theAmplify.Storage.getProperties() after the operation completes. When set to true the returned item will contain additional info such as metadata and content type. |
| useAccelerateEndpoint | boolean | Whether to use accelerate endpoint. <br/><br/> Read more at [Transfer Acceleration](/[platform]/build-a-backend/storage/upload-files/#transfer-acceleration) |
| bytesRange | S3DataBytesRange | The byte range to download from the object |

### Example of `downloadFile` with options

```dart
final operation = Amplify.Storage.downloadFile(
  path: const StoragePath.fromString('public/example.txt'),
  localFile: AWSFile.fromPath('/path/to/local/file.txt'),
  options: const StorageDownloadFileOptions(
    pluginOptions: S3DownloadFilePluginOptions(
      getProperties: true,
      useAccelerateEndpoint: true,
    ),
    bucket: StorageBucket.fromOutputs('secondBucket'),
  ),
);
```

### Example of `downloadData` with options

```dart
final operation = Amplify.Storage.downloadData(
  path: const StoragePath.fromString('public/example.txt'),
  options: StorageDownloadDataOptions(
    pluginOptions: S3DownloadDataPluginOptions(
      getProperties: true,
      useAccelerateEndpoint: true,
      bytesRange: S3DataBytesRange(start: 0, end: 100),
    ),
  ),
);
```

You can also perform a `downloadData` or `downloadFile` operation to a specific bucket by providing the `bucket` option. You can pass in a `StorageBucket` object representing the target bucket from the name defined in the Amplify Backend.

```dart
final operation = Amplify.Storage.downloadFile(
  path: const StoragePath.fromString('public/example.txt'),
  localFile: AWSFile.fromPath('/path/to/local/file.txt'),
  options: const StorageDownloadFileOptions(
    pluginOptions: S3DownloadFilePluginOptions(
      getProperties: true,
      useAccelerateEndpoint: true,
    ),
    bucket: StorageBucket.fromOutputs('secondBucket'),
  ),
);
```

Alternatively, you can also pass in an object by specifying the bucket name and region from the console.

```dart
final operation = Amplify.Storage.downloadData(
  path: const StoragePath.fromString('public/example.txt'),
  options: StorageDownloadDataOptions(
    pluginOptions: S3DownloadDataPluginOptions(
      getProperties: true,
      useAccelerateEndpoint: true,
      bytesRange: S3DataBytesRange(start: 0, end: 100),
    ),
    bucket: StorageBucket.fromBucketInfo(
      BucketInfo(
        bucketName: 'second-bucket-name-from-console',
        region: 'us-east-2',
      ),
    ),
  ),
);
```
</InlineFilter>

<InlineFilter filters={["swift"]}>

### Pause, resume, and cancel downloads

Calls to `downloadData` or `downloadFile` return a reference to the task that is actually performing the download.

You can pause then resume the task or cancel a task as shown below.

```swift
downloadTask.pause()
downloadTask.resume()
downloadTask.cancel()
```

<Callout>

Download tasks are run using `URLSessionTask` instances internally. You can learn more about them in [Apple's official documentation](https://developer.apple.com/documentation/foundation/urlsessiontask).

</Callout>

</InlineFilter>

<InlineFilter filters={["react", "angular", "javascript", "vue", "nextjs", "react-native"]}>

### More download options
The behavior of the `downloadData` API can be customized by passing in options.

```javascript
import { downloadData } from 'aws-amplify/storage';

// Downloads file content to memory
const { body, eTag } = await downloadData({
  path: "album/2024/1.jpg",
  options: {
    // optional bytes range parameter to download a part of the file, the 2nd MB of the file in this example
    bytesRange: {
      start: 1024,
      end: 2048
    },
    useAccelerateEndpoint: true,
  }
}).result;

```

Option | Type | Default | Description |
| :--: | :--: | :--: | ----------- |
| bucket | string \| <br />\{ bucketName: string;<br/> region: string; \} | Default bucket and region from Amplify configuration | A string representing the target bucket's assigned name in Amplify Backend or an object specifying the bucket name and region from the console.<br/><br/>Read more at [Configure additional storage buckets](/[platform]/build-a-backend/storage/set-up-storage/#configure-additional-storage-buckets) |
| onProgress | callback | — | Callback function tracking the upload/download progress. |
| bytesRange |  \{ start: number; end:number; \} | — | Bytes range parameter to download a part of the file. |
| useAccelerateEndpoint | boolean | false | Whether to use accelerate endpoint.<br/><br/>Read more at [Transfer Acceleration](/[platform]/build-a-backend/storage/extend-s3-resources/#example---enable-transfer-acceleration) |
| expectedBucketOwner | string | Optional | The account ID that owns requested bucket. |

## Frequently Asked Questions

- `downloadData` is cached; if you have recently modified a file you may not get the latest version right away. You can pass in `cacheControl: 'no-cache'` to get the latest version.
- `downloadData` only returns the latest cached version of the file; there is [not yet an API to view prior versions](https://github.com/aws-amplify/amplify-js/issues/2131).
- [Image compression](https://github.com/aws-amplify/amplify-js/issues/6081) or CloudFront CDN caching for your S3 buckets is not yet possible.
- There is no API for [Cognito Group-based access to files](https://github.com/aws-amplify/amplify-js/issues/3388).
- There is currently [no API for getting the `identityId` of other users](https://github.com/aws-amplify/amplify-js/issues/5177); you have to retrieve this from elsewhere before calling `Storage.get`.

</InlineFilter>


Contents of build-a-backend_storage_extend-s3-resources_index.txt:
import { getCustomStaticPath } from '@/utils/getCustomStaticPath';

export const meta = {
  title: 'Extend S3 resources',
  description: 'Extend configuration for S3 resources',
  platforms: [
    'angular',
    'javascript',
    'nextjs',
    'react',
    'vue',
    'swift',
    'android',
    'flutter',
    'react-native'
  ]
};

export const getStaticPaths = async () => {
  return getCustomStaticPath(meta.platforms);
};

export function getStaticProps(context) {
  return {
    props: {
      platform: context.params.platform,
      meta
    }
  };
}

## For Amplify-generated S3 resources

Amplify Storage generates Amazon S3 resources to offer storage features. You can access the underlying Amazon S3 resources to further customize your backend configuration by using the AWS Cloud Developer Kit (AWS CDK).

### Example - Enable Transfer Acceleration

The following is an example of how you would enable Transfer Acceleration on the bucket ([CDK documentation](https://docs.aws.amazon.com/cdk/api/v2/docs/aws-cdk-lib.aws_s3.CfnBucket.AccelerateConfigurationProperty.html)). In order to enable Transfer Acceleration on the bucket, you will have to unwrap the L1 CDK construct from the L2 CDK construct like the following.

```tsx
// highlight-next-line
import * as s3 from 'aws-cdk-lib/aws-s3';
import { defineBackend } from '@aws-amplify/backend';
import { storage } from './storage/resource';

const backend = defineBackend({
  storage
});

// highlight-start
const s3Bucket = backend.storage.resources.bucket;

const cfnBucket = s3Bucket.node.defaultChild as s3.CfnBucket;

cfnBucket.accelerateConfiguration = {
  accelerationStatus: "Enabled" // 'Suspended' if you want to disable transfer acceleration
}
// highlight-end
```
<InlineFilter filters={['android']}>

### Upload files using the accelerated S3 endpoint

We switch to the accelerated S3 endpoint by using the `useAccelerateEndpoint` parameter set to `true` in the `AWSS3StorageUploadFileOptions`.

<BlockSwitcher>
<Block name="Java">

```java
AWSS3StorageUploadFileOptions awsS3StorageUploadFileOptions =
              AWSS3StorageUploadFileOptions.builder().setUseAccelerateEndpoint(true).build();
 Amplify.Storage.uploadFile(
   StoragePath.fromString("public/example"),
   file
   awsS3StorageUploadFileOptions,
   result -> Log.i("MyAmplifyApp", "Successfully uploaded: " + result.getPath()),
   storageFailure -> Log.e("MyAmplifyApp", "Upload failed", storageFailure)
);
```
</Block>
<Block name="Kotlin - Callbacks">

```kotlin
val awsS3StorageUploadFileOptions = AWSS3StorageUploadFileOptions.builder().
                                                  setUseAccelerateEndpoint(true).
                                                  build()
 Amplify.Storage.uploadFile(
   StoragePath.fromString("public/example"),
   file
   awsS3StorageUploadFileOptions,
   { Log.i("MyAmplifyApp", "Successfully uploaded: " + it.getPath()) },
   { Log.e("MyAmplifyApp", "Upload failed", it) }
)
```
</Block>
<Block name="Kotlin - Coroutines">

```kotlin
val awsS3StorageUploadFileOptions = AWSS3StorageUploadFileOptions.builder().
                                                    setUseAccelerateEndpoint(true).
                                                    build()
val upload = Amplify.Storage.uploadFile(StoragePath.fromString("public/example"), file, awsS3StorageUploadFileOptions)
try {
    val result = upload.result()
    Log.i("MyAmplifyApp", "Successfully uploaded: ${result.path}")
} catch (error: StorageException) {
    Log.e("MyAmplifyApp", "Upload failed", error)
}

```
</Block>
<Block name="RxJava">

```java
AWSS3StorageUploadFileOptions awsS3StorageUploadFileOptions =
            AWSS3StorageUploadFileOptions.builder().setUseAccelerateEndpoint(true).build();
RxProgressAwareSingleOperation<StorageUploadFileResult> rxUploadOperation =
            RxAmplify.Storage.uploadFile(StoragePath.fromString("public/example"), file, awsS3StorageUploadFileOptions);
rxUploadOperation
            .observeResult()
            .subscribe(
                result -> Log.i("MyAmplifyApp", "Successfully uploaded: " + result.getPath()),
                error -> Log.e("MyAmplifyApp", "Upload failed", error)
            );

```
</Block>
</BlockSwitcher>
</InlineFilter>

<InlineFilter filters={["swift"]}>

### Upload files using the accelerated S3 endpoint

You can use transfer acceleration by setting `"useAccelerateEndpoint"` to `true` in the corresponding `pluginOptions` for any of the following Storage APIs:
- `getUrl(key:options:)`
- `downloadData(key:options:)`
- `downloadFile(key:local:options:)`
- `uploadData(key:data:options:)`
- `uploadFile(key:local:options:)`

For example, to upload a file using transfer acceleration:

```swift
let uploadTask = Amplify.Storage.uploadFile(
    key: aKey,
    local: aLocalFile,
    options: .init(
        pluginOptions: [
            "useAccelerateEndpoint": true
        ]
    )
)

let data = try await uploadTask.value
```

</InlineFilter>

<InlineFilter filters={['flutter']}>

### Upload files using the accelerated S3 endpoint

You can use transfer acceleration when calling the following APIs:

* `getUrl`
* `downloadData`
* `downloadFile`
* `uploadData`
* `uploadFile`

Set `useAccelerateEndpoint` to `true` in the corresponding Storage S3 plugin options to apply an accelerated S3 endpoint to the operation. For example, upload a file using transfer acceleration:

```dart
import 'package:amplify_storage_s3/amplify_storage_s3.dart';

Future<void> uploadFileUsingAcceleration(String filePath, String key) async {
  final localFile = AWSFile.fromPath(filePath);
  try {
    final uploadFileOperation = Amplify.Storage.uploadFile(
      localFile: localFile,
      key: key,
      options: const StorageUploadFileOptions(
        pluginOptions: S3UploadFilePluginOptions(
          useAccelerateEndpoint: true,
        ),
      ),
    );

    final result = await uploadFileOperation.result;
    safePrint('Uploaded file: ${result.uploadedItem.key}');
  } on StorageException catch (error) {
    safePrint('Something went wrong uploading file: ${error.message}');
  }
}
```

</InlineFilter>

Read more about [escape hatches in the CDK](https://docs.aws.amazon.com/cdk/v2/guide/cfn_layer.html#develop-customize-escape).

<InlineFilter filters={["react", "angular", "javascript", "vue", "nextjs", "react-native", "flutter"]}>

## For Manually configured S3 resources

<InlineFilter filters={["flutter"]}>

Follow this guide if you are building against a web target.

</InlineFilter>

<Callout warning>

To make calls to your S3 bucket from your App, you need to set up a CORS Policy for your S3 bucket. This callout is only for manual configuration of your S3 bucket.

</Callout>

The following steps will set up your CORS Policy:

1. Go to [Amazon S3 console](https://s3.console.aws.amazon.com/s3/home?region=us-east-1) and click on your project's `userfiles` bucket, which is normally named as [Bucket Name][Id]-dev. ![Go to [Amazon S3 Console]](/images/storage/CORS1.png)
2. Click on the **Permissions** tab for your bucket. ![Click on the **Permissions** tab for your bucket](/images/storage/CORS2.png)
3. Click the edit button in the **Cross-origin resource sharing (CORS)** section. ![Click the edit button in the **Cross-origin resource sharing (CORS)** section](/images/storage/CORS3.png)
4. Make the Changes and click on Save Changes. You can add required metadata to be exposed in `ExposeHeaders` with `x-amz-meta-XXXX` format. ![Click on Save Changes:](/images/storage/CORS4.png)

```json
[
  {
    "AllowedHeaders": ["*"],
    "AllowedMethods": ["GET", "HEAD", "PUT", "POST", "DELETE"],
    "AllowedOrigins": ["*"],
    "ExposeHeaders": [
      "x-amz-server-side-encryption",
      "x-amz-request-id",
      "x-amz-id-2",
      "ETag",
      "x-amz-meta-foo"
    ],
    "MaxAgeSeconds": 3000
  }
]
```

<Callout>

**Note:** You can restrict the access to your bucket by updating AllowedOrigin to include individual domains.

</Callout>

</InlineFilter>


Contents of build-a-backend_storage_index.txt:
import { getCustomStaticPath } from '@/utils/getCustomStaticPath';
import { getChildPageNodes } from '@/utils/getChildPageNodes';

export const meta = {
  title: 'Storage',
  description: 'Set up and connect to storage.',
  route: '/[platform]/build-a-backend/storage',
  platforms: [
    'angular',
    'javascript',
    'nextjs',
    'react',
    'vue',
    'swift',
    'android',
    'flutter',
    'react-native'
  ]
};

export const getStaticPaths = async () => {
  return getCustomStaticPath(meta.platforms);
};

export function getStaticProps(context) {
  const childPageNodes = getChildPageNodes(meta.route);
  return {
    props: {
      meta,
      childPageNodes
    }
  };
}

<Overview childPageNodes={props.childPageNodes} />


Contents of build-a-backend_storage_lambda-triggers_index.txt:
import { getCustomStaticPath } from '@/utils/getCustomStaticPath';

export const meta = {
  title: 'Listen to storage events',
  description: 'Set up triggers on Storage events',
  platforms: [
    'angular',
    'javascript',
    'nextjs',
    'react',
    'vue',
    'swift',
    'android',
    'flutter',
    'react-native'
  ]
};

export const getStaticPaths = async () => {
  return getCustomStaticPath(meta.platforms);
};

export function getStaticProps(context) {
  return {
    props: {
      platform: context.params.platform,
      meta
    }
  };
}

Function triggers can be configured to enable event-based workflows when files are uploaded or deleted. To add a function trigger, modify the `defineStorage` configuration.

First, in your storage definition, add the following:

```ts title="amplify/storage/resource.ts"
export const storage = defineStorage({
  name: 'myProjectFiles',
  // highlight-start
  triggers: {
    onUpload: defineFunction({
      entry: './on-upload-handler.ts'
    }),
    onDelete: defineFunction({
      entry: './on-delete-handler.ts'
    })
  }
  // highlight-end
});
```

Then create the function definitions at `amplify/storage/on-upload-handler.ts` and `amplify/storage/on-delete-handler.ts`.

```ts title="amplify/storage/on-upload-handler.ts"
import type { S3Handler } from 'aws-lambda';

export const handler: S3Handler = async (event) => {
  const objectKeys = event.Records.map((record) => record.s3.object.key);
  console.log(`Upload handler invoked for objects [${objectKeys.join(', ')}]`);
};
```

```ts title="amplify/storage/on-delete-handler.ts"
import type { S3Handler } from 'aws-lambda';

export const handler: S3Handler = async (event) => {
  const objectKeys = event.Records.map((record) => record.s3.object.key);
  console.log(`Delete handler invoked for objects [${objectKeys.join(', ')}]`);
};
```

<Callout info>

**Note:** The `S3Handler` type comes from the [`@types/aws-lambda`](https://www.npmjs.com/package/@types/aws-lambda) npm package. This package contains types for different kinds of Lambda handlers, events, and responses.

</Callout>

Now, when you deploy your backend, these functions will be invoked whenever an object is uploaded or deleted from the bucket.

## More Advanced Triggers

The example listed above demonstrates what is exposed directly in your `storage` definition. Specifically, the use of the `triggers` option when you use `defineStorage`. This method is for simple triggers that always execute on file uploads or file deletions. There are no additional modifications you can make to the triggers defined in this way.

If you want the ability to do something more than simply handle the events `onUpload` and `onDelete` you will have to use `.addEventNotification` in your `backend.ts`. If you use this method, the `triggers` section in your `storage/resource.ts` file should be removed.

Here is an example of how you can add a Lambda trigger for an S3 object PUT event. This trigger will execute when a file that has been uploaded to the bucket defined in your `storage/resource.ts` has a matching prefix and suffix as that listed in the function input of `addEventNotification`.

```ts title="amplify/backend.ts"
import { EventType } from 'aws-cdk-lib/aws-s3';
import { LambdaDestination } from 'aws-cdk-lib/aws-s3-notifications';
import { defineBackend } from '@aws-amplify/backend';
import { storage } from './storage/resource';
import { yourLambda } from './functions/yourLambda/resource';

const backend = defineBackend({
  storage,
  yourLambda,
});

backend.storage.resources.bucket.addEventNotification(
	EventType.OBJECT_CREATED_PUT,
	new LambdaDestination(backend.yourLambda.resources.lambda),
	{
		prefix: 'protected/uploads/',
		suffix: '-uploadManifest.json',
	}
);
```

It's important to note that using this methodology does not require any changes your lambda function. This modification on your `backend.ts` file will create a new `AWS CloudFormation handler for "Custom::S3BucketNotifications" resources (@aws-cdk/aws-s3)` that specifically handles checking the prefix and suffix.


Contents of build-a-backend_storage_list-files_index.txt:
import { getCustomStaticPath } from '@/utils/getCustomStaticPath';

export const meta = {
  title: 'List file properties',
  description: 'Get list of files or file properties using Amplify Storage',
  platforms: [
    'angular',
    'javascript',
    'nextjs',
    'react',
    'vue',
    'swift',
    'android',
    'flutter',
    'react-native'
  ]
};

export const getStaticPaths = async () => {
  return getCustomStaticPath(meta.platforms);
};

export function getStaticProps(context) {
  return {
    props: {
      platform: context.params.platform,
      meta
    }
  };
}

You can list files without having to download all the files. You can do this by using the `list` API from the Amplify Library for Storage. <InlineFilter filters={["react", "angular", "javascript", "vue", "nextjs", "react-native"]}>You can also get properties individually for a file using the `getProperties` API.</InlineFilter>

## List Files

<InlineFilter filters={["react", "angular", "javascript", "vue", "nextjs", "react-native"]}>
```javascript
import { list } from 'aws-amplify/storage';

const result = await list({
	path: 'album/photos/',
  // Alternatively, path: ({identityId}) => `album/{identityId}/photos/`
});
```

Note the trailing slash `/` - if you had requested `list({ path :  'album/photos' })` it would also match against files like `album/photos123.jpg` alongside `album/photos/123.jpg`.

The format of the response will look similar to the below example:

```js
{
  items: [
    {
      path: "album/photos/123.jpg",
      eTag: "30074401292215403a42b0739f3b5262",
      lastModified: "Thu Oct 08 2020 23:59:31 GMT+0800 (Singapore Standard Time)",
      size: 138256
    },
    // ...
  ],
}
````

If the `pageSize` is set lower than the total file size, a single `list` call only returns a subset of all the files. To list all the files with multiple calls, users can use the `nextToken` flag:

```javascript
import { list } from 'aws-amplify/storage';

const PAGE_SIZE = 20;
let nextToken;
// ...
const loadNextPage = async () => {
  const response = await list({
    path: 'photos/',
    // Alternatively, path: ({ identityId }) => `album/{identityId}/photos/`
    options: {
      pageSize: PAGE_SIZE,
      nextToken,
    },
  });
  if (response.nextToken) {
    nextToken = response.nextToken;
  } else {
    nextToken = undefined;
  }
  // render list items from response.items
};
```

### List All files
```javascript
import { list } from 'aws-amplify/storage';

const result = await list({
	path: 'album/photos/',
  // Alternatively, path: ({identityId}) => `album/{identityId}/photos/`,
  options: {
    listAll: true,
  }
});
```


{/* in other files we're referring to paths instead of folders, can we be consistent on terminology? */} Manually created folders will show up as files with a `size` of 0, but you can also match keys against a regex like `file.key.match(/\.[0-9a-z]+$/i)` to distinguish files from folders. Since "folders" are a virtual concept in Amazon S3, any file may declare any depth of folder just by having a `/` in its name.

To access the contents and subpaths of a "folder", you have two options:

1. Request the entire path and parse the contents.
2. Use the subpathStrategy option to retrieve only the files within the specified path (i.e. exclude files under subpaths).

### Get all nested files within a path

This retrieves all files and folders under a given path. You may need to parse the result to get only the files within the specified path.

```js
function processStorageList(response) {
  let files = [];
  let folders = new Set();
  response.items.forEach((res) => {
    if (res.size) {
      files.push(res);
      // sometimes files declare a folder with a / within then
      let possibleFolder = res.path.split('/').slice(0, -1).join('/');
      if (possibleFolder) folders.add(possibleFolder);
    } else {
      folders.add(res.path);
    }
  });
  return { files, folders };
}
```

If you need the files and folders in terms of a nested object instead (for example, to build an explorer UI), you could parse it recursively:

```js
function processStorageList(response) {
  const filesystem = {};
  // https://stackoverflow.com/questions/44759750/how-can-i-create-a-nested-object-representation-of-a-folder-structure
  const add = (source, target, item) => {
    const elements = source.split('/');
    const element = elements.shift();
    if (!element) return; // blank
    target[element] = target[element] || { __data: item }; // element;
    if (elements.length) {
      target[element] =
        typeof target[element] === 'object' ? target[element] : {};
      add(elements.join('/'), target[element], item);
    }
  };
  response.items.forEach((item) => add(item.path, filesystem, item));
  return filesystem;
}
```

This places each item's data inside a special `__data` key.

### Excluding subpaths

In addition to using the `list` API to get all the contents of a path, you can also use it to get only the files within a path while excluding files under subpaths.

For example, given the following keys in your `path` you may want to return only the jpg object, and not the "vacation" subpath and its contents:

```
photos/photo1.jpg
photos/vacation/
```

This can be accomplished with the `subpathStrategy` option:

```ts title="src/main.ts"
import { list } from "aws-amplify/storage";
const result = await list({ 
  path: "photos/",
  options:{
    subpathStrategy: { strategy:'exclude' }
  }
});
```

The response will include only the objects within the `photos/` path and will also communicate any excluded subpaths:

```js
{
    excludedSubpaths: [
      'photos/vacation/'
    ],
    items: [
      {
        path: "photos/photo1.jpg",
        eTag: "30074401292215403a42b0739f3b5262",
        lastModified: "Thu Oct 08 2020 23:59:31 GMT+0800 (Singapore Standard Time)",
        size: 138256
      },
    ]
}
```

The default delimiter character is '/', but this can be changed by supplying a custom delimiter:

```ts title="src/main.ts"
const result = await list({
  // Path uses '-' character to organize files rather than '/'
  path: 'photos-',
  options: {
    subpathStrategy: {
      strategy: 'exclude',
      delimiter: '-'
    }
  }
});
```

### List files from a specified bucket

You can also perform an `copy` operation to a specific bucket by providing the `bucket` option. This option can either be a string representing the target bucket's assigned name in Amplify Backend or an object specifying the bucket name and region from the console.

```ts
import { list } from 'aws-amplify/storage';

const result = await list({
  path: 'photos/',
  options: {
    // Specify a target bucket using name assigned in Amplify Backend
    bucket: 'assignedNameInAmplifyBackend',
    // Alternatively, provide bucket name from console and associated region
    // bucket: {
    //   bucketName: 'generated-secondary-bucket-name',
    //   region: 'us-east-2'
    // }
  }
});
```

### More `list` options

| Option | Type | Default | Description |
| -- | :--: | :--: | ----------- |
| bucket | string \| <br />\{ bucketName: string;<br/> region: string; \} | Default bucket and region from Amplify configuration | A string representing the target bucket's assigned name in Amplify Backend or an object specifying the bucket name and region from the console.<br/><br/>Read more at [Configure additional storage buckets](/[platform]/build-a-backend/storage/set-up-storage/#configure-additional-storage-buckets) |
| listAll | boolean | false | Set to true to list all files within the specified `path` |
| pageSize | number | 1000 | Sets the maximum number of files to be return. The range is 0 - 1000 |
| nextToken | string | — | Indicates whether the list is being continued on this bucket with a token |
| subpathStrategy | \{ strategy: 'include' \} \|<br/>\{ 'exclude',<br />delimiter?: string \} | \{ strategy: 'include' \} | An object representing the subpath inclusion strategy and the delimiter used to group results for exclusion. <br/><br/> Read more at [Excluding subpaths](/[platform]/build-a-backend/storage/list-files/#excluding-subpaths) |
| useAccelerateEndpoint | boolean | false | Whether to use accelerate endpoint. <br/><br/> Read more at [Transfer Acceleration](/[platform]/build-a-backend/storage/extend-s3-resources/#example---enable-transfer-acceleration) |
| expectedBucketOwner | string | Optional | The account ID that owns requested bucket. |

</InlineFilter>

<InlineFilter filters={["android"]}>
The following example lists all objects inside the `public/photos/` path:

<BlockSwitcher>
<Block name="Java">

```java
StoragePagedListOptions options = StoragePagedListOptions.builder()
    .setPageSize(1000)
    .build();

Amplify.Storage.list(
    StoragePath.fromString("public/photos/"),
    options,
    result -> {
        for (StorageItem item : result.getItems()) {
            Log.i("MyAmplifyApp", "Item: " + item.getPath());
        }
        Log.i("MyAmplifyApp", "Next Token: " + result.getNextToken());
    },
    error -> Log.e("MyAmplifyApp", "List failure", error);
);
```

</Block>
<Block name="Kotlin - Callbacks">

```kotlin
val options = StoragePagedListOptions.builder()
    .setPageSize(1000)
    .build()

Amplify.Storage.list(StoragePath.fromString("public/photos/"), options,
    { result ->
        result.items.forEach { item ->
            Log.i("MyAmplifyApp", "Item: ${item.path}")
        }
        Log.i("MyAmplifyApp", "Next Token: ${result.nextToken}")
    },
    { Log.e("MyAmplifyApp", "List failure", it) }
)
```

</Block>
<Block name="Kotlin - Coroutines">

```kotlin
val options = StoragePagedListOptions.builder()
    .setPageSize(1000)
    .build()

try {
    val result = Amplify.Storage.list(StoragePath.fromString("public/photos/"), options)
    result.items.forEach {
        Log.i("MyAmplifyApp", "Item: $it")
    }
    Log.i("MyAmplifyApp", "next token: ${result.nextToken}")
} catch (error: StorageException) {
    Log.e("MyAmplifyApp", "List failure", error)
}
```

</Block>
<Block name="RxJava">

```java
StoragePagedListOptions options = StoragePagedListOptions.builder()
        .setPageSize(1000)
        .build();

RxAmplify.Storage.list(StoragePath.fromString("public/photos/"), options)
        .subscribe(
            result -> {
                for (StorageItem item : result.getItems()) {
                    Log.i("MyAmplifyApp", "Item: " + item.getPath());
                }
                Log.i("MyAmplifyApp", "Next Token: " + result.getNextToken());
            },
            error -> Log.e("MyAmplifyApp", "List failure", error);
        );
```

</Block>
</BlockSwitcher>

<Callout>
Note the trailing slash `/` in the given path.

If you had used `public/photos` as path, it would also match against files like `public/photos01.jpg`.
</Callout>

### List files from a specified bucket

You can also perform a list operation to a specific bucket by providing the `bucket` option. You can pass in a string representing the target bucket's assigned name in Amplify Backend.

<BlockSwitcher>
<Block name="Java">

```java
StorageBucket secondBucket = StorageBucket.fromOutputs("secondBucket");
StoragePagedListOptions options = StoragePagedListOptions.builder()
    .setPageSize(1000)
    .bucket(secondBucket)
    .build();

Amplify.Storage.list(
    StoragePath.fromString("public/photos/"),
    options,
    result -> {
        for (StorageItem item : result.getItems()) {
            Log.i("MyAmplifyApp", "Item: " + item.getPath());
        }
        Log.i("MyAmplifyApp", "Next Token: " + result.getNextToken());
    },
    error -> Log.e("MyAmplifyApp", "List failure", error);
);
```

</Block>
<Block name="Kotlin - Callbacks">

```kotlin
val secondBucket = StorageBucket.fromOutputs("secondBucket")
val options = StoragePagedListOptions.builder()
    .setPageSize(1000)
    .bucket(secondBucket)
    .build()

Amplify.Storage.list(StoragePath.fromString("public/photos/"), options,
    { result ->
        result.items.forEach { item ->
            Log.i("MyAmplifyApp", "Item: ${item.path}")
        }
        Log.i("MyAmplifyApp", "Next Token: ${result.nextToken}")
    },
    { Log.e("MyAmplifyApp", "List failure", it) }
)
```

</Block>
<Block name="Kotlin - Coroutines">

```kotlin
val secondBucket = StorageBucket.fromOutputs("secondBucket")
val options = StoragePagedListOptions.builder()
    .setPageSize(1000)
    .bucket(secondBucket)
    .build()

try {
    val result = Amplify.Storage.list(StoragePath.fromString("public/photos/"), options)
    result.items.forEach {
        Log.i("MyAmplifyApp", "Item: $it")
    }
    Log.i("MyAmplifyApp", "next token: ${result.nextToken}")
} catch (error: StorageException) {
    Log.e("MyAmplifyApp", "List failure", error)
}
```

</Block>
<Block name="RxJava">

```java      
StorageBucket secondBucket = StorageBucket.fromOutputs("secondBucket");
StoragePagedListOptions options = StoragePagedListOptions.builder()
        .setPageSize(1000)
        .bucket(secondBucket)
        .build();

RxAmplify.Storage.list(StoragePath.fromString("public/photos/"), options)
        .subscribe(
            result -> {
                for (StorageItem item : result.getItems()) {
                    Log.i("MyAmplifyApp", "Item: " + item.getPath());
                }
                Log.i("MyAmplifyApp", "Next Token: " + result.getNextToken());
            },
            error -> Log.e("MyAmplifyApp", "List failure", error);
        );
```

</Block>
</BlockSwitcher>

Alternatively, you can also pass in an object by specifying the bucket name and region from the console.

<BlockSwitcher>
<Block name="Java">

```java
BucketInfo bucketInfo = new BucketInfo("second-bucket-name-from-console", "us-east-2");
StorageBucket secondBucket = StorageBucket.fromBucketInfo(bucketInfo);
StoragePagedListOptions options = StoragePagedListOptions.builder()
    .setPageSize(1000)
    .bucket(secondBucket)
    .build();

Amplify.Storage.list(
    StoragePath.fromString("public/photos/"),
    options,
    result -> {
        for (StorageItem item : result.getItems()) {
            Log.i("MyAmplifyApp", "Item: " + item.getPath());
        }
        Log.i("MyAmplifyApp", "Next Token: " + result.getNextToken());
    },
    error -> Log.e("MyAmplifyApp", "List failure", error);
);
```

</Block>
<Block name="Kotlin - Callbacks">

```kotlin
val bucketInfo = BucketInfo("second-bucket-name-from-console", "us-east-2")
val secondBucket = StorageBucket.fromBucketInfo(bucketInfo)
val options = StoragePagedListOptions.builder()
    .setPageSize(1000)
    .bucket(secondBucket)
    .build()

Amplify.Storage.list(StoragePath.fromString("public/photos/"), options,
    { result ->
        result.items.forEach { item ->
            Log.i("MyAmplifyApp", "Item: ${item.path}")
        }
        Log.i("MyAmplifyApp", "Next Token: ${result.nextToken}")
    },
    { Log.e("MyAmplifyApp", "List failure", it) }
)
```

</Block>
<Block name="Kotlin - Coroutines">

```kotlin
val bucketInfo = BucketInfo("second-bucket-name-from-console", "us-east-2")
val secondBucket = StorageBucket.fromBucketInfo(bucketInfo)
val options = StoragePagedListOptions.builder()
    .setPageSize(1000)
    .bucket(secondBucket)
    .build()

try {
    val result = Amplify.Storage.list(StoragePath.fromString("public/photos/"), options)
    result.items.forEach {
        Log.i("MyAmplifyApp", "Item: $it")
    }
    Log.i("MyAmplifyApp", "next token: ${result.nextToken}")
} catch (error: StorageException) {
    Log.e("MyAmplifyApp", "List failure", error)
}
```

</Block>
<Block name="RxJava">

```java
BucketInfo bucketInfo = new BucketInfo("second-bucket-name-from-console", "us-east-2");
StorageBucket secondBucket = StorageBucket.fromBucketInfo(bucketInfo);
StoragePagedListOptions options = StoragePagedListOptions.builder()
        .setPageSize(1000)
        .bucket(secondBucket)
        .build();

RxAmplify.Storage.list(StoragePath.fromString("public/photos/"), options)
        .subscribe(
            result -> {
                for (StorageItem item : result.getItems()) {
                    Log.i("MyAmplifyApp", "Item: " + item.getPath());
                }
                Log.i("MyAmplifyApp", "Next Token: " + result.getNextToken());
            },
            error -> Log.e("MyAmplifyApp", "List failure", error);
        );
```

</Block>
</BlockSwitcher>

### Exclude results from nested subpaths

By default, the `list` API will return all objects contained within the given path, including objects inside nested subpaths.

For example, the previous `public/photos/` path would include these objects:

```bash
Path: public/photos/photo1.jpg
Path: public/photos/vacation/photo1.jpg
Path: public/photos/thumbnails/photo1.jpg
```

In order to exclude objects within the `vacation` and `thumbnails` subpaths, you can set the `subpathStrategy` option to `SubpathStrategy.Exclude()`:

<BlockSwitcher>
<Block name="Java">

```java
StoragePagedListOptions options = StoragePagedListOptions.builder()
    .setPageSize(1000)
    .setSubpathStrategy(SubpathStrategy.Exclude())
    .build();

Amplify.Storage.list(
    StoragePath.fromString("public/photos/"),
    options,
    result -> {
        for (StorageItem item : result.getItems()) {
            Log.i("MyAmplifyApp", "Item: " + item.getPath());
        }
        Log.i("MyAmplifyApp", "Next Token: " + result.getNextToken());
    },
    error -> Log.e("MyAmplifyApp", "List failure", error);
);
```

</Block>
<Block name="Kotlin - Callbacks">

```kotlin
val options = StoragePagedListOptions.builder()
    .setPageSize(1000)
    .setSubpathStrategy(SubpathStrategy.Exclude())
    .build()

Amplify.Storage.list(StoragePath.fromString("public/photos/"), options,
    { result ->
        result.items.forEach { item ->
            Log.i("MyAmplifyApp", "Item: ${item.path}")
        }
        Log.i("MyAmplifyApp", "Next Token: ${result.nextToken}")
    },
    { Log.e("MyAmplifyApp", "List failure", it) }
)
```

</Block>
<Block name="Kotlin - Coroutines">

```kotlin
val options = StoragePagedListOptions.builder()
    .setPageSize(1000)
    .setSubpathStrategy(SubpathStrategy.Exclude())
    .build()

try {
    val result = Amplify.Storage.list(StoragePath.fromString("public/photos/"), options)
    result.items.forEach {
        Log.i("MyAmplifyApp", "Item: $it")
    }
    Log.i("MyAmplifyApp", "next token: ${result.nextToken}")
} catch (error: StorageException) {
    Log.e("MyAmplifyApp", "List failure", error)
}
```

</Block>
<Block name="RxJava">

```java
StoragePagedListOptions options = StoragePagedListOptions.builder()
        .setPageSize(1000)
        .setSubpathStrategy(SubpathStrategy.Exclude())
        .build();

RxAmplify.Storage.list(StoragePath.fromString("public/photos/"), options)
        .subscribe(
            result -> {
                for (StorageItem item : result.getItems()) {
                    Log.i("MyAmplifyApp", "Item: " + item.getPath());
                }
                Log.i("MyAmplifyApp", "Next Token: " + result.getNextToken());
            },
            error -> Log.e("MyAmplifyApp", "List failure", error);
        );
```

</Block>
</BlockSwitcher>

The response will only include objects within the `public/photos/` path and will also provide a list of the excluded subpaths:

```bash
Path: public/photos/photo01.jpg
Subpath: public/photos/vacation/
Subpath: public/photos/thumbnails/
```

The default delimiter character is `"/"`, but this can be changed by supplying a custom delimiter:

<BlockSwitcher>
<Block name="Java">

```java
StoragePagedListOptions options = StoragePagedListOptions.builder()
    .setPageSize(1000)
    .setSubpathStrategy(SubpathStrategy.Exclude("-"))
    .build();

Amplify.Storage.list(
    StoragePath.fromString("public/photos/"),
    options,
    result -> {
        for (StorageItem item : result.getItems()) {
            Log.i("MyAmplifyApp", "Item: " + item.getPath());
        }
        Log.i("MyAmplifyApp", "Next Token: " + result.getNextToken());
    },
    error -> Log.e("MyAmplifyApp", "List failure", error);
);
```

</Block>
<Block name="Kotlin - Callbacks">

```kotlin
val options = StoragePagedListOptions.builder()
    .setPageSize(1000)
    .setSubpathStrategy(SubpathStrategy.Exclude("-"))
    .build()

Amplify.Storage.list(StoragePath.fromString("public/photos/"), options,
    { result ->
        result.items.forEach { item ->
            Log.i("MyAmplifyApp", "Item: ${item.path}")
        }
        Log.i("MyAmplifyApp", "Next Token: ${result.nextToken}")
    },
    { Log.e("MyAmplifyApp", "List failure", it) }
)
```

</Block>
<Block name="Kotlin - Coroutines">

```kotlin
val options = StoragePagedListOptions.builder()
    .setPageSize(1000)
    .setSubpathStrategy(SubpathStrategy.Exclude("-"))
    .build()

try {
    val result = Amplify.Storage.list(StoragePath.fromString("public/photos/"), options)
    result.items.forEach {
        Log.i("MyAmplifyApp", "Item: $it")
    }
    Log.i("MyAmplifyApp", "next token: ${result.nextToken}")
} catch (error: StorageException) {
    Log.e("MyAmplifyApp", "List failure", error)
}
```

</Block>
<Block name="RxJava">

```java
StoragePagedListOptions options = StoragePagedListOptions.builder()
        .setPageSize(1000)
        .setSubpathStrategy(SubpathStrategy.Exclude("-"))
        .build();

RxAmplify.Storage.list(StoragePath.fromString("public/photos/"), options)
        .subscribe(
            result -> {
                for (StorageItem item : result.getItems()) {
                    Log.i("MyAmplifyApp", "Item: " + item.getPath());
                }
                Log.i("MyAmplifyApp", "Next Token: " + result.getNextToken());
            },
            error -> Log.e("MyAmplifyApp", "List failure", error);
        );
```

</Block>
</BlockSwitcher>

The response will only include objects within the `public/photos/` path not grouped by the delimiter `-`.

```bash
Path: public/photos/2023/photos01.jpg
Path: public/photos/2024/photos02.jpg
Subpath: public/photos/202-
```

### All `list` options

| Option | Type | Description |
| --- | --- | --- |
| subpathStrategy | SubpathStrategy | The strategy to use when listing contents from subpaths. |
| pageSize | int | Number between 1 and 1,000 that indicates the limit of how many entries to fetch when retrieving file lists from the server. |
| bucket | StorageBucket | The bucket in which the objects are stored. |
| nextToken | String | String indicating the page offset at which to resume a listing. |


If the `pageSize` is set lower than the total file size available, a single `list` call only returns a subset of all the files. To list all the files with multiple calls, the user can use the `nextToken` value from the previous response.

</InlineFilter>

<InlineFilter filters={["swift"]}>

The following example lists all objects inside the `public/photos/` path:

<BlockSwitcher>

<Block name="Async/Await">

```swift
let listResult = try await Amplify.Storage.list(
    path: .fromString("public/photos/")
)
listResult.items.forEach { item in
    print("Path: \(item.path)")
}
```

</Block>

<Block name="Combine">

```swift
let sink = Amplify.Publisher.create {
    try await Amplify.Storage.list(
        path: .fromString("public/photos/")
    )
}.sink {
    if case let .failure(error) = $0 {
        print("Failed: \(error)")
    }
}
receiveValue: { listResult in
    listResult.items.forEach { item in
        print("Path: \(item.path)")
    }
}
```

</Block>

</BlockSwitcher>

<Callout>
Note the trailing slash `/` in the given path.

If you had used `public/photos` as path, it would also match against files like `public/photos01.jpg`.
</Callout>

### List files from a specified bucket

You can perform a list operation from a specific bucket by providing the `bucket` option.

<BlockSwitcher>
<Block name="From Outputs">
You can use `.fromOutputs(name:)` to provide a string representing the target bucket's assigned name in the Amplify Backend.

```swift
let listResult = try await Amplify.Storage.list(
    path: .fromString("public/photos/"),
    options: .init(
        bucket: .fromOutputs(name: "secondBucket")
    )
)
```
</Block>

<Block name="From Bucket Info">
You can also use `.fromBucketInfo(_:)` to provide a bucket name and region directly.

```swift
let listResult = try await Amplify.Storage.list(
    path: .fromString("public/photos/"),
    options: .init(
        bucket: .fromBucketInfo(.init(
            bucketName: "another-bucket-name",
            region: "another-bucket-region")
        )    
    )
)
```
</Block>
</BlockSwitcher>

### Exclude results from nested subpaths

By default, the `list` API will return all objects contained within the given path, including objects inside nested subpaths.

For example, the previous `public/photos/` path would include these objects:

```bash
Path: public/photos/photo1.jpg
Path: public/photos/vacation/photo1.jpg
Path: public/photos/thumbnails/photo1.jpg
```

In order to exclude objects within the `vacation` and `thumbnails` subpaths, you can set the `subpathStrategy` option to `.exclude`:

<BlockSwitcher>

<Block name="Async/Await">

```swift
let listResult = try await Amplify.Storage.list(
    path: .fromString("public/photos/"),
    options: .init(
        subpathStrategy: .exclude
    )
)
listResult.items.forEach { item in
    print("Path: \(item.path)")
}
listResult.excludedSubpaths.forEach { subpath in
    print("Subpath: \(subpath)")
}
```

</Block>

<Block name="Combine">

```swift
let sink = Amplify.Publisher.create {
    try await Amplify.Storage.list(
        path: .fromString("public/photos/"),
        options: .init(
            subpathStrategy: .exclude
        )
    )
}.sink {
    if case let .failure(error) = $0 {
        print("Failed: \(error)")
    }
}
receiveValue: { listResult in
    listResult.items.forEach { item in
        print("Path: \(item.path)")
    }
    listResult.excludedSubpaths.forEach { subpath in
        print("Subpath: \(subpath)")
    }
}
```

</Block>

</BlockSwitcher>

The response will only include objects within the `public/photos/` path and will also provide a list of the excluded subpaths:

```bash
Path: public/photos/photo01.jpg
Subpath: public/photos/vacation/
Subpath: public/photos/thumbnails/
```

The default delimiter character is `"/"`, but this can be changed by supplying a custom delimiter:

<BlockSwitcher>

<Block name="Async/Await">

```swift
let listResult = try await Amplify.Storage.list(
    path: .fromString("public/photos-"),
    options: .init(
        subpathStrategy: .exclude(delimitedBy: "-")
    )
)
```

</Block>

<Block name="Combine">

```swift
let sink = Amplify.Publisher.create {
    try await Amplify.Storage.list(
        path: .fromString("public/photos-"),
        options: .init(
            subpathStrategy: .exclude(delimitedBy: "-")
        )
    )
}.sink {
    if case let .failure(error) = $0 {
        print("Failed: \(error)")
    }
}
receiveValue: { listResult in
    // ...
}
```

</Block>

</BlockSwitcher>

### All `list` options

| Option | Type | Description |
| --- | --- | --- |
| subpathStrategy | SubpathStrategy | The strategy to use when listing contents from subpaths |
| pageSize | UInt | Number between 1 and 1,000 that indicates the limit of how many entries to fetch when retrieving file lists from the server |
| bucket | StorageBucket | The bucket in which the objects are stored |
| nextToken | String | String indicating the page offset at which to resume a listing. |


If the `pageSize` is set lower than the total file size available, a single `list` call only returns a subset of all the files. To list all the files with multiple calls, the user can use the `nextToken` value from the previous response.

</InlineFilter>

<InlineFilter filters={["flutter"]}>

This will list all files located under path `album` that:

- have `private` access level
- are in the root of `album/` (the result doesn't include files under any sub path)

```dart
Future<void> listAlbum() async {
  try {
    String? nextToken;
    bool hasNextPage;
    do {
      final result = await Amplify.Storage.list(
        path: const StoragePath.fromString('public/album/'),
        options: StorageListOptions(
          pageSize: 50,
          nextToken: nextToken,
          pluginOptions: const S3ListPluginOptions(
            excludeSubPaths: true,
          ),
        ),
      ).result;
      safePrint('Listed items: ${result.items}');
      nextToken = result.nextToken;
      hasNextPage = result.hasNextPage;
    } while (hasNextPage);
  } on StorageException catch (e) {
    safePrint(e.message);
  }
}
```

Pagination is enabled by default. The default `pageSize` is `1000` if it is not set in the `StorageListOptions`.

### List all files without pagination

You can also list all files under a given path without pagination by using the `pluginOptions` and `S3ListPluginOptions.listAll()` constructor.

This will list all public files (i.e. those with `guest` access level):

```dart

Future<void> listAllUnderPublicPath() async {
  try {
    final result = await Amplify.Storage.list(
      path: const StoragePath.fromString('public/'),
      options: const StorageListOptions(
        pluginOptions: S3ListPluginOptions.listAll(),
      ),
    ).result;
    safePrint('Listed items: ${result.items}');
  } on StorageException catch (e) {
    safePrint(e.message);
  }
}

```
<InlineFilter filters={["flutter"]}>

### List files from a specified bucket
You can also perform a `list` operation to a specific bucket by providing the `bucket` option. You can pass in a `StorageBucket` object representing the target bucket from the name defined in the Amplify Backend.

```dart
final result = await Amplify.Storage.list(
  path: const StoragePath.fromString('path/to/dir'),
  options: StorageListOptions(
    // highlight-start
    // Specify a target bucket using name assigned in Amplify Backend
    bucket: StorageBucket.fromOutputs('secondBucket'),
    // highlight-end
  ),
).result;
```
Alternatively, you can also pass in an object by specifying the bucket name and region from the console.

```dart
final result = await Amplify.Storage.list(
  path: const StoragePath.fromString('path/to/dir'),
  options: StorageListOptions(
    // highlight-start
    // Alternatively, provide bucket name from console and associated region
   bucket: StorageBucket.fromBucketInfo(
        BucketInfo(
          bucketName: 'second-bucket-name-from-console',
          region: 'us-east-2',
        ),
      ),
      // highlight-end
  ),
).result;
```
</InlineFilter>

### More `list` options

| Option | Type | Description |
| --- | --- | --- |
| bucket | StorageBucket | The target bucket from the assigned name in the Amplify Backend or from the bucket name and region in the console<br/><br/>Defaults to the default bucket and region from the Amplify configuration if this option is not provided.<br/><br/>Read more at [Configure additional storage buckets](/[platform]/build-a-backend/storage/set-up-storage/#configure-additional-storage-buckets) |
| excludeSubPaths | boolean | Whether to exclude objects under the sub paths of the path to list. Defaults to false. |
| delimiter | String | The delimiter to use when evaluating sub paths. If excludeSubPaths is false, this value has no impact on behavior. |

</InlineFilter>

<InlineFilter filters={["react", "angular", "javascript", "vue", "nextjs", "react-native"]}>

## Get File Properties

You can also view the properties of an individual file.

```javascript
import { getProperties } from 'aws-amplify/storage';

try {
  const result = await getProperties({
    path: 'album/2024/1.jpg',
    // Alternatively, path: ({ identityId }) => `album/{identityId}/1.jpg`
    options: {
      // Specify a target bucket using name assigned in Amplify Backend
      bucket: 'assignedNameInAmplifyBackend'
    }
  });
  console.log('File Properties ', result);
} catch (error) {
  console.log('Error ', error);
}
```

The properties and metadata will look similar to the below example

```js
{
  path: "album/2024/1.jpg",
  contentType: "image/jpeg",
  contentLength: 6873,
  eTag: "\"56b32cf4779ff6ca3ba3f2d455fa56a7\"",
  lastModified: Wed Apr 19 2023 14:20:55 GMT-0700 (Pacific Daylight Time) {},
  metadata: { owner: 'aws' }
}
```

### More `getProperties` options

Option | Type | Default | Description |
| -- | -- | -- | ----------- |
| bucket | string \| <br />\{ bucketName: string;<br/> region: string; \} | Default bucket and region from Amplify configuration | A string representing the target bucket's assigned name in Amplify Backend or an object specifying the bucket name and region from the console.<br/><br/>Read more at [Configure additional storage buckets](/[platform]/build-a-backend/storage/set-up-storage/#configure-additional-storage-buckets) |
| useAccelerateEndpoint | boolean | false | Whether to use accelerate endpoint. | [Transfer Acceleration](/[platform]/build-a-backend/storage/extend-s3-resources/#example---enable-transfer-acceleration) |

<Callout>

To get the metadata in result for all APIs you have to configure user defined metadata in CORS.

Learn more about how to setup an appropriate [CORS Policy](/[platform]/build-a-backend/storage/extend-s3-resources/#for-manually-configured-s3-resources).

</Callout>

</InlineFilter>

<InlineFilter filters={["flutter"]}>

## Get File Properties

You can also view properties of an individual file.

```dart
Future<void> getFileProperties() async {
  try {
    final result = await Amplify.Storage.getProperties(
      path: const StoragePath.fromString('example.txt'),
    ).result;
    safePrint('File size: ${result.storageItem.size}');
  } on StorageException catch (e) {
    safePrint(e.message);
  }
}
```

As well as specify a bucket to target to view properties of a file

```dart
Future<void> getFileProperties() async {
  try {
    final result = await Amplify.Storage.getProperties(
      path: const StoragePath.fromString('example.txt'),
      options: StorageGetPropertiesOptions(
        StorageBucket.fromOutputs('secondBucket'),
      ),
      // Alternatively, provide bucket name from console and associated region
      /*
      options: StorageGetPropertiesOptions( 
        bucket: StorageBucket.fromBucketInfo(
          BucketInfo(
            bucketName: 'second-bucket-name-from-console',
            region: 'us-east-2',
          ),
        ),
      ),
      */
    ).result;
    safePrint('File size: ${result.storageItem.size}');
  } on StorageException catch (e) {
    safePrint(e.message);
  }
}
```

<Callout>

To get the metadata in result for all APIs when building against a web target, you have to configure user defined metadata in CORS.

Learn more about how to setup an appropriate [CORS Policy](/[platform]/build-a-backend/storage/extend-s3-resources/#for-manually-configured-s3-resources).

</Callout>

</InlineFilter>


Contents of build-a-backend_storage_manage-with-amplify-console_index.txt:
import { getCustomStaticPath } from '@/utils/getCustomStaticPath';

export const meta = {
  title: 'Manage files with Amplify console',
  description:
    'Manage your applications storage files with Amplify console',
  platforms: [
    'android',
    'angular',
    'flutter',
    'javascript',
    'nextjs',
    'react',
    'react-native',
    'swift',
    'vue'
  ]
};

export function getStaticPaths() {
  return getCustomStaticPath(meta.platforms);
}

export function getStaticProps(context) {
  return {
    props: {
      platform: context.params.platform,
      meta
    }
  };
}

The **File storage** page in the Amplify console provides a user-friendly interface for managing your application's backend file storage. It allows for efficient testing and management of your files.

If you have not yet created a **storage** resource, visit the [Storage setup guide](/[platform]/build-a-backend/storage/set-up-storage/).

## Access File storage

After you've deployed your storage resource, you can access the manager on Amplify Console.

1. Log in to the [Amplify console](https://console.aws.amazon.com/amplify/home) and choose your app.
2. Select the branch you would like to access.
3. Select **Storage** from the left navigation bar.

<Video src="/images/gen2/manage/storage-manager.mp4" description="Video - Access storage manager on Amplify console"/>

### To upload a file

1. On the **Storage** page, select the **Upload** button
2. Select the file you would like to upload and then select **Done**

Alternatively, you can **Drag and drop** a file onto the Storage page.

### To delete a file

1. On the **Storage** page, select the file you want to delete.
2. Select the **Actions** dropdown and then select **Delete**.

### To copy a file

1. On the **Storage** page, select the file you want to copy.
2. Select the **Actions** dropdown and then select **Copy to**.
3. Select or create the folder you want a copy of your file to be saved to.
4. Select **Copy** to copy your file to the selected folder.

### To move a file

1. On the **Storage** page, select the file you want to move.
3. Select the **Actions** dropdown and then select **Move to**.
4. Select or create the folder you want to move your file to.
5. Select **Move** to move your file to the selected folder.



Contents of build-a-backend_storage_remove-files_index.txt:
import { getCustomStaticPath } from '@/utils/getCustomStaticPath';

export const meta = {
  title: 'Remove files',
  description: 'Remove files using Amplify Storage',
  platforms: [
    'angular',
    'javascript',
    'nextjs',
    'react',
    'vue',
    'swift',
    'android',
    'flutter',
    'react-native'
  ]
};

export const getStaticPaths = async () => {
  return getCustomStaticPath(meta.platforms);
};

export function getStaticProps(context) {
  return {
    props: {
      platform: context.params.platform,
      meta
    }
  };
}

Files can be removed from a storage bucket using the `remove` API. If a file is protected by an identity Id, only the user who owns the file will be able to remove it.

<InlineFilter filters={["react", "angular", "javascript", "vue", "nextjs", "react-native"]}>

You can also perform a remove operation from a specific bucket by providing the target bucket's assigned name from Amplify Backend in `bucket` option.

```javascript
import { remove } from 'aws-amplify/storage';

try {
  await remove({ 
    path: 'album/2024/1.jpg',
    // Alternatively, path: ({identityId}) => `album/{identityId}/1.jpg`
    bucket: 'assignedNameInAmplifyBackend', // Specify a target bucket using name assigned in Amplify Backend
  });
} catch (error) {
  console.log('Error ', error);
}
```

Alternatively, you can also pass in an object by specifying the bucket name and region from the console.

```javascript
import { remove } from 'aws-amplify/storage';

try {
  await remove({ 
    path: 'album/2024/1.jpg',
    // Alternatively, provide bucket name from console and associated region
    bucket: {
      bucketName: 'bucket-name-from-console',
      region: 'us-east-2'
    }

  });
} catch (error) {
  console.log('Error ', error);
}
```
</InlineFilter>


<InlineFilter filters={["android"]}>
<BlockSwitcher>
<Block name="Java">

```java
Amplify.Storage.remove(
    StoragePath.fromString("public/myUploadedFileName.txt"),
    result -> Log.i("MyAmplifyApp", "Successfully removed: " + result.getPath()),
    error -> Log.e("MyAmplifyApp", "Remove failure", error)
);
```

</Block>
<Block name="Kotlin - Callbacks">

```kotlin
Amplify.Storage.remove(StoragePath.fromString("public/myUploadedFileName.txt"),
    { Log.i("MyAmplifyApp", "Successfully removed: ${it.path}") },
    { Log.e("MyAmplifyApp", "Remove failure", it) }
)
```

</Block>
<Block name="Kotlin - Coroutines">

```kotlin
try {
    val result = Amplify.Storage.remove(StoragePath.fromString("public/myUploadedFileName.txt"))
    Log.i("MyAmplifyApp", "Successfully removed: ${result.path}")
} catch (error: StorageException) {
    Log.e("MyAmplifyApp", "Remove failure", error)
}
```

</Block>
<Block name="RxJava">

```java
RxAmplify.Storage.remove(StoragePath.fromString("public/myUploadedFileName.txt"))
        .subscribe(
            result -> Log.i("MyAmplifyApp", "Successfully removed: " + result.getPath()),
            error -> Log.e("MyAmplifyApp", "Remove failure", error)
        );
```

</Block>
</BlockSwitcher>

## Remove files from a specified bucket

You can also perform a remove operation to a specific bucket by providing the `bucket` option. You can pass in a string representing the target bucket's assigned name in Amplify Backend.

<BlockSwitcher>
<Block name="Java">

```java
StorageBucket secondBucket = StorageBucket.fromOutputs("secondBucket");
StorageRemoveOptions options = StorageRemoveOptions.builder()
    .bucket(secondBucket)
    .build();

Amplify.Storage.remove(
    StoragePath.fromString("public/myUploadedFileName.txt"), 
    options,
    result -> Log.i("MyAmplifyApp", "Successfully removed: " + result.getPath()),
    error -> Log.e("MyAmplifyApp", "Remove failure", error)
);
```

</Block>
<Block name="Kotlin - Callbacks">

```kotlin
val secondBucket = StorageBucket.fromOutputs("secondBucket")
val options = StorageRemoveOptions.builder()
    .bucket(secondBucket)
    .build()

Amplify.Storage.remove(StoragePath.fromString("public/myUploadedFileName.txt"), options,
    { Log.i("MyAmplifyApp", "Successfully removed: ${it.path}") },
    { Log.e("MyAmplifyApp", "Remove failure", it) }
)
```

</Block>
<Block name="Kotlin - Coroutines">

```kotlin
val secondBucket = StorageBucket.fromOutputs("secondBucket")
val options = StorageRemoveOptions.builder()
    .bucket(secondBucket)
    .build()

try {
    val result = Amplify.Storage.remove(StoragePath.fromString("public/myUploadedFileName.txt"), options)
    Log.i("MyAmplifyApp", "Successfully removed: ${result.path}")
} catch (error: StorageException) {
    Log.e("MyAmplifyApp", "Remove failure", error)
}
```

</Block>
<Block name="RxJava">

```java     
StorageBucket secondBucket = StorageBucket.fromOutputs("secondBucket");
StorageRemoveOptions options = StorageRemoveOptions.builder()
    .bucket(secondBucket)
    .build(); 
RxAmplify.Storage.remove(StoragePath.fromString("public/myUploadedFileName.txt"), options)
        .subscribe(
            result -> Log.i("MyAmplifyApp", "Successfully removed: " + result.getPath()),
            error -> Log.e("MyAmplifyApp", "Remove failure", error)
        );
```

</Block>
</BlockSwitcher>

Alternatively, you can also pass in an object by specifying the bucket name and region from the console.

<BlockSwitcher>
<Block name="Java">

```java
BucketInfo bucketInfo = new BucketInfo("second-bucket-name-from-console", "us-east-2");
StorageBucket secondBucket = StorageBucket.fromBucketInfo(bucketInfo);
StorageRemoveOptions options = StorageRemoveOptions.builder()
    .bucket(secondBucket)
    .build(); 

Amplify.Storage.remove(
    StoragePath.fromString("public/myUploadedFileName.txt"),
    options,
    result -> Log.i("MyAmplifyApp", "Successfully removed: " + result.getPath()),
    error -> Log.e("MyAmplifyApp", "Remove failure", error)
);
```

</Block>
<Block name="Kotlin - Callbacks">

```kotlin
val bucketInfo = BucketInfo("second-bucket-name-from-console", "us-east-2")
val secondBucket = StorageBucket.fromBucketInfo(bucketInfo)
val options = StorageRemoveOptions.builder()
    .bucket(secondBucket)
    .build()

Amplify.Storage.remove(StoragePath.fromString("public/myUploadedFileName.txt"), options,
    { Log.i("MyAmplifyApp", "Successfully removed: ${it.path}") },
    { Log.e("MyAmplifyApp", "Remove failure", it) }
)
```

</Block>
<Block name="Kotlin - Coroutines">

```kotlin
val bucketInfo = BucketInfo("second-bucket-name-from-console", "us-east-2")
val secondBucket = StorageBucket.fromBucketInfo(bucketInfo)
val options = StorageRemoveOptions.builder()
    .bucket(secondBucket)
    .build()

try {
    val result = Amplify.Storage.remove(StoragePath.fromString("public/myUploadedFileName.txt"), options)
    Log.i("MyAmplifyApp", "Successfully removed: ${result.path}")
} catch (error: StorageException) {
    Log.e("MyAmplifyApp", "Remove failure", error)
}
```

</Block>
<Block name="RxJava">

```java
BucketInfo bucketInfo = new BucketInfo("second-bucket-name-from-console", "us-east-2");
StorageBucket secondBucket = StorageBucket.fromBucketInfo(bucketInfo);
StorageRemoveOptions options = StorageRemoveOptions.builder()
    .bucket(secondBucket)
    .build(); 

RxAmplify.Storage.remove(StoragePath.fromString("public/myUploadedFileName.txt"), options)
        .subscribe(
            result -> Log.i("MyAmplifyApp", "Successfully removed: " + result.getPath()),
            error -> Log.e("MyAmplifyApp", "Remove failure", error)
        );
```

</Block>
</BlockSwitcher>

</InlineFilter>

<InlineFilter filters={["swift"]}>

<BlockSwitcher>

<Block name="Async/Await">

```swift
let removedObject = try await Amplify.Storage.remove(
    path: .fromString("public/example/path")
)
print("Deleted \(removedObject)")
```

</Block>

<Block name="Combine">

```swift
let sink = Amplify.Publisher.create {
    try await Amplify.Storage.remove(
        path: .fromString("public/example/path")
    )
}.sink {
    if case let .failure(error) = $0 {
        print("Failed: \(error)")
    }
}
receiveValue: { removedObject in
    print("Deleted \(removedObject)")
}
```

</Block>

</BlockSwitcher>

## Remove files from a specified bucket

You can perform a remove operation from a specific bucket by providing the `bucket` option.

<BlockSwitcher>
<Block name="From Outputs">
You can use `.fromOutputs(name:)` to provide a string representing the target bucket's assigned name in the Amplify Backend.

```swift
let removedObject = try await Amplify.Storage.remove(
    path: .fromString("public/example/path"),
    options: .init(
        bucket: .fromOutputs(name: "secondBucket")
    )
)
```
</Block>

<Block name="From Bucket Info">
You can also use `.fromBucketInfo(_:)` to provide a bucket name and region directly.

```swift
let removedObject = try await Amplify.Storage.remove(
    path: .fromString("public/example/path"),
    options: .init(
        bucket: .fromBucketInfo(.init(
            bucketName: "another-bucket-name",
            region: "another-bucket-region")
        )    
    )
)
```
</Block>
</BlockSwitcher>

</InlineFilter>

<InlineFilter filters={["flutter"]}>

You can also perform a `remove` operation to a specific bucket by providing the `bucket` option. You can pass in a `StorageBucket` object representing the target bucket from the name defined in the Amplify Backend.

```dart
final result = await Amplify.Storage.remove(
  path: const StoragePath.fromString('path/to/file.txt'),
  options: StorageRemoveOptions(
    // highlight-start
    // Specify a target bucket using name assigned in Amplify Backend
    bucket: StorageBucket.fromOutputs('secondBucket'),
    // highlight-end
  ),
).result;
```

Alternatively, you can also pass in an object by specifying the bucket name and region from the console.

```dart
final result = await Amplify.Storage.remove(
  path: const StoragePath.fromString('path/to/file.txt'),
  options: StorageRemoveOption(
    // highlight-start
    // Alternatively, provide bucket name from console and associated region
   bucket: StorageBucket.fromBucketInfo(
        BucketInfo(
          bucketName: 'second-bucket-name-from-console',
          region: 'us-east-2',
        ),
      ),
      // highlight-end
  ),
).result;
```

## Remove multiple Files

You can remove multiple files using `Amplify.Storage.removeMany`, as well as specify a bucket to target, the files to be removed in a batch should have the same access level:

```dart
Future<void> remove() async {
  try {
    final result = await Amplify.Storage.removeMany(
      paths: [
        const StoragePath.fromString('public/file-1.txt'),
        const StoragePath.fromString('public/file-2.txt'),
      ],
      // if this option is not provided, the default bucket in the Amplify Backend will be used
      options: StorageRemoveManyOptions(
        bucket: StorageBucket.fromOutputs('secondBucket'),
        /* Alternatively, provide bucket name from console and associated region
        bucket: StorageBucket.fromBucketInfo(
          BucketInfo(
            bucketName: 'second-bucket-name-from-console',
            region: 'us-east-2',
          ),
        ),
        */
      ),
    ).result;
    safePrint('Removed files: ${result.removedItems}');
  } on StorageException catch (e) {
    safePrint(e.message);
  }
}
```

</InlineFilter>

<InlineFilter filters={["react", "angular", "javascript", "vue", "nextjs", "react-native"]}>

## More `remove` options

Option | Type | Default | Description |
| -- | :--: | :--: | ----------- |
| bucket | string \| <br />\{ bucketName: string;<br/> region: string; \} | Default bucket and region from Amplify configuration | A string representing the target bucket's assigned name in Amplify Backend or an object specifying the bucket name and region from the console.<br/><br/>Read more at [Configure additional storage buckets](/[platform]/build-a-backend/storage/set-up-storage/#configure-additional-storage-buckets) |
| expectedBucketOwner | string | Optional | The account ID that owns requested bucket. |
</InlineFilter>


Contents of build-a-backend_storage_set-up-storage_index.txt:
import { getCustomStaticPath } from '@/utils/getCustomStaticPath';

export const meta = {
  title: 'Set up Storage',
  description: 'Set up Amplify Storage for your project',
  platforms: [
    'angular',
    'javascript',
    'nextjs',
    'react',
    'vue',
    'swift',
    'android',
    'flutter',
    'react-native'
  ]
};

export const getStaticPaths = async () => {
  return getCustomStaticPath(meta.platforms);
};

export function getStaticProps(context) {
  return {
    props: {
      platform: context.params.platform,
      meta
    }
  };
}

In this guide, you will learn how to set up storage in your Amplify app. You will set up your backend resources, and enable listing, uploading, and downloading files.

If you have not yet created an Amplify app, visit the [quickstart guide](/[platform]/start/quickstart/).

Amplify Storage seamlessly integrates file storage and management capabilities into frontend web and mobile apps, built on top of Amazon Simple Storage Service (Amazon S3). It provides intuitive APIs and UI components for core file operations, enabling developers to build scalable and secure file storage solutions without dealing with cloud service complexities.

## Building your storage backend

First, create a file `amplify/storage/resource.ts`. This file will be the location where you configure your storage backend. Instantiate storage using the `defineStorage` function and providing a `name` for your storage bucket. This `name` is a friendly name to identify your bucket in your backend configuration. Amplify will generate a unique identifier for your app using a UUID, the name attribute is just for use in your app.

```ts title="amplify/storage/resource.ts"
import { defineStorage } from '@aws-amplify/backend';

export const storage = defineStorage({
  name: 'amplifyTeamDrive'
});
```

Import your storage definition in your `amplify/backend.ts` file that contains your backend definition. Add storage to `defineBackend`.

```ts title="amplify/backend.ts"
import { defineBackend } from '@aws-amplify/backend';
import { auth } from './auth/resource';
// highlight-next-line
import { storage } from './storage/resource';

defineBackend({
  auth,
  // highlight-next-line
  storage
});
```

Now when you run `npx ampx sandbox` or deploy your app on Amplify, it will configure an Amazon S3 bucket where your files will be stored. Before files can be accessed in your application, you must configure storage access rules.

To deploy these changes, commit them to git and push the changes upstream. Amplify's CI/CD system will automatically pick up the changes and build and deploy the updates.

```bash title="Terminal" showLineNumbers={false}
git commit -am "add storage backend"
git push
```

### Define File Path Access

By default, no users or other project resources have access to any files in the storage bucket. Access must be explicitly granted within `defineStorage` using the `access` callback.

The access callback returns an object where each key in the object is a file path and each value in the object is an array of access rules that apply to that path.

The following example shows you how you can set up your file storage structure for a generic photo sharing app. Here,

1. Guests have access to see all profile pictures and only the users that uploaded the profile picture can replace or delete them. Users are identified by their Identity Pool ID in this case i.e. identityID.
2. There's also a general pool where all users can submit pictures.

[Learn more about customizing access to file path](/[platform]/build-a-backend/storage/authorization/).

```ts title="amplify/storage/resource.ts"
export const storage = defineStorage({
  name: 'amplifyTeamDrive',
  access: (allow) => ({
    'profile-pictures/{entity_id}/*': [
      allow.guest.to(['read']),
      allow.entity('identity').to(['read', 'write', 'delete'])
    ],
    'picture-submissions/*': [
      allow.authenticated.to(['read','write']),
      allow.guest.to(['read', 'write'])
    ],
  })
});
```

### Configure additional storage buckets

Amplify Storage gives you the flexibility to configure your backend to automatically provision and manage multiple storage resources. 

You can define additional storage buckets by using the same `defineStorage` function and providing a unique, descriptive `name` to identify the storage bucket. You can pass this `name` to the storage APIs to specify the bucket you want to perform the action to. Ensure that this `name` attribute is unique across the defined storage buckets in order to reliably identify the correct bucket and prevent conflicts.

It's important to note that if additional storage buckets are defined one of them must be marked as default with the `isDefault` flag.

```ts title="amplify/storage/resource.ts"
export const firstBucket = defineStorage({
  name: 'firstBucket',
  isDefault: true, // identify your default storage bucket (required)
});

export const secondBucket = defineStorage({
  name: 'secondBucket',
  access: (allow) => ({
    'private/{entity_id}/*': [
      allow.entity('identity').to(['read', 'write', 'delete'])
    ]
  })
})
```

Add additional storage resources to the backend definition.

```ts title="amplify/backend.ts"
import { defineBackend } from '@aws-amplify/backend';
import { auth } from './auth/resource';
import { firstBucket, secondBucket } from './storage/resource';

defineBackend({
  auth,
  firstBucket,
  // highlight-next-line
  secondBucket
});
```

<InlineFilter filters={["react", "angular", "javascript", "vue", "nextjs", "react-native"]}>
### Storage bucket client usage

Additional storage buckets can be referenced from application code by passing the `bucket` option to Amplify Storage APIs. You can provide a target bucket's name assigned in Amplify Backend.

```ts
import { downloadData } from 'aws-amplify/storage';

try {
  const result = downloadData({
    path: "album/2024/1.jpg",
    options: {
      // highlight-start
      // Specify a target bucket using name assigned in Amplify Backend
      bucket: "secondBucket"
      // highlight-end
    }
  }).result;
} catch (error) {
  console.log(`Error: ${error}`)
}
```
Alternatively, you can also pass in an object by specifying the bucket name and region from the console. See each Amplify Storage API page for additional usage examples.

```ts
import { downloadData } from 'aws-amplify/storage';

try {
  const result = downloadData({
    path: 'album/2024/1.jpg',
    options: {
      // highlight-start
      // Alternatively, provide bucket name from console and associated region
      bucket: {
        bucketName: 'second-bucket-name-from-console',
        region: 'us-east-2'
      }
      // highlight-end
    }
  }).result;
} catch (error) {
  console.log(`Error: ${error}`);
}

```
</InlineFilter>

<InlineFilter filters={["android"]}>
### Storage bucket client usage

Additional storage buckets can be referenced from application code by passing the `bucket` option to Amplify Storage APIs. You can provide a target bucket's name assigned in Amplify Backend.

<BlockSwitcher>
<Block name="Java">

```java
StorageBucket secondBucket = StorageBucket.fromOutputs("secondBucket");
StorageDownloadFileOptions options = StorageDownloadFileOptions.builder().bucket(secondBucket).build();
Amplify.Storage.downloadFile(
        StoragePath.fromString("public/example"),
        new File(getApplicationContext().getFilesDir() + "/download.txt"),
        options,
        result -> Log.i("MyAmplifyApp", "Successfully downloaded: " + result.getFile().getName()),
        error -> Log.e("MyAmplifyApp",  "Download Failure", error)
);
```

</Block>
<Block name="Kotlin - Callbacks">

```kotlin
val secondBucket = StorageBucket.fromOutputs("secondBucket")
val options = StorageDownloadFileOptions.builder().bucket(secondBucket).build()
val file = File("${applicationContext.filesDir}/download.txt")
Amplify.Storage.downloadFile(StoragePath.fromString("public/example"), file, option,
    { Log.i("MyAmplifyApp", "Successfully downloaded: ${it.file.name}") },
    { Log.e("MyAmplifyApp",  "Download Failure", it) }
)
```

</Block>
<Block name="Kotlin - Coroutines">

```kotlin
val secondBucket = StorageBucket.fromOutputs("secondBucket")
val options = StorageDownloadFileOptions.builder().bucket(secondBucket).build()
val file = File("${applicationContext.filesDir}/download.txt")
val download = Amplify.Storage.downloadFile(StoragePath.fromString("public/example"), file, options)
try {
    val fileName = download.result().file.name
    Log.i("MyAmplifyApp", "Successfully downloaded: $fileName")
} catch (error: StorageException) {
    Log.e("MyAmplifyApp", "Download Failure", error)
}
```

</Block>
<Block name="RxJava">

```java      
StorageBucket secondBucket = StorageBucket.fromOutputs("secondBucket");
StorageDownloadFileOptions options = StorageDownloadFileOptions.builder().bucket(secondBucket).build();
RxProgressAwareSingleOperation<StorageDownloadFileResult> download =
        RxAmplify.Storage.downloadFile(
            StoragePath.fromString("public/example"),
            new File(getApplicationContext().getFilesDir() + "/download.txt"),
            options
        );

download
    .observeResult()
    .subscribe(
        result -> Log.i("MyAmplifyApp", "Successfully downloaded: " + result.getFile().getName()),
        error -> Log.e("MyAmplifyApp",  "Download Failure", error)
    );
```

</Block>
</BlockSwitcher>

Alternatively, you can also pass in an object by specifying the bucket name and region from the console. See each Amplify Storage API page for additional usage examples.

<BlockSwitcher>
<Block name="Java">

```java
BucketInfo bucketInfo = new BucketInfo("second-bucket-name-from-console", "us-east-2");
StorageBucket secondBucket = StorageBucket.fromBucketInfo(bucketInfo);
StorageDownloadFileOptions options = StorageDownloadFileOptions.builder().bucket(secondBucket).build();
Amplify.Storage.downloadFile(
        StoragePath.fromString("public/example"),
        new File(getApplicationContext().getFilesDir() + "/download.txt"),
        options,
        result -> Log.i("MyAmplifyApp", "Successfully downloaded: " + result.getFile().getName()),
        error -> Log.e("MyAmplifyApp",  "Download Failure", error)
);
```

</Block>
<Block name="Kotlin - Callbacks">

```kotlin
val bucketInfo = BucketInfo("second-bucket-name-from-console", "us-east-2")
val secondBucket = StorageBucket.fromBucketInfo(bucketInfo)
val options = StorageDownloadFileOptions.builder().bucket(secondBucket).build()
val file = File("${applicationContext.filesDir}/download.txt")
Amplify.Storage.downloadFile(StoragePath.fromString("public/example"), file, options,
    { Log.i("MyAmplifyApp", "Successfully downloaded: ${it.file.name}") },
    { Log.e("MyAmplifyApp",  "Download Failure", it) }
)
```

</Block>
<Block name="Kotlin - Coroutines">

```kotlin
val bucketInfo = BucketInfo("second-bucket-name-from-console", "us-east-2")
val secondBucket = StorageBucket.fromBucketInfo(bucketInfo)
val options = StorageDownloadFileOptions.builder().bucket(secondBucket).build()
val file = File("${applicationContext.filesDir}/download.txt")
val download = Amplify.Storage.downloadFile(StoragePath.fromString("public/example"), file, options)
try {
    val fileName = download.result().file.name
    Log.i("MyAmplifyApp", "Successfully downloaded: $fileName")
} catch (error: StorageException) {
    Log.e("MyAmplifyApp", "Download Failure", error)
}
```

</Block>
<Block name="RxJava">

```java
BucketInfo bucketInfo = new BucketInfo("second-bucket-name-from-console", "us-east-2");
StorageBucket secondBucket = StorageBucket.fromBucketInfo(bucketInfo);
StorageDownloadFileOptions options = StorageDownloadFileOptions.builder().bucket(secondBucket).build();
RxProgressAwareSingleOperation<StorageDownloadFileResult> download =
        RxAmplify.Storage.downloadFile(
            StoragePath.fromString("public/example"),
            new File(getApplicationContext().getFilesDir() + "/download.txt"),
            options,
        );

download
    .observeResult()
    .subscribe(
        result -> Log.i("MyAmplifyApp", "Successfully downloaded: " + result.getFile().getName()),
        error -> Log.e("MyAmplifyApp",  "Download Failure", error)
    );
```

</Block>
</BlockSwitcher>
</InlineFilter>

<InlineFilter filters={["swift"]}>
### Storage bucket client usage

Additional storage buckets can be referenced from application code by passing the `bucket` option to Amplify Storage APIs. You can provide a target bucket's name assigned in Amplify Backend.

```swift
let downloadTask = Amplify.Storage.downloadData(
    path: .fromString("public/example/path"),
    options: .init(
        bucket: .fromOutputs(name: "secondBucket")
    )
)
```

Alternatively, you can also directly specify the bucket name and region from the console. See each Amplify Storage API page for additional usage examples.

```swift
let downloadTask = Amplify.Storage.downloadData(
    path: .fromString("public/example/path"),
    options: .init(
        bucket: .fromBucketInfo(.init(
            bucketName: "another-bucket-name",
            region: "another-bucket-region")
        )    
    )
)
```
</InlineFilter>

<InlineFilter filters={["flutter"]}>
### Storage bucket client usage

Additional storage buckets can be referenced from application code by passing the `bucket` option to Amplify Storage APIs. You can provide a target bucket's name assigned in Amplify Backend.

```dart
import 'package:amplify_flutter/amplify_flutter.dart';

try {
  final result = await Amplify.Storage.downloadData(
    path: const StoragePath.fromString('album/2024/1.jpg'),
    options: StorageDownloadDataOptions(
      // highlight-start
      // Specify a target bucket using name assigned in Amplify Backend
      bucket: StorageBucket.fromOutputs('secondBucket'),
      // highlight-end
    ),
  ).result;
} on Exception catch (e) {
    print('Error: $e');
}
```
Alternatively, you can also pass in an object by specifying the bucket name and region from the console. See each Amplify Storage API page for additional usage examples.

```dart
import 'package:amplify_flutter/amplify_flutter.dart';

try {
  final result = await Amplify.Storage.downloadData(
    path: const StoragePath.fromString('album/2024/1.jpg'),
    options: const StorageDownloadDataOptions(
      // highlight-start
      // Alternatively, provide bucket name from console and associated region
      bucket: StorageBucket.fromBucketInfo(
        BucketInfo(
          bucketName: 'second-bucket-name-from-console',
          region: 'us-east-2',
        ),
      ),
      // highlight-end
    ),
  ).result;
} on Exception catch (e) {
  print('Error: $e');
}
```
</InlineFilter>

## Connect your app code to the storage backend

The Amplify Storage library provides client APIs that connect to the backend resources you defined.

<InlineFilter filters={["react", "angular", "javascript", "vue", "nextjs", "react-native"]}>

### Configure Amplify in project

{/* this document has configuration but we're not actually using any of the libraries or UI components in this guide - should this instead just link you to the connect to backend guide? the intro says we "enable listing, uploading, and downloading files." but we aren't doing that - should we add that? */}

{/* We're inconsistent on pre-requisites across categories - JS doesn't have them but others do, is this intentional?  */}
Import and load the configuration file in your app. It's recommended you add the Amplify configuration step to your app's root entry point. For example `index.js` in React or `main.ts` in Angular.

```javascript
import { Amplify } from 'aws-amplify';
import outputs from '../amplify_outputs.json';

Amplify.configure(outputs);
```
<Callout warning="true">

Make sure you call `Amplify.configure` as early as possible in your application’s life-cycle. A missing configuration or `NoCredentials` error is thrown if `Amplify.configure` has not been called before other Amplify JavaScript APIs.

</Callout>

</InlineFilter>

<InlineFilter filters={["swift"]}>

### Prerequisites

An application with Amplify libraries integrated and a minimum target of any of the following:
- **iOS 13.0**, using **Xcode 14.1** or later.
- **macOS 10.15**, using **Xcode 14.1** or later.
- **tvOS 13.0**, using **Xcode 14.3** or later.
- **watchOS 9.0**, using **Xcode 14.3** or later.
- **visionOS 1.0**, using **Xcode 15 beta 2** or later. (Preview support - see below for more details.)

For a full example, please follow the [project setup walkthrough](/[platform]/start/quickstart/).

<Callout>

visionOS support is currently in **preview** and can be used by using the latest [Amplify Release](https://github.com/aws-amplify/amplify-swift/releases). 
As new Xcode and visionOS versions are released, the support will be updated with any necessary fixes on a best effort basis.

</Callout>

### Install Amplify library via Swift Package Manager

1. To install Amplify Libraries in your application, open your project in Xcode and select **File > Add Packages...**.

2. Enter the **Amplify Library for Swift** GitHub repo URL (`https://github.com/aws-amplify/amplify-swift`) into the search bar and click **Add Package**.

  <Callout>

  **Note:** **Up to Next Major Version** should be selected from the **Dependency Rule** dropdown.

  </Callout>

3. Lastly, choose **AWSS3StoragePlugin**, **AWSCognitoAuthPlugin**, and **Amplify**. Then click **Add Package**.

### Configure Amplify in project

Initialize the Amplify Storage category by calling `Amplify.add(plugin:)`. To complete initialization call `Amplify.configure()`.

<BlockSwitcher>

<Block name="SwiftUI">

Add the following imports to the top of your `App` scene and configure Amplify in the `init`:
```swift
import Amplify
import AWSCognitoAuthPlugin
import AWSS3StoragePlugin

@main
struct MyAmplifyApp: App {
    var body: some Scene {
        WindowGroup {
            ContentView()
        }
    }

    init() {
        do {
            try Amplify.add(plugin: AWSCognitoAuthPlugin())
            try Amplify.add(plugin: AWSS3StoragePlugin())
            try Amplify.configure(with: .amplifyOutputs)
            print("Amplify configured with Auth and Storage plugins")
        } catch {
            print("Failed to initialize Amplify with \(error)")
        }
    }
}
```

</Block>

<Block name="UIKit">

Add the following imports to the top of your `AppDelegate.swift` file:

```swift
import Amplify
import AWSCognitoAuthPlugin
import AWSS3StoragePlugin
```

Add the following code to the `application:didFinishLaunchingWithOptions` method:

```swift
func application(
    _ application: UIApplication,
    didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?
) -> Bool {
    do {
        try Amplify.add(plugin: AWSCognitoAuthPlugin())
        try Amplify.add(plugin: AWSS3StoragePlugin())
        try Amplify.configure(with: .amplifyOutputs)
        print("Amplify configured with Auth and Storage plugins")
    } catch {
        print("Failed to initialize Amplify with \(error)")
    }

    return true
}
```

</Block>

</BlockSwitcher>

Upon building and running this application you should see the following in your console window:

```console
Amplify configured with Auth and Storage plugins
```

</InlineFilter>

<InlineFilter filters={["android"]}>

### Prerequisites

* An Android application targeting Android API level 24 (Android 7.0) or above
    * For a full example of creating Android project, please follow the [quickstart guide](/[platform]/start/quickstart/)

### Install the Amplify library

Expand **Gradle Scripts**, open **build.gradle (Module: app)**. You will already have configured Amplify by following the steps in the [quickstart guide](/[platform]/start/quickstart/).

Add these libraries into the `dependencies` block:
```kotlin title="app/build.gradle.kts"
android {
    compileOptions {
        // Support for Java 8 features
        isCoreLibraryDesugaringEnabled = true
        sourceCompatibility = JavaVersion.VERSION_1_8
        targetCompatibility = JavaVersion.VERSION_1_8
    }
}

dependencies {
    // Amplify API dependencies
    // highlight-start
    implementation("com.amplifyframework:aws-storage-s3:ANDROID_VERSION")
    implementation("com.amplifyframework:aws-auth-cognito:ANDROID_VERSION")    
    // highlight-end
    // ... other dependencies
    coreLibraryDesugaring("com.android.tools:desugar_jdk_libs:2.0.3")
}
```

`aws-auth-cognito` is used to provide authentication for Amazon S3.

Click **Sync Now**.

### Configure Amplify in your project

Initialize Amplify Storage by calling `Amplify.addPlugin()`. To complete initialization, call `Amplify.configure()`.

Add the following code to your `onCreate()` method in your application class:

<Callout warning>
Before calling the `Amplify.configure` function, make sure to either download the `amplify_outputs.json` file from the console, or generate it with the following command: 

```bash title="Terminal" showLineNumbers={false}
npx ampx generate outputs --app-id <app-id> --branch main --out-dir app/src/main/res/raw
```

Next, be sure the file you generated or downloaded is in the appropriate resource directory for your application (for example, `app/src/main/res/raw`) in your Android project. Otherwise, you will not be able to compile your application.
</Callout>

<BlockSwitcher>
<Block name="Java">

```java
import android.util.Log;
import com.amplifyframework.auth.cognito.AWSCognitoAuthPlugin;
import com.amplifyframework.core.Amplify;
import com.amplifyframework.core.configuration.AmplifyOutputs;
import com.amplifyframework.storage.s3.AWSS3StoragePlugin;
```

```java
Amplify.addPlugin(new AWSCognitoAuthPlugin());
Amplify.addPlugin(new AWSS3StoragePlugin());
```

Your class will look like this:

```java
public class MyAmplifyApp extends Application {
    @Override
    public void onCreate() {
        super.onCreate();

        try {
            // Add these lines to add the AWSCognitoAuthPlugin and AWSS3StoragePlugin plugins
            Amplify.addPlugin(new AWSCognitoAuthPlugin());
            Amplify.addPlugin(new AWSS3StoragePlugin());
            Amplify.configure(AmplifyOutputs.fromResource(R.raw.amplify_outputs), getApplicationContext());

            Log.i("MyAmplifyApp", "Initialized Amplify");
        } catch (AmplifyException error) {
            Log.e("MyAmplifyApp", "Could not initialize Amplify", error);
        }
    }
}
```

</Block>
<Block name="Kotlin">

```kotlin
import android.util.Log
import com.amplifyframework.auth.cognito.AWSCognitoAuthPlugin
import com.amplifyframework.core.Amplify
import com.amplifyframework.core.configuration.AmplifyOutputs
import com.amplifyframework.storage.s3.AWSS3StoragePlugin
```

```kotlin
Amplify.addPlugin(AWSCognitoAuthPlugin())
Amplify.addPlugin(AWSS3StoragePlugin())
```

Your class will look like this:

```kotlin
class MyAmplifyApp : Application() {
    override fun onCreate() {
        super.onCreate()

        try {
            // Add these lines to add the AWSCognitoAuthPlugin and AWSS3StoragePlugin plugins
            Amplify.addPlugin(AWSCognitoAuthPlugin())
            Amplify.addPlugin(AWSS3StoragePlugin())
            Amplify.configure(AmplifyOutputs(R.raw.amplify_outputs), applicationContext)
            Log.i("MyAmplifyApp", "Initialized Amplify")
        } catch (error: AmplifyException) {
            Log.e("MyAmplifyApp", "Could not initialize Amplify", error)
        }
    }
}
```

</Block>
<Block name="RxJava">

```java
import android.util.Log;
import com.amplifyframework.auth.cognito.AWSCognitoAuthPlugin;
import com.amplifyframework.core.configuration.AmplifyOutputs;
import com.amplifyframework.rx.RxAmplify;
import com.amplifyframework.storage.s3.AWSS3StoragePlugin;
```

```java
RxAmplify.addPlugin(new AWSCognitoAuthPlugin());
RxAmplify.addPlugin(new AWSS3StoragePlugin());
```

Your class will look like this:

```java
public class MyAmplifyApp extends Application {
    @Override
    public void onCreate() {
        super.onCreate();

        try {
            // Add these lines to add the AWSCognitoAuthPlugin and AWSS3StoragePlugin plugins
            RxAmplify.addPlugin(new AWSCognitoAuthPlugin());
            RxAmplify.addPlugin(new AWSS3StoragePlugin());
            RxAmplify.configure(AmplifyOutputs.fromResource(R.raw.amplify_outputs), getApplicationContext());

            Log.i("MyAmplifyApp", "Initialized Amplify");
        } catch (AmplifyException error) {
            Log.e("MyAmplifyApp", "Could not initialize Amplify", error);
        }
    }
}
```

</Block>
</BlockSwitcher>

Note that because the storage category requires auth, you will need to either configure [guest access](/[platform]/build-a-backend/auth/concepts/guest-access/) or [sign in a user](/[platform]/build-a-backend/auth/connect-your-frontend/sign-in) before using features in the storage category.

</InlineFilter>

<InlineFilter filters={["flutter"]}>

### Prerequisites

Amplify Flutter requires a minimum target platform for iOS (13.0), Android (API level 24), and macOS (10.15). Refer to [Flutter's supported deployment platforms](https://docs.flutter.dev/reference/supported-platforms) when targeting Web, Windows, or Linux.

### Install Amplify library

Add the following dependency to your **app**'s `pubspec.yaml` along with others you added above in **Prerequisites**:

```yaml
dependencies:
  flutter:
    sdk: flutter

  amplify_auth_cognito: ^2.0.0
  amplify_flutter: ^2.0.0
  amplify_storage_s3: ^2.0.0
```

### Configure Amplify in project

To initialize the Amplify Auth and Storage categories, call `Amplify.addPlugin()` for each plugin or pass all the plugins in `Amplify.addPlugins()`. To complete initialization, call `Amplify.configure()`.

Your code should look like this:

```dart
import 'package:amplify_auth_cognito/amplify_auth_cognito.dart';
import 'package:amplify_flutter/amplify_flutter.dart';
import 'package:amplify_storage_s3/amplify_storage_s3.dart';
import 'package:flutter/material.dart';

import 'amplify_outputs.dart';

Future<void> _configureAmplify() async {
  try {
    final auth = AmplifyAuthCognito();
    final storage = AmplifyStorageS3();
    await Amplify.addPlugins([auth, storage]);

    // call Amplify.configure to use the initialized categories in your app
    await Amplify.configure(amplifyConfig);
  } on Exception catch (e) {
    safePrint('An error occurred configuring Amplify: $e');
  }
}

Future<void> main() async {
  WidgetsFlutterBinding.ensureInitialized();
  await _configureAmplify();
  runApp(const MyApp());
}

class MyApp extends StatefulWidget {
  const MyApp({Key? key}) : super(key: key);

  // ...
}
```

</InlineFilter>

### Upload your first file

Next, let's a photo to the `picture-submissions/` path.

<InlineFilter filters={["react", "react-native"]}>
```jsx
import React from 'react';
import { uploadData } from 'aws-amplify/storage';

function App() {
  const [file, setFile] = React.useState();

  const handleChange = (event) => {
    setFile(event.target.files?.[0]);
  };

  const handleClick = () => {
    if (!file) {
      return;
    }
    uploadData({
      path: `picture-submissions/${file.name}`,
      data: file,
    });
  };

  return (
    <div>
      <input type="file" onChange={handleChange} />
      <button onClick={handleClick}>Upload</button>
    </div>
  );
}
```
</InlineFilter>

<InlineFilter filters={["javascript", "angular", "vue", "nextjs"]}>
```javascript
import { uploadData } from "aws-amplify/storage";

const file = document.getElementById("file");
const upload = document.getElementById("upload");

upload.addEventListener("click", () => {
  const fileReader = new FileReader();
  fileReader.readAsArrayBuffer(file.files[0]);

  fileReader.onload = async (event) => {
    console.log("Complete File read successfully!", event.target.result);
    try {
      await uploadData({
        data: event.target.result,
        path: `picture-submissions/${file.files[0].name}`
      });
    } catch (e) {
      console.log("error", e);
    }
  };
});
```
</InlineFilter>

<InlineFilter filters={["swift"]}>

```swift
import Amplify
import SwiftUI
import PhotosUI

struct ContentView: View {
    @State private var selectedPhoto: PhotosPickerItem?
    @State private var image: Image?

    var body: some View {
        NavigationStack {
            VStack {
                image?
                    .resizable()
                    .scaledToFit()
            }
            .padding()
            PhotosPicker(
                selection: $selectedPhoto
            ) {
                Text("Select a photo to upload")
            }
            .task(id: selectedPhoto) {
                if let imageData = try? await selectedPhoto?.loadTransferable(type: Data.self) {
                    if let uiImage = UIImage(data: imageData) {
                        image = Image(uiImage: uiImage)
                    }
                    let uploadTask = Amplify.Storage.uploadData(
                        path: .fromString("picture-submissions/myPhoto.png"),
                        data: imageData
                    )
                }
            }
        }
    }
}
```

</InlineFilter>

<InlineFilter filters={["android"]}>

<BlockSwitcher>
<Block name="Java">

```java
private void uploadFile() {
    File exampleFile = new File(getApplicationContext().getFilesDir(), "myPhoto.png");

    try {
        BufferedWriter writer = new BufferedWriter(new FileWriter(exampleFile));
        writer.append("Example file contents");
        writer.close();
    } catch (Exception exception) {
        Log.e("MyAmplifyApp", "Upload failed", exception);
    }

    Amplify.Storage.uploadFile(
            StoragePath.fromString("picture-submissions/myPhoto.png"),
            exampleFile,
            result -> Log.i("MyAmplifyApp", "Successfully uploaded: " + result.getPath()),
            storageFailure -> Log.e("MyAmplifyApp", "Upload failed", storageFailure)
    );
}
```

</Block>
<Block name="Kotlin - Callbacks">

```kotlin
private fun uploadFile() {
    val exampleFile = File(applicationContext.filesDir, "myPhoto.png")
    exampleFile.writeText("Example file contents")

    Amplify.Storage.uploadFile(StoragePath.fromString("picture-submissions/myPhoto.png"), exampleFile,
        { Log.i("MyAmplifyApp", "Successfully uploaded: ${it.path}") },
        { Log.e("MyAmplifyApp", "Upload failed", it) }
    )
}
```

</Block>
<Block name="Kotlin - Coroutines">

```kotlin
private suspend fun uploadFile() {
    val exampleFile = File(applicationContext.filesDir, "myPhoto.png")
    exampleFile.writeText("Example file contents")

    val upload = Amplify.Storage.uploadFile(StoragePath.fromString("picture-submissions/myPhoto.png"), exampleFile)
    try {
        val result = upload.result()
        Log.i("MyAmplifyApp", "Successfully uploaded: ${result.path}")
    } catch (error: StorageException) {
        Log.e("MyAmplifyApp", "Upload failed", error)
    }
}
```

</Block>
<Block name="RxJava">

```java
private void uploadFile() {
    File exampleFile = new File(getApplicationContext().getFilesDir(), "myPhoto.png");

    try {
        BufferedWriter writer = new BufferedWriter(new FileWriter(exampleFile));
        writer.append("Example file contents");
        writer.close();
    } catch (Exception exception) {
        Log.e("MyAmplifyApp", "Upload failed", exception);
    }

    RxProgressAwareSingleOperation<StorageUploadFileResult> rxUploadOperation =
            RxAmplify.Storage.uploadFile(StoragePath.fromString("picture-submissions/myPhoto.png"), exampleFile);

    rxUploadOperation
            .observeResult()
            .subscribe(
                result -> Log.i("MyAmplifyApp", "Successfully uploaded: " + result.getPath()),
                error -> Log.e("MyAmplifyApp", "Upload failed", error)
            );
}
```

</Block>
</BlockSwitcher>

</InlineFilter>

<InlineFilter filters={["flutter"]}>

<Callout>

**Note**: To use `AWSFilePlatform`, add [aws_common](https://pub.dev/packages/aws_common) package to your Flutter project
by running: `flutter pub add aws_common`

</Callout>

<BlockSwitcher>

<Block name="All Platforms">

```dart
import 'package:amplify_flutter/amplify_flutter.dart';

Future<void> uploadFile() async {
  try {
    final result = await Amplify.Storage.uploadFile(
      localFile: AWSFile.fromPath('/path/to/local/myPhoto.png'),
      path: const StoragePath.fromString('picture-submissions/myPhoto.png'),
    ).result;
    safePrint('Uploaded file: ${result.uploadedItem.path}');
  } on StorageException catch (e) {
    safePrint(e.message);
  }
}
```

</Block>

<Block name= "Mobile & Desktop">

```dart
import 'dart:io' show File;

import 'package:amplify_flutter/amplify_flutter.dart';
import 'package:aws_common/vm.dart';

Future<void> uploadFile(File file) async {
  try {
    final result = await Amplify.Storage.uploadFile(
      localFile: AWSFilePlatform.fromFile(file),
      path: const StoragePath.fromString('picture-submissions/myPhoto.png'),
    ).result;
    safePrint('Uploaded file: ${result.uploadedItem.path}');
  } on StorageException catch (e) {
    safePrint(e.message);
  }
}
```

</Block>

<Block name="Web">

```dart
import 'dart:html' show File;

import 'package:amplify_flutter/amplify_flutter.dart';
import 'package:aws_common/web.dart';

Future<void> uploadFile(File file) async {
  final awsFile = AWSFilePlatform.fromFile(file);
  try {
    final result = await Amplify.Storage.uploadFile(
      localFile: awsFile,
      path: const StoragePath.fromString('picture-submissions/myPhoto.png'),
    ).result;
    safePrint('Uploaded file: ${result.uploadedItem.path}');
  } on StorageException catch (e) {
    safePrint(e.message);
  }
}
```

</Block>

</BlockSwitcher>

</InlineFilter>

## Manage files in Amplify console

After successfully publishing your storage backend and connecting your project with client APIs, you can manage files and folders in [the Amplify console](https://console.aws.amazon.com/amplify). You can perform on-demand actions like upload, download, copy, and more under the Storage tab in the console. Refer to [Manage files in Amplify Console](/[platform]/build-a-backend/storage/manage-with-amplify-console/) guide for additional information.

## Conclusion

Congratulations! You finished the Set up Amplify Storage guide. In this guide, you set up and connected to backend resources, customized your file paths and access definitions, and connected your application to the backend to implement features like file uploads and downloads.

### Next steps

Now that you have completed setting up storage in your Amplify app, you can proceed to add file management features to your app. You can use the following guides to implement upload and download functionality, or you can access more capabilities from the side navigation.

- [Upload Files](/[platform]/build-a-backend/storage/upload-files/)
- [Download Files](/[platform]/build-a-backend/storage/download-files/)


Contents of build-a-backend_storage_upload-files_index.txt:
import { getCustomStaticPath } from '@/utils/getCustomStaticPath';

export const meta = {
  title: 'Upload files',
  description: 'Upload files using Amplify Storage',
  platforms: [
    'angular',
    'javascript',
    'nextjs',
    'react',
    'vue',
    'android',
    'swift',
    'flutter',
    'react-native'
  ]
};

export const getStaticPaths = async () => {
  return getCustomStaticPath(meta.platforms);
};

export function getStaticProps(context) {
  return {
    props: {
      platform: context.params.platform,
      meta
    }
  };
}

<InlineFilter filters={["javascript","nextjs","react"]}>

You can implement upload functionality in your app by either using the File Uploader UI component or further customizing the upload experience using the upload API.

## File Uploader React UI Component

Upload files from your app in minutes by using the cloud-connected File Uploader UI Component.

```bash title="Terminal" showLineNumbers={false}
npm add @aws-amplify/ui-react-storage aws-amplify
```
Then, use the component in your app.
{/* Let's add explanations for the props - which are mandatory now? I know before it was maxFileCount and accessLevel */}

```tsx
import { FileUploader } from '@aws-amplify/ui-react-storage';
import '@aws-amplify/ui-react/styles.css';

export const DefaultFileUploaderExample = () => {
  return (
    <FileUploader
      acceptedFileTypes={['image/*']}
      path="public/"
      maxFileCount={1}
      isResumable
    />
  );
};
```

![Showing File Uploader UI component](/images/gen2/storage/upload-ui-component.png)

Learn more about how you can further customize the UI component by referring to the [File Uploader documentation](https://ui.docs.amplify.aws/react/connected-components/storage/fileuploader).

</InlineFilter>

## Implement upload functionality

<Callout>

**Note:** Refer to [the Transfer Acceleration documentation](/[platform]/build-a-backend/storage/extend-s3-resources/#example---enable-transfer-acceleration) to learn how to enable transfer acceleration for storage APIs.

</Callout>

<InlineFilter filters={["react", "angular", "javascript", "vue", "nextjs", "react-native"]}>

{/* why would we choose file vs. data? I feel like what's changed is that one code snippet is React, one vanilla JS and then the onProgress callback? Can we add more framing here? */}

### Upload from file

The following is an example of how you would upload a file from a file object, this could be retrieved from the local machine or a different source.

<InlineFilter filters={["react", "react-native"]}>
```jsx
import React from 'react';
import { uploadData } from 'aws-amplify/storage';

function App() {
  const [file, setFile] = React.useState();

  const handleChange = (event) => {
    setFile(event.target.files?.[0]);
  };

  const handleClick = () => {
    if (!file) {
      return;
    }
    uploadData({
      path: `photos/${file.name}`,
      data: file,
    });
  };

  return (
    <div>
      <input type="file" onChange={handleChange} />
      <button onClick={handleClick}>Upload</button>
    </div>
  );
}
```
</InlineFilter>

<InlineFilter filters={["javascript", "angular", "vue", "nextjs"]}>
```javascript
import { uploadData } from "aws-amplify/storage";

const file = document.getElementById("file");
const upload = document.getElementById("upload");

upload.addEventListener("click", () => {
  const fileReader = new FileReader();
  fileReader.readAsArrayBuffer(file.files[0]);

  fileReader.onload = async (event) => {
    console.log("Complete File read successfully!", event.target.result);
    try {
      await uploadData({
                data: event.target.result,
                path: file.files[0].name
            });
    } catch (e) {
      console.log("error", e);
    }
  };
});
```
</InlineFilter>

### Upload from data

You can follow this example if you have data saved in memory and would like to upload this data to the cloud.

```javascript
import { uploadData } from 'aws-amplify/storage';

try {
  const result = await uploadData({
    path: "album/2024/1.jpg",
    // Alternatively, path: ({identityId}) => `album/${identityId}/1.jpg`
    data: file,
  }).result;
  console.log('Succeeded: ', result);
} catch (error) {
  console.log('Error : ', error);
}
```
</InlineFilter>

<InlineFilter filters={["android"]}>

### Upload from file

<BlockSwitcher>
<Block name="Java">

```java
private void uploadFile() {
    File exampleFile = new File(getApplicationContext().getFilesDir(), "example");

    try {
        BufferedWriter writer = new BufferedWriter(new FileWriter(exampleFile));
        writer.append("Example file contents");
        writer.close();
    } catch (Exception exception) {
        Log.e("MyAmplifyApp", "Upload failed", exception);
    }

    Amplify.Storage.uploadFile(
            StoragePath.fromString("public/example"),
            exampleFile,
            result -> Log.i("MyAmplifyApp", "Successfully uploaded: " + result.getPath()),
            storageFailure -> Log.e("MyAmplifyApp", "Upload failed", storageFailure)
    );
}
```

</Block>
<Block name="Kotlin - Callbacks">

```kotlin
private fun uploadFile() {
    val exampleFile = File(applicationContext.filesDir, "example")
    exampleFile.writeText("Example file contents")

    Amplify.Storage.uploadFile(StoragePath.fromString("public/example"), exampleFile,
        { Log.i("MyAmplifyApp", "Successfully uploaded: ${it.path}") },
        { Log.e("MyAmplifyApp", "Upload failed", it) }
    )
}
```

</Block>
<Block name="Kotlin - Coroutines">

```kotlin
private suspend fun uploadFile() {
    val exampleFile = File(applicationContext.filesDir, "example")
    exampleFile.writeText("Example file contents")

    val upload = Amplify.Storage.uploadFile(StoragePath.fromString("public/example"), exampleFile)
    try {
        val result = upload.result()
        Log.i("MyAmplifyApp", "Successfully uploaded: ${result.path}")
    } catch (error: StorageException) {
        Log.e("MyAmplifyApp", "Upload failed", error)
    }
}
```

</Block>
<Block name="RxJava">

```java
private void uploadFile() {
    File exampleFile = new File(getApplicationContext().getFilesDir(), "example");

    try {
        BufferedWriter writer = new BufferedWriter(new FileWriter(exampleFile));
        writer.append("Example file contents");
        writer.close();
    } catch (Exception exception) {
        Log.e("MyAmplifyApp", "Upload failed", exception);
    }

    RxProgressAwareSingleOperation<StorageUploadFileResult> rxUploadOperation =
            RxAmplify.Storage.uploadFile(StoragePath.fromString("public/example"), exampleFile);

    rxUploadOperation
            .observeResult()
            .subscribe(
                result -> Log.i("MyAmplifyApp", "Successfully uploaded: " + result.getPath()),
                error -> Log.e("MyAmplifyApp", "Upload failed", error)
            );
}
```

</Block>
</BlockSwitcher>

</InlineFilter>

<InlineFilter filters={["android"]}>

### Upload from Input Stream

<BlockSwitcher>
<Block name="Java">

```java
private void uploadInputStream() {
    try {
        InputStream exampleInputStream = getContentResolver().openInputStream(uri);

        Amplify.Storage.uploadInputStream(
                StoragePath.fromString("public/example"),
                exampleInputStream,
                result -> Log.i("MyAmplifyApp", "Successfully uploaded: " + result.getPath()),
                storageFailure -> Log.e("MyAmplifyApp", "Upload failed", storageFailure)
        );
    }  catch (FileNotFoundException error) {
        Log.e("MyAmplifyApp", "Could not find file to open for input stream.", error);
    }
}
```

</Block>
<Block name="Kotlin - Callbacks">

```kotlin
private fun uploadInputStream(uri: Uri) {
    val stream = contentResolver.openInputStream(uri)

    Amplify.Storage.uploadInputStream(StoragePath.fromString("public/example"), stream,
        { Log.i("MyAmplifyApp", "Successfully uploaded: ${it.path}") },
        { Log.e("MyAmplifyApp", "Upload failed", it) }
    )
}
```

</Block>
<Block name="Kotlin - Coroutines">

```kotlin
private suspend fun uploadInputStream(uri: Uri) {
    val stream = contentResolver.openInputStream(uri)

    val upload = Amplify.Storage.uploadInputStream(StoragePath.fromString("public/example"), stream)
    try {
        val result = upload.result()
        Log.i("MyAmplifyApp", "Successfully uploaded: ${result.path}.")
    } catch (error: StorageException) {
        Log.e("MyAmplifyApp", "Upload failed")
    }
}
```

</Block>
<Block name="RxJava">

```java
private void uploadInputStream() {
    try {
        InputStream exampleInputStream = getContentResolver().openInputStream(uri);

        RxProgressAwareSingleOperation<StorageUploadInputStreamResult> rxUploadOperation =
                RxAmplify.Storage.uploadInputStream(StoragePath.fromString("public/example"), exampleInputStream);

        rxUploadOperation
                .observeResult()
                .subscribe(
                    result -> Log.i("MyAmplifyApp", "Successfully uploaded: " + result.getPath()),
                    error -> Log.e("MyAmplifyApp", "Upload failed", error)
                );
    } catch (FileNotFoundException error) {
        Log.e("MyAmplifyApp", "Could not find file to open for input stream.", error);
    }
}
```

</Block>
</BlockSwitcher>
</InlineFilter>

<InlineFilter filters={["swift"]}>

### Upload from file

When you have a file that you want to upload, you can specify the url to the file in the `local` parameter.
If a file with the same `path` already exists in S3, the existing S3 file will be overwritten.

```swift
let dataString = "My Data"
let fileName = "myFile.txt"
guard let fileUrl = FileManager.default.urls(
    for: .documentDirectory,
    in: .userDomainMask
).first?.appendingPathComponent(fileName)
else { return }

try dataString.write(
    to: fileUrl,
    atomically: true,
    encoding: .utf8
)

let uploadTask = Amplify.Storage.uploadFile(
    path: .fromString("public/example/path/myFile.txt"),
    local: fileUrl
)

```

### Upload from data

To upload a file from a data object, specify the `path` and the `data` object to be uploaded.

```swift
let dataString = "My Data"
let data = Data(dataString.utf8)
let uploadTask = Amplify.Storage.uploadData(
    path: .fromString("public/example/path/myFile.txt"),
    data: data
)
```

</InlineFilter>

<InlineFilter filters={["flutter"]}>

### Upload from file

<Callout>

**Note**: To use `AWSFilePlatform`, add [aws_common](https://pub.dev/packages/aws_common) package to your Flutter project
by running: `flutter pub add aws_common`

</Callout>

<BlockSwitcher>

<Block name="All Platforms">

```dart
import 'package:amplify_flutter/amplify_flutter.dart';

Future<void> uploadFile() async {
  try {
    final result = await Amplify.Storage.uploadFile(
      localFile: AWSFile.fromPath('/path/to/local/file.txt'),
      path: const StoragePath.fromString('public/file.txt'),
    ).result;
    safePrint('Uploaded file: ${result.uploadedItem.path}');
  } on StorageException catch (e) {
    safePrint(e.message);
  }
}
```

</Block>

<Block name= "Mobile & Desktop">

```dart
import 'dart:io' show File;

import 'package:amplify_flutter/amplify_flutter.dart';
import 'package:aws_common/vm.dart';

Future<void> uploadFile(File file) async {
  try {
    final result = await Amplify.Storage.uploadFile(
      localFile: AWSFilePlatform.fromFile(file),
      path: const StoragePath.fromString('public/file.png'),
    ).result;
    safePrint('Uploaded file: ${result.uploadedItem.path}');
  } on StorageException catch (e) {
    safePrint(e.message);
  }
}
```

</Block>

<Block name="Web">

```dart
import 'dart:html' show File;

import 'package:amplify_flutter/amplify_flutter.dart';
import 'package:aws_common/web.dart';

Future<void> uploadFile(File file) async {
  final awsFile = AWSFilePlatform.fromFile(file);
  try {
    final result = await Amplify.Storage.uploadFile(
      localFile: awsFile,
      path: const StoragePath.fromString('public/file.png'),
    ).result;
    safePrint('Uploaded file: ${result.uploadedItem.path}');
  } on StorageException catch (e) {
    safePrint(e.message);
  }
}
```

</Block>

</BlockSwitcher>

### Upload from Flutter's `file_picker` plugin

The [file_picker](https://pub.dev/packages/file_picker) plugin can be used to retrieve arbitrary file types from the user's device.

```dart
import 'package:amplify_flutter/amplify_flutter.dart';
import 'package:file_picker/file_picker.dart';

Future<void> uploadImage() async {
  // Select a file from the device
  final result = await FilePicker.platform.pickFiles(
    type: FileType.custom,
    withData: false,
    // Ensure to get file stream for better performance
    withReadStream: true,
    allowedExtensions: ['jpg', 'png', 'gif'],
  );

  if (result == null) {
    safePrint('No file selected');
    return;
  }

  // Upload file using the filename
  final platformFile = result.files.single;
  try {
    final result = await Amplify.Storage.uploadFile(
      localFile: AWSFile.fromStream(
        platformFile.readStream!,
        size: platformFile.size,
      ),
      path: StoragePath.fromString('public/${platformFile.name}'),
      onProgress: (progress) {
        safePrint('Fraction completed: ${progress.fractionCompleted}');
      },
    ).result;
    safePrint('Successfully uploaded file: ${result.uploadedItem.path}');
  } on StorageException catch (e) {
    safePrint(e.message);
  }
}
```

### Upload from data

To upload from a data object, specify the `path` and `data`, where `data` is an instance of `S3DataPayload` created from various data formats.

<BlockSwitcher>

<Block name="String">

```dart
Future<void> uploadData() async {
  try {
    final result = await Amplify.Storage.uploadData(
      data: StorageDataPayload.string(
        'hello world',
        contentType: 'text/plain',
      ),
      path: const StoragePath.fromString('public/example.txt'),
    ).result;
    safePrint('Uploaded data: ${result.uploadedItem.path}');
  } on StorageException catch (e) {
    safePrint(e.message);
  }
}
```

</Block>

<Block name="JSON Object">

```dart
Future<void> uploadData() async {
  try {
    final result = await Amplify.Storage.uploadData(
      data: StorageDataPayload.json({
        'title': 'example',
        'author': {
          'firstName': 'Jane',
          'lastName': 'Doe',
        },
      }),
      path: const StoragePath.fromString('public/example.json'),
    ).result;
    safePrint('Uploaded data: ${result.uploadedItem.path}');
  } on StorageException catch (e) {
    safePrint(e.message);
  }
}
```

</Block>

<Block name="Data URL">

See more info about [data URL](https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/Data_URLs).

```dart
Future<void> uploadData() async {
  // dataUrl should be a valid Data Url.
  // see: https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/Data_URLs
  const dataUrl = 'data:text/plain;charset=utf-8;base64,aGVsbG8gd29ybGQ=';
  try {
    final result = await Amplify.Storage.uploadData(
      data: StorageDataPayload.dataUrl(dataUrl),
      path: const StoragePath.fromString('public/example.txt'),
    ).result;
    safePrint('Uploaded data: ${result.uploadedItem.path}');
  } on StorageException catch (e) {
    safePrint(e.message);
  }
}
```

</Block>

<Block name="Bytes">

```dart
Future<void> uploadBytes() async {
  try {
    final bytes = 'hello world'.codeUnits;
    final result = await Amplify.Storage.uploadData(
      data: StorageDataPayload.bytes(
        bytes,
        contentType: 'text/plain',
      ),
      path: const StoragePath.fromString('public/example.txt'),
    ).result;
    safePrint('Uploaded data: ${result.uploadedItem.path}');
  } on StorageException catch (e) {
    safePrint(e.message);
  }
}
```

</Block>

</BlockSwitcher>

</InlineFilter>

<InlineFilter filters={["flutter"]}>

### Monitor upload progress

```dart
final operation = Amplify.Storage.uploadFile(
  localFile: AWSFile.fromPath('/path/to/local/file'),
  path: const StoragePath.fromString('public/example.txt'),
  onProgress: (progress) {
    safePrint('fraction totalBytes: ${progress.totalBytes}');
    safePrint('fraction transferredBytes: ${progress.transferredBytes}');
    safePrint('fraction completed: ${progress.fractionCompleted}');
  }
);
```
</InlineFilter>

<InlineFilter filters={["flutter"]}>

### Pause, resume, and cancel uploads

A call to `Amplify.Storage.uploadFile` or `Amplify.Storage.uploadData` returns a reference to the operation that is performing the upload.

```dart
Future<void> upload() async {
  final operation = Amplify.Storage.uploadFile(
    localFile: AWSFile.fromPath('/path/to/local/file'),
    path: const StoragePath.fromString('public/example.txt'),
  );

  // pause operation
  await operation.pause();

  // resume operation
  await operation.resume();

  // cancel operation
  await operation.cancel();
}
```

</InlineFilter>

<InlineFilter filters={["flutter"]}>

### Upload to a specified bucket

You can also perform an `upload` operation to a specific bucket by providing the `bucket` option. You can pass in a `StorageBucket` object representing the target bucket from the name defined in the Amplify Backend.

```dart
final data = 'multi bucket upload data byte'.codeUnits;
final result = await Amplify.Storage.uploadData(
  data: StorageDataPayload.bytes(data),
  path: const StoragePath.fromString('path/to/file.txt'),
  options: StorageUploadDataOptions(
    // highlight-start
    // Specify a target bucket using name assigned in Amplify Backend
    bucket: StorageBucket.fromOutputs('secondBucket'),
    // highlight-end
  ),
).result;
```
Alternatively, you can also pass in an object by specifying the bucket name and region from the console.

```dart
final data = 'multi bucket upload data byte'.codeUnits;
final result = await Amplify.Storage.uploadData(
  data: StorageDataPayload.bytes(data),
  path: const StoragePath.fromString('path/to/file.txt'),
  options: StorageUploadDataOptions(
    // highlight-start
    // Alternatively, provide bucket name from console and associated region
   bucket: StorageBucket.fromBucketInfo(
        BucketInfo(
          bucketName: 'second-bucket-name-from-console',
          region: 'us-east-2',
        ),
      ),
      // highlight-end
  ),
).result;
```
</InlineFilter>

<InlineFilter filters={["flutter"]}>

### More upload options

Option | Type | Description |
| -- | -- | ----------- |
| bucket | StorageBucket | The target bucket from the assigned name in the Amplify Backend or from the bucket name and region in the console<br/><br/>Defaults to default bucket and region from the Amplify configuration if this option is not provided.<br/><br/>Read more at [Configure additional storage buckets](/[platform]/build-a-backend/storage/set-up-storage/#configure-additional-storage-buckets) |
| getProperties | boolean | Whether to retrieve properties for the uploaded object using theAmplify.Storage.getProperties() after the operation completes. When set to true the returned item will contain additional info such as metadata and content type. |
| useAccelerateEndpoint | boolean | Whether to use accelerate endpoint. <br/><br/> Read more at [Transfer Acceleration](/[platform]/build-a-backend/storage/upload-files/#transfer-acceleration) |

Example of `uploadFile` with options:

```dart
final operation = Amplify.Storage.uploadFile(
  localFile: AWSFile.fromPath('/path/to/local/file'),
  path: const StoragePath.fromString('public/example.txt'),
  options: const StorageUploadFileOptions(
    metadata: {'key': 'value'},
    pluginOptions: S3UploadFilePluginOptions(
      getProperties: true,
      useAccelerateEndpoint: true,
    ),
  ),
);
```

Example of `uploadData` with options:

```dart
final operation = Amplify.Storage.uploadData(
  data: StorageDataPayload.string('example'),
  path: const StoragePath.fromString('public/example.txt'),
  options: const StorageUploadDataOptions(
    metadata: {'key': 'value'},
    pluginOptions: S3UploadDataPluginOptions(
      getProperties: true,
      useAccelerateEndpoint: true,
    ),
  ),
);
```

</InlineFilter>
<InlineFilter filters={["react", "angular", "javascript", "vue", "nextjs", "react-native"]}>

### Upload to a specified bucket

You can also perform an upload operation to a specific bucket by providing the `bucket` option. You can pass in a string representing the target bucket's assigned name in Amplify Backend.

```ts
import { uploadData } from 'aws-amplify/storage';

const result = await uploadData({
  path: 'album/2024/1.jpg',
  data: file,
  options: {
    // highlight-start
    // Specify a target bucket using name assigned in Amplify Backend
    bucket: 'assignedNameInAmplifyBackend'
    // highlight-end
  }
}).result;
```
Alternatively, you can also pass in an object by specifying the bucket name and region from the console.

```ts
import { uploadData } from 'aws-amplify/storage';

const result = await uploadData({
  path: 'album/2024/1.jpg',
  data: file,
  options: {
    // highlight-start
    // Alternatively, provide bucket name from console and associated region
    bucket: {
      bucketName: 'bucket-name-from-console',
      region: 'us-east-2'
    }
    // highlight-end
  }
}).result;

```
</InlineFilter>

<InlineFilter filters={["android"]}>

### Upload to a specified bucket

You can also perform an upload operation to a specific bucket by providing the `bucket` option. You can pass in a string representing the target bucket's assigned name in Amplify Backend.

<BlockSwitcher>
<Block name="Java">

```java
private void uploadFile() {
    File exampleFile = new File(getApplicationContext().getFilesDir(), "example");

    try {
        BufferedWriter writer = new BufferedWriter(new FileWriter(exampleFile));
        writer.append("Example file contents");
        writer.close();
    } catch (Exception exception) {
        Log.e("MyAmplifyApp", "Upload failed", exception);
    }

    StorageBucket secondBucket = StorageBucket.fromOutputs("secondBucket");
    StorageUploadFileOptions options = StorageUploadFileOptions.builder().bucket(secondBucket).build();

    Amplify.Storage.uploadFile(
            StoragePath.fromString("public/example"),
            exampleFile,
            options,
            result -> Log.i("MyAmplifyApp", "Successfully uploaded: " + result.getPath()),
            storageFailure -> Log.e("MyAmplifyApp", "Upload failed", storageFailure)
    );
}
```

</Block>
<Block name="Kotlin - Callbacks">

```kotlin
private fun uploadFile() {
    val exampleFile = File(applicationContext.filesDir, "example")
    exampleFile.writeText("Example file contents")

    val secondBucket = StorageBucket.fromOutputs("secondBucket")
    val options = StorageUploadFileOptions.builder().bucket(secondBucket).build()

    Amplify.Storage.uploadFile(StoragePath.fromString("public/example"), exampleFile, options,
        { Log.i("MyAmplifyApp", "Successfully uploaded: ${it.path}") },
        { Log.e("MyAmplifyApp", "Upload failed", it) }
    )
}
```

</Block>
<Block name="Kotlin - Coroutines">

```kotlin
private suspend fun uploadFile() {
    val exampleFile = File(applicationContext.filesDir, "example")
    exampleFile.writeText("Example file contents")

    val secondBucket = StorageBucket.fromOutputs("secondBucket")
    val options = StorageUploadFileOptions.builder().bucket(secondBucket).build()

    val upload = Amplify.Storage.uploadFile(StoragePath.fromString("public/example"), exampleFile, options)
    try {
        val result = upload.result()
        Log.i("MyAmplifyApp", "Successfully uploaded: ${result.path}")
    } catch (error: StorageException) {
        Log.e("MyAmplifyApp", "Upload failed", error)
    }
}
```

</Block>
<Block name="RxJava">

```java
private void uploadFile() {
    File exampleFile = new File(getApplicationContext().getFilesDir(), "example");

    try {
        BufferedWriter writer = new BufferedWriter(new FileWriter(exampleFile));
        writer.append("Example file contents");
        writer.close();
    } catch (Exception exception) {
        Log.e("MyAmplifyApp", "Upload failed", exception);
    }

    StorageBucket secondBucket = StorageBucket.fromOutputs("secondBucket");
    StorageUploadFileOptions options = StorageUploadFileOptions.builder().bucket(secondBucket).build();

    RxProgressAwareSingleOperation<StorageUploadFileResult> rxUploadOperation =
            RxAmplify.Storage.uploadFile(StoragePath.fromString("public/example"), exampleFile, options);

    rxUploadOperation
            .observeResult()
            .subscribe(
                result -> Log.i("MyAmplifyApp", "Successfully uploaded: " + result.getPath()),
                error -> Log.e("MyAmplifyApp", "Upload failed", error)
            );
}
```

</Block>
</BlockSwitcher>


Alternatively, you can also pass in an object by specifying the bucket name and region from the console.

<BlockSwitcher>
<Block name="Java">

```java
private void uploadFile() {
    File exampleFile = new File(getApplicationContext().getFilesDir(), "example");

    try {
        BufferedWriter writer = new BufferedWriter(new FileWriter(exampleFile));
        writer.append("Example file contents");
        writer.close();
    } catch (Exception exception) {
        Log.e("MyAmplifyApp", "Upload failed", exception);
    }

    BucketInfo bucketInfo = new BucketInfo("second-bucket-name-from-console", "us-east-2");
    StorageBucket secondBucket = StorageBucket.fromBucketInfo(bucketInfo);
    StorageUploadFileOptions options = StorageUploadFileOptions.builder().bucket(secondBucket).build();

    Amplify.Storage.uploadFile(
            StoragePath.fromString("public/example"),
            exampleFile,
            options,
            result -> Log.i("MyAmplifyApp", "Successfully uploaded: " + result.getPath()),
            storageFailure -> Log.e("MyAmplifyApp", "Upload failed", storageFailure)
    );
}
```

</Block>
<Block name="Kotlin - Callbacks">

```kotlin
private fun uploadFile() {
    val exampleFile = File(applicationContext.filesDir, "example")
    exampleFile.writeText("Example file contents")

    val bucketInfo = new BucketInfo("second-bucket-name-from-console", "us-east-2");
    val secondBucket = StorageBucket.fromBucketInfo(bucketInfo);
    val options = StorageUploadFileOptions.builder().bucket(secondBucket).build();

    Amplify.Storage.uploadFile(StoragePath.fromString("public/example"), exampleFile, options,
        { Log.i("MyAmplifyApp", "Successfully uploaded: ${it.path}") },
        { Log.e("MyAmplifyApp", "Upload failed", it) }
    )
}
```

</Block>
<Block name="Kotlin - Coroutines">

```kotlin
private suspend fun uploadFile() {
    val exampleFile = File(applicationContext.filesDir, "example")
    exampleFile.writeText("Example file contents")

    val bucketInfo = new BucketInfo("second-bucket-name-from-console", "us-east-2");
    val secondBucket = StorageBucket.fromBucketInfo(bucketInfo);
    val options = StorageUploadFileOptions.builder().bucket(secondBucket).build();

    val upload = Amplify.Storage.uploadFile(StoragePath.fromString("public/example"), exampleFile, options)
    try {
        val result = upload.result()
        Log.i("MyAmplifyApp", "Successfully uploaded: ${result.path}")
    } catch (error: StorageException) {
        Log.e("MyAmplifyApp", "Upload failed", error)
    }
}
```

</Block>
<Block name="RxJava">

```java
private void uploadFile() {
    File exampleFile = new File(getApplicationContext().getFilesDir(), "example");

    try {
        BufferedWriter writer = new BufferedWriter(new FileWriter(exampleFile));
        writer.append("Example file contents");
        writer.close();
    } catch (Exception exception) {
        Log.e("MyAmplifyApp", "Upload failed", exception);
    }

    BucketInfo bucketInfo = new BucketInfo("second-bucket-name-from-console", "us-east-2");
    StorageBucket secondBucket = StorageBucket.fromBucketInfo(bucketInfo);
    StorageUploadFileOptions options = StorageUploadFileOptions.builder().bucket(secondBucket).build();

    RxProgressAwareSingleOperation<StorageUploadFileResult> rxUploadOperation =
            RxAmplify.Storage.uploadFile(StoragePath.fromString("public/example"), exampleFile, options);

    rxUploadOperation
            .observeResult()
            .subscribe(
                result -> Log.i("MyAmplifyApp", "Successfully uploaded: " + result.getPath()),
                error -> Log.e("MyAmplifyApp", "Upload failed", error)
            );
}
```

</Block>
</BlockSwitcher>
</InlineFilter>

<InlineFilter filters={["swift"]}>

### Upload to a specified bucket

You can perform an upload operation to a specific bucket by providing the `bucket` option.

<BlockSwitcher>
<Block name="From Outputs">
You can use `.fromOutputs(name:)` to provide a string representing the target bucket's assigned name in the Amplify Backend.

```swift
// Upload from File
let uploadTask = Amplify.Storage.uploadFile(
    path: .fromString("public/example/path/myFile.txt"),
    local: fileUrl,
    options: .init(
        bucket: .fromOutputs(name: "secondBucket")
    )
)

// Upload from Data
let uploadTask = Amplify.Storage.uploadData(
    path: .fromString("public/example/path/myFile.txt"),
    data: data,
    options: .init(
        bucket: .fromOutputs(name: "secondBucket")
    )
)
```
</Block>

<Block name="From Bucket Info">
You can also use `.fromBucketInfo(_:)` to provide a bucket name and region directly.

```swift
// Upload from File
let uploadTask = Amplify.Storage.uploadFile(
    path: .fromString("public/example/path/myFile.txt"),
    local: fileUrl,
    options: .init(
        bucket: .fromBucketInfo(.init(
            bucketName: "another-bucket-name",
            region: "another-bucket-region")
        )    
    )
)

// Upload from Data
let uploadTask = Amplify.Storage.uploadData(
    path: .fromString("public/example/path/myFile.txt"),
    data: data,
    options: .init(
        bucket: .fromBucketInfo(.init(
            bucketName: "another-bucket-name",
            region: "another-bucket-region")
        )
    )
)
```
</Block>
</BlockSwitcher>

</InlineFilter>

<InlineFilter filters={["angular","javascript","nextjs","react","vue","react-native"]}>

### Monitor upload progress

Monitor progress of upload by using the `onProgress` option.

```javascript
import { uploadData } from 'aws-amplify/storage';

const monitorUpload = async () => {
  try {
    const result = await uploadData({
      path: "album/2024/1.jpg",
      // Alternatively, path: ({identityId}) => `album/${identityId}/1.jpg`
      data: file,
      options: {
        onProgress: ({ transferredBytes, totalBytes }) => {
          if (totalBytes) {
            console.log(
              `Upload progress ${Math.round(
                (transferredBytes / totalBytes) * 100
              )} %`
            );
          }
        },
      },
    }).result;
    console.log("Path from Response: ", result.path);
  } catch (error) {
    console.log("Error : ", error);
  }
}
```
</InlineFilter>

<InlineFilter filters={["swift"]}>

### Monitor upload progress

To track progress of the upload, use the reference returned by the `uploadFile` or `uploadData` as shown below.

<BlockSwitcher>
<Block name="Async/Await">
```swift
Task {
    for await progress in await uploadTask.progress {
        print("Progress: \(progress)")
    }
}

let value = try await uploadTask.value
print("Completed: \(value)")
```
</Block>
<Block name="Combine">

```swift
let progressSink = uploadTask
    .inProcessPublisher
    .sink { progress in
        print("Progress: \(progress)")
    }

let resultSink = uploadTask
    .resultPublisher
    .sink {
        if case let .failure(storageError) = $0 {
            print("Failed: \(storageError.errorDescription). \(storageError.recoverySuggestion)")
        }
    }
    receiveValue: { data in
        print("Completed: \(data)")
    }
```
</Block>
</BlockSwitcher>

</InlineFilter>

<InlineFilter filters={["android"]}>

### Monitor upload progress

To track progress of the upload, use the `uploadFile` API that includes a progress listener callback.

<BlockSwitcher>
<Block name="Java">

```java
private void uploadFile() {
    File exampleFile = new File(getApplicationContext().getFilesDir(), "example");

    try {
        BufferedWriter writer = new BufferedWriter(new FileWriter(exampleFile));
        writer.append("Example file contents");
        writer.close();
    } catch (Exception exception) {
        Log.e("MyAmplifyApp", "Upload failed", exception);
    }

    Amplify.Storage.uploadFile(
        StoragePath.fromString("public/example"),
        exampleFile,
        StorageUploadFileOptions.defaultInstance(),
        progress -> Log.i("MyAmplifyApp", "Fraction completed: " + progress.getFractionCompleted()),
        result -> Log.i("MyAmplifyApp", "Successfully uploaded: " + result.getPath()),
        storageFailure -> Log.e("MyAmplifyApp", "Upload failed", storageFailure)
    );
}
```

</Block>
<Block name="Kotlin - Callbacks">

```kotlin
private fun uploadFile() {
    val exampleFile = File(applicationContext.filesDir, "example")
    exampleFile.writeText("Example file contents")

    val options = StorageUploadFileOptions.defaultInstance()
    Amplify.Storage.uploadFile(StoragePath.fromString("public/example"), exampleFile, options,
        { Log.i("MyAmplifyApp", "Fraction completed: ${it.fractionCompleted}") },
        { Log.i("MyAmplifyApp", "Successfully uploaded: ${it.path}") },
        { Log.e("MyAmplifyApp", "Upload failed", it) }
    )
}
```

</Block>
<Block name="Kotlin - Coroutines">

```kotlin
private suspend fun uploadFile() {
    val exampleFile = File(applicationContext.filesDir, "example")
    exampleFile.writeText("Example file contents")

    val options = StorageUploadFileOptions.defaultInstance()
    val upload = Amplify.Storage.uploadFile(StoragePath.fromString("public/example"), exampleFile, options)
    val progressJob = activityScope.async {
        upload.progress().collect {
            Log.i("MyAmplifyApp", "Fraction completed: ${it.fractionCompleted}")
        }
    }
    try {
        val result = upload.result()
        Log.i("MyAmplifyApp", "Successfully uploaded: ${result.path}")
    } catch (error: StorageException) {
        Log.e("MyAmplifyApp", "Upload failed", error)
    }
    progressJob.cancel()
}
```

</Block>
<Block name="RxJava">

```java
RxProgressAwareSingleOperation<StorageUploadFileResult> upload =
        RxAmplify.Storage.uploadFile("example", exampleFile);

upload
    .observeProgress()
    .subscribe(
      progress -> Log.i("MyAmplifyApp", progress.getFractionCompleted())
    );
```

</Block>
</BlockSwitcher>
</InlineFilter>

<InlineFilter filters={["android"]}>

### All `upload` options

Option | Type | Description |
| -- | -- | ----------- |
| metadata | Map\<String\, String\> | Metadata for the object to store. |
| contentType | String | The standard MIME type describing the format of the object to store. |
| bucket | StorageBucket | The bucket in which the object should be stored. |
| serverSideEncryption | ServerSideEncryption | The server side encryption algorithm. |
| useAccelerateEndpoint | boolean | Flag to determine whether to use acceleration endpoint. |

</InlineFilter>

<InlineFilter filters={["android"]}>

### Query transfers

When an upload or download operation is requested using the Amplify Android library, the request is first persisted in the local SQLite Database and then queued for execution. You can query the transfer operation queued in the local database using the transfer ID returned by an upload or download API. Get-Transfer API could retrieve a pending transfer previously en-queued and enable attaching a listener to receive updates on progress change, on-error or on-success, or pause, cancel or resume it.
<BlockSwitcher>
<Block name="Java">

```java
Amplify.Storage.getTransfer("TRANSFER_ID",
    operation -> {
        Log.i("MyAmplifyApp", "Current State" + operation.getTransferState());
        // set listener to receive updates
        operation.setOnProgress( progress -> {});
        operation.setOnSuccess( result -> {});
        operation.setOnError(error -> {});

        // possible actions
        operation.pause();
        operation.resume();
        operation.start();
        operation.cancel();
    },
    {
        error -> Log.e("MyAmplifyApp", "Failed to query transfer", error)
    }
);
```

</Block>
<Block name="Kotlin - Callbacks">

```kotlin
Amplify.Storage.getTransfer("TRANSFER_ID",
    { operation ->
        Log.i("MyAmplifyApp", "Current State" + operation.transferState)
        // set listener to receive updates
        operation.setOnProgress {  }
        operation.setOnSuccess {  }
        operation.setOnError {  }

        // possible actions
        operation.pause()
        operation.resume()
        operation.start()
        operation.cancel()
    },
    {
        Log.e("MyAmplifyApp", "Failed to query transfer", it)
    }
)
```

</Block>
<Block name="Kotlin - Coroutines">

```kotlin
try {
    val operation = Amplify.Storage.getTransfer("TRANSFER_ID")
    Log.i("MyAmplifyApp", "Current State" + operation.transferState)
    // set listener to receive updates
    operation.setOnProgress {  }
    operation.setOnSuccess {  }
    operation.setOnError {  }

    // possible actions
    operation.pause()
    operation.resume()
    operation.start()
    operation.cancel()
} catch (error: StorageException) {
    Log.e("MyAmplifyApp", "Failed to query transfer", error)
}
```

</Block>
<Block name="RxJava">

```java
RxAmplify.Storage.getTransfer("TRANSFER_ID")
    .subscribe(
        operation -> {
            Log.i("MyAmplifyApp", "Current State" + operation.getTransferState());
            // set listener to receive updates
            operation.setOnProgress( progress -> {});
            operation.setOnSuccess( result -> {});
            operation.setOnError(error -> {});

            // possible actions
            operation.pause();
            operation.resume();
            operation.start();
            operation.cancel();
        },
        error -> Log.e("MyAmplifyApp", "Failed to query transfer", error);
    );
```

</Block>
</BlockSwitcher>

</InlineFilter>

<InlineFilter filters={["android"]}>

### Transfer with Object Metadata

To upload a file accompanied by metadata, utilize the `StorageUploadFileOptions` builder. Start by creating a hashMap object, then incorporate it into the `StorageUploadFileOptions` during the build process before passing it along to the upload function.

<BlockSwitcher>
<Block name="Java">
```java
private void uploadFile() {
    File exampleFile = new File(getApplicationContext().getFilesDir(), "example");
    try {
        BufferedWriter writer = new BufferedWriter(new FileWriter(exampleFile));
        writer.append("Example file contents");
        writer.close();
    } catch (Exception exception) {
        Log.e("MyAmplifyApp", "Upload failed", exception);
    }

    // Create metadata
    Map<String, String> userMetadata = new HashMap<>();
    userMetadata.put("myKey", "myVal");

    // Configure upload options with metadata
    StorageUploadFileOptions options = StorageUploadFileOptions.builder()
        .metadata(userMetadata)
        .build();

    // Perform the upload
    Amplify.Storage.uploadFile(
        StoragePath.fromString("public/example"),
        exampleFile,
        options,
        result -> Log.i("MyAmplifyApp", "Successfully uploaded: " + result.getPath()),
        error -> Log.e("MyAmplifyApp", "Upload failed", error)
    );
}
```
</Block>
<Block name="Kotlin - Callbacks">
```kotlin
fun uploadFile() {
    val exampleFile = File(applicationContext.filesDir, "example")
    exampleFile.writeText("Example file contents")

    // Create metadata
    val userMetadata: MutableMap<String, String> = HashMap()
    userMetadata["myKey"] = "myVal"

    // Configure upload options with metadata
    val options = StorageUploadFileOptions.builder()
        .metadata(userMetadata)
        .build()

    // Perform the upload
    Amplify.Storage.uploadFile(
        StoragePath.fromString("public/example"),
        exampleFile,
        options,
        { result -> Log.i("MyAmplifyApp", "Successfully uploaded: ${result.path}") },
        { error -> Log.e("MyAmplifyApp", "Upload failed", error) }
    )
}
```
</Block>
<Block name="Kotlin - Coroutines">
```kotlin
fun uploadFile() {
    val exampleFile = File(applicationContext.filesDir, "example")
    exampleFile.writeText("Example file contents")

    // Create metadata
    val userMetadata: MutableMap<String, String> = HashMap()
    userMetadata["myKey"] = "myVal"

    // Configure upload options with metadata
    val options = StorageUploadFileOptions.builder()
        .metadata(userMetadata)
        .build()

    val upload = Amplify.Storage.uploadFile(StoragePath.fromString("public/example"), exampleFile, options)
    val progressJob = activityScope.async {
        upload.progress().collect {
            Log.i("MyAmplifyApp", "Fraction completed: ${it.fractionCompleted}")
        }
    }
    try {
        val result = upload.result()
        Log.i("MyAmplifyApp", "Successfully uploaded: ${result.path}")
    } catch (error: StorageException) {
        Log.e("MyAmplifyApp", "Upload failed", error)
    }
    progressJob.cancel()
}
```
</Block>
<Block name="RxJava">
```Java
private void uploadFile() {
    File exampleFile = new File(getApplicationContext().getFilesDir(), "example");

    try {
        BufferedWriter writer = new BufferedWriter(new FileWriter(exampleFile));
        writer.append("Example file contents");
        writer.close();
    } catch (Exception exception) {
        Log.e("MyAmplifyApp", "Upload failed", exception);
    }

    Map<String, String> userMetadata = new HashMap<>();
    userMetadata.put("myKey", "myVal");

    StorageUploadFileOptions options = StorageUploadFileOptions.builder()
            .metadata(userMetadata)
            .build();

    RxStorageBinding.RxProgressAwareSingleOperation<StorageUploadFileResult> rxUploadOperation =
            RxAmplify.Storage.uploadFile(StoragePath.fromString("public/example"), exampleFile, options);

    rxUploadOperation
            .observeResult()
            .subscribe(
                    result -> Log.i("MyAmplifyApp", "Successfully uploaded: " + result.getPath()),
                    error -> Log.e("MyAmplifyApp", "Upload failed", error)
            );
}
 ```
</Block>
</BlockSwitcher>
</InlineFilter>

<InlineFilter filters={["react", "angular", "javascript", "vue", "nextjs", "react-native"]}>
### Pause, resume, and cancel uploads

We have callback functions that support resuming, pausing, and cancelling `uploadData` requests.

```javascript
import { uploadData, isCancelError } from 'aws-amplify/storage';

// Pause, resume, and cancel a task
const uploadTask = uploadData({ path, data: file });
//...
uploadTask.pause();
//...
uploadTask.resume();
//...
uploadTask.cancel();
//...
try {
  await uploadTask.result;
} catch (error) {
  if (isCancelError(error)) {
    // Handle error thrown by task cancellation
  }
}
```
</InlineFilter>

<InlineFilter filters={["swift"]}>
### Pause, resume, and cancel uploads

Calls to `uploadData` or `uploadFile` return a reference to the task that is actually performing the upload.

You can pause then resume the task or cancel a task as shown below.

```swift
uploadTask.pause()
uploadTask.resume()
uploadTask.cancel()
```

<Callout>

Upload tasks are run using `URLSessionTask` instances internally. You can learn more about them in [Apple's official documentation](https://developer.apple.com/documentation/foundation/urlsessiontask).

</Callout>

</InlineFilter>

<InlineFilter filters={["swift"]}>

### All `upload` options

Option | Type | Description |
| -- | -- | ----------- |
| metadata | [String: String] | Metadata for the object to store. |
| contentType | String | The standard MIME type describing the format of the object to store. |
| bucket | StorageBucket | The bucket in which the object should be stored |

</InlineFilter>

<InlineFilter filters={["swift"]}>

## Working with Security Scoped Resources (from iCloud)
Security scoped resources refer to files that are retrieved from iCloud  or other cloud storage providers. You're likely to run into these file types when using system components that provide access to files stored in iCloud, e.g. [UIDocumentBrowserViewController](https://developer.apple.com/documentation/uikit/uidocumentbrowserviewcontroller).

To upload security scoped resources, you'll need to:
1. use [startAccessingSecurityScopedResource()](https://developer.apple.com/documentation/foundation/url/1779698-startaccessingsecurityscopedreso) and [stopAccessingSecurityScopedResource()](https://developer.apple.com/documentation/foundation/url/1780153-stopaccessingsecurityscopedresou) to access the data within security scoped files
2. temporarily persist the data from the security scoped files in your app's sandbox
3. upload files using the temporary URLs
4. delete temporarily persisted files (optional)
```swift
struct ScopedResourceFile {
    let name: String
    let data: Data
}

func getTempUrls(securityScopedUrls: [URL]) -> [URL] {
    // 1. get the content of security scoped resources into ScopedResourceFile struct
    let fileContents = securityScopedUrls.compactMap { url -> ScopedResourceFile? in
        let startAccess = url.startAccessingSecurityScopedResource()
        guard startAccess else {
            print("Issue accessing security scoped resource at :\(url)")
            return nil
        }
        defer { url.stopAccessingSecurityScopedResource() }
        do {
            let data = try Data(contentsOf: url)
            let fileName = url.lastPathComponent
            return ScopedResourceFile(name: fileName, data: data)
        } catch {
            print("Couldn't create Data from contents of file at url: \(url)")
            return nil
        }
    }

    // 2. write the file contents to temporary files and return the URLs of the temp files
    let localFileURLs = persistTemporaryFiles(fileContents)

    // 3. Now you have local URLs for the files you'd like to upload.
    return localFileURLs
}
```

</InlineFilter>

<InlineFilter filters={["react", "angular", "javascript", "vue", "nextjs", "react-native"]}>
### Transfer with Object Metadata

Custom metadata can be associated with your uploaded object by passing the metadata option.

```ts
import { uploadData } from 'aws-amplify/storage';

const result = await uploadData({
  path: 'album/2024/1.jpg',
  data: file,
  options: {
    metadata: {
      customKey: 'customValue',
    },
  },
});
```

### More upload options

The behavior of `uploadData` and properties of the uploaded object can be customized by passing in additional options.

```ts
import { uploadData } from 'aws-amplify/storage';

const result = await uploadData({
  path: 'album/2024/1.jpg',
  data: file,
  options: {
    // content-type header to be used when downloading
    contentType: "image/jpeg",
    // configure how object is presented
    contentDisposition: "attachment",
    // whether to use accelerate endpoint
    useAccelerateEndpoint: true,
    // the account ID that owns requested bucket
    expectedBucketOwner: "123456789012",
    // whether to check if an object with the same key already exists before completing the upload
    preventOverwrite: true,
    // whether to compute the checksum for the data to be uploaded, so the S3 can verify the data integrity
    checksumAlgorithm: "crc-32", // only 'crc-32' is supported currently
  },
});
```
Option | Type | Default | Description |
| -- | :--: | :--: | ----------- |
| bucket | string \| <br />\{ bucketName: string;<br/> region: string; \} | Default bucket and region from Amplify configuration | A string representing the target bucket's assigned name in Amplify Backend or an object specifying the bucket name and region from the console.<br/><br/> Read more at [Configure additional storage buckets](/[platform]/build-a-backend/storage/set-up-storage/#configure-additional-storage-buckets) |
| contentType | string | application/octet-stream | The default content-type header value of the file when downloading it. <br/><br/> Read more at [Content-Type documentation](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Type) |
| contentEncoding | string | — | The default content-encoding header value of the file when downloading it.<br/><br/> Read more at [Content-Encoding documentation](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Encoding) |
| contentDisposition | string | — | Specifies presentational information for the object. <br/><br/> Read more at [Content-Disposition documentation](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Disposition) |
| metadata | map\<string\> | — | A map of metadata to store with the object in S3. <br/><br/> Read more at [S3 metadata documentation](https://docs.aws.amazon.com/AmazonS3/latest/userguide/UsingMetadata.html#UserMetadata) |
| useAccelerateEndpoint | boolean | false | Whether to use accelerate endpoint. <br/><br/> Read more at [Transfer Acceleration](/[platform]/build-a-backend/storage/upload-files/#transfer-acceleration) |
| expectedBucketOwner | string | - | The account ID that owns requested bucket. |
| preventOverwrite | boolean | false | Whether to check if an object with the same key already exists before completing the upload. If exists, a `Precondition Failed` error will be thrown |
| checksumAlgorithm | "crc-32" | - | Whether to compute the checksum for the data to be uploaded, so the S3 can verify the data integrity. Only 'crc-32' is supported currently |

<Callout>

Uploads that were initiated over one hour ago will be cancelled automatically. There are instances (e.g. device went offline, user logs out) where the incomplete file remains in your Amazon S3 account. It is recommended to [setup a S3 lifecycle rule](https://aws.amazon.com/blogs/aws-cloud-financial-management/discovering-and-deleting-incomplete-multipart-uploads-to-lower-amazon-s3-costs/) to automatically cleanup incomplete upload requests.

</Callout>

</InlineFilter>

## MultiPart upload

Amplify will automatically perform an Amazon S3 multipart upload for objects that are larger than 5MB. For more information about S3's multipart upload, see [Uploading and copying objects using multipart upload](https://docs.aws.amazon.com/AmazonS3/latest/userguide/mpuoverview.html)


Contents of build-a-backend_storage_use-aws-sdk_index.txt:
import { getCustomStaticPath } from '@/utils/getCustomStaticPath';

export const meta = {
  title: 'Use AWS SDK for S3 APIs',
  description: 'Use escape hatch to access the S3Client',
  platforms: [
    'android',
    'swift'
  ]
};

export const getStaticPaths = async () => {
  return getCustomStaticPath(meta.platforms);
};

export function getStaticProps(context) {
  return {
    props: {
      platform: context.params.platform,
      meta
    }
  };
}

For advanced use cases where Amplify does not provide the functionality, you can retrieve the escape hatch to access the `S3Client` instance:

<InlineFilter filters={["android"]}>

<BlockSwitcher>

<Block name="Java">

<Callout>

Learn more about consuming Kotlin clients from Java using either a blocking interface or an equivalent async interface based on futures [here](https://github.com/awslabs/smithy-kotlin/blob/main/docs/design/kotlin-smithy-sdk.md#java-interop).

</Callout>

```java
AWSS3StoragePlugin plugin = (AWSS3StoragePlugin) Amplify.Storage.getPlugin("awsS3StoragePlugin");
S3Client client = plugin.getEscapeHatch();
```

</Block>
<Block name="Kotlin">

```kotlin
val plugin = Amplify.Storage.getPlugin("awsS3StoragePlugin") as AWSS3StoragePlugin
val client = plugin.escapeHatch
```

</Block>
</BlockSwitcher>

</InlineFilter>

<InlineFilter filters={["swift"]}>

Add the following import:

```swift
import AWSS3StoragePlugin
```

Then retrieve the escape hatch with this code:

```swift
do {
    // Retrieve the reference to AWSS3StoragePlugin
    let plugin = try Amplify.Storage.getPlugin(for: "awsS3StoragePlugin")
    guard let storagePlugin = plugin as? AWSS3StoragePlugin else {
        return
    }

    // Retrieve the reference to S3Client
    let s3Client = storagePlugin.getEscapeHatch()

    // Make requests using s3Client...
    // ...
} catch {
    print("Get escape hatch failed with error - \(error)")
}
```

For additional client documentation, see the [AWS SDK for Swift Client documentation](https://docs.aws.amazon.com/sdk-for-swift/latest/developer-guide/using-client-services.html). For S3Client code examples, see the [Amazon S3 examples using SDK for Swift](https://docs.aws.amazon.com/sdk-for-swift/latest/developer-guide/swift_s3_code_examples.html)

</InlineFilter>


Contents of build-a-backend_storage_use-with-custom-s3_index.txt:
import { getCustomStaticPath } from '@/utils/getCustomStaticPath';

export const meta = {
  title: 'Use Amplify Storage with any S3 bucket',
  description: 'You can use the Amplify Storage APIs against your own S3 bucket in your account.',
  platforms: [
    'javascript',
    'react',
    'react-native',
    'angular',
    'vue',
    'nextjs',
    'swift',
    'android',
    'flutter'
  ]
};

export const getStaticPaths = async () => {
  return getCustomStaticPath(meta.platforms);
};

export function getStaticProps(context) {
  return {
    props: {
      platform: context.params.platform,
      meta
    }
  };
}

With Amplify Storage APIs, you can use your own S3 buckets instead of the Amplify-created ones.

<Callout>
**Important:** To utilize the storage APIs with an S3 bucket outside of Amplify, you must have Amplify Auth configured in your project.
</Callout>
## Use storage resources with an Amplify backend

### Add necessary permissions to the S3 bucket

For the specific Amazon S3 bucket that you want to use with these APIs, you need to make sure that the associated IAM role has the necessary permissions to read and write data to that bucket.

To do this, go to **Amazon S3 console** > **Select the S3 bucket** > **Permissions** > **Edit** Bucket Policy.

![Showing Amplify console showing Storage tab selected](/images/gen2/storage/s3-console-permissions.png)

The policy will look something like this

```json
{
	"Version": "2012-10-17",
	"Statement": [
		{
			"Sid": "Statement1",
			"Principal": { "AWS": "arn:aws:iam::<AWS-account-ID>:role/<role-name>" },
			"Effect": "Allow",
			"Action": [
				"s3:PutObject",
				"s3:GetObject",
				"s3:DeleteObject",
				"s3:ListBucket"
			],
			"Resource": [
				"arn:aws:s3:::<bucket-name>/*"
			]
		}
	]
}
```
Replace `<AWS-account-ID>` with your AWS account ID and `<role-name>` with the IAM role associated with your Amplify Auth setup. Replace `<bucket-name>` with the S3 bucket name.

You can refer to [Amazon S3's Policies and Permissions documentation](https://docs.aws.amazon.com/AmazonS3/latest/userguide/access-policy-language-overview.html) for more ways to customize access to the bucket.

### Specify S3 bucket in Amplify's backend config

Next, use the `addOutput` method from the backend definition object to define a custom s3 bucket by specifying the name and region of the bucket in your **amplify/backend.ts** file.

<Callout>

**Important**

You cannot use both a storage backend configured through Amplify and a custom S3 bucket at the same time. 

If you specify a custom S3 bucket, no sandbox storage resource will be created. The provided custom S3 bucket will be used, even in the sandbox environment.

</Callout>

```javascript

import { defineBackend } from '@aws-amplify/backend';
import { auth } from './auth/resource';
import { data } from './data/resource';

const backend = defineBackend({
  auth,
  data,
});

//highlight-start
backend.addOutput({
  storage: {
    aws_region: "<region>",
    bucket_name: "<bucket-name>"
  },
});
//highlight-end

```

<InlineFilter filters={["javascript", "nextjs", "react", "angular", "vue", "react-native", "android", "swift"]}>

### Import latest amplify_outputs.json file

To ensure the local **amplify_outputs.json** file is up-to-date, you can run [the npx ampx generate outputs command](/[platform]/reference/cli-commands/#npx-ampx-generate-outputs) or download the latest **amplify_outputs.json** from the Amplify console as shown below.

![](/images/gen2/getting-started/react/amplify-outputs-download.png)

</InlineFilter>

<InlineFilter filters={["flutter"]}>

### Import latest amplify_outputs.dart file

To ensure the local **amplify_outputs.dart** file is up-to-date, you can run [the npx ampx generate outputs command](/[platform]/reference/cli-commands/#npx-ampx-generate-outputs).

</InlineFilter>

Now that you've configured the necessary permissions, you can start using the storage APIs with your chosen S3 bucket.
<InlineFilter filters={["react", "angular", "javascript", "vue", "nextjs", "react-native"]}>

## Use storage resources without an Amplify backend

While using the Amplify Backend is the easiest way to get started, existing storage resources can also be integrated with Amplify Storage. 

In addition to manually configuring your storage options, you will also need to ensure Amplify Auth is properly configured in your project and associated IAM roles have the necessary permissions to interact with your existing bucket. Read more about [using existing auth resources without an Amplify backend](/[platform]/build-a-backend/auth/use-existing-cognito-resources/#use-auth-resources-without-an-amplify-backend).

### Using Amplify configure
Existing storage resource setup can be accomplished by passing the resource metadata to `Amplify.configure`. This will configure the Amplify Storage client library to interact with the additional resources. It's recommended to add the Amplify configuration step as early as possible in the application lifecycle, ideally at the root entry point.


```ts
import { Amplify } from 'aws-amplify';

Amplify.configure({
  Auth: {
    // add your auth configuration
  },
  Storage: {
    S3: {
      bucket: '<your-default-bucket-name>',
      region: '<your-default-bucket-region>',
      // default bucket metadata should be duplicated below with any additional buckets
      buckets: {
        '<your-default-bucket-friendly-name>': {
          bucketName: '<your-default-bucket-name>',
          region: '<your-default-bucket-region>'
        },
        '<your-additional-bucket-friendly-name>': {
          bucketName: '<your-additional-bucket-name>',
          region: '<your-additional-bucket-region>'
        }
      }
    }
  }
});

```
### Using Amplify outputs

Alternatively, existing storage resources can be used by creating or modifying the `amplify_outputs.json` file directly.

```ts title="amplify_outputs.json"
{
  "auth": {
    // add your auth configuration
  },
  "storage": {
    "aws_region": "<your-default-bucket-region>", 
    "bucket_name": "<your-default-bucket-name>",
    // default bucket metadata should be duplicated below with any additional buckets
    "buckets": [
      {
        "name": "<your-default-bucket-friendly-name>", 
        "bucket_name": "<your-default-bucket-name>", 
        "aws_region": "<your-default-bucket-region>" 
      },
      {
        "name": "<your-additional-bucket-friendly-name>",
        "bucket_name": "<your-additional-bucket-name>",
        "aws_region": "<your-additional-bucket-region>"
      }
    ]
  }
}
```
</InlineFilter>


Contents of build-a-backend_troubleshooting_cannot-find-module-amplify-env_index.txt:
import { getCustomStaticPath } from '@/utils/getCustomStaticPath';

export const meta = {
  title: 'Troubleshoot "Cannot find module $amplify/env/<function-name>"',
  description: 'Addressing "Cannot find module $amplify/env/<function-name>" error message',
  platforms: [
    'angular',
    'javascript',
    'nextjs',
    'react',
    'react-native',
    'vue'
  ]
};

export function getStaticPaths() {
  return getCustomStaticPath(meta.platforms);
}

export function getStaticProps(context) {
  return {
    props: {
      meta
    }
  };
}

<InlineFilter filters={["javascript",  "react-native", "angular", "nextjs", "react"]}>

When deploying a Amplify Gen 2 app, you may encounter the error message `Cannot find module $amplify/env/<function-name>` in your frontend build on Amplify Console. This error occurs when your framework `tsconfig.json` configuration picks up the `amplify` directory and tries to resolve it as a module. This module is a placeholder for environment variables that are injected at build time by Amplify. To resolve this error, you need to exclude the `amplify` directory.

To exclude the `amplify` directory in your `tsconfig.json`, add the following lines to the `exclude` section:

```ts title='tsconfig.json'
{
  "exclude": ["amplify/**/*"]
}
```

Amplify will perform type-checking on sandbox and pipeline-deploy using the tsconfig local to the Amplify backend `amplify/tsconfig.json`. If you'd like to extend your base configuration you can add it to the localized tsconfig.

Alternatively, if you work within a monorepo you can move your backend to its own package and export the Schema and outputs for ease of sharing with your other apps. For example, in your backend package's `package.json`

```json title='package.json'
{
  "name": "my-backend",
  "private": true,
  "exports": {
    "./schema": "./amplify/data/resource.ts",
    "./outputs": "./amplify_outputs.json"
  }
}
```

</InlineFilter>


<InlineFilter filters={["vue"]}>

When deploying a Amplify Gen 2 app, you may encounter the error message `Cannot find module $amplify/env/<function-name>` in your frontend build on Amplify Console. This error occurs when your framework `tsconfig.json` configuration picks up the `amplify` directory and tries to resolve it as a module. This module is a placeholder for environment variables that are injected at build time by Amplify. To resolve this error, you will need to include the `resource.ts` files in your `tsconfig.app.json` file.

For example, if you have a `function` resource dependent on the `data` resource, you will need to include both the `resource.ts` files in your `tsconfig.app.json` file.

```ts title='tsconfig.app.json'
{
  "include": [
    "amplify/data/resource.ts",
    "amplify/function/api-function/resource.ts",
  ]
}
```

</InlineFilter>


Contents of build-a-backend_troubleshooting_cdktoolkit-stack_index.txt:
import { getCustomStaticPath } from '@/utils/getCustomStaticPath';

export const meta = {
  title: 'Troubleshoot CDKToolkit stack issues',
  description: 'Addressing issues with CDKToolkit stack',
  platforms: [
    "android",
    'angular',
    "flutter",
    'javascript',
    'nextjs',
    'react',
    'react-native',
    "swift",
    'vue'
  ]
};

export function getStaticPaths() {
  return getCustomStaticPath(meta.platforms);
}

export function getStaticProps(context) {
  return {
    props: {
      platform: context.params.platform,
      meta
    }
  };
}

AWS Amplify requires your AWS account and region to be _bootstrapped_ in order to deploy resources into your account. Amplify uses the [AWS Cloud Development Kit (AWS CDK)](https://aws.amazon.com/cdk/) to scaffold backend resource configurations and orchestrate deployments by using the supplemental resources created by the process of bootstrapping.

> _Bootstrapping_ is the process of preparing your AWS environment for usage with the AWS Cloud Development Kit (AWS CDK). Before you deploy a CDK stack into an AWS environment, the environment must first be bootstrapped.

Learn more about bootstrapping by visiting the [AWS documentation for AWS CDK's concept of bootstrapping](https://docs.aws.amazon.com/cdk/v2/guide/bootstrapping.html).

## Error bootstrapping account

When deploying an Amplify app you may be redirected to the Amplify Console to complete bootstrapping for your current account ID and region. If this process encounters an error you will be prompted with the following message:

```text title="Amplify Console" showLineNumbers={false}
Error bootstrapping account in region “<your-aws-region>”. There is an issue with the CDKToolkit stack which must be resolved manually.
```

This typically indicates one or more of the resources within the `CDKToolkit` stack has failed to create or update. Navigate to the [AWS CloudFormation console](https://us-east-1.console.aws.amazon.com/cloudformation/home), select your `CDKToolkit` stack, and select the "Events" tab to view resource events. Here you may identify issues with the corresponding [assets bucket](https://docs.aws.amazon.com/cdk/v2/guide/assets.html) or issues with the IAM roles used for deployments.

You can mitigate by manually updating your `CDKToolkit` stack using the browser-based [AWS CloudShell](https://aws.amazon.com/cloudshell/):

```bash title="AWS CloudShell" showLineNumbers={false}
cdk bootstrap aws://$(aws sts get-caller-identity --query Account --output text)/$AWS_REGION
```

Or by running `bootstrap` using the AWS CDK CLI from your terminal:

```bash title="Terminal" showLineNumbers={false}
npx aws-cdk@latest bootstrap aws://<your-aws-account-id>/<your-aws-region>
```

If you continue to experience this issue after applying the workaround noted above, please file an issue in the [GitHub repository for Amplify Backend](https://github.com/aws-amplify/amplify-backend).

## Stack CDKToolkit already exists

If you are deploying an Amplify app for the first time and have previously bootstrapped your AWS account to work with CDK, and you encounter the following error in the Amplify Console:

```text title="Amplify Console" showLineNumbers={false}
Build error!
Stack [CDKToolkit] already exists
```

You can mitigate by manually updating your `CDKToolkit` stack using the browser-based [AWS CloudShell](https://aws.amazon.com/cloudshell/):

```bash title="AWS CloudShell" showLineNumbers={false}
cdk bootstrap aws://$(aws sts get-caller-identity --query Account --output text)/$AWS_REGION
```

Or by running `bootstrap` using the AWS CDK CLI from your terminal:

```bash title="Terminal" showLineNumbers={false}
npx aws-cdk@latest bootstrap aws://<your-aws-account-id>/<your-aws-region>
```

If you continue to experience this issue after applying the workaround noted above, please file an issue in the [GitHub repository for Amplify Backend](https://github.com/aws-amplify/amplify-backend).


Contents of build-a-backend_troubleshooting_circular-dependency_index.txt:
import { getCustomStaticPath } from '@/utils/getCustomStaticPath';

export const meta = {
  title: 'Troubleshoot circular dependency issues',
  description: 'Addressing deployment failures caused by circular dependencies',
  platforms: [
    'angular',
    'javascript',
    'nextjs',
    'react',
    'react-native',
    'vue'
  ]
};

export function getStaticPaths() {
  return getCustomStaticPath(meta.platforms);
}

export function getStaticProps(context) {
  return {
    props: {
      meta
    }
  };
}

When deploying a Amplify Gen 2 app, you may encounter the error message `The CloudFormation deployment failed due to circular dependency` in your backend build on Amplify Console or while running a sandbox. This error can occur due to circular dependencies between CloudFormation nested stacks or between resources in a single CloudFormation stack.

## Circular dependency error between nested stacks

If you see this error "The CloudFormation deployment failed due to circular dependency found between nested stacks [data1234ABCD, function6789XYZ]", it means that the nested stack for `data` and the nested stack for `function` have circular dependencies. E.g. if you are using the `function` as a query handler, but the `function` also needs access to the data (or `AppSync`) API, you might run into this issue. To resolve, group this `function` with other resources in the `data` stack

```ts title="amplify/functions/my-function/resource.ts"
export const queryFunction = defineFunction({
  name: 'query-function',
  resourceGroupName: 'data',
});
```

Similarly, if you are using your `function` as an auth trigger, you can group your `function` with other resources in the `auth` stack to break the circular dependency.

```ts title="amplify/functions/my-function/resource.ts"
export const preSignUpTrigger = defineFunction({
  name: 'pre-sign-up',
  resourceGroupName: 'auth',
});
```
If you are unable to resolve this error using function's `resourceGroupName` property, please [create an issue on the GitHub repository for Amplify backend](https://github.com/aws-amplify/amplify-backend/issues/new/choose)

### Circular dependency error with with a custom stack

If you are creating resources using the [AWS Cloud Development Kit (AWS CDK)](https://aws.amazon.com/cdk/) and assigning them to a custom stack, you might also run into this issue. Your error message would look like "The CloudFormation deployment failed due to circular dependency found between nested stacks [storage1234ABCD, auth5678XYZ, **MYCustomStack0123AB**]"

To resolve this, try creating your resources in the same stack as the resources you are trying to interact with. For example, if a custom resource such as `sqs` needs to interact with the underlying Amazon S3 resource created by `defineStorage`, you can create that `sqs` resource in the stack created by Amplify. You can reference the existing Amplify created stack like

```ts title="amplify/backend.ts"
const queue = new sqs.Queue(backend.storage.stack, 'MyCustomQueue');
```

## Circular dependency error between resources in the same stack

If you see this error "The CloudFormation deployment failed due to circular dependency found between resources [resource1, resource2] in a single stack", that means the resources themselves have a circular dependency in the same stack. For handling such errors, review the [AWS Blog post for handling circular dependency errors](https://aws.amazon.com/blogs/infrastructure-and-automation/handling-circular-dependency-errors-in-aws-cloudformation/).


Contents of build-a-backend_troubleshooting_index.txt:
import { getChildPageNodes } from '@/utils/getChildPageNodes';
import { getCustomStaticPath } from '@/utils/getCustomStaticPath';

export const meta = {
  title: 'Troubleshooting',
  description: 'Debugging guides for frequent customer errors',
  route: '/[platform]/build-a-backend/troubleshooting',
  platforms: [
    'angular',
    'javascript',
    'nextjs',
    'react',
    'react-native',
    'vue',
    'swift',
    'android',
    'flutter'
  ]
};

export const getStaticPaths = async () => {
  return getCustomStaticPath(meta.platforms);
};

export function getStaticProps(context) {
  const childPageNodes = getChildPageNodes(meta.route);
  return {
    props: {
      meta,
      childPageNodes
    }
  };
}

<Overview childPageNodes={props.childPageNodes} />


Contents of build-a-backend_troubleshooting_library-not-configured_index.txt:
import { getCustomStaticPath } from '@/utils/getCustomStaticPath';

export const meta = {
  title: 'Troubleshoot configuration errors',
  description: 'Addressing missing configuration or NoCredentials error messages',
  platforms: [
    'angular',
    'javascript',
    'nextjs',
    'react',
    'react-native',
    'vue'
  ]
};

export const getStaticPaths = async () => {
  return getCustomStaticPath(meta.platforms);
};

export function getStaticProps(context) {
  return {
    props: {
      platform: context.params.platform,
      meta
    }
  };
}

If you are running into a missing configuration or `NoCredentials` error message and have called `Amplify.configure` in your project, your Amplify API is most likely being called before `Amplify.configure`. This can happen in a few different ways. Below are three possibilities you can check to troubleshoot this issue.

## Check 1: Validate that `Amplify.configure` is called in the root of your project

Make sure you are calling `Amplify.configure` in the root file of your project. The root file of your app may be different depending on your frontend framework. The current default for some common frameworks are listed below (if you are not using TypeScript the `ts` and `tsx` extensions would be `js` and `jsx`):

* Vue.js: **src/main.ts**
* React: **src/main.tsx**
* Angular: **src/main.ts**
* Next.js Page Router: **pages/_app.tsx** or **src/pages/_app.tsx**
* Nuxt: **app.vue** (Or in a plugins file, as recommended [here](https://docs.amplify.aws/react/build-a-backend/server-side-rendering/nuxt/).)

<Callout>

If you are using the Next.js App Router, you can follow the suggestions in our [Next.js documentation](/[platform]/build-a-backend/server-side-rendering/#configure-amplify-apis-for-server-side-usage) for root-level configuration. Keep in mind that if you are calling any APIs at the module-level (i.e. at the top of your file) in any of the Child components, you may still run into this issue. Continue on the [Check 2](/[platform]/build-a-backend/troubleshooting/library-not-configured/#check-2-move-module-level-amplify-api-invocations) if this is the case.

</Callout>

## Check 2: Move module-level Amplify API invocations

When Amplify APIs are used outside of your application lifecycle, there is a risk that a JavaScript bundler may place that API call before `Amplify.configure`. Module-level function calls (calls at the top-level of a file), are generally evaluated in the order that they are imported.

Below is an example of code that will likely result in a missing configuration or `NoCredentials` error message:

```tsx title="index.ts"
import { Amplify } from 'aws-amplify';
import ComponentX from 'module-fetch-auth';

// fetchAuthSession() in ComponentX executed on import

Amplify.configure();

export default function App() {
  return (
    <div>
        <ComponentX />
    </div>
  );
}
```

```tsx title="module-fetch-auth.tsx"
import { fetchAuthSession } from 'aws-amplify/auth';

fetchAuthSession(); // Will throw "AuthUserPoolException: Auth UserPool not configured."

export default function ComponentX() {
  return (
    <div className="box">
      ...
    </div>
  );
}
```

This error can also happen when using Next.js Layouts and calling Amplify APIs in child components at the module-level (at the top of your file/module). See below for an example of this issue:

```tsx title="layout.tsx"
import ConfigureAmplifyClientSide from '@/ConfigureAmplifyClientSide';

export default function RootLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  return (
    <html lang="en">
      <body className="container py-6">
        <>
          <ConfigureAmplifyClientSide />
          {children}
        </>
      </body>
    </html>
  );
}
```

```tsx title="ConfigureAmplifyClientSide.tsx"
import { Amplify } from "aws-amplify";

Amplify.configure(config, { ssr: true });

export default function ConfigureAmplifyClientSide() {
  return null;
}
```

```tsx title="page.tsx"
import { fetchAuthSession } from "aws-amplify/auth";

// The layout calls configure, but fetchAuthSession ends up executing first
// Will throw "AuthUserPoolException: Auth UserPool not configured."
fetchAuthSession().then((session) => {
  console.log(session);
});

export default function HomePage() {
  return (
    <div className="box">
      ...
    </div>
  );
}
```

To fix this, we suggest moving all Amplify API calls to within the application lifecycle. For instance, if you are using **React**, you can use the `useEffect` hook for functions that should run before the app is loaded:

```tsx title="index.ts"
import { Amplify } from 'aws-amplify';
import ComponentX from 'module-fetch-auth';

Amplify.configure();

export default function App() {
  return (
    <div>
        <ComponentX />
    </div>
  );
}
```

```tsx title="module-fetch-auth.tsx"
import { type AuthSession, fetchAuthSession } from 'aws-amplify/auth';
import { useEffect, useState } from 'react';

export default function ComponentX() {
  const [session, setSession] = useState<AuthSession|undefined>();

  const getSession = async () => {
    try {
      const currentSession = await fetchAuthSession();
      setSession(currentSession);
    } catch (error: unknown) {
      console.log(error);
    }
  };

  useEffect(() => {
    getSession();
  }, []);

  return (
    <div className="box">
      ...
    </div>
  );
}
```

## Check 3: Configure Amplify on each page of a multi-page app

If you are working in a multi-page app, you need to call `Amplify.configure()` for each page/route of your application. We recommend calling `Amplify.configure` in a common source file and importing it into each page.


Contents of build-ui_figma-to-code_index.txt:
import { getCustomStaticPath } from '@/utils/getCustomStaticPath';

export const meta = {
  title: 'Figma-to-React',
  description: 'Generate React code directly inside Figma using Amplify UI.',
  platforms: [
    'javascript',
    'nextjs',
    'react'
  ]
};

export const getStaticPaths = async () => {
  return getCustomStaticPath(meta.platforms);
};

export function getStaticProps(context) {
  return {
    props: {
      platform: context.params.platform,
      meta
    }
  };
}

You can generate React code using the [Amplify UI Figma file](https://www.figma.com/community/file/1047600760128127424) and the [Amplify UI Builder plugin](https://www.figma.com/community/plugin/1040722185526429545).

## Step 1: Duplicate the Amplify UI Figma file

![Duplicate the AWS Amplify UI kit by clicking on "open in Figma"](/images/console/ui-figma-file.png)

This file contains the following pages:

- **README**: The README page explains how to use the Figma file to create new components, theme primitives, and customize layout and styling.
- **Theme**: The theme page displays the theme values and design tokens Amplify UI uses to style the primitives. If you want to theme the primitives, use the [AWS Amplify UI Builder Figma plugin](https://www.figma.com/community/plugin/1040722185526429545) to make changes to the theme. Any changes you make on the theme page itself will not be generated in code.
- **Primitives**: Primitives are building-block components such as alerts, buttons, and badges. These primitives correspond to the [Amplify UI primitives](https://ui.docs.amplify.aws/react/components) and get exported to code with all the primitive properties. This page is read-only. Changes to the primitives on this page will not be reflected in code that is generated.
- **My components**: This page contains all of the custom components built using the primitives. Amplify provides dozens of components such as news feed, social media, and marketing hero components to get you started. Customize these to match your needs or build your own components.
- **Examples**: This is for demonstration purposes only, to show designers how to use our components to build entire pages.

Please follow the README in our Figma file to learn how to create your components to optimize for code quality.

## Step 2: Run the Amplify UI Builder Figma plugin

After you duplicate the Figma file, you run the Amplify UI Builder figma plugin in dev mode or non-dev mode to generate Amplify UI React code.

### Dev Mode

1. Turn on Figma dev mode in your Figma file.
2. Click on the **Plugins** tab.
3. Select the **AWS Amplify UI Builder** plugin.
4. Choose any layer in your file to get React code and a live preview of the generated code.

### Non-dev Mode

1. Click on the **Plugins** tab.
2. Select the **AWS Amplify UI Builder** plugin.
3. Choose **Download component code** to download the React code for your components.


Contents of build-ui_formbuilder_customize_index.txt:
import { getCustomStaticPath } from '@/utils/getCustomStaticPath';

export const meta = {
  title: 'Customize form inputs',
  description: 'Customize Amplify generated form inputs. You can add new form inputs, customize labels, and form action buttons.',
  platforms: [
    'javascript',
    'react',
    'nextjs'
  ]
};

export const getStaticPaths = async () => {
  return getCustomStaticPath(meta.platforms);
};

export function getStaticProps(context) {
  return {
    props: {
      platform: context.params.platform,
      meta
    }
  };
}

In this guide, you will learn how to customize connected forms that are generated by running `npx ampx generate forms`. Before you begin you will need: 

- Your cloud sandbox with an Amplify Data resource up and running (npx ampx sandbox)
- A frontend application that has [generated a connected form](/[platform]/build-ui/formbuilder/)


All Amplify forms are built with the [Amplify UI library](https://ui.docs.amplify.aws/). The generated form provides a mechanism to override properties for each individual input component, like [TextField](https://ui.docs.amplify.aws/react/components/textfield), [TextAreaField](https://ui.docs.amplify.aws/react/components/textareafield), [SelectField](https://ui.docs.amplify.aws/react/components/selectfield). You can override any props to those components with the `overrides` prop on the form component. For example, if you want to change the variation and label of the `content` field in the TodoCreateForm:

```jsx
import TodoCreateForm from '@/ui-components/TodoCreateForm'

<TodoCreateForm
  // highlight-start
  overrides={{
    content: {
      variation: 'quiet',
      label: 'Todo'
    }
  }}
  // highlight-end
/>
```

<Callout>

Note: We do not recommend overriding properties that are already set by the generated form. This could lead to unexpected behavior during runtime. Verify the set properties by navigating to the component in the src/ui-components/[your-form-component].jsx file.

</Callout>
You own updating the code directly for the generated form. Here's how you can customize the form.

## Manually add form input field

You can manually add a form input connected to a data model to the generated form. For example, let's say you add a `priority` field to your data model. Make the following edits to the generated form:

```jsx title="src/ui-components/TodoCreateForm.js"
  // 1. Set initialValues
  const initialValues = {
    content: "",
    // highlight-next-line
    priority: "" // Initial value for priority
  };

  // 2. State setup
  const [priority, setPriority] = React.useState(initialValues.priority);

  // 3. Update resetValues
  const resetStateValues = () => {
    .. // previous fields
    // highlight-next-line
    setPriority(initialValues.priority)
    setErrors({});
  };

  // 4. Validation setup
  const validations = {
    content: [],
    // highlight-next-line
    priority: [] // Assuming no special validations for now
  };

  // 5. Update form submission
   onSubmit={async (event) => {
        event.preventDefault();
        let modelFields = {
          ..,
          // highlight-next-line
          priority
        };

  // 6. Add TextField
  <TextField
     label="Priority"
     isRequired={false}
     isReadOnly={false}
     value={priority}
     onChange={(e) => {
       let { value } = e.target;
       if (onChange) {
         const modelFields = {
           priority: value,
         };
         const result = onChange(modelFields);
         value = result?.priority ?? value;
       }
       if (errors.priority?.hasError) {
         runValidationTasks("priority", value);
       }
       setPriority(value);
     }}
     onBlur={() => runValidationTasks("priority", priority)}
     errorMessage={errors.priority?.errorMessage}
     hasError={errors.priority?.hasError}
     {...getOverrideProps(overrides, "priority")}
   />

```

## Manually add option fields

[Select Fields](https://ui.docs.amplify.aws/react/components/selectfield), [Radio Group Fields](https://ui.docs.amplify.aws/react/components/radiogroupfield), and [Autocomplete Fields](https://ui.docs.amplify.aws/react/components/autocomplete) require a set of options for your users to choose from. For example, a "Status" input can only have the options "Not started", "In progress", and "Done". This would be identical to the above 6 steps, but in step 6 you would replace `<TextField>` with `<SelectField>`

{/* cSpell:disable */}
```js title="src/ui-components/TodoCreateForm.js"
  // 6. Import <SelectField> component and add to form return
  <SelectField
    label="Label" 
    placeholder="Please select an option" 
    value={status} 
    onChange={(e) => {
      let { value } = e.target;
      if (onChange) {
          const modelFields = {
              status: value
          };
          const result = onChange(modelFields);
          value = result?.status ?? value;
      }
      if (errors.status?.hasError) {
          runValidationTasks("status", value);
      }
      setStatus(value);
      }} 
      onBlur={() => runValidationTasks("status", status)}
      errorMessage={errors.status?.errorMessage} 
      hasError={errors.status?.hasError} 
      {...getOverrideProps(overrides, "status")}
    >
      <option children="Not started" value="Not started" {...getOverrideProps(overrides, "statusOption0")}></option>
      <option children="In progress" value="In progress" {...getOverrideProps(overrides, "statusOption1")}></option>
      <option children="Done" value="Done" {...getOverrideProps(overrides, "statusOption2")}></option>
  </SelectField>
```
{/* cSpell:enable */}


## Configure form spacings (paddings and gaps)

Add spacing to your form and between inputs. Spacing values can either be a CSS length value (`px`, `rem`, `em`, `%`) or a reference to your theme object's spacing value (`xss`, `medium`, `large`).

```js
import TodoCreateForm from '@/ui-components/TodoCreateForm'

<TodoCreateForm overrides={{
  // highlight-start
  TodoCreateForm: {
    rowGap: 'xl',    // horizontal gap between inputs
    columnGap: 'xs', // vertical gap between inputs
    padding: 'xl',   // padding around form
  },
  // highlight-end
}} />
```


## Customize label for Submit and Clear buttons

You can customize action button labels to better describe your form's use case, such as changing `Submit` to `Create Todo`.

```js
import TodoCreateForm from '@/ui-components/TodoCreateForm'

<TodoCreateForm overrides={{
  // highlight-start
  ClearButton: {
    children: 'Close'
  },
  SubmitButton: {
    children: 'Save todo'
  }
  // highlight-end
}} />
```

## Toggle visibility for Submit and Clear buttons

You can customize the visibility of action buttons to better accommodate your form's use case.

```js
import TodoCreateForm from '@/ui-components/TodoCreateForm'

<TodoCreateForm overrides={{
  // highlight-start
  ClearButton: {
    display: 'none'
  },
  SubmitButton: {
    display: 'none'
  }
  // highlight-end
}} />
```

If you hide all form action buttons, you can still leverage the [`onChange` event handler](/gen1/[platform]/build-ui/formbuilder/lifecycle/#get-form-data-as-your-user-inputs-data---onchange) to self-manage the form lifecycle. This is useful for a form that updates data in real-time without explicit user confirmation.


```jsx
import TodoCreateForm from '@/ui-components/TodoCreateForm'

<TodoCreateForm
  // highlight-start
  onChange={(fields) => {
    console.log({ fields })
    // make sure you return fields!
    return fields
  }}
  // highlight-end
/>
```


Contents of build-ui_formbuilder_index.txt:
import { getCustomStaticPath } from '@/utils/getCustomStaticPath';

export const meta = {
  title: 'Connected forms',
  description:
    'Generate React forms for creating and updating data in your Amplify data backend.',
  platforms: [
    'javascript',
    'nextjs',
    'react'
  ]
};

export const getStaticPaths = async () => {
  return getCustomStaticPath(meta.platforms);
};

export function getStaticProps(context) {
  return {
    props: {
      platform: context.params.platform,
      meta
    }
  };
}


Connected Forms are bound to a model in your app's data schema. Whenever a connected form is submitted, a record is automatically created or updated in the bound data model, with some or all of the form's input fields mapping to fields in the data model. Connected forms automatically work with any Amplify GraphQL API, and no `onSubmit` handling is required.

## Generate forms
First, install the Amplify UI library.

```bash title="Terminal" showLineNumbers={false}
npm add @aws-amplify/ui-react
```

To use connected forms, you first need to deploy a data model from your sandbox environment. We will use the same example as in the getting started [tutorial](/[platform]/start/quickstart).
To get started run the following command from your project root:

```bash title="Terminal" showLineNumbers={false}
npx ampx generate forms
```

This will generate create and update forms for each model defined in your schema in a folder called `ui-components`.

```bash title="Terminal" showLineNumbers={false}
File written: ui-components/graphql/subscriptions.ts
File written: ui-components/graphql/mutations.ts
File written: ui-components/graphql/queries.ts
File written: ui-components/TodoCreateForm.jsx
File written: ui-components/TodoCreateForm.d.ts
File written: ui-components/TodoUpdateForm.jsx
File written: ui-components/TodoUpdateForm.d.ts
File written: ui-components/utils.js
File written: ui-components/index.js
```


### Re-generating forms

In Gen 2, we automatically generate the form UI for you, which you can then customize and manage. If you decide to update your data model and need to regenerate the forms, please ensure you back up the original `ui-components` folder before executing the `npx ampx generate forms` command again.


## Render React form in your app

1. In your application's entrypoint file (e.g. `src/index.js` for create-react-app or `src/main.jsx` for Vite), add the following imports and configuration

```jsx
// highlight-start
import '@aws-amplify/ui-react/styles.css';
import { ThemeProvider } from '@aws-amplify/ui-react';
// highlight-end
import { Amplify } from 'aws-amplify';

import outputs from './amplify_outputs.json';

Amplify.configure(outputs);
```

2. In your application's entrypoint file (e.g. `src/main.jsx` for Vite), wrap the `<App />` component with the following:

```jsx
<ThemeProvider>
  <App />
</ThemeProvider>
```

3. Import your form by name. For a form named `TodoCreateForm`, you would use the following code:

```jsx
import { TodoCreateForm } from './ui-components';
```

4. Place your form in code. For a form named `ProductCreateForm` in a React project, you could use the following App code:

```jsx
function App() {
  return <TodoCreateForm />;
}

export default App;
```


## Types of forms

All connected and unconnected forms are either a **Create** form or an **Update** form.

### Create forms

Create forms render a form with empty inputs. If a create form is connected to a data model, will always generate a new record upon submission.

### Update forms

Update forms expect an input value in order to pre-populate the form.

For update forms that are connected to a data model, you can use the `id` prop, or the model prop:

- `id` prop: id string of the record you want to update. For example:

```jsx
<AuthorUpdateForm id="ac74af5c-3aab-4274-8f41-23e1e6576af5" />
```

- Model prop: if your form is bound to a data model named `Author`, your form will have a prop named `author` as well, which can receive a record. For example:

```jsx

<AuthorUpdateForm author={authorRecord}>

```


Contents of build-ui_formbuilder_lifecycle_index.txt:
import { getCustomStaticPath } from '@/utils/getCustomStaticPath';
                  
export const meta = {
  title: 'Manage form lifecycle',
  description: "Hook into the form's lifecycle events to customize user input before submission, run validations, handle errors, or self-manage user input events.",
  platforms: [
    'javascript',
    'react',
    'nextjs'
  ]
};

export const getStaticPaths = async () => {
  return getCustomStaticPath(meta.platforms);
};

export function getStaticProps(context) {
  return {
    props: {
      platform: context.params.platform,
      meta
    }
  };
}
          

Hook into the form's lifecycle events to customize user input before submission, run validations, or handle errors. 

![Lifecycle diagram of the Amplify Forms](/images/console/formbuilder/lifecycle-diagram.png)

1. **Initial state** - The inputs are either empty or pre-populated based on a default value provided by you.

  **Use case:** If your user clicks on the **Clear** or **Reset** button, they'll be brought back to this state.

2. [`onChange`](#get-form-data-as-your-user-inputs-data---onchange) - Event when form data is changed by the user.

  **Use case:** Use this to get the form data after every user input.

3. [`onValidate`](#extend-validation-rules-in-code---onvalidate) - Event hook for custom validations. This event triggers after `onChange`.

  **Use case:**  Use this to extend validation rules via code. `onValidate` also supports asynchronous validation rules, which enable you to validate the form input against external APIs.

4. [`onSubmit`](#handle-form-data-submissions---onsubmit) - Event when your user clicks the **Submit** button.

  **Use case:**  If your form is **not connected to a data model**, use set this event handler to retrieve the form data. If your form is **connected to a data model**, use this to customize the provided form data before they are saved to the cloud. 

5. [`onSuccess`](#handle-form-data-successfully-saving-to-the-cloud---onsuccess) - Event when saving form data to the cloud succeeds.

  **Use case:**  Use this to dismiss the form or reroute your user after a successful form submission. Only use this if your form is connected to a data model.

6. [`onError`](#handle-form-submission-errors---onerror) - Event when saving form data to the cloud fails.

  **Use case:**  Use this to log the error and investigate further if your validation rules need to be enhanced to catch input formatting issues. Only use this if your form is connected to a data model.

7. [`onCancel`](#handle-user-clicking-on-undefined-action-button---oncancel) - Event when your user clicks on the **Cancel** button.

  **Use case:**  Use this to dismiss the form without saving the form data.

## Get form data as your user inputs data - onChange

In some cases, you want to get the form data in real-time as the user is filling the form. The `onChange` event provides you the form data in the `fields` parameter. 

```jsx
import { useState } from 'react'
import { HomeCreateForm } from './ui-components'

function App() {
  const [formData, setFormData] = useState()

  return (
    <HomeCreateForm onChange={fields => setFormData(fields)}/>
  )
}
```

## Extend validation rules in code - onValidate

With the `onValidate` event, you can extend the validation rules in code. Learn more about [How to add validation rules](/[platform]/build-ui/formbuilder/validations/).

## Handle form data submissions - onSubmit

`onSubmit` should be your default way to handle form submission. It is triggered every time the user clicks on the **Submit** action button.

You can use the `onSubmit` handler to customize the form data before they are saved to the cloud. The form data that's returned from the `onSubmit` handler will be saved to the cloud.

For example, if you want to trim all the string data before saving it:

```jsx
<HomeCreateForm
    onSubmit={(fields) => {
        const updatedFields = {}
        Object.keys(fields).forEach(key => {
            if (typeof fields[key] === 'string') {
                updatedFields[key] = fields[key].trim()
            } else {
                updatedFields[key] = fields[key]
            }
        })
        return updatedFields
    }}
/>
```

### Handle form data successfully saving to the cloud - onSuccess

You can use the `onSuccess` handler to take an action after the form data has been successfully submitted. The example below hides the form after it has been successfully submitted. 

```jsx
import { useState } from 'react'
import { HomeCreateForm } from './ui-components'

function App() {
  const [showForm, setShowForm] = useState(true)

  return (
    {showForm &&
      <HomeCreateForm onSuccess={() => {
        setShowForm(false) // Hide the form
      }}/>}
  )
}
```

### Handle form submission errors - onError

You might encounter additional errors during the submit process. You can log these errors and present an alert to customers by using the `onError` handler.

```jsx
import { HomeCreateForm } from './ui-components'

function App() {
  return (
    <HomeCreateForm onError={(error) => {
      console.log(error)
    }}/>
  )
}
```

## Handle user clicking on **Cancel** action button - onCancel

If the user clicks on the **Cancel** action button, you can use the `onCancel` event to hide the form or route the customer to another page.

```jsx
import { useState } from 'react'
import { HomeCreateForm } from './ui-components'

function App() {
  const [showForm, setShowForm] = useState(true)

  return (
    {showForm &&
      <HomeCreateForm onCancel={() => {
        setShowForm(false) // Hide the form
      }}/>}
  )
}
```


Contents of build-ui_formbuilder_special-inputs_index.txt:
import { getCustomStaticPath } from '@/utils/getCustomStaticPath';

export const meta = {
  title: 'Configure special inputs',
  description: 'Special input fields in Amplify form builder allow the user to interact with unique Amplify features',
  platforms: [
    'javascript',
    'react',
    'nextjs'
  ]
};

export const getStaticPaths = async () => {
  return getCustomStaticPath(meta.platforms);
};

export function getStaticProps(context) {
  return {
    props: {
      platform: context.params.platform,
      meta
    }
  };
}



## File Uploader


[**File Uploader**](https://ui.docs.amplify.aws/react/connected-components/storage/fileuploader) fields allow your forms to accept file uploads, which are stored in an Amazon S3 bucket connected to your Amplify app. After uploading, that file's S3 key is stored in your data model, allowing for systematic retrieval using the [Amplify JS library](/[platform]/build-a-backend/storage/download-files/).


### Prerequisites

In order to use the File Uploader field, your Amplify app must have an Amplify app with [Authentication](/[platform]/build-a-backend/auth/set-up-auth/) and [Storage](/[platform]/build-a-backend/storage/set-up-storage/) enabled.


### How it works

The File Uploader input will allow users to select from files on their local device and upload them to an S3 bucket. File Uploader automatically connects to your S3 bucket added as part of Amplify Storage.

Files are uploaded immediately upon selection, and an S3 key is generated. By default, File Uploader will generate a [unique S3 key](#unique-s3-keys) based on the file uploaded. On form submission, File Uploader will return the S3 key of the uploaded file as a `String`.


### Adding it to your form

To use the FileUploader component with an autogenerated form you will first need a data model that has an attribute that is either a string or an array of strings (`a.string().array()` in **amplify/data/resource.ts**). Then make sure to run `npx ampx generate forms` after you update your data model. 

Then go into the generated form JSX file you want to use the FileUploader, for example: **ui-components/TodoCreateForm.jsx**. If your attribute is an array of strings, look for an `<ArrayField>` with `items={images}` (if your attribute name is "images"). Remove that entire component and replace it with the FileUploader component like this:

```jsx title="ui-components/TodoCreateForm.jsx"
// imports
import { FileUploader } from "@aws-amplify/ui-react-storage";
// import the processFile helper function which will create unique filenames based on the file contents
import { processFile } from "./utils";

//...
<FileUploader
  accessLevel="public"
  maxFileCount={10}
  acceptedFileTypes={['image/*']}
  processFile={processFile}
  onUploadSuccess={({key}) => {
    // assuming you have an attribute called 'images' on your data model that is an array of strings
    setImages(prevImages => [...prevImages, key])
  }}
  onFileRemove={({key}) => {
    setImages(prevImages => prevImages.filter(img => img !== key))
  }}
/>
```


If you want your data model to have only one image instead of an array of images, look for the `<TextField>` component with `value={image}` and replace it with the FileUploader component like this:


```jsx title="ui-components/TodoCreateForm.jsx"
// imports
import { FileUploader } from "@aws-amplify/ui-react-storage";
// import the processFile helper function which will create unique filenames based on the file contents
import { processFile } from "./utils";

//...
<FileUploader
  accessLevel="public"
  maxFileCount={1}
  acceptedFileTypes={['image/*']}
  processFile={processFile}
  onUploadSuccess={({key}) => {
    // assuming you have an attribute called 'images' on your data model that is an array of strings
    setImage(key)
  }}
  onFileRemove={({key}) => {
    setImage(undefined)
  }}
/>
```

See the documentation for the [FileUploader](https://ui.docs.amplify.aws/react/connected-components/storage/fileuploader) for all configuration options. 


### Unique S3 keys

If files with identical S3 keys are uploaded to the same path, S3 will overwrite those files. To prevent accidental overwriting of files, File Uploader generates a unique S3 key by hashing the _file contents_. Uploading different files with the same name will not overwrite the original file.

However, if a form submitter uploads two identical files to the same path - even with different file names - File Uploader will prevent file duplication in your S3 bucket.

<Callout warning>

File overwriting only occurs for identical S3 keys _in the same path_. If the **File level access** for your File Uploader is set to `private` or `protected`, identical files uploaded by separate users will be saved separately.

<br />
If your **File level access** is set to `public`, identical files will overwrite
each other.

</Callout>


Contents of build-ui_formbuilder_validations_index.txt:
import { getCustomStaticPath } from '@/utils/getCustomStaticPath';

export const meta = {
  title: 'Validate form data',
  description: "Add and customize validation rules on Amplify generated forms",
  platforms: [
    'javascript',
    'react',
    'nextjs'
  ]
};

export const getStaticPaths = async () => {
  return getCustomStaticPath(meta.platforms);
};

export function getStaticProps(context) {
  return {
    props: {
      platform: context.params.platform,
      meta
    }
  };
}

Sanitize user input by adding validation rules to your form. By default, Amplify generated forms infers a range of validation rules based on the data model. For example, given a data model with an `AWSEmail` field, the generated form input will automatically run an email validation rule.

## Configurable validation rules

By default, the following validation rules are available for you to configure:

| Input type | Configurable validation rule |
| --- | --- |
| `String` | - Start With <br/> - End With <br/> - Contain <br/> - Does not contain <br/> - Be less than N characters long <br/> - Be at least N characters long <br/> |
| `Int`, `Float` | - Be greater than <br/> - Be less than <br/> - Be equal to <br/> |
| `AWSDate`, `AWSTime`, `AWSDateTime` | - Be before <br/> - Be after <br/> |

### Automatically configured validation rules

For the types below, we automatically apply validation rules on form inputs:

- `AWSIPAddress`: input value must be a valid IPv4 or IPv6 address.
- `AWSURL`: input value must consist of a schema (`http`, `mailto`) and a path part. Path part can't contain two forward slashes (//).
- `AWSEmail`: input value must be an email address in the format `<local-part>@<domain-part>`.
- `AWSJSON`: input value must be a valid JSON.
- `AWSPhone`: input value must be a phone number that can contain either spaces or hyphens to separate digit groups.

## Add validation rules

Every form provides an `onValidate` event handler to provide additional validation rules via code. Return an object with validation functions for the fields you want to validate. In the example below, `address` must start with a number, otherwise return any existing auto-generated validation responses.

```jsx
<HomeCreateForm
  onValidate={{
    address: (value, validationResponse) => {
      const firstWord = value.split('')[0];
      if (!isNaN(firstWord)) {
        // check if the first word is a number
        return {
          hasError: true,
          errorMessage: 'Address must start with a number'
        };
      }
      return validationResponse;
    }
  }}
/>
```

**Note:** the validation function must return a validation response of the following shape:

```ts
type ValidationResponse = {
  hasError: boolean;
  errorMessage?: string;
};
```

### Add validation rules for nested JSON data

Amplify generated forms can also produce nested JSON object. For example, you can create a new `ProductForm` component based on the following JSON object:

```json
{
  "name": "Piano",
  "price": {
    "maxDiscount": 0.15,
    "default": 999,
    "currency": "$"
  }
}
```

To add validation rules to the nested objects, pass in validation functions in the same nested structure as the data:

```js
<ProductForm
  onValidate={{
    price: {
      currency: (value, validationResponse) => {
        // Pass validation function to match the nested object
        const allowedCurrencies = ['$', '€', '￥', '₹'];
        if (!allowedCurrencies.includes(value)) {
          return {
            hasError: true,
            errorMessage: 'Currency must be either "$", "€", "￥", or "₹".'
          };
        }
        return validationResponse;
      }
    }
  }}
  onSubmit={(fields) => {
    /* handle form data submission */
  }}
/>
```

### Call external APIs for asynchronous form validation

Sometimes your form needs to asynchronously validate an input with an external API or database before the form data is submitted.

Return a Promise in the `onValidate` prop to run an asynchronous validation rule. In the following example, we check with an external API if a real estate agent exist based on a given license number:

```jsx
<AgentContactForm
  onValidate={{
    licenseNumber: (value, validationResponse) => {
      // fetch calls an external API,
      // which ultimately returns a Promise<ValidationResponse>
      return fetch(`http://localhost:3000/api/agent/${value}`).then(
        (response) => {
          if (response.status !== 200) {
            return {
              // If the request failed, return a validation error
              hasError: true,
              errorMessage: 'No agent was not found with that license number.'
            };
          }
          return validationResponse;
        }
      );
    }
  }}
  onSubmit={(fields) => {
    /* Handle form submission */
  }}
/>
```


Contents of build-ui_index.txt:
import { getChildPageNodes } from '@/utils/getChildPageNodes';
import { getCustomStaticPath } from '@/utils/getCustomStaticPath';

export const meta = {
  title: 'Build UI',
  description: 'Learn how to build and customize your UI.',
  route: '/[platform]/build-ui',
  platforms: [
    'angular',
    'javascript',
    'nextjs',
    'react',
    'react-native',
    'flutter',
    'vue',
    'swift',
    'android'
  ]
};

export const getStaticPaths = async () => {
  return getCustomStaticPath(meta.platforms);
};

export function getStaticProps(context) {
  const childPageNodes = getChildPageNodes(meta.route);
  return {
    props: {
      meta,
      childPageNodes
    }
  };
}

Amplify offers a [UI Library](https://ui.docs.amplify.aws) that makes it easy to build web app user interfaces that are connected to the backend. Amplify UI offers:

* **Connected components** that are designed to work seamlessly with AWS Amplify backend services, allowing you to quickly add common UX patterns for authentication, storage etc. without having to build them from scratch.
<InlineFilter filters={["javascript", "nextjs", "react"]}>
* **Tooling** that generates React forms over data, and React components from Figma designs.
</InlineFilter>

<Overview childPageNodes={props.childPageNodes} />



Contents of deploy-and-host_fullstack-branching_branch-deployments_index.txt:
import { getCustomStaticPath } from '@/utils/getCustomStaticPath';

export const meta = {
  title: 'Fullstack branch deployments',
  description: 'Use fullstack branch deployments to test changes from feature branches.',
  platforms: [
    'android',
    'angular',
    'flutter',
    'javascript',
    'nextjs',
    'react',
    'react-native',
    'swift',
    'vue'
  ]
};

export const getStaticPaths = async () => {
  return getCustomStaticPath(meta.platforms);
};

export function getStaticProps(context) {
  return {
    props: {
      meta
    }
  };

}

Amplify code-first DX (Gen 2) offers fullstack branch deployments that allow you to automatically deploy infrastructure and application code changes from feature branches. This enables testing changes in an isolated environment before merging to the main branch.

## Set up feature branch deployments

After you've deployed your [first branch](/[platform]/start/quickstart/), you can manually connect more, but the recommended workflow is to use the **branch auto-detection** feature.

1. Log in to the [Amplify console](https://console.aws.amazon.com/amplify/home) and choose your app.

2. Navigate to **App settings > Branch settings**, select **Edit** and enable **Branch auto-detection** and **Branch auto-disconnection**. The following video uses the default settings, which will connect any branch in your repo automatically. Branch auto-disconnection will ensure that if you delete a branch from your repository, the branch will also be deleted.

<Callout>
You can also define a pattern to connect only certain branches. For example, setting `dev`, `staging`, and `feature/*` will automatically connect all three branch types. Your `dev` and `staging` branches, as well as any branch that begins with `feature/`, will be connected.
</Callout>

<Video src="/images/gen2/fullstack-branching/Enable-branch-autodetection.mp4" description="Video - Enable branch autodetection" />

3. Push a commit to your `feature/A` and `staging` branches that match the pattern. You should start seeing deployments on the console page. You will now have three fullstack branches deployed.

![Production, feature/A, and staging branches listed on app overview page in Amplify console.](/images/gen2/fullstack-branching/branches.png)

## Promote changes to production

In Gen 2, promoting changes to production follows the normal Git-based workflow.

![Workflow for merging changes from feature/A branch to main, or production, branch.](/images/gen2/fullstack-branching/gitflow.png)

1. Make a change in your `feature/A` branch.

```bash title="Terminal" showLineNumbers={false}
git checkout -b feature/A

## make some edits to your code

git commit --am "New data model to track comments for todos added"

git push origin feature/A
```

2. Submit a pull request to your `main` branch. Once your team has validated the changes, merge the pull request to `main`. This will initiate a build on your `main` branch and update any frontend or backend resources that you changed.


### Generate client config

You can generate the config for a branch environment by running:

<InlineFilter filters={['angular','javascript','nextjs','react','react-native','swift','vue']}>
For Web and React Native, generating the config with the default format and output directory.

```bash title="Terminal" showLineNumbers={false}
npx ampx generate outputs --app-id <your-amplify-app-id> --branch <your-git-branch-name> --out-dir <path/to/config>
```
</InlineFilter>

<InlineFilter filters={['android']}>
<Callout warning>
  Be sure to add a "raw" folder under app/src/main/res directory if it doesn't
  exist.
</Callout>

```bash title="Terminal" showLineNumbers={false}
npx ampx generate outputs --app-id <your-amplify-app-id> --branch <your-git-branch-name> --out-dir app/src/main/res/raw
```
</InlineFilter>
<InlineFilter filters={['flutter']}>
```bash title="Terminal" showLineNumbers={false}
npx ampx generate outputs --app-id <your-amplify-app-id> --branch <your-git-branch-name> --format dart --out-dir lib
```
</InlineFilter>
<InlineFilter filters={['swift']}>
```bash title="Terminal" showLineNumbers={false}
npx ampx generate outputs --app-id <your-amplify-app-id> --branch <your-git-branch-name>
```

Once the sandbox environment is running, you would also generate the configuration file for your application. However, Xcode won't recognize the file by default. To recognize the files, you need to drag and drop the generated configuration file to your project.

<Video src="/images/gen2/getting-started/ios/ios-getting-started-2.mp4" description="Video - iOS Getting Started" />

</InlineFilter>


Contents of deploy-and-host_fullstack-branching_cross-account-deployments_index.txt:
import { getCustomStaticPath } from '@/utils/getCustomStaticPath';

export const meta = {
  title: 'Cross-account deployments',
  description:
    'Set up a cross-account deployment pipeline powered by Amazon CodeCatalyst and AWS Amplify Hosting.',
  platforms: [
    'android',
    'angular',
    'flutter',
    'javascript',
    'nextjs',
    'react',
    'react-native',
    'swift',
    'vue'
  ]
};

export const getStaticPaths = async () => {
  return getCustomStaticPath(meta.platforms);
};

export function getStaticProps(context) {
  return {
    props: {
      platform: context.params.platform,
      meta
    }
  };
}

This guide walks you through how to create a trunk-based, multi-region deployment pipeline for applications built using AWS Amplify Gen 2. We will be using Amazon CodeCatalyst and AWS Amplify Hosting in this guide, but you can choose any CI/CD provider.

<Callout info>

**Note**: You can deploy this custom pipeline either in the us-west-2 or eu-west-1 Regions, as Amazon CodeCatalyst is currently only available in those two [AWS Regions](https://docs.aws.amazon.com/general/latest/gr/codecatalyst.html).

</Callout>

## Step 1: Set up an Amazon CodeCatalyst space

Please refer to this Amazon CodeCatalyst [guide](https://docs.aws.amazon.com/codecatalyst/latest/userguide/setting-up-topnode.html) for a detailed step-by-step walkthrough to set up your [space](https://docs.aws.amazon.com/codecatalyst/latest/userguide/spaces.html).

## Step 2: Deploy a fullstack Amplify Gen 2 app

<InlineFilter filters={["nextjs"]}>

 - Use our [**Next.js starter template**](/[platform]/start/quickstart/nextjs-pages-router/#1-create-the-repository) to create a repository in your GitHub account.
- Sign in to the [AWS Management Console](https://console.aws.amazon.com/).
- Navigate to the Amplify console and select [**Create new app**](https://us-west-2.console.aws.amazon.com/amplify/create).
- Select the **next-pages-template** repository, then select **Next**.
- Review the details on the **Create Git Repository** page, then select **Save and deploy**.
- Done! You have successfully deployed a fullstack Gen 2 app. You can review the status of the app deployment in the Amplify console.

 </InlineFilter>

<InlineFilter filters={["angular", "android", "javascript", "react", "react-native", "swift", "vue", "flutter"]}>

- Sign in to the [AWS Management Console](https://console.aws.amazon.com/).
- Navigate to the Amplify console and select [**Create new app**](https://us-west-2.console.aws.amazon.com/amplify/create).
- Select the **next-pages-template** repository, then select **Next**.
- Review the details on the **Create Git Repository** page, then select **Save and deploy**.
- Done! You have successfully deployed a fullstack Gen 2 app. You can review the status of the app deployment in the Amplify console.

 </InlineFilter>


![Screenshot of completed deployment in AWS Amplify Gen 2 console](images/gen2/cross-account-deployments/pipeline1.png)

## Step 3: Update build specification

Add the `npx ampx generate outputs --branch $AWS_BRANCH --app-id $AWS_APP_ID` command to the build spec and comment out the `npx ampx pipeline-deploy --branch $AWS_BRANCH --app-id $AWS_APP_ID` command. `ampx pipeline-deploy` runs a script to deploy backend updates, while `ampx generate outputs` fetches the latest `amplify_outputs.json` for the specified environment.

![Screenshot of Build image settings section in AWS Amplify Gen 2 console, with details about the app build specification](images/gen2/cross-account-deployments/pipeline10.png)

## Step 4: Disable automatic builds on the branch

You can configure Amplify to disable automatic builds on every code commit. Navigate to the app in the Amplify console. Under **App settings**, select **Branch settings**. From the **Branches** section, select the branch and then choose **Disable auto build** from the **Actions** dropdown menu.

<Video src="/images/gen2/fullstack-branching/auto-build.mp4" description="Video - Disable automatic builds on the branch" />

## Step 5: Create an incoming webhook

You can set up an incoming webhook to trigger a build without committing code to your Git repository. Use the Amplify Console to create an [incoming webhook](https://docs.aws.amazon.com/amplify/latest/userguide/webhooks.html).

Navigate to the app, under **Hosting > Build settings** select **Create webhook**. Provide a **name** for the webhook and select the **target branch** to build on incoming webhook requests.

![Screenshot of the Build settings page in the Amplify console showing the incoming webhooks feature](/images/gen2/fullstack-branching/multirepo5.png)

Next, select the webhook and copy the `curl` command which will be used to trigger a build for the app.

![Screenshot of the Incoming webhooks page in the Amplify console displaying the newly created webhook](/images/gen2/fullstack-branching/multirepo6.png)

## Step 6: Create a new Amazon CodeCatalyst project

Please refer to this Amazon CodeCatalyst [guide](https://docs.aws.amazon.com/codecatalyst/latest/userguide/projects-create.html#projects-create-github) for a detailed step-by-step walkthrough to create a new [project](https://docs.aws.amazon.com/codecatalyst/latest/userguide/projects.html).

<Callout info>

**Note**: When creating your project, select the **next-pages-template** GitHub repository, which we used to deploy the app in Step 2.

</Callout>

![Screenshot of CodeCatalyst console showing Source repositories section](images/gen2/cross-account-deployments/pipeline2.png)

## Step 7: Set up the resources in a different or target AWS account

To achieve a cross-account deployment, you will need to implement Steps 1 through 6 outlined previously in this guide in a different AWS account (for example, `production` account).

## Step 8: Add the target AWS account to the CodeCatalyst space

Navigate to the CodeCatalyst space created as part of Step 1, select **Settings**, and then select **AWS accounts**. Add the target **AWS account ID** (Step 7) to it and select **Associate AWS account**.

![Screenshot of CodeCatalyst console showing details of the Associate AWS account section](images/gen2/cross-account-deployments/pipeline12.png)

You will also need to create an IAM role in the target AWS account which will be assumed by the `staging` environment to perform actions and deploy resources in the `production` environment. As a best practice, we recommend attaching the [`AmplifyBackendDeployFullAccess`](https://docs.aws.amazon.com/amplify/latest/userguide/security-iam-awsmanpol.html#security-iam-awsmanpol-AmplifyBackendDeployFullAccess) AWS managed policy to the IAM role as it contains all the required permissions to deploy Gen 2 resources in your account. You can learn more about adding IAM roles to account connections in the CodeCatalyst [documentation](https://docs.aws.amazon.com/codecatalyst/latest/userguide/ipa-connect-account-addroles.html).

## Step 9: Create a workflow in the Amazon CodeCatalyst project

A workflow is an automated procedure that describes how to build, test, and deploy your code as part of a continuous integration and continuous delivery (CI/CD) system. You can learn more about workflows in the [Amazon CodeCatalyst User Guide](https://docs.aws.amazon.com/codecatalyst/latest/userguide/flows.html).

- Within the CodeCatalyst project, navigate to the **CI/CD** feature and select **Workflows**.
- Select **Create workflow**.
- Choose the **next-pages-template** GitHub repository and the branch **main** from the dropdown menu.
- Next, select **Create**.

![Screenshot of the CodeCatalyst console showing details of the Create workflow dialog box](images/gen2/cross-account-deployments/pipeline3.png)

Once you create the workflow, you should see a **yaml** editor in the CodeCatalyst console.

![Screenshot of yaml editor in CodeCatalyst console](images/gen2/cross-account-deployments/pipeline4.png)

Switch the experience in the console to the **Visual** editor. Select the **Actions** button to see a list of workflow actions that you can add to your workflow.

![Screenshot of CodeCatalyst console showing the Workflows section with +Actions highlighted](images/gen2/cross-account-deployments/pipeline5.png)

Add the **Build** action to the workflow and select the **Add variable** button in the **Inputs** section. Add the following environment variables to it:

- AWS_APP_ID_STAGING: `amplify app id for staging app`
- AWS_APP_ID_PRODUCTION: `amplify app id for production app`
- AWS_BRANCH: `git branch name`

![Screenshot of CodeCatalyst console showing the Workflows section, focusing on Inputs for the build](images/gen2/cross-account-deployments/pipeline13.png)

Add another **Build** action to the workflow and select the **Depends on** button in the **Inputs** section. From the dropdown menu, select the name of the previous build action to set up the pipeline.

![Screenshot of CodeCatalyst console showing the Workflows section, focusing on the visual workflow and the Inputs section](images/gen2/cross-account-deployments/pipeline14.png)

Next, select the **Configuration** section and add the following information to each of the build actions:

- Environment information (optional): `staging, production, etc.`
- AWS account connection: `your account connection`
- Role: `role setup with your account connection`

![Screenshot of CodeCatalyst console showing the Workflows section, focusing on the Configuration section](images/gen2/cross-account-deployments/pipeline8.png)

You will then need to add the following shell commands to each of the build actions:

```bash title="Terminal" showLineNumbers={false}
// This environment variable is required to run the pipeline-deploy command in a non Amplify CI environment
- Run: export CI=1

// Perform a clean install of the dependencies
- Run: npm ci

// Deploy the backend for your Amplify Gen 2 app
- Run: npx ampx pipeline-deploy --branch $AWS_BRANCH --app-id $AWS_APP_ID

// Trigger frontend build using incoming webhooks
- Run: if [ $AWS_BRANCH = "main" ]; then curl -X POST -d {} "`webhookUrl`&operation=startbuild" -H "Content-Type:application/json"; fi
```

You can now run **Validate** to ensure your workflow definition `yaml` file is valid. Lastly, select **Commit** to save your changes.

<Callout info>

**Note**: Since workflows are saved as commits, and this workflow has a code push trigger enabled, committing the workflow will automatically start a new workflow run.

</Callout>

Next, you can review the result of the workflow run from the **Runs** tab:

![Screenshot of CodeCatalyst console showing the Workflows section, focusing on the Runs tab](images/gen2/cross-account-deployments/pipeline11.png)

Done! You have successfully set up a custom cross-account pipeline to deploy your frontend and backend for apps built using Amplify Gen 2. To summarize, this custom pipeline will enable you to deploy your backend initially with your `staging` environment using `ampx pipeline-deploy` in the CodeCatalyst workflow and `ampx generate outputs` will generate the `amplify_outputs.json` file for the `main` branch. Amplify Hosting will not deploy backend resources as part of the build and instead will use the deployed backend resources from the `main` branch. Once the staging environment deploys successfully, a similar process will be followed to deploy your `production` environment in a different AWS account.


Contents of deploy-and-host_fullstack-branching_custom-pipelines_index.txt:
import { getCustomStaticPath } from '@/utils/getCustomStaticPath';

export const meta = {
  title: 'Custom pipelines',
  description: 'Set up fullstack CI/CD in a custom pipeline.',
  platforms: [
    'android',
    'angular',
    'flutter',
    'javascript',
    'nextjs',
    'react',
    'react-native',
    'swift',
    'vue'
  ]
};

export const getStaticPaths = async () => {
  return getCustomStaticPath(meta.platforms);
};

export function getStaticProps(context) {
  return {
    props: {
      meta
    }
  };

}

While building with Amplify CI/CD offers benefits such as zero-config setup, fullstack previews, centralized secrets management, Amplify Gen 2 makes it easy to integrate fullstack CI/CD into your custom pipelines (for example, AWS CodePipeline, Amazon CodeCatalyst, GitHub Actions, and more).

## Set up backend deployments

You can set up your backend deployments using the following steps:

1.  Create an Amplify app by connecting a fullstack Gen 2 branch from your Git repository. This is a one time setup as for subsequent deployments, we will be using a custom pipeline.

2.  Disable Auto-build for your branch. This will ensure code commits to your branch will not trigger a build.

<Video src="/images/gen2/fullstack-branching/auto-build.mp4"  description="Video - Disable auto-build" />

3. Update the Amplify build specification file to add `npx ampx generate outputs --branch $AWS_BRANCH --app-id $AWS_APP_ID` and comment out the `pipeline-deploy` script. `ampx pipeline-deploy` runs a script to deploy backend updates, while `ampx generate outputs` fetches the latest `amplify_outputs.json` for the specified environment.

![custom-ci](/images/gen2/fullstack-branching/custom-ci.png)

4. Now go to your pipeline provider and update the build settings to include the following:
    * Run `npm ci`.
    * Run `export CI=1` to tell the deployment script that is a CI environment.
    * Run `npx ampx pipeline-deploy --branch BRANCH_NAME --app-id AMPLIFY_APP_ID`. `BRANCH_NAME` refers to the branch you're deploying. `AMPLIFY_APP_ID` is the Amplify App ID. To locate the `App ID` for your backend application, navigate to the Amplify console and select your **backend-app**. On the Overview page, the `App ID` is displayed under the project name.

The example below demonstrates how you would set up the build-spec when using Amazon CodeCatalyst.

```yaml
Actions:
  Build_82:
    # Identifies the action. Do not modify this value.
    Identifier: aws/build@v1.0.0
    # Specifies the source and/or artifacts to pass to the action as input.
    Inputs:
      # Optional
      Sources:
        - WorkflowSource # This specifies that the action requires this Workflow as a source
      Variables:
        - Name: BRANCH_NAME
          Value: main
        - Name: AMPLIFY_APP_ID
          Value: #####
    Configuration:
      # Required - Steps are sequential instructions that run shell commands
      Steps:
        - Run: export CI=1
        - Run: npm ci
        - Run: npx ampx pipeline-deploy --branch $BRANCH_NAME --app-id $AMPLIFY_APP_ID
```
5. Trigger a `git push` to your branch. Your build logs should show that there is an AWS CloudFormation deployment underway.

## Set up frontend deployments

If you want to complete the fullstack CI/CD setup, we have to build, deploy, and host the frontend in addition to the backend.

1. Use the Amplify Console to create an [incoming webhook](https://docs.aws.amazon.com/amplify/latest/userguide/webhooks.html).

2. Navigate to the frontend app, under **Hosting > Build settings** select **Create webhook**. Provide a **name** for the webhook and select the **target branch** to build on incoming webhook requests.

![Screenshot of the Build settings page in the Amplify console showing the incoming webhooks feature](/images/gen2/fullstack-branching/multirepo5.png)

3. Next, select the webhook and copy the `curl` command which will be used to trigger a build for the frontend app.

![Screenshot of the Incoming webhooks page in the Amplify console displaying the newly created webhook](/images/gen2/fullstack-branching/multirepo6.png)

4. Now update your custom-pipeline build settings to include the `curl` command to trigger a frontend build after the `pipeline-deploy` succeeds. Using the same Amazon CodeCatalyst example above, this step includes:

``` yaml
    Configuration:
      # Required - Steps are sequential instructions that run shell commands
      Steps:
        - Run: export CI=1
        - Run: npm ci
        - Run: npx ampx pipeline-deploy --branch $BRANCH_NAME --app-id $AMPLIFY_APP_ID
        - Run: if [ $BRANCH_NAME = "main" ]; then curl -X POST -d {}
            "https://webhooks.amplify.us-west-2.amazonaws.com/prod/webhooks?id=WEBHOOK-ID&token=TOKEN&operation=startbuild"
            -H "Content-Type:application/json"; fi
```

4. This should trigger a build in your Amplify app. Amplify CI will build and first generate the `amplify_outputs.json` for the branch and then build, deploy, and host the frontend.


Contents of deploy-and-host_fullstack-branching_index.txt:
import { getChildPageNodes } from '@/utils/getChildPageNodes';
import { getCustomStaticPath } from '@/utils/getCustomStaticPath';

export const meta = {
  title: 'Fullstack workflows',
  description: 'Overview of fullstack branching capabilities.',
  route: '/[platform]/deploy-and-host/fullstack-branching',
  platforms: [
    'android',
    'angular',
    'flutter',
    'javascript',
    'nextjs',
    'react',
    'react-native',
    'swift',
    'vue'
  ]
};

export const getStaticPaths = async () => {
  return getCustomStaticPath(meta.platforms);
};

export function getStaticProps(context) {
  const childPageNodes = getChildPageNodes(meta.route);
  return {
    props: {
      meta,
      childPageNodes
    }
  };
}

<Overview childPageNodes={props.childPageNodes} />


Contents of deploy-and-host_fullstack-branching_mono-and-multi-repos_index.txt:
import { getCustomStaticPath } from '@/utils/getCustomStaticPath';

export const meta = {
  title: 'Separate frontend and backend teams',
  description:
    'Set up multiple repositories with the Amplify CI/CD pipeline.',
  platforms: [
    'android',
    'angular',
    'flutter',
    'javascript',
    'nextjs',
    'react',
    'react-native',
    'swift',
    'vue'
  ]
};

export const getStaticPaths = async () => {
  return getCustomStaticPath(meta.platforms);
};

export function getStaticProps(context) {
  return {
    props: {
      meta
    }
  };

}

You might have different frontend and backend teams that maintain their own repositories. With Amplify Gen 2, you can deploy repositories that have backend-only code, so frontend and backend teams can operate independently of each other.

## Deploy the backend app

1. Run `mkdir backend-app && cd backend-app && npm create amplify@latest` to set up a backend-only Amplify project. Commit the code to a Git provider of your choice.

1. Connect the `backend-app` in the new console. Navigate to the Amplify console and select **Create new app**.

1. When you connect the repository, notice the only auto-detected framework is Amplify.

![Screenshot of the App Settings section in the Amplify console with Amplify Deploy listed under Auto-detected frameworks](/images/gen2/fullstack-branching/multirepo1.png)

4. Once you choose **Save and deploy**, your backend project will build.

![Screenshot of the Overview page in the Amplify console showcasing the deployment for the main branch](/images/gen2/fullstack-branching/multirepo2.png)

## Deploy the frontend app

1. Now let's set up the frontend app and connect to the deployed backend.

```bash title="Terminal" showLineNumbers={false}
npm create next-app@14 -- multi-repo-example --typescript --eslint --no-app --no-src-dir --no-tailwind --import-alias '@/*'

```

2. Install Amplify dependencies.

```bash title="Terminal" showLineNumbers={false}
cd multi-repo-example
npm add @aws-amplify/backend-cli aws-amplify @aws-amplify/ui-react
```

3. To connect to the deployed backend, run the following command. To locate the `App ID` for your backend application, navigate to the Amplify console and select your **backend-app**. On the Overview page, the `App ID` is displayed under the project name.

```bash title="Terminal" showLineNumbers={false}
npx ampx generate outputs --branch main --app-id <your-backend-app-id>
```

This will generate the `amplify_outputs.json` file that contains all the information about your backend at the root of your project.

<img
  src="/images/gen2/fullstack-branching/multirepo3.png"
  alt="Screenshot of project folder contents with amplify_outputs.json file highlighted"
  width="300"
/>

4. To validate that your frontend can connect to the backend, add the `Authenticator` login form to your app.

```ts title="pages/_app.tsx"
import { withAuthenticator } from '@aws-amplify/ui-react';
import { Amplify } from 'aws-amplify';
import outputs from '@/amplify_outputs.json';
import '@aws-amplify/ui-react/styles.css';
import '@/styles/globals.css';
import type { AppProps } from 'next/app';

// configure the Amplify client library with the configuration generated by `ampx sandbox`
Amplify.configure(outputs);

function App({ Component, pageProps }: AppProps) {
  return <Component {...pageProps} />;
}

export default withAuthenticator(App);
```

4. Let's also add an `amplify.yml` build-spec to our repository.

```yaml
version: 1
backend:
  phases:
    build:
      commands:
        - npm ci --cache .npm --prefer-offline
        - npx ampx generate outputs --branch main --app-id BACKEND-APPID
frontend:
  phases:
    build:
      commands:
        - npm run build
  artifacts:
    baseDirectory: .next
    files:
      - '**/*'
  cache:
    paths:
      - .next/cache/**/*
      - .npm/**/*
      - node_modules/**/*
```

4. Now let's deploy the app. In the Amplify console, choose **Create new app**. Connect the repository with the default settings. You should see that the build generates the output and does not deploy a frontend. Validate that your app is working fine.

![Screenshot of the Deployments page in the Amplify console showing the build of the app](/images/gen2/fullstack-branching/multirepo4.png)

## Trigger a frontend build on backend updates

The ideal scenario is that the frontend automatically retrieves the latest updates from the backend every time there is a modification made to the backend code.

1. Use the Amplify Console to create an [incoming webhook](https://docs.aws.amazon.com/amplify/latest/userguide/webhooks.html).

2. Navigate to the **multi-repo-example** app, under **Hosting > Build settings** select **Create webhook**. Provide a **name** for the webhook and select the **target branch** to build on incoming webhook requests.

![Screenshot of the Build settings page in the Amplify console showing the incoming webhooks feature](/images/gen2/fullstack-branching/multirepo5.png)

3. Next, select the webhook and copy the `curl` command which will be used to trigger a build for the **multi-repo-example** app.

![Screenshot of the Incoming webhooks page in the Amplify console displaying the newly created webhook](/images/gen2/fullstack-branching/multirepo6.png)

4. Now update the build settings for the `backend-app` to include the `curl` command to trigger a frontend build any time there are changes to the backend.

```yaml title="amplify.yml"
version: 1
backend:
  phases:
    build:
      commands:
        - npm ci --cache .npm --prefer-offline
        - npx ampx pipeline-deploy --branch $AWS_BRANCH --app-id $AWS_APP_ID
frontend:
  phases:
    build:
      commands:
        - mkdir ./dist && touch ./dist/index.html
        - curl -X POST -d {} "https://webhooks.amplify.ca-central-1.amazonaws.com/prod/webhooks?id=WEBHOOK-ID&token=TOKEN&operation=startbuild" -H "Content-Type:application/json"
  artifacts:
    baseDirectory: dist
    files:
      - '**/*'
  cache:
    paths:
      - node_modules/**/*
```

<InlineFilter filters={['angular','javascript','nextjs','react','react-native','vue']}>
## Sharing schema type definitions

If you're using Amplify Data, we recommend adding a `paths` entry in the `tsconfig.json` of your frontend app that points to the `amplify/data/resource.ts` file in your backend app to easily access your schema type definitions from your frontend apps.

First, cone your backend repo into the same parent directory as your frontend app, then add the following entry:

```json title="tsconfig.json" showLineNumbers={false}
{
  "compilerOptions": {
    "paths": {
      "@/data-schema": ["../backend-app/amplify/data/resource"]
    }
  }
}
```

You can then import the `Schema` type from this path in your frontend code to get code completion and strong typing for your API calls:

```ts title="apps/admin-dashboard/page.tsx"
import { generateClient } from "aws-amplify/data";
import type { Schema } from "@/data-schema";

const client = generateClient<Schema>();

const createTodo = async () => {
  await client.models.Todo.create({
    content: window.prompt("Todo content?"),
    isDone: false,
  });
}

```

</InlineFilter>


Contents of deploy-and-host_fullstack-branching_monorepos_index.txt:
import { getCustomStaticPath } from '@/utils/getCustomStaticPath';

export const meta = {
  title: 'Monorepo setup',
  description: 'Set up monorepos with the Amplify CI/CD pipeline.',
  platforms: [
    'android',
    'angular',
    'flutter',
    'javascript',
    'nextjs',
    'react',
    'react-native',
    'swift',
    'vue'
  ]
};

export const getStaticPaths = async () => {
  return getCustomStaticPath(meta.platforms);
};

export function getStaticProps(context) {
  return {
    props: {
      platform: context.params.platform,
      meta
    }
  };
}

Some teams choose a monorepo approach, or single repositories that contain multiple packages or components to simplify the deployment process for shared libraries and components. Without a monorepo, you have to deploy each package individually, keep track of package versions and dependencies across packages, and ensure version compatibility. This can become exponentially more complex as the number of packages grows. With a monorepo, all packages and dependencies are contained within a single repository.

Amplify Gen 2 supports monorepo workflows for fullstack builds with monorepo tools such as Nx and yarn workspaces. When building with Gen 2, we recommend creating the `amplify/` folder in a shared workspace. We will use the following example for this guide:

```text
├── apps/
│   ├── admin-dashboard/
│   │   ├── next.config.mjs
│   │   └── package.json
│   └── marketing-site/
│       ├── astro.config.mjs
│       └── package.json
├── packages/
│   └── my-shared-backend/
│       ├── amplify/
│       │   ├── auth/
│       │   │   └── resource.ts
│       │   ├── data/
│       │   │   └── resource.ts
│       │   └── backend.ts
│       |── package.json
        └── tsconfig.json
└── package.json
```

Monorepos require a slightly different setup. We are going to deploy 3 Amplify apps:

1. `my-shared-backend`
2. `admin-dashboard`
3. `marketing-site`

## Deploy backend app

The first app, `my-shared-backend`, will be the only app that updates changes to the backend. The other apps will only run frontend builds that point to the shared backend.

1. To get started, deploy the shared backend Amplify app. With Gen 2, you can now setup backend-only CI/CD apps. Navigate to the Amplify console and select **Create new app**.

1. Once you connect your repository, select your monorepo project. Check the box that says **My app is a monorepo** and enter the path to your amplify backend.

![monorepo](/images/gen2/fullstack-branching/monorepo.png)

3. Your build settings should be automatically detected. Save and deploy.

## Deploy frontend apps

1. For the frontend apps, connect the frontend projects in the Amplify console separately, and update the build commands to include:

<InlineFilter filters={['angular','javascript','nextjs','react','react-native','vue']}>

```bash title="Terminal" showLineNumbers={false}
npx ampx generate outputs --branch main --app-id BACKEND-APP-ID
```
</InlineFilter>

<InlineFilter filters={['flutter']}>
```bash title="Terminal" showLineNumbers={false}
npx ampx generate outputs --app-id <your-backend-amplify-app-id> --branch main --format dart --out-dir lib
```
</InlineFilter>

<InlineFilter filters={['android']}>
<Callout warning>
  Be sure to add a "raw" folder under app/src/main/res directory if it doesn't
  exist.
</Callout>

```bash title="Terminal" showLineNumbers={false}
npx ampx generate outputs --app-id <your-backend-amplify-app-id> --branch main --out-dir app/src/main/res/raw
```
</InlineFilter>

<InlineFilter filters={['swift']}>
```bash title="Terminal" showLineNumbers={false}
npx ampx generate outputs --app-id <your-backend-amplify-app-id> --branch main
```

Once the sandbox environment is running, you would also generate the configuration files for your application. However, Xcode won't be able to recognize them. For recognizing the files, you need to drag and drop the generated files to your project.

<Video src="/images/gen2/getting-started/ios/ios-getting-started-2.mp4" description="Video - iOS Getting Started" />

</InlineFilter>

- To locate the `App ID` for your backend application, navigate to the Amplify console and select your **backend-app**. On the Overview page, the `App ID` is displayed under the project name.

<InlineFilter filters={['angular','javascript','nextjs','react','react-native','vue']}>

```bash title="Terminal" showLineNumbers={false}
npx ampx generate outputs --branch main --app-id BACKEND-APP-ID
```
</InlineFilter>


<InlineFilter filters={['angular','javascript','nextjs','react','react-native','vue']}>

## Sharing schema type definitions

If you're using Amplify Data, we recommend adding a `paths` entry in your `tsconfig.json` file that points to the `amplify/data/resource.ts` file to easily access your schema type definitions from your frontend apps.

```json title="tsconfig.json" showLineNumbers={false}
{
  "compilerOptions": {
    "paths": {
      "@/data-schema": ["./packages/my-shared-backend/amplify/data/resource"]
    }
  }
}
```

You can then import the `Schema` type from this path in your frontend code to get code completion and strong typing for your API calls:

```ts title="apps/admin-dashboard/page.tsx"
import { generateClient } from "aws-amplify/data";
import type { Schema } from "@/data-schema";

const client = generateClient<Schema>();

const createTodo = async () => {
  await client.models.Todo.create({
    content: window.prompt("Todo content?"),
    isDone: false,
  });
}

```

</InlineFilter>


Contents of deploy-and-host_fullstack-branching_pr-previews_index.txt:
import { getCustomStaticPath } from '@/utils/getCustomStaticPath';

export const meta = {
  title: 'Fullstack previews',
  description:
    'Set up ephemeral fullstack environments with pull request previews.',
  platforms: [
    'android',
    'angular',
    'flutter',
    'javascript',
    'nextjs',
    'react',
    'react-native',
    'swift',
    'vue'
  ]
};

export const getStaticPaths = async () => {
  return getCustomStaticPath(meta.platforms);
};

export function getStaticProps(context) {
  return {
    props: {
      meta
    }
  };

}

With fullstack previews, you can set up ephemeral fullstack environments on every pull request. This allows you to test features in isolation from production. Once fullstack previews are enabled, your typical workflow would look like the following diagram:

![Pull request workflow detailing how Amplify handles the deployment of ephemeral environments](/images/gen2/fullstack-branching/previews.png)

1. Your `main` (production branch) and `featureA` branch are deployed on Amplify.
1. You and your team work on `featureA` until it's ready.
1. The `featureA` branch is updated to `main` HEAD and then a pull request to `main` is opened.
1. The pull request preview is deployed on Amplify and available at `pr-1.appid.amplifyapp.com`.
1. Once the pull request is merged into `main`, the request is closed and the fullstack environment is also automatically torn down.

## Prerequisites

Before you get started, make sure you have the following:

- [A fullstack Amplify app deployed](/[platform]/start/quickstart/)
- Ensure that your git repository is private. For security purposes, fullstack previews are disabled for public repositories with Amplify backend templates.


## Enable fullstack previews

To enable fullstack web previews for your Amplify app, follow these steps:

1. Login to the [Amplify console](https://console.aws.amazon.com/amplify/home) and select your app.

2. Navigate to **Hosting > Previews**. Select the **`main`** branch and click on **Edit settings**. 
![Amplify console page displaying the list of branches for the previews functionality](/images/gen2/fullstack-branching/previews-1.png)

3. Click on the **Pull request previews** toggle button and choose **Confirm** to enable previews.
![Amplify console page displaying a toggle button to enable the previews functionality](/images/gen2/fullstack-branching/previews-2.png)

4. Done! You have successfully enabled previews on the production branch.
![Amplify console page displaying the main branch with previews functionality enabled](/images/gen2/fullstack-branching/previews-3.png)

5. Ship updates to the `dev` branch. Now, when you create a pull request for the `main` branch, Amplify will build and deploy your fullstack PR and provide you with a preview URL.
![Amplify console page displaying the main, dev, and preview branch](/images/gen2/fullstack-branching/previews-4.png)

For **GitHub repositories only**, you can access your preview URL directly on the pull request from the Amplify Hosting's bot comment:

![GitHub pull request displaying preview URL in a bot comment](/images/gen2/fullstack-branching/previews-5.png)

After the pull request is merged or closed, the preview URL is deleted and any ephemeral fullstack environment is also deleted.

## Share backend resources across Preview branches

Fullstack previews allow teams a way to preview changes from pull requests before merging code to a production branch. Pull requests let you tell others about changes you’ve pushed to a branch in a repository and the changes can be reviewed by accessing the preview URL. When previews are enabled on a git branch, by default every pull request created against the git branch creates an ephemeral fullstack environment.

In some instances, you may not want to deploy new resources for every preview branch. For example, you might want all your preview branches to point to the backend resources deployed by the `dev` branch so you can reuse seed data, users, and groups.

To achieve this, you can update your app build settings to reuse backend resources across your preview branches. In the Amplify console, select your app on the **All apps** page. From the **App overview** page, select **Hosting > Build settings** to view your app's build specification YAML file.

![The build specification YAML file on the Build settings page in Amplify console.](/images/gen2/fullstack-branching/preview-settings.png)

Update the build settings for the `backend` phase to run `npx ampx generate outputs --branch dev app-id $AWS_APP_ID` to generate the `amplify_outputs.json` file for all preview branches. After this update, any new deployed preview branches will not deploy backend resources as part of the build and instead will use the deployed backend resources from the `dev` branch.

```yaml title="amplify.yml"
version: 1
backend:
    phases:
        build:
            commands:
                - 'npm ci --cache .npm --prefer-offline'
                - 'echo $AWS_BRANCH'
                - |
                  // highlight-start
                  case "${AWS_BRANCH}" in
                      main)
                          echo "Deploying main branch..."
                          npx ampx pipeline-deploy --branch $AWS_BRANCH --app-id $AWS_APP_ID
                          ;;
                      dev)
                          echo "Deploying dev branch..."
                          npx ampx pipeline-deploy --branch $AWS_BRANCH --app-id $AWS_APP_ID
                          ;;
                      pr-*)
                          echo "Deploying pull request branch..."
                          npx ampx generate outputs --branch dev --app-id $AWS_APP_ID 
                          ;;
                      *)
                          echo "Deploying to staging branch..."
                          npx ampx generate outputs --branch staging --app-id $AWS_APP_ID 
                          ;;
                  esac
                  // highlight-end
frontend:
    phases:
        build:
            commands:
                - 'npm run build'
    artifacts:
        baseDirectory: .amplify-hosting
        files:
            - '**/*'
    cache:
        paths:
            - .next/cache/**/*
            - .npm/**/*
            - node_modules/**/*
```


Contents of deploy-and-host_fullstack-branching_secrets-and-vars_index.txt:
import { getCustomStaticPath } from '@/utils/getCustomStaticPath';

export const meta = {
  title: 'Secrets and environment vars',
  description: 'Manage secrets and environment variables across your fullstack branch and local dev environments.',
  platforms: [
    'android',
    'angular',
    'flutter',
    'javascript',
    'nextjs',
    'react',
    'react-native',
    'swift',
    'vue'
  ]
};

export const getStaticPaths = async () => {
  return getCustomStaticPath(meta.platforms);
};

export function getStaticProps(context) {
  return {
    props: {
      meta
    }
  };

}

Amplify Gen 2 offers centralized management of secrets and environment variables for all fullstack branches. Secrets allow you to securely configure environment-specific values like social sign-in keys, function environment variables, function secrets, and other sensitive data needed by your application across environments.

<Accordion title="How is this different from Amplify Gen 1?" eyebrow='FAQ'>
  In Amplify Gen 1, you need to define environment variables and secrets using the CLI and store keys in both AWS Parameter Store and a local `team-provider.json` file. We have streamlined this workflow in Amplify Gen 2 by centralizing the management of secrets and environment variables in the Amplify console.
</Accordion>

## Set secrets

You can set secrets for your fullstack branch deployments or your local dev server.

### Branch environment

You can add secrets for branch deployments in the Amplify console. From the App home page, navigate to **Hosting > Secrets**, and then choose the **Manage secrets** button. You can add a secret key or value that applies to all deployed branches or just specific branches.

<Video src="/images/gen2/secrets-and-vars/secrets.mp4" description="Video - Secrets" />

Secrets are stored in AWS Systems Manager Parameter Store under the following naming conventions:

- Secrets that apply to all branches: `/amplify/shared/<app-id>/<secret-key>`
- Secrets that apply to a specific branch: `/amplify/<app-id>/<branchname>/<secret-key>`

### Local environment

[comment]: <> (When editing this section, also update /gen2/deploy-and-host/sandbox-environments/features/index.md -)

<Callout info>
  Secrets set in a sandbox do not show up in the Amplify console. You can view them in the AWS Parameter Store console.
</Callout>

When testing features locally, you might want to test with real secrets. You can add secrets while running the cloud sandbox with the following command:

```bash title="Terminal" showLineNumbers={false}
npx ampx sandbox secret set foo
? Enter secret value: ###
Done!

> npx ampx sandbox secret set bar
? Enter secret value: ###
Done!
```

## Access secrets

Once you have set a secret, you can access the values in code by calling the `secret()` function. The following example shows how to set up social sign-in with authentication in your app. Depending on your environment, Amplify will automatically load the correct secret value with no extra configuration.

```ts
import { defineAuth, secret } from '@aws-amplify/backend';

export const auth = defineAuth({
  loginWith: {
    email: true,
    externalProviders: {
      facebook: {
        clientId: secret('foo'),
        clientSecret: secret('bar')
      }
    }
  }
});
```

## Remove secrets

<Callout warning>
When deleting branch environments or sandbox environments, you need to manually delete the secrets as well.
</Callout>

### Branch environment

Secrets that are used in branch deployments can be managed directly in the Amplify console. You can remove them under **Secret management** by choosing **Remove**.

![Removing application secrets in Secret management section of Amplify console.](/images/gen2/secrets-and-vars/secret-management.png)

### Local environment

To remove a secret in your local environment, run the following command in your terminal:

```bash title="Terminal" showLineNumbers={false}
npx ampx sandbox secret remove foo
```

## Set environment variables

<Callout warning>

Note: do not store secret values in environment variables. Environment variables values are rendered in plaintext to the build artifacts and can be accessed by anyone with access to the build artifacts or [get-app](https://awscli.amazonaws.com/v2/documentation/api/latest/reference/amplify/get-app.html) command.

</Callout>

Environment variables work like key-value pairs to help manage configurable settings across different deployment environments, including development, staging, and production. Unlike secrets, which store sensitive data, environment variables are typically nonconfidential and are used for controlling application behavior in different environments. Another key difference is that environment variables are stored and managed by the Amplify managed service. You can set environment variables in the Amplify console (view the [AWS Amplify Hosting User Guide](https://docs.aws.amazon.com/amplify/latest/userguide/environment-variables.html#setting-env-vars) for detailed instructions).

<Video src="/images/gen2/secrets-and-vars/env-vars.mp4" description="Video - Secrets" />

## Access environment variables

You can enable access to environment variables for your fullstack branch deployments or your local dev server.

### Branch environment

You can manage your branch environment access through the Amplify console.

1. First, create an environment variable in the Amplify console (in this example, you will name it `REACT_APP_TEST_VARIABLE`)

1. Next, navigate to the Build Settings in console (or to the `amplify.yml` file) and update the build settings to pipe the environment variable into a file. Here is an example of writing it into an `.env` file:

```yml title="amplify.yml"
build:
  commands:
    // highlight-next-line
    - echo "REACT_APP_TEST_VARIABLE=$REACT_APP_TEST_VARIABLE" >> .env
    - npm run build
```

<Callout info>
With the implementation above, the environment variable is written in a `.env` file. However, you can write it to any file depending on your platform.

- For Flutter, you can still use `.env` with an external package or generate your configuration file in Dart or JSON format.
- For Android, you can use Build Configurations or Gradle variables.
- For iOS, you can update your plist file with the necessary code or create a configuration file in JSON format.
</Callout>

Now the `.env` can access the environment variable through `process.env` in your client code:

```typescript
console.log('REACT_APP_TEST_VARIABLE', process.env.REACT_APP_TEST_VARIABLE);
```

### Local environment

When working on your local machine, you must manually load the sandbox's environment variables. First, add the environment variable in your `.env.local` file. Then, a library such as [`@dotenvx/dotenvx`](https://www.npmjs.com/package/@dotenvx/dotenvx) can load the environment variables, which you can then reference with `process.env`.


Contents of deploy-and-host_fullstack-branching_share-resources_index.txt:
import { getCustomStaticPath } from '@/utils/getCustomStaticPath';

export const meta = {
  title: 'Share resources across branches',
  description: 'Update app build settings to share resources across branches.',
  platforms: [
    'android',
    'angular',
    'flutter',
    'javascript',
    'nextjs',
    'react',
    'react-native',
    'swift',
    'vue'
  ]
};

export const getStaticPaths = async () => {
  return getCustomStaticPath(meta.platforms);
};

export function getStaticProps(context) {
  return {
    props: {
      meta
    }
  };

}

In some instances, you may not want to deploy new resources for every branch. For example, you might want all your `feature` branches to point to the backend resources deployed by the `dev` branch so you can reuse seed data, users, and groups.

![Main and dev environments, each with their own backend resources. In the dev environment, two feature branches are shown sharing the same backend resources. ](/images/gen2/fullstack-branching/share-resources.png)

You can update your app build settings to share resources across branches. From the Amplify console, go to your **App overview** page, select **Build settings** under the **Hosting** for viewing your app's build specification YAML file.

![The build specification YAML file on the Build settings page in Amplify console.](/images/gen2/fullstack-branching/build-settings.png)

Update the build settings for the `backend` phase to run `npx ampx generate outputs --branch dev app-id $AWS_APP_ID` to generate the `amplify_outputs.json` file for all branches other than `main` or `dev`. After this update, any new deployed branches will not deploy backend resources as part of the build and instead will use the deployed backend resources from the `dev` branch.
Update the build settings for the `backend` phase to run `npx ampx generate outputs --branch dev app-id $AWS_APP_ID` to generate the `amplify_outputs.json` file for all branches other than `main` or `dev`. After this update, any new deployed branches will not deploy backend resources as part of the build and instead will use the deployed backend resources from the `dev` branch.

```yaml title="amplify.yml"
version: 1
backend:
    phases:
        build:
            commands:
                - 'npm ci --cache .npm --prefer-offline'
                - 'echo $AWS_BRANCH'
                - |
                  case "${AWS_BRANCH}" in
                      main)
                          echo "Deploying main branch..."
                          npx ampx pipeline-deploy --branch $AWS_BRANCH --app-id $AWS_APP_ID
                          ;;
                      dev)
                          echo "Deploying dev branch..."
                          npx ampx pipeline-deploy --branch $AWS_BRANCH --app-id $AWS_APP_ID
                          ;;
                      pr-*)
                          echo "Deploying pull request branch..."
                          npx ampx generate outputs --branch previews --app-id $AWS_APP_ID
                          ;;
                      *)
                          echo "Deploying to staging branch..."
                          npx ampx generate outputs --branch dev --app-id $AWS_APP_ID
                          ;;
                  esac
frontend:
    phases:
        build:
            commands:
                - 'npm run build'
    artifacts:
        baseDirectory: .next
        files:
            - '**/*'
    cache:
        paths:
            - .next/cache/**/*
            - .npm/**/*
            - node_modules/**/*
```


Contents of deploy-and-host_hosting_index.txt:
import { getCustomStaticPath } from '@/utils/getCustomStaticPath';

export const meta = {
  title: 'Frontend hosting',
  description:
    'Host static and server-rendered web apps built with modern JS frameworks like Next.js, Vue, and React.',
  platforms: [
    'android',
    'angular',
    'flutter',
    'javascript',
    'nextjs',
    'react',
    'react-native',
    'swift',
    'vue'
  ]
};

export const getStaticPaths = async () => {
  return getCustomStaticPath(meta.platforms);
};

export function getStaticProps(context) {
  return {
    props: {
      meta
    }
  };

}

AWS Amplify Hosting is a fully managed CI/CD and hosting service for fast, secure, and reliable static and server-side rendered apps that scale with your business. This service supports modern web frameworks such as React, Angular, Vue, Next.js, Nuxt.js, Gatsby, and more.

Because AWS Amplify Hosting is a fully managed service, its documentation lives on the AWS Documentation site. To learn about hosting features such as custom domains, redirects, and more, please visit the Hosting documentation.

<ExternalLinkButton
  variation="primary"
  href="https://docs.aws.amazon.com/amplify/latest/userguide/getting-started.html"
>
  View Hosting Docs
</ExternalLinkButton>


Contents of deploy-and-host_index.txt:
import { getChildPageNodes } from '@/utils/getChildPageNodes';
import { getCustomStaticPath } from '@/utils/getCustomStaticPath';

export const meta = {
  title: 'Deployment',
  description: 'Learn about the capabilities to deploy and host your app.',
  route: '/[platform]/deploy-and-host',
  platforms: [
    'android',
    'angular',
    'flutter',
    'javascript',
    'nextjs',
    'react',
    'react-native',
    'swift',
    'vue'
  ]
};

export const getStaticPaths = async () => {
  return getCustomStaticPath(meta.platforms);
};

export function getStaticProps(context) {
  const childPageNodes = getChildPageNodes(meta.route);
  return {
    props: {
      meta,
      childPageNodes
    }
  };
}

<Overview childPageNodes={props.childPageNodes} />


Contents of deploy-and-host_sandbox-environments_features_index.txt:
import { getCustomStaticPath } from '@/utils/getCustomStaticPath';

export const meta = {
  title: 'Sandbox features',
  description:
    'Explore sandbox features such as secrets, client codegen, and config generation for mobile and cross-platform.',
  platforms: [
    'android',
    'angular',
    'flutter',
    'javascript',
    'nextjs',
    'react',
    'react-native',
    'swift',
    'vue'
  ]
};

export const getStaticPaths = async () => {
  return getCustomStaticPath(meta.platforms);
};

export function getStaticProps(context) {
  return {
    props: {
      meta
    }
  };

}

Sandbox environments include additional features for managing secrets, deploying multiple sandboxes, config generation, and client codegen for your Amplify app.

## Secure secrets in your sandbox

<Callout info>

  Secrets set in a sandbox do not show up in the Amplify Console. You can view them in the AWS Systems Manager (SSM) Parameter Store console.
  
</Callout>

Amplify Gen 2 offers secure secret storage to manage sensitive data like API keys and database credentials. Secrets are similar to environment variables, but they are encrypted AWS Systems Manager Parameter Store key value pairs. Secrets are stored in AWS Parameter Store under the `/amplify` prefix.

### Set secrets

You can add secrets to your sandbox environment using the following command:

```bash
npx ampx sandbox secret set foo
? Enter secret value: ###
Done!

npx ampx sandbox secret set bar
? Enter secret value: ###
Done!
```

After these commands, your sandbox will have two secrets named `foo` and `bar`.

### List secrets

You can list all of the secret names available in your sandbox environment with the following command:

```bash
npx ampx sandbox secret list
 - foo
 - bar
```

### Retrieve a secret

<Callout warning>

**Note:** This will print a secret value in plain text to the terminal. Do not use this command anywhere that terminal logs may be stored (such as CI/CD jobs).

</Callout>

To show the value of a secret, run the following command.

```bash
npx ampx sandbox secret get foo
name: foo
version: 1
value: abc123
lastUpdated: Mon Nov 13 2023 22:19:12 GMT-0800 (Pacific Standard Time)
```

### Remove secrets

To remove a secret from from the sandbox, run the following command in your terminal:

```bash
npx ampx sandbox secret remove foo
```

### Reference secrets

Once you have set a secret, you can reference the secret in your backend definition using the `secret()` function. The following example shows how to set up social sign-in with authentication in your app. Depending on your environment, Amplify will automatically load the correct secret value.

```ts
import { defineAuth, secret } from '@aws-amplify/backend';

export const auth = defineAuth({
  loginWith: {
    email: true,
    externalProviders: {
      facebook: {
        // highlight-start
        clientId: secret('foo'),
        clientSecret: secret('bar')
        // highlight-end
      }
    }
  }
});
```

The `secret()` function does NOT retrieve the value of the secret. It places a reference to the secret value in the backend definition. The secret value is only resolved during deployment of your backend.

The `secret()` function can only be used in specific places in your backend definition such as [configuring auth providers](/[platform]/build-a-backend/auth/concepts/external-identity-providers) and [function secrets](/[platform]/build-a-backend/functions/environment-variables-and-secrets/#accessing-environment-variables).

<Callout info>

To deploy a backend that uses `secret()` references via Amplify hosting, the secret values must be [configured for the Amplify app or branch](/[platform]/deploy-and-host/fullstack-branching/secrets-and-vars)

</Callout>

## Work with multiple AWS profiles

Sometimes you might have multiple AWS profiles set up locally. To run `ampx sandbox secret` commands, use the `--profile` flag to deploy to a specific profile. For example, let's say you have two AWS profiles set up locally—`default` and `work`. To add secrets to the sandbox in the `work` profile, run the following command in your terminal:

```bash
npx ampx sandbox secret set foo --profile work
```

## Work with multiple named sandboxes

<Callout info>

Provisioning multiple sandboxes per app is possible but not recommended because managing multiple ephemeral environments for a single developer introduces complexity. With multiple sandboxes, it can be difficult to keep track of what code version or configuration is deployed where. Sticking to a single sandbox per developer keeps your workflows simpler.

</Callout>

You can create multiple sandboxes if you want to have different features or test environments available in different sandboxes. By default, your sandbox is named based on the local machine username. To override this name, use the `--identifier` option:

```bash
npx ampx sandbox --identifier feature1sandbox
```

This will start a sandbox named `feature1sandbox`.

Once the deployment completes, exit sandbox and run the following command in the terminal:

```bash
npx ampx sandbox --identifier feature2sandbox
```

After successful deployment, you will have two sandboxes `feature1sandbox` and `feature2sandbox`. You can switch between them but only one can be running at a time.

### Secret management with named sandboxes

When working with multiple sandboxes, secrets must be configured for each one. All of the `sandbox secret` commands accept the `--identifier` argument to manage secrets for named sandboxes. For example, to add a secret to `feature1sandbox`, use:

```bash
npx ampx sandbox --identifier feature1sandbox secret set baz
```

## Stream function logs

Amplify offers the ability to stream function logs directly to your terminal or a file. [Learn more about streaming function logs](/[platform]/build-a-backend/functions/streaming-logs/).

## Generate client config

The client config, or `amplify_outputs.json` file, contains the configuration strings for interacting with AWS resources specific to an environment. The Amplify client libraries need the client config in order to use the library APIs to connect to backend resources. By default, the cloud sandbox generates the client configuration file at the root of the project (such as `@/amplify_outputs.json`). If you want to place the file at a different path (such as for a monorepo or Android app), run the following command in the terminal:

<InlineFilter filters={['angular','javascript','nextjs','react','react-native','vue']}>
```bash title="Terminal" showLineNumbers={false}
npx ampx sandbox --outputs-out-dir ./path/to/config --outputs-format ["json", "dart"]
```

Alternatively, if you want to generate the config for a branch environment to test against, run the following command in the terminal.

```bash
npx ampx generate outputs --app-id <your-amplify-app-id> --branch main --format ["json", "dart"] --out-dir ./path/to/config
```
</InlineFilter>

<InlineFilter filters={['flutter']}>
```bash title="Terminal" showLineNumbers={false}
npx ampx sandbox --outputs-format dart --outputs-out-dir lib
```
</InlineFilter>
<InlineFilter filters={['android']}>
<Callout warning>
  Be sure to add a "raw" folder under app/src/main/res directory if it doesn't
  exist.
</Callout>

```bash title="Terminal" showLineNumbers={false}
npx ampx sandbox --outputs-format json-mobile --outputs-out-dir app/src/main/res/raw
```
</InlineFilter>

<InlineFilter filters={['swift']}>

```bash title="Terminal" showLineNumbers={false}
npx ampx sandbox --outputs-format json-mobile
```

Once the sandbox environment is running, you would also generate the configuration files for your application. However, Xcode won't be able to recognize them. For recognizing the files, you need to drag and drop the generated files to your project.

<Video src="/images/gen2/getting-started/ios/ios-getting-started-2.mp4" description="Video - iOS getting started" />

</InlineFilter>

### Deployment Environment

Alternatively, if you want to generate the config for a branch environment to test against, you can run the following command below in the terminal:

<InlineFilter filters={['android','angular','flutter','javascript','nextjs','react','react-native','swift','vue']}>
For Web and React Native, generating the config with the default format and output directory.

```bash title="Terminal" showLineNumbers={false}
npx ampx generate outputs --app-id <app-id> --branch main
```
</InlineFilter>
<InlineFilter filters={['flutter']}>
```bash title="Terminal" showLineNumbers={false}
npx ampx generate outputs --app-id <app-id> --branch main --format dart --out-dir lib
```
</InlineFilter>
<InlineFilter filters={['android']}>
<Callout warning>
  Be sure to add a "raw" folder under app/src/main/res directory if it doesn't
  exist.
</Callout>

```bash title="Terminal" showLineNumbers={false}
npx ampx generate outputs --app-id <app-id> --branch main --out-dir app/src/main/res/raw
```
</InlineFilter>
<InlineFilter filters={['swift']}>

```bash title="Terminal" showLineNumbers={false}
npx ampx generate outputs --app-id <app-id> --format json-mobile
```

Once the sandbox environment is running, it will generate the backend outputs file for your frontend application. However, Xcode won't be able to recognize them. For recognizing the files, you need to drag and drop the generated files to your project.

<Video src="/images/gen2/getting-started/ios/ios-getting-started-2.mp4" description="Video - iOS Getting Started" />

</InlineFilter>

## Generate client codegen

<Callout info>

Amplify Gen 2 introduces a fully typed experience for data that no longer requires an explicit codegen step, unlike in Amplify Gen 1. You will only need this command if you are building a mobile app or have Gen 1 requirements.

</Callout>

Codegen generates native code for Swift (iOS), Java (Android), and JavaScript that represents your GraphQL API's data models. It can also generate GraphQL statements (queries, mutations, and subscriptions) so that you don't have to manually code them.

Once your sandbox completes a deployment, you can run the following command in the terminal to generate client code that is specific to your needs:

```bash
npx ampx generate graphql-client-code
--format [choices: "modelgen", "graphql-codegen", "introspection"]
```

## Delete a sandbox

You can delete a cloud sandbox environment in several ways:

1. Ctrl+C your sandbox and choose to delete resources.
1. Run `npx ampx sandbox delete` or `npx ampx sandbox delete --name`
1. Visit the Amplify console and [delete sandboxes](/[platform]/deploy-and-host/sandbox-environments/setup/#manage-sandbox-environments).


Contents of deploy-and-host_sandbox-environments_index.txt:
import { getChildPageNodes } from '@/utils/getChildPageNodes';
import { getCustomStaticPath } from '@/utils/getCustomStaticPath';

export const meta = {
  title: 'Cloud sandbox environments',
  description: 'Learn about sandbox development.',
  route: '/[platform]/deploy-and-host/sandbox-environments',
  platforms: [
    'android',
    'angular',
    'flutter',
    'javascript',
    'nextjs',
    'react',
    'react-native',
    'swift',
    'vue'
  ]
};

export const getStaticPaths = async () => {
  return getCustomStaticPath(meta.platforms);
};

export function getStaticProps(context) {
  const childPageNodes = getChildPageNodes(meta.route);
  return {
    props: {
      meta,
      childPageNodes
    }
  };
}

<Overview childPageNodes={props.childPageNodes} />


Contents of deploy-and-host_sandbox-environments_setup_index.txt:
import { getCustomStaticPath } from '@/utils/getCustomStaticPath';

export const meta = {
  title: 'Use cloud sandbox in dev environment',
  description: 'Set up a cloud sandbox environment you can use with your frontend dev environment.',
  platforms: [
    'android',
    'angular',
    'flutter',
    'javascript',
    'nextjs',
    'react',
    'react-native',
    'swift',
    'vue'
  ]
};

export const getStaticPaths = async () => {
  return getCustomStaticPath(meta.platforms);
};

export function getStaticProps(context) {
  return {
    props: {
      platform: context.params.platform,
      meta
    }
  };
}

You can use a personal cloud sandbox environment that provides an isolated development space to rapidly build, test, and iterate on a fullstack app. Each developer on your team can use their own disposable sandbox environment connected to cloud resources.

<Callout>

Cloud sandbox environments are not intended for production workloads.

</Callout>

![How cloud sandbox environments work](/images/gen2/how-amplify-works/sandbox.png)

## Create a new sandbox environment

You can set up a new sandbox environment on your machine once you have an Amplify app set up. If you have not yet created an Amplify Gen 2 app, visit the [Quickstart](/[platform]/start/quickstart).

First, open the terminal and run the following command:

```bash title="Terminal" showLineNumbers={false}
npx ampx sandbox
```

When you deploy a cloud sandbox, Amplify creates an [AWS CloudFormation](https://aws.amazon.com/cloudformation/) stack following the naming convention of `amplify-<app-name>-<$(whoami)>-sandbox` in your AWS account with the resources configured in your `amplify/` folder.

![terminal output of a successful cloud sandbox deployment](/images/gen2/sandbox/sandbox1.png)

After a successful deployment, `sandbox` watches for file changes in your `amplify/` folder and performs real-time updates to the associated CloudFormation stack. This functionality is built leveraging the [hot swap capability of the AWS Cloud Development Kit (CDK)](https://docs.aws.amazon.com/cdk/v2/guide/cli.html#cli-deploy-hotswap).

![terminal output of a successful cloud sandbox deployments with hot-swapped resources](/images/gen2/sandbox/sandbox2.png)

### Terminating a sandbox environment

After testing all the changes associated with the backend, you can terminate the sandbox session via <kbd>Ctrl</kbd>+<kbd>c</kbd>.

To delete all the resources in the sandbox environment, run the following command:

```bash title="Terminal" showLineNumbers={false}
npx ampx sandbox delete
```

## Manage sandbox environments

You can view and manage all the sandbox environments for your team in the new [Amplify console](https://us-east-1.console.aws.amazon.com/amplify/apps/sandboxes). This is useful for a team leader to audit all of the Amplify sandbox environments deployed within an account.

Choose **Manage Sandboxes** to get started:

![Amplify console view with a deployed Amplify app and navigation for "Manage sandboxes"](/images/gen2/sandbox/sandbox4.png)

You can then check the number, status, and last updates for sandbox environments across your team. You can also use the console to delete sandbox environments when no longer needed.

![Amplify console view for "Manage sandbox" showing one active cloud sandbox](/images/gen2/sandbox/sandbox5.png)

## Best practices

Keep the following best practices in mind when working with cloud sandbox environments:

- Sandboxes are identical in fidelity to your production environments.
- Code changes are continuously deployed to your sandbox on every save for fast iterations.
- Use sandboxes for experimentation and testing, not for production workloads.
- Deploy one sandbox per Amplify app per developer to prevent conflicts.
- Reset sandboxes occasionally to clear out unused resources and save costs.


Contents of how-amplify-works_concepts_index.txt:
import { getCustomStaticPath } from '@/utils/getCustomStaticPath';

export const meta = {
  title: 'Concepts',
  description:
    'Learn about the Amplify fullstack TypeScript DX ',
  platforms: [
    'android',
    'angular',
    'flutter',
    'javascript',
    'nextjs',
    'react',
    'react-native',
    'swift',
    'vue'
  ]
};

export const getStaticPaths = async () => {
  return getCustomStaticPath(meta.platforms);
};

export function getStaticProps(context) {
  return {
    props: {
      meta
    }
  };

}

AWS Amplify Gen 2 uses a TypeScript-based, code-first developer experience (DX) for defining backends. The Gen 2 DX offers a unified Amplify developer experience with hosting, backend, and UI-building capabilities and a code-first approach. Amplify empowers frontend developers to deploy cloud infrastructure by simply expressing their app’s data model, business logic, authentication, and authorization rules completely in TypeScript. Amplify automatically configures the correct cloud resources and removes the requirement to stitch together underlying AWS services.

## Capabilities

You can use Amplify for end-to-end fullstack development.

### Build fullstack apps with TypeScript

With the Gen 2 DX, you can provision backend infrastructure by authoring TypeScript. In the following diagram, the box at the bottom (outlined in pink), highlights the main difference in how you provision infrastructure compared to Gen 1. In Gen 1, you would use Studio's console or the CLI to provision infrastructure; in Gen 2, you author TypeScript code in files following a file-based convention (such as `amplify/auth/resource.ts` or `amplify/auth/data.ts`). With TypeScript types and classes for resources, you gain strict typing and IntelliSense in Visual Studio Code to prevent errors. A breaking change in the backend code immediately reflects as a type error in the co-located frontend code. The file-based convention follows the "convention over configuration" paradigm—you know exactly where to look for resource definitions when you group them by type in separate files.

![How Amplify capabilities can be used together or independently.](/images/gen2/how-amplify-works/amplify-flow.png)

### Faster local development

Per-developer cloud sandbox environments are optimized for faster iterations. Each developer on a team gets an isolated cloud development environment against which they can test their changes. These cloud sandbox environments are meant for local development only, but they deploy high-fidelity AWS backends while you build. Depending on the workflow, iterative updates are now deployed up to 8X faster than Gen 1 deployments. In the diagram below, four developers are able to work on fullstack features independently without disrupting each other's environments.

![How cloud sandbox environments work.](/images/gen2/how-amplify-works/sandbox.png)

### Fullstack Git-based environments

All shared environments (such as `production`, `staging`, `gamma`) map 1:1 to Git branches in your repository. New features can be tested in ephemeral environments with pull request previews (or feature branches) before they are merged into production. Unlike the Gen 1 experience, which requires users to configure a number of steps in the CLI or Console to set up a fullstack environment, the Gen 2 experience is zero-config. Because of our code-first approach, the Git repository is always the source of truth for the state of the fullstack app—all backend resources are defined as code for reproducibility and portability across branches. This, along with central management of environment variables and secrets, simplifies the promotion workflow from lower to upper environments.

![How fullstack deployments work.](/images/gen2/how-amplify-works/fullstack.png)

### Unified management console

All branches can be managed in the new Amplify console. The Amplify Gen 2 console provides a single place for you to manage your builds, hosting settings (such as custom domains), deployed resources (such as data browser or user management), and environment variables and secrets. Even though you can access deployed resources directly in other AWS service consoles, the Amplify console will offer a first-party experience for the categories almost every app needs—data, auth, storage, and functions. For example, with Data, Amplify offers an API playground and a data manager (coming soon) with relationship building, seed data generation, and file upload capabilities.

<Video src="/images/gen2/how-amplify-works/console.mp4" description="Video - Amplify Gen 2 Console" />

## Build an app

### Data

The `@aws-amplify/backend` library offers a TypeScript-first `Data` library for setting up fully typed real-time APIs (powered by AWS AppSync GraphQL APIs) and NoSQL databases (powered by Amazon DynamoDB tables). After you generate an Amplify backend, you will have an `amplify/data/resource.ts` file, which will contain your app's data schema. The `defineData` function turns the schema into a fully functioning data backend with all the boilerplate handled automatically.

<Callout>
  The schema-based approach is an evolution of the Amplify GraphQL API in Gen 1.
  It offers several benefits, including dot completion, IntelliSense, and type
  validation.
</Callout>

A data model for a chat app may look something like this, for example:

```ts
const schema = a.schema({
  Chat: a.model({
    name: a.string(),
    message: a.hasMany('Message', 'chatId'),
  }),
  Message: a.model({
    text: a.string(),
    chat: a.belongsTo('Chat', 'chatId'),
    chatId: a.id()
  }),
});
```

On your app's frontend, you can use the `generateClient` function, which provides a typed client instance, making it easy to integrate CRUD (create, read, update, delete) operations for your models in your application code.

<Callout>
  Gen 2 automatically generates your types without the explicit codegen step
  that was part of Gen 1.
</Callout>

```ts
// generate your data client using the Schema from your backend
const client = generateClient<Schema>();

// list all messages
const { data } = await client.models.Message.list();

// create a new message
const { errors, data: newMessage } = await client.models.Message.create({
  text: 'My message text'
});
```

### Auth

Auth works similarly to data. You can configure the authentication settings you want for your app in `amplify/auth/resource.ts`. If you want to change the verification email's subject line, you can change out the default generated code with the following:

```ts title="amplify/auth/resource.ts"
export const auth = defineAuth({
  loginWith: {
    email: {
      verificationEmailSubject: 'Welcome 👋 Verify your email!'
    }
  }
});
```

You can customize your authentication flow with customized sign-in and registration flows, multi-factor authentication (MFA), and third-party social providers. Amplify deploys an Amazon Cognito instance in your AWS account when you add auth to your app.

Then, you could use the Amplify `Authenticator` component or the client libraries to add user flows.

```ts
import { withAuthenticator } from '@aws-amplify/ui-react';

function App({ signOut, user }) {
  return (
    <>
      <h1>Hello {user.username}</h1>
      <button onClick={signOut}>Sign out</button>
    </>
  );
}

export default withAuthenticator(App);
```

### UI building

Amplify makes it easy to quickly build web app user interfaces using the UI component library, Figma-to-code generation, and CRUD form-generation capabilities. [Learn more.](https://ui.docs.amplify.aws/react/components)

![Screenshot showing Figma to Code](/images/gen2/how-amplify-works/ui.jpg)

## Connecting to AWS beyond Amplify

### Add any AWS resource

Gen 2 is layered on top of [AWS Cloud Development Kit (CDK)](https://docs.aws.amazon.com/cdk/api/v2/)—the Data and Auth capabilities in `@aws-amplify/backend` wrap L3 AWS CDK constructs. As a result, extending the resources generated by Amplify does not require any special configuration. The following example adds Amazon Location Services by adding a file: `amplify/custom/maps/resource.ts`.

```ts
import { CfnOutput, Stack, StackProps } from 'aws-cdk-lib';
import * as locations from 'aws-cdk-lib/aws-location';
import { Construct } from 'constructs';

export class LocationMapStack extends Stack {
  constructor(scope: Construct, id: string, props?: StackProps) {
    super(scope, id, props);

    // Create the map resource
    const map = new locations.CfnMap(this, 'LocationMap', {
      configuration: {
        style: 'VectorEsriStreets' // map style
      },
      description: 'My Location Map',
      mapName: 'MyMap'
    });

    new CfnOutput(this, 'mapArn', {
      value: map.attrArn,
      exportName: 'mapArn'
    });
  }
}
```

This is then included in the `amplify/backend.ts` file so it gets deployed as part of your Amplify app.

```ts
import { Backend } from '@aws-amplify/backend';
import { auth } from './auth/resource';
import { data } from './data/resource';
import { LocationMapStack } from './locationMapStack/resource';

const backend = new Backend({
  auth,
  data
});

new LocationMapStack(
  backend.getStack('LocationMapStack'),
  'myLocationResource',
  {}
);
```

### Connect to existing resources

Amplify is designed to work with your existing AWS resources and configurations. For example, you can use Amplify's pre-built authentication UI components with an existing Amazon Cognito user pool you created and configured separately. Or you can display images and files from an existing Amazon S3 bucket in your app's user interface by integrating with Amplify Storage.

Amplify's libraries provide an interface to leverage your existing AWS services so that you can adopt Amplify's capabilities incrementally into your current workflows, without disrupting your existing backend infrastructure.

## Next steps

Now that you have a conceptual understanding of AWS Amplify's capabilities, complete the [quickstart tutorial](/[platform]/start/quickstart/) to put it into action in an app.


Contents of how-amplify-works_faq_index.txt:
import { getCustomStaticPath } from '@/utils/getCustomStaticPath';

export const meta = {
  title: 'FAQ',
  description: 'Frequently asked questions about the code-first DX.',
  platforms: [
    'android',
    'angular',
    'flutter',
    'javascript',
    'nextjs',
    'react',
    'react-native',
    'swift',
    'vue'
  ]
};

export const getStaticPaths = async () => {
  return getCustomStaticPath(meta.platforms);
};

export function getStaticProps(context) {
  return {
    props: {
      meta
    }
  };

}

**Is there a way to upgrade an existing Amplify project from Gen 1 to Gen 2?**

We are still actively developing migration tooling to aid in transitioning your project from Gen 1 to Gen 2. Until then, we recommend you continue working with your Gen 1 Amplify project. We’ve put together a Gen 1 vs. Gen 2 feature support matrix [here](https://docs.amplify.aws/react/start/migrate-to-gen2/). We remain committed to supporting both Gen 1 and Gen 2 for the foreseeable future. For new projects, we recommend adopting Gen 2 to take advantage of its enhanced capabilities. Meanwhile, customers on Gen 1 will continue to receive support for high-priority bugs and essential security updates.

**If I have a Gen 1 app, can I use Gen 2 in it?**

Amplify Gen 1 and Gen 2 follow different architectural and tooling paradigms, which was necessary to address common customer feedback from Gen 1. You will need to use our upcoming migration tooling to move from a Gen 1 to Gen 2 app. You cannot use Amplify Gen 1 (Studio/CLI) in the same app as Gen 2.

**Should I use Amplify Gen 1 or Gen 2 in new apps?**

If you're building a new app, we recommend you use Amplify Gen 2.

**Does Amplify Gen 2 support DataStore?**

Amplify Gen 2 supports GraphQL APIs without DataStore. We will release migration support for moving DataStore Gen 1 apps to Gen 2.

**What programming languages does Amplify Gen 2 support?**

Amplify Gen 2 supports a wide range of programming languages for client-side development. This includes dedicated client-side libraries for JavaScript, TypeScript, Dart, Java, Kotlin, and Swift. For backend development, Amplify Gen 2 uses TypeScript.

**In Gen 1, Amplify offered a set of use case categories for building applications (for example, Authentication, Analytics, API, DataStore, Geo, and Predictions). Are those same categories available in Gen 2?**

Amplify Gen 2 offers built-in support for Auth, Data, Storage, and Functions. Other use cases can be implemented in Amplify Gen 2 as well using AWS Cloud Development Kit (AWS CDK) constructs which there is documentation for under the respective category name.

**Can I use Gen 2 with a JavaScript frontend that doesn't use TypeScript?**

Yes. Amplify Gen 2's TypeScript backend definition works with JavaScript frontends. In addition, you still get an end-to-end typed data fetching experience even with a pure JavaScript frontend. See [Generate a Data client](/react/build-a-backend/data/connect-to-API/#generate-the-amplify-data-client) for the recommended JavaScript client code.

**What if we want to add a feature like AI/ML or Amazon Location Service to our application in Gen 2?**

Because Amplify builds on the AWS Cloud Development Kit (AWS CDK), any AWS services supported by the CDK can be added to your app using [custom resources](/[platform]/build-a-backend/add-aws-services/custom-resources/) and L2/L1 AWS CDK constructs.

**What happens once my application grows too big and I want to do more configuration with my application (add more features, other AWS services, etc.)?**

You can stay with Amplify no matter how big your application grows. Amplify is layered on top of the AWS CDK and AWS CloudFormation. These provide a standardized way of interacting with AWS, so you can add any [AWS service supported by CDK to your Amplify app](/[platform]/build-a-backend/add-aws-services/custom-resources/). You can also override [Amplify-generated configuration of your resources](/[platform]/build-a-backend/add-aws-services/overriding-resources/) using the CDK. You can use any deployment pipeline you choose if you want more control over your CI.

**How much does it cost to operate Amplify Gen2?**

You can read all about Amplify's pricing on our [pricing page](https://aws.amazon.com/amplify/pricing/).

**Which Amplify JavaScript version is compatible with Gen 2?**

Amplify JavaScript version 6.2.0 and above is compatible with backends created by Amplify Gen 2.

{/* **Can I use any other database storage other than Amazon DynamoDB? Does it have to be noSQL?**

You can also use an [existing MySQL or PostgreSQL database](/[platform]/build-a-backend/data/connect-api-to-existing-database/) in an Amplify app. With Gen 2's [custom query and mutation support](/[platform]/build-a-backend/data/custom-business-logic), you can integrate with any existing data source through a Lambda function as well. */}



Contents of how-amplify-works_index.txt:
import { getChildPageNodes } from '@/utils/getChildPageNodes';
import { getCustomStaticPath } from '@/utils/getCustomStaticPath';

export const meta = {
  title: 'How Amplify works',
  description:
    'Learn about the capabilities of AWS Amplify and how they can be used together or independently for fullstack app development.',
  route: '/[platform]/how-amplify-works',
  platforms: [
    'android',
    'angular',
    'flutter',
    'javascript',
    'nextjs',
    'react',
    'react-native',
    'swift',
    'vue'
  ]
};

export const getStaticPaths = async () => {
  return getCustomStaticPath(meta.platforms);
};

export function getStaticProps(context) {
  const childPageNodes = getChildPageNodes(meta.route);
  return {
    props: {
      meta,
      childPageNodes
    }
  };
}

<Overview childPageNodes={props.childPageNodes} />


Contents of reference_amplify_outputs_index.txt:
import { getCustomStaticPath } from '@/utils/getCustomStaticPath';
import schema from "./amplify-outputs-schema-v1.json"

export const meta = {
  title: 'About amplify_outputs.json',
  description: 'Reference for amplify_outputs.json',
  platforms: [
    'android',
    'angular',
    'flutter',
    'javascript',
    'nextjs',
    'react',
    'react-native',
    'swift',
    'vue'
  ]
};

export async function getStaticPaths() {
  return getCustomStaticPath(meta.platforms);
}

export async function getStaticProps() {
  return {
    props: {
      meta,
    }
  };
}

In Amplify Gen 2, the CLI will generate an `amplify_outputs.json` file with your backend's outputs such as your Data endpoint and Auth metadata. This file -- also known as the "client configuration file" -- is used to configure the client libraries in order to interact with your backend resources. Locally, this file is created while using `ampx sandbox`. In Amplify's CI/CD, this is created automatically for you based on the current Amplify app ID and git branch.

You can also manually create this file for a specified Amplify app ID and branch, or an AWS CloudFormation stack name with [`ampx generate outputs`](/[platform]/reference/cli-commands#npx-ampx-generate-outputs).

{/* @TODO full type/interface to reference */}

## Extending Amplify outputs file

The `amplify_outputs.json` file is not just a static artifact; it is designed to be extendable to suit the evolving needs of your application. By leveraging the `addOutput` method from your `backend`, you can programmatically add configurations. This is particularly useful for customizing outputs that are not directly exposed through the Amplify constructs or for dynamically adjusting your app's configuration in response to changes in your backend strategy.

<Callout warning>

Overriding Amplify-managed configurations on `amplify_outputs.json` is not supported.

</Callout>

One common scenario where extending the configuration becomes handy is when you need to add custom outputs or extend existing configurations without manual file edits.

Consider a scenario where you want to add output parameters in your `amplify_outputs.json` that specify an S3 bucket and its region that your application will use for storing files.

```ts title="amplify/backend.ts"
import { defineBackend } from "@aws-amplify/backend";
import { auth } from "./auth/resource";
import { data } from "./data/resource";

const backend = defineBackend({
  auth, 
  data, 
});

backend.addOutput({
  storage: {
    aws_region: "us-east-1",
    bucket_name: "my-externally-managed-bucket",
  },
});
```

In your frontend end application, you can configure Amplify as follows:

```ts title="src/index.ts"
import { Amplify } from "aws-amplify";
import outputs from "@/amplify_outputs.json";

Amplify.configure(outputs);
```

### Custom configuration

In addition to extending existing configurations, you can also add custom output parameters to your `amplify_outputs.json`. This is useful for surfacing arbitrary outputs, values from custom CDK resources, or any other information that might be necessary for your application's logic or configuration.

```ts title="amplify/backend.ts"
import { defineBackend } from "@aws-amplify/backend";
import { auth } from "./auth/resource";
import { data } from "./data/resource";

const backend = defineBackend({
  auth, 
  data, 
});

backend.addOutput({
  custom: {
    api_id: "restAPIId",
    api_endpoint: "https://api.example.com",
    api_name: "restApiName",
  },
});
```


In your frontend application, you can access these custom configurations as follows:

```ts title="src/index.ts"
import { Amplify } from "aws-amplify";
import outputs from "@/amplify_outputs.json";

Amplify.configure(outputs);
const currentConfig = Amplify.getConfig(); 
Amplify.configure({
  ...currentConfig,
  API: {
    REST: {
      [outputs.custom.api_name]: {
        endpoint: outputs.custom.api_endpoint,
        region: "us-east-1",
      },
    },
  },
});
```
{/* @TODO  Link examples once published*/}

## Schema reference

The Amplify outputs file is defined using a JSON schema. You can find this schema in the [`aws-amplify/amplify-backend` repository](https://github.com/aws-amplify/amplify-backend/blob/main/packages/client-config/src/client-config-schema/schema_v1.json).

<pre><code style={{ maxWidth: "100%", overflowX: "scroll" }}>
{JSON.stringify(schema, null, 2)}
</code></pre>


Contents of reference_cdk-constructs_index.txt:
import { getCustomStaticPath } from '@/utils/getCustomStaticPath';

export const meta = {
  title: 'CDK constructs',
  description: 'Reference for CDK constructs.',
  platforms: [
    'android',
    'angular',
    'flutter',
    'javascript',
    'nextjs',
    'react',
    'react-native',
    'swift',
    'vue'
  ]
};

export const getStaticPaths = async () => {
  return getCustomStaticPath(meta.platforms);
};

export function getStaticProps(context) {
  return {
    props: {
      platform: context.params.platform,
      meta
    }
  };
}

Constructs—the basic building blocks of [AWS Cloud Development Kit (AWS CDK)](https://aws.amazon.com/cdk/) apps—abstract away the complexity of configuring cloud resources, so you can concentrate on your application code. In the following sections, we summarize the available Amplify backend constructs.

## Amplify Data

The official `AmplifyData` construct can be found on [Construct Hub](https://constructs.dev/packages/@aws-amplify/data-construct/?lang=typescript).

<Callout>
This package provides a Level 3 (L3) CDK construct wrapping the behavior of the Amplify GraphQL API. This enables quick development and iteration of AppSync APIs that support the Amplify GraphQL directives.
</Callout>

For more information on data modeling, visit the [data-modeling documentation](/[platform]/build-a-backend/data/data-modeling).

## Amplify Auth

The official `AmplifyAuth` construct can be found on the [npm registry](https://www.npmjs.com/package/@aws-amplify/auth-construct).


Contents of reference_cli-commands_index.txt:
import { getCustomStaticPath } from '@/utils/getCustomStaticPath';

export const meta = {
  title: 'CLI commands',
  description: 'Reference for CLI commands.',
  platforms: [
    'android',
    'angular',
    'flutter',
    'javascript',
    'nextjs',
    'react',
    'react-native',
    'swift',
    'vue'
  ]
  /**
   * Notes for documentation:
   * - only document 2 command levels deep. document further levels in the top-level command as usage examples but without additional subheading
   *   - (good) ampx sandbox secret
   *   - (bad) ampx sandbox secret set
   * - all commands should describe:
   *   - what the command is and when it is used
   *   - unordered list of options
   *   - usage examples
   */
};

export const getStaticPaths = async () => {
  return getCustomStaticPath(meta.platforms);
};

export function getStaticProps(context) {
  return {
    props: {
      platform: context.params.platform,
      meta
    }
  };
}

This page serves as a reference for commands found in the [`@aws-amplify/backend-cli`](https://www.npmjs.com/package/@aws-amplify/backend-cli) package.

All commands can be prefixed with [AWS CLI environment variables](https://docs.aws.amazon.com/cli/latest/userguide/cli-configure-envvars.html#envvars-list) to change the AWS account behavior with Amplify Gen 2 commands.

## npx ampx sandbox

Sandbox enables you to develop your backend alongside your frontend's development server. Run `npx ampx sandbox` to deploy to your personal cloud sandbox, this command will automatically watch for changes in the `amplify/` folder, and redeploy each time you save a file.

### Options

- `--dir-to-watch` (_string_) - Directory to watch for file changes. All subdirectories and files will be included. Defaults to the amplify directory.
- `--exclude` (_string[]_) - An array of paths or glob patterns to ignore. Paths can be relative or absolute and can either be files or directories.
- `--identifier` (_string_) - An optional name to distinguish between different sandbox environments. Default is the name of the system user executing the process
- `--outputs-out-dir` (_string_) - A path to a directory where the client config file is written. If not provided, defaults to the working directory of the current process.
- `--outputs-format` (_string_) - Format in which the client config file is written (choices: `json`, `dart`).
- `--outputs-version` (_string_) - Version of the configuration. Version 0 represents classic amplify-cli config file amplify-configuration and 1 represents newer config file amplify_outputs (choices: `0`, `1`).
- `--profile` (_string_) - An AWS profile name.
- `--stream-function-logs` (_boolean_) - Whether to stream function execution logs. (default: false)
- `--logs-filter` (_string[]_) - Regex pattern to filter logs from only matched functions. E.g. to stream logs for a function, specify it's name, and to stream logs from all functions starting with auth specify 'auth' (default: Stream all logs)
- `--logs-out-file` (_string_) - File to append the streaming logs. The file is created if it does not exist. (default: stdout)

### Usage

```bash title="Terminal" showLineNumbers={false}
npx ampx sandbox
```

#### Use with an alternate profile

You can use the `--profile` flag to run sandbox with an AWS profile other than `default`:

```bash title="Terminal" showLineNumbers={false}
npx ampx sandbox --profile my-other-profile
```

Additionally, you can use AWS CLI environment variables to specify a different profile:

```bash title="Terminal" showLineNumbers={false}
AWS_PROFILE=my-other-profile ampx sandbox
```

#### Use with an alternate Region

Use AWS environment variables to deploy to a Region other than your AWS profile's configured Region:

```bash title="Terminal" showLineNumbers={false}
AWS_REGION=us-west-2 ampx sandbox
```

#### Use with mobile applications

For mobile applications, you will need to set the output directory and format of the generated configuration file, specifically `amplify_outputs.json`:

```bash title="Terminal" showLineNumbers={false}
# for Android
npx ampx sandbox --outputs-out-dir app/src/main/res
```

```bash title="Terminal" showLineNumbers={false}
# for Swift/iOS
npx ampx sandbox
```

```bash title="Terminal" showLineNumbers={false}
# for Flutter
npx ampx sandbox --outputs-format dart --outputs-out-dir lib
```

## npx ampx sandbox delete

Delete your personal cloud sandbox. This should only be used if you have an active cloud sandbox that you opted to _not_ delete when exiting `npx ampx sandbox`.

### Options

- `--name` (_string_) - An optional name to distinguish between different sandbox environments. Default is the name in your package.json.
- `--profile` (_string_) - An AWS profile name.
- `-y, --yes` (_boolean_) - Do not ask for confirmation before deleting the sandbox environment.

### Usage

```bash title="Terminal" showLineNumbers={false}
npx ampx sandbox delete
```

## npx ampx sandbox secret

Manage backend secrets used with your personal cloud sandbox.

### Options

- `--profile` (_string_) - An AWS profile name.

### Usage

```bash title="Terminal" showLineNumbers={false}
npx ampx sandbox secret
```

#### Using with an alternate AWS profile

You can use the `--profile` flag to run sandbox with an AWS profile other than `default`:

```bash title="Terminal" showLineNumbers={false}
npx ampx sandbox secret list --profile my-other-profile
```

Additionally, you can use AWS environment variables to specify a different profile:

```bash title="Terminal" showLineNumbers={false}
AWS_PROFILE=my-other-profile ampx sandbox secret list
```

#### Creating a secret

Create secrets for use with your personal cloud sandbox by using `sandbox secret set`:

```bash title="Terminal" showLineNumbers={false}
npx ampx sandbox secret set LOGINWITHAMAZON_CLIENT_ID
```

This is how you configure secrets to be retrieved and used within your backend using `secret()`.

#### Removing a secret

If you want to remove a secret you previously set, use `sandbox secret remove`:

```bash title="Terminal" showLineNumbers={false}
npx ampx sandbox secret remove LOGINWITHAMAZON_CLIENT_ID
```

#### Listing secrets

List all available secrets for your personal sandbox in the default AWS profile and Region:

```bash title="Terminal" showLineNumbers={false}
npx ampx sandbox secret list
```

#### Get a secret and view its details

You can view an existing secret and its details, such as the current version and when it was last updated:

```console title="Terminal" showLineNumbers={false}
npx ampx sandbox secret get LOGINWITHAMAZON_CLIENT_ID
 name: LOGINWITHAMAZON_CLIENT_ID
 version: 1
 value: ****
 lastUpdated: Fri Nov 17 2023 12:00:00 GMT-0800 (Pacific Standard Time)
```

## npx ampx generate

Generate is not intended to be used standalone; however, it does offer a few subcommands to generate information or code that is supplemental to your frontend development.

Each of the following `generate` subcommands require either a CloudFormation stack name or an existing Amplify App ID and corresponding git branch:

```bash title="Terminal" showLineNumbers={false}
# with CloudFormation stack name
npx ampx generate <subcommand> --stack <cloudformation-stack-name>
```

```bash title="Terminal" showLineNumbers={false}
# with Amplify App ID and git branch
npx ampx generate <subcommand> --app-id <app-id> --branch <git-branch-name>
```

## npx ampx generate outputs

Generate the backend outputs file (e.g. `amplify_outputs.json`) for your frontend application to consume. This is intended to be used to manually generate a configuration file for an environment other than your personal cloud sandbox. For example, you might use it if you would like to verify something your coworker is seeing in their cloud sandbox, or to demonstrate frontend changes locally using a pre-existing "staging" branch.

### Options

In addition to the required options noted in [`ampx generate`](#npx-ampx-generate):

- `--profile` (_string_) - An AWS profile name.
- `--format` (_string_) - The format into which the configuration should be exported (choices: `json`, `dart`).
- `--out-dir` (_string_) - A path to the directory where config is written. If not provided, it defaults to the working directory of the current process.
- `--outputs-version` (_string_) - Version of the configuration. Version 0 represents classic amplify-cli config file amplify-configuration and 1 represents newer config file amplify_outputs (choices: `0`, `1`).

### Usage

As mentioned above, you can specify a team member's cloud sandbox CloudFormation stack:

```bash title="Terminal" showLineNumbers={false}
npx ampx generate outputs --stack amplify-nextamplifygen2-josef-sandbox-ca85e1081b
```

#### Use with mobile applications

Similar to `sandbox`, you can specify an alternate outputs file format by using `--format`:

```bash title="Terminal" showLineNumbers={false}
npx ampx generate outputs --stack amplify-nextamplifygen2-josef-sandbox-ca85e1081b
```

## npx ampx generate graphql-client-code

Generate GraphQL statements and types for your frontend application to consume.

### Options

The available parameters for `npx ampx generate graphql-client-code` are:

Required parameters:
- Stack identifier
  - `--stack`(_string_) - A stack name that contains an Amplify backend.
- Project identifier
  - `--app-id`(_string_) - The Amplify App ID of the project.
  - `--branch`(_string_) - A git branch of the Amplify project.

Optional parameters:
- `--out`(_string_) - Specifies the path to the directory where the config is written. If not provided, defaults to the current process working directory.
- `--format`(_string_) (choices: `modelgen`, `graphql-codegen`, `introspection`) - Specifies the format of the GraphQL client code to be generated.
- `--model-target` (_string_) (choices: `java`, `swift`, `javascript`, `typescript`, `dart`) - Specifies the modelgen export target. Only applies when the --format parameter is set to modelgen.
- `--statement-target`(_string_) (choices: `javascript`, `graphql`, `flow`, `typescript`, `angular`) - Specifies the graphql-codegen statement export target. Only applies when the --format parameter is set to graphql-codegen.
- `--statement-max-depth`(_integer_) - Specifies the maximum depth of the generated GraphQL statements. Only applies when the --format parameter is set to graphql-codegen.
- `--type-target`(_string_) (choices: `json`, `swift`, `typescript`, `flow`, `scala`, `flow-modern`, `angular`) - Specifies the optional graphql-codegen type export target. Only applies when the --format parameter is set to graphql-codegen.
- `--all`(_boolean_)- Shows hidden options.
- `--profile`(_string_) - Specifies an AWS profile name.
- `--debug` (_boolean_) - Print debug logs to the console.
- `--help`(_boolean_) - Displays help information about the command.

### Usage

#### Generate GraphQL client code using the Amplify App ID and branch. 

```bash title="Terminal" showLineNumbers={false}
npx ampx generate graphql-client-code --app-id <your-amplify-app-id>	--branch staging
```

#### Generate GraphQL client code for a branch that is connected to Amplify

Sometimes you want to test your latest local changes with the backend of another deployed branch. If you want to generate the GraphQL client code file(s) for the latest deployment of another branch, you can run the following command:

```bash title="Terminal" showLineNumbers={false}
npx ampx generate graphql-client-code --branch staging
```

#### Generate codegen for CDK app using a joint "AmplifyBackendStack" construct

Assume you have deployed your Amplify project with the CDK construct. You will need to remember your app's project name (designated as the second parameter in your CDK construct) and stack name (designated as part of your `npx cdk deploy` context)

```ts title="lib/stack.ts" showLineNumbers={false}
import { Construct } from 'constructs';
import { App, Backend } from 'aws-cdk-lib/aws-amplify';

export class MyAmplifyStack extends cdk.Stack {
  constructor(scope: cdk.Construct, id: string, props?: cdk.StackProps) {
    super(scope, id, props);

    new Backend(this, "Backend", { /* ... */ });
  }
}
```

#### Deployment command for CDK project

```bash title="Terminal" showLineNumbers={false}
npx cdk deploy
```

Run Amplify codegen command to generate GraphQL codegen:

```bash title="Terminal" showLineNumbers={false}
npx ampx generate graphql-client-code --stack Backend --platform ts --out ./src
```

#### Generate codegen in specific language and format

```bash title="Terminal" showLineNumbers={false}
npx ampx generate graphql-client-code --format modelgen --type-target angular
```

#### Supported GraphQL client code combinations:

| Format | Platform | Codegen command in Amplify CLI | Command in Amplify Gen2 | Default generated file/path |
| -------| -------- | ------------------------------ | ----------------------- | --------------------------- |
| Introspection schema | Amplify Javascript | N/A | `npx ampx generate graphql-client-code --format introspection` | `<path_to_app>/` |
| GraphQL codegen | Amplify Javascript | `amplify codegen` | `npx ampx generate graphql-client-code --format graphql-codegen --statement-target javascript --out <path_to_app>/src/graphql/` | `<path_to_app>/src/graphql/` |
| Modelgen | Amplify Javascript | `amplify codegen model` | `npx ampx generate graphql-client-code --format modelgen --model-target javascript --out <path_to_app>/src/models/` | `<path_to_app>/src/models/` |
| Modelgen | Amplify Android | `amplify codegen model` | `npx ampx generate graphql-client-code --format modelgen --model-target java --out <path_to_app/src/main/java/>` | `<path_to_app>/src/main/java/com/amplifyframework/datastore/generated/model` |
| Modelgen | Amplify Swift | `amplify codegen model` | `npx ampx generate graphql-client-code --format modelgen --model-target swift --out <path_to_swift_project>/AmplifyModels` | `<path_to_swift_project>/AmplifyModels` |
| Modelgen | Amplify Flutter | `amplify codegen model` | `npx ampx generate graphql-client-code --format modelgen --model-target dart --out <path_to_flutter_project>/AmplifyModels` | `<path_to_flutter_project>/AmplifyModels` |


## npx ampx generate forms

Generate React form components derived from your backend data models for your frontend application to consume.

### Options

- `--stack`(_string_) - A stack name that contains an Amplify backend.
- `--branch` (_string_) - Name of the git branch being deployed.
- `--app-id` (_string_) - The app id of the target Amplify app.
- `--out-dir` (_string_) - A path to directory where generated forms are written. Defaults to the `./ui-components` directory.
- `--models` (_array_) - Model name to generate.
- `--profile` (_string_) - An AWS profile name.

### Usage

```bash title="Terminal" showLineNumbers={false}
npx ampx generate forms --branch $BRANCH_NAME --app-id $AWS_APP_ID --out-dir ./src
```

## npx ampx info

Generates information on system, binaries, npm packages, and environment variables for troubleshooting Amplify issues.

```bash title="Terminal" showLineNumbers={false}
npx ampx info
```

This command will print system information as follows:

```bash title="Terminal" showLineNumbers={false}
System:
  OS: macOS 14.3.1
  CPU: (10) arm64 Apple M1 Pro
  Memory: 165.89 MB / 32.00 GB
  Shell: /opt/homebrew/bin/fish
Binaries:
  Node: 20.12.2 - ~/Library/Caches/fnm_multishells/1063_1714573452292/bin/node
  Yarn: 1.22.19 - ~/Library/Caches/fnm_multishells/1063_1714573452292/bin/yarn
  npm: 10.5.0 - ~/Library/Caches/fnm_multishells/1063_1714573452292/bin/npm
  pnpm: 9.0.5 - ~/Library/Caches/fnm_multishells/1063_1714573452292/bin/pnpm
NPM Packages:
  @aws-amplify/backend: 1.0.0
  @aws-amplify/backend-cli: 1.0.1
  aws-amplify: 6.2.0
  aws-cdk: 2.139.1
  aws-cdk-lib: 2.139.1
  typescript: 5.4.5
AWS environment variables:
  AWS_PROFILE = amplify-admin
  AWS_STS_REGIONAL_ENDPOINTS = regional
  AWS_NODEJS_CONNECTION_REUSE_ENABLED = 1
  AWS_SDK_LOAD_CONFIG = 1
No CDK environment variables
```

## npx ampx pipeline-deploy

Deploys the Amplify project in a CI/CD pipeline for a specified Amplify app and branch.

### Options

- `--branch` (_string_) - Name of the git branch being deployed.
- `--app-id` (_string_) - The app id of the target Amplify app.
- `--outputs-out-dir` (_string_) - A path to a directory where the client config file is written. If not provided, defaults to the working directory of the current process.
- `--outputs-version` (_string_) - Version of the configuration. Version 0 represents classic amplify-cli config file amplify-configuration and 1 represents newer config file amplify_outputs (choices: `0`, `1`).

### Usage

```bash title="Terminal" showLineNumbers={false}
npx ampx pipeline-deploy --branch $BRANCH_NAME --app-id $AWS_APP_ID
```


Contents of reference_flutter-api_index.txt:
import { getCustomStaticPath } from '@/utils/getCustomStaticPath';
                  
export const meta = {
  title: 'API Documentation',
  description: 'A list of Amplify Libraries for Flutter API reference docs.',
  platforms: ['flutter']
};

export const getStaticPaths = async () => {
  return getCustomStaticPath(meta.platforms);
};

export function getStaticProps(context) {
  return {
    props: {
      platform: context.params.platform,
      showBreadcrumbs: false,
      meta
    }
  };
}
          

* [Amplify Libraries for Flutter API reference](https://pub.dev/packages/amplify_api)
* [Amplify Libraries for Flutter: Core reference](https://pub.dev/packages/amplify_core)
* [Amplify Libraries for Flutter: Analytics reference](https://pub.dev/packages/amplify_analytics_pinpoint)
* [Amplify Libraries for Flutter: Auth reference](https://pub.dev/packages/amplify_auth_cognito)
* [Amplify Libraries for Flutter: Authenticator reference](https://pub.dev/packages/amplify_authenticator)
* [Amplify Libraries for Flutter: Datastore reference](https://pub.dev/packages/amplify_datastore)
* [Amplify Libraries for Flutter: Storage reference](https://pub.dev/packages/amplify_storage_s3)


Contents of reference_iam-policy_index.txt:
import { getCustomStaticPath } from '@/utils/getCustomStaticPath';

export const meta = {
  title: 'IAM policy',
  description: 'Learn more about the IAM policy required by Amplify.',
  platforms: [
    'android',
    'angular',
    'flutter',
    'javascript',
    'nextjs',
    'react',
    'react-native',
    'swift',
    'vue'
  ]
};

export const getStaticPaths = async () => {
  return getCustomStaticPath(meta.platforms);
};

export function getStaticProps(context) {
  return {
    props: {
      platform: context.params.platform,
      meta
    }
  };
}

## Branch deployments

Branch deployments require the [`AmplifyBackendDeployFullAccess`](https://docs.aws.amazon.com/amplify/latest/userguide/security-iam-awsmanpol.html#security-iam-awsmanpol-AmplifyBackendDeployFullAccess) managed policy to be able to deploy backend resources during a fullstack deployment. When connecting your project through the console, a role with this policy attached will be automatically created for you.

<Video src="/images/gen2/references/iam-policy.mp4" description="Video - IAM Policy" />

## Cloud sandbox deployments

Sandbox deployments, by design, use local credentials to deploy resources. You need to ensure that the local profile has the `AmplifyBackendDeployFullAccess` policy attached to it.


Contents of reference_index.txt:
import { getChildPageNodes } from '@/utils/getChildPageNodes';
import { getCustomStaticPath } from '@/utils/getCustomStaticPath';

export const meta = {
  title: 'Reference',
  description: 'Overview of available references.',
  route: '/[platform]/reference',
  platforms: [
    'android',
    'angular',
    'flutter',
    'javascript',
    'nextjs',
    'react',
    'react-native',
    'swift',
    'vue'
  ]
};

export const getStaticPaths = async () => {
  return getCustomStaticPath(meta.platforms);
};

export function getStaticProps(context) {
  const childPageNodes = getChildPageNodes(meta.route);
  return {
    props: {
      meta,
      childPageNodes
    }
  };
}

<Overview childPageNodes={props.childPageNodes} />


Contents of reference_project-structure_index.txt:
import { getCustomStaticPath } from '@/utils/getCustomStaticPath';

export const meta = {
  title: 'Project structure',
  description: 'Learn more about how Amplify projects are structured.',
  platforms: [
    'android',
    'angular',
    'flutter',
    'javascript',
    'nextjs',
    'react',
    'react-native',
    'swift',
    'vue'
  ]
};

export const getStaticPaths = async () => {
  return getCustomStaticPath(meta.platforms);
};

export function getStaticProps(context) {
  return {
    props: {
      platform: context.params.platform,
      meta
    }
  };
}

Amplify Gen 2 backends are defined using TypeScript, and enable you to collocate resources depending on their function. For example, you can author a [post confirmation trigger for Amazon Cognito that creates a UserProfile model](/[platform]/build-a-backend/functions/examples/create-user-profile-record/) right next to your auth's resource file.

When you create your first Amplify project using `npm create amplify@latest`, it will automatically set up the scaffolding for Data and Authentication resources:

```text
├── amplify/
│   ├── auth/
│   │   └── resource.ts
│   ├── data/
│   │   └── resource.ts
│   ├── backend.ts
│   └── package.json
├── node_modules/
├── .gitignore
├── package-lock.json
├── package.json
└── tsconfig.json
```

As your project grows and you build out your backend, the structure of your project may look like the following:

```text
├── amplify/
│   ├── auth/
│   │   ├── custom-message/
│   │   │   ├── custom-message.tsx
│   │   │   ├── handler.ts
│   │   │   ├── package.json
│   │   │   └── resource.ts
│   │   ├── post-confirmation.ts
│   │   ├── pre-sign-up.ts
│   │   ├── resource.ts
│   │   └── verification-email.tsx
│   ├── data/
│   │   ├── resolvers/
│   │   │   ├── list-featured-posts.ts
│   │   │   └── list-top-10-posts.ts
│   │   ├── resource.ts
│   │   └── schema.ts
│   ├── jobs/
│   │   ├── monthly-report/
│   │   │   ├── handler.ts
│   │   │   └── resource.ts
│   │   ├── process-featured-posts/
│   │   │   ├── handler.py
│   │   │   ├── requirements.txt
│   │   │   └── resource.ts
│   │   └── store-top-10-posts/
│   │       ├── handler.ts
│   │       └── resource.ts
│   ├── storage/
│   │   ├── photos/
│   │   │   ├── resource.ts
│   │   │   └── trigger.ts
│   │   └── reports/
│   │       └── resource.ts
│   ├── backend.ts
│   └── package.json
├── node_modules/
├── .gitignore
├── package-lock.json
├── package.json
└── tsconfig.json
```

Backend resources are defined in `resource` files using the `define*` helpers:

```ts title="amplify/auth/resource.ts"
import { defineAuth } from '@aws-amplify/backend';

export const auth = defineAuth({
  loginWith: {
    email: true
  }
});
```

After the resources are defined, they are set up on the backend:

```ts title="amplify/backend.ts"
import { defineBackend } from '@aws-amplify/backend';
import { auth } from './auth/resource';
import { data } from './data/resource';

defineBackend({
  auth,
  data
});
```

You can extend backends by using the [AWS Cloud Development Kit (AWS CDK)](https://docs.aws.amazon.com/cdk/v2/guide/home.html), which is installed by default as part of the [`create-amplify`](https://www.npmjs.com/package/create-amplify) workflow. With the CDK, you can build using any AWS service, such as an Amazon S3 bucket that authenticated users have read and write access to. To get started with the CDK, add it to your backend:

```ts title="amplify/backend.ts"
import * as s3 from 'aws-cdk-lib/aws-s3';
import { defineBackend } from '@aws-amplify/backend';
import { auth } from './auth/resource';
import { data } from './data/resource';

const backend = defineBackend({
  auth,
  data
});

// create the bucket and its stack
const bucketStack = backend.getStack('BucketStack');
const bucket = new s3.Bucket(bucketStack, 'Bucket', {
  blockPublicAccess: s3.BlockPublicAccess.BLOCK_ALL
});

// allow any authenticated user to read and write to the bucket
const authRole = backend.auth.resources.authenticatedUserIamRole;
bucket.grantReadWrite(authRole);

// allow any guest (unauthenticated) user to read from the bucket
const unauthRole = backend.auth.resources.unauthenticatedUserIamRole;
bucket.grantRead(unauthRole);
```

## Next steps

- [Learn the concepts](/[platform]/how-amplify-works/concepts)
- [Learn how to add AWS services to your backend](/[platform]/build-a-backend/add-aws-services)


Contents of reference_telemetry_index.txt:
import { getCustomStaticPath } from '@/utils/getCustomStaticPath';

export const meta = {
  title: 'Telemetry',
  description: 'Reference for Amplify Gen 2 telemetry.',
  platforms: [
    'android',
    'angular',
    'flutter',
    'javascript',
    'nextjs',
    'react',
    'react-native',
    'swift',
    'vue'
  ]
};

export const getStaticPaths = async () => {
  return getCustomStaticPath(meta.platforms);
};

export function getStaticProps(context) {
  return {
    props: {
      platform: context.params.platform,
      meta
    }
  };
}

{/* inspired by https://nextjs.org/telemetry */}

Amplify Gen 2 collects anonymous telemetry data about general usage of the CLI. Participation is optional, and you may [opt out](#how-do-i-opt-out) by using `ampx configure telemetry disable`.

Your decision to opt out is stored for your user, meaning all Amplify apps you work with on that computer will not send telemetry data.

{/* ## Why is telemetry collected? */}

{/* @TODO */}

{/* ## What is being collected? */}

{/* @TODO */}

## How do I opt out?

You may opt out by using the `configure telemetry disable` command from the root of your Amplify app:

```bash title="Terminal" showLineNumbers={false}
npx ampx configure telemetry disable
```

You can opt back in to the program by running the following from the root of your Amplify app:

```bash title="Terminal" showLineNumbers={false}
npx ampx configure telemetry enable
```

In the event you would like to disable telemetry on a one-time basis, you can opt out by defining an environment variable:

```bash title="Terminal" showLineNumbers={false}
export AMPLIFY_DISABLE_TELEMETRY=1
```


Contents of sdk_configuration_amplify-compatibility_index.txt:
import { getCustomStaticPath } from '@/utils/getCustomStaticPath';

export const meta = {
  title: 'Amplify v2 Compatibility',
  description:
    'Learn how to use the AWS SDK with Amplify v2.',
  platforms: ['android']
};

export const getStaticPaths = async () => {
  return getCustomStaticPath(meta.platforms);
};

export function getStaticProps(context) {
  return {
    props: {
      platform: context.params.platform,
      meta
    }
  };
}

<InlineFilter filters={["android"]}>
<Callout warning>
The AWS Mobile Client (com.amazonaws:aws-android-sdk-mobile-client) and Amplify Android v2 are not compatible with each other. Amplify v2 migrates the credentials from AWS Mobile Client into a different format, leaving AWS Mobile Client unable to read the credentials. If AWS Mobile Client is launched after this migration has taken place, the Amplify v2 credentials will also be cleared.
</Callout>

## Using Amplify V2 Auth with AWS Android SDK Plugin

We recommend using Amplify v2 with the [AWS Kotlin SDK](https://aws.amazon.com/sdk-for-kotlin/), rather than the AWS Android SDK. In order to better support existing implementations, this guide demonstrates how to continue using AWS Android SDK plugins with Amplify v2.

### Creating an AmplifyCredentialsProvider

Many of the AWS Android SDK plugins accept a custom `AWSCredentialsProvider` implementation. You can implement your own `AWSCredentialsProvider` that uses Amplify Android v2 to provide credentials. 

<BlockSwitcher>
<Block name="Java">

```java
import com.amazonaws.auth.AWSCredentials;
import com.amazonaws.auth.AWSCredentialsProvider;
import com.amazonaws.auth.BasicSessionCredentials;
import com.amplifyframework.auth.AWSTemporaryCredentials;
import com.amplifyframework.auth.cognito.AWSCognitoAuthSession;
import com.amplifyframework.auth.options.AuthFetchSessionOptions;
import com.amplifyframework.core.Amplify;

import java.util.concurrent.CompletableFuture;

class AmplifyCredentialsProvider implements AWSCredentialsProvider {

    @Override
    public AWSCredentials getCredentials() {
        CompletableFuture<AWSCredentials> sdkCredentials = new CompletableFuture<>();

        Amplify.Auth.fetchAuthSession((authSession) -> {
            BasicSessionCredentials credentials = null;
            if (authSession instanceof AWSCognitoAuthSession) {
                AWSCognitoAuthSession cognitoAuthSession = (AWSCognitoAuthSession) authSession;
                com.amplifyframework.auth.AWSCredentials awsCredentials =
                        cognitoAuthSession.getAwsCredentialsResult().getValue();
                if (awsCredentials instanceof AWSTemporaryCredentials) {
                    AWSTemporaryCredentials temporaryAwsCredentials =
                            (AWSTemporaryCredentials) awsCredentials;
                    credentials = new BasicSessionCredentials(
                            temporaryAwsCredentials.getAccessKeyId(),
                            temporaryAwsCredentials.getSecretAccessKey(),
                            temporaryAwsCredentials.getSessionToken()
                    );
                }
            }

            if (credentials != null) {
                sdkCredentials.complete(credentials);
            } else {
                sdkCredentials.completeExceptionally(
                        new RuntimeException("Failed to get credentials")
                );
            }
        }, (exception) -> sdkCredentials.completeExceptionally(
                new RuntimeException("Failed to get credentials", exception)
        ));

        return sdkCredentials.join();
    }

    @Override
    public void refresh() {
        CompletableFuture<Void> result = new CompletableFuture<>();
        Amplify.Auth.fetchAuthSession(
                AuthFetchSessionOptions.builder().forceRefresh(true).build(),
                // We do not need to capture value if refresh succeeds
                (authSession) -> result.complete(null),
                // We do not need to throw if refresh fails
                (exception) -> result.complete(null)
        );

        result.join();
    }
}
```

</Block>
<Block name="Kotlin">

```kotlin
import com.amazonaws.auth.AWSCredentials
import com.amazonaws.auth.AWSCredentialsProvider
import com.amazonaws.auth.BasicSessionCredentials
import com.amplifyframework.auth.AWSTemporaryCredentials
import com.amplifyframework.auth.cognito.AWSCognitoAuthSession
import com.amplifyframework.auth.options.AuthFetchSessionOptions
import com.amplifyframework.core.Amplify
import java.lang.RuntimeException
import kotlin.coroutines.resume
import kotlin.coroutines.resumeWithException
import kotlin.coroutines.suspendCoroutine
import kotlinx.coroutines.runBlocking

class AmplifyCredentialsProvider : AWSCredentialsProvider {

    override fun getCredentials(): AWSCredentials = runBlocking {
        suspendCoroutine { continuation ->
            Amplify.Auth.fetchAuthSession(
                { authSession ->
                    val awsTemporaryCredentials = (authSession as? AWSCognitoAuthSession)
                        ?.awsCredentialsResult?.value as? AWSTemporaryCredentials

                    val sdkCredentials = awsTemporaryCredentials?.let {
                        BasicSessionCredentials(it.accessKeyId, it.secretAccessKey, it.sessionToken)
                    }

                    if (sdkCredentials != null) {
                        continuation.resume(sdkCredentials)
                    } else {
                        val authException = RuntimeException("Failed to get credentials")
                        continuation.resumeWithException(authException)
                    }
                },
                {
                    continuation.resumeWithException(
                        RuntimeException("Failed to get credentials. See exception.", it)
                    )
                }
            )
        }
    }

    override fun refresh() = runBlocking {
        suspendCoroutine { continuation ->
            Amplify.Auth.fetchAuthSession(
                AuthFetchSessionOptions.builder().forceRefresh(true).build(),
                // We do not need to capture value if refresh succeeds
                { continuation.resume(Unit) },
                // We do not need to throw if refresh fails
                { continuation.resume(Unit) }
            )
        }
    }
}
```

</Block>
</BlockSwitcher>

You can now use your `AmplifyCredentialsProvider` in any plugins that accept an `AWSCredentialsProvider`, instead of using `AWSMobileClient.getInstance()` as your AWSCredentialsProvider.


## Providing AWS Configuration Information

Amplify v2 uses the `amplify_outputs.json` file where AWS Android SDK uses the `awsconfiguration.json` file. If you are using both Amplify v2 and AWS Android SDK in your project, it is important to ensure the resources are in sync. The Amplify CLI still generates and updates both of these file types, but any manual customizations should be applied to both files.

For AWS Android SDK plugins that require configuration information, you can continue to use the `AWSConfiguration` class.

<BlockSwitcher>
<Block name="Java">

```java
AWSConfiguration awsConfiguration = new AWSConfiguration(context);
```

</Block>
<Block name="Kotlin">

```kotlin
val awsConfiguration = AWSConfiguration(context)
```

</Block>
</BlockSwitcher>

## Example Usage of  AWS Android SDK Plugins with Amplify v2

This is not an exhaustive list of supported plugins. Any plugins that accept an AWSCredentialsProvider and do not rely on AWS Mobile Client should work.

### S3 Storage (com.amazonaws:aws-android-sdk-s3)

<BlockSwitcher>
<Block name="Java">

```java
AWSConfiguration awsConfiguration = new AWSConfiguration(context);
TransferUtility transferUtility = TransferUtility.builder()
    .context(context)
    .awsConfiguration(awsConfig)
    .s3Client(
        new AmazonS3Client(
            new AmplifyCredentialsProvider(),
            Region.getRegion(Regions.US_EAST_1)
        )
    )
    .build();
```

</Block>
<Block name="Kotlin">

```kotlin
val awsConfiguration = AWSConfiguration(context)
val transferUtility = TransferUtility.builder()
    .context(context)
    .awsConfiguration(awsConfiguration)
    .s3Client(
        AmazonS3Client(
            AmplifyCredentialsProvider(),
            Region.getRegion(Regions.US_EAST_1)
        )
    )
    .build()
```

</Block>
</BlockSwitcher>

### IoT (com.amazonaws:aws-android-sdk-iot)

<BlockSwitcher>
<Block name="Java">

```java
AWSIotClient client = new AWSIotClient(new AmplifyCredentialsProvider());

```

</Block>
<Block name="Kotlin">

```kotlin
val client = AWSIotClient(AmplifyCredentialsProvider())
```

</Block>
</BlockSwitcher>



### Android SDK Generated by API Gateway (aws-android-sdk-apigateway-core)

<BlockSwitcher>
<Block name="Java">

```java
ApiClientFactory clientFactory = new ApiClientFactory();
clientFactory.credentialsProvider(new AmplifyCredentialsProvider());
```

</Block>
<Block name="Kotlin">

```kotlin
val clientFactory = ApiClientFactory()
clientFactory.credentialsProvider(AmplifyCredentialsProvider())
```

</Block>
</BlockSwitcher>

</InlineFilter>


Contents of start_account-setup_index.txt:
import { getCustomStaticPath } from '@/utils/getCustomStaticPath';

export const meta = {
  title: 'Configure AWS for local development',
  description:
    'Learn how to set up your AWS account and configure it locally for use with Amplify.',
  platforms: [
    'android',
    'angular',
    'flutter',
    'javascript',
    'nextjs',
    'react',
    'react-native',
    'swift',
    'vue'
  ]
};

export const getStaticPaths = async () => {
  return getCustomStaticPath(meta.platforms);
};

export function getStaticProps(context) {
  return {
    props: {
      platform: context.params.platform,
      meta
    }
  };
}

<Callout info>

**Note**: If you already have an AWS account and profile configured locally, you do not need to follow this guide. Please add the`AmplifyBackendDeployFullAccess` IAM role to your configured AWS profile.

</Callout>

This guide will help you set up Temporary credentials with [IAM Identity Center](https://docs.aws.amazon.com/singlesignon/latest/userguide/what-is.html) and [AWS Organizations](https://docs.aws.amazon.com/organizations/latest/userguide/orgs_introduction.html), which will enable you to define Single-sign on (SSO), users, groups, permission sets, and more for your team. AWS Organizations can grow to house multiple AWS accounts. Users within the organization can traverse the AWS account(s) as their permission set allows.

Amplify leverages the standard local credentials chain provider to simplify access to AWS services. While this guide highlights IAM Identity Center, you can explore additional methods for [authenticating with AWS locally](https://docs.aws.amazon.com/cli/latest/userguide/getting-started-quickstart.html#getting-started-prereqs-keys).

<Accordion title="IAM Identity Center terminology">

IAM Identity Center enables users to sign in using a single user identity to access all their assigned AWS accounts, business applications, and custom applications in the AWS Cloud. This single sign-on capability reduces the complexity of managing multiple credentials and improves security by centralizing user authentication.

### Users

Users refers to the location where user identities and group information are stored and managed. IAM Identity Center can integrate with external identity sources like Microsoft Active Directory or use a built-in identity store provided by AWS.

### Permission Set

A collection of permissions that can be assigned to users or groups. Permission sets define what actions users are allowed to perform in your AWS accounts. They are similar to IAM policies but are used within the context of IAM Identity Center to manage access across multiple accounts.

### AWS Organization

AWS Organizations and IAM Identity Center work together to streamline management across multiple AWS accounts. AWS Organizations manages account structures and policies, while IAM Identity Center integrates with it to enable single sign-on and align permissions with organizational roles. This synergy ensures secure and consistent access control, simplifying user and permission management.

### Local Profiles

Credentials are typically resolved through the use of [AWS profiles](https://docs.aws.amazon.com/cli/latest/userguide/cli-configure-files.html#cli-configure-files-using-profiles). Profiles can contain permanent credentials or SSO metadata, and can be set for use with Amplify by using the same techniques as the AWS CLI:

- with the `--profile` flag
- with the `AWS_PROFILE` environment variable

### Temporary credentials

An alternative to permanent credentials, enable you to define permissions for a _session_. Sessions are created when you [_assume_ an IAM role](https://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles_use.html) or sign in using AWS IAM Identity Center. These sessions come with an additional "session token" that is used to validate the temporary credentials and must be included on requests to AWS. As you are working locally, this will be presented as an additional environment variable.

You can use temporary security credentials to make programmatic requests for AWS resources using the AWS CLI or AWS API (through the AWS SDKs). The temporary credentials provide the same permissions as long-term security credentials, such as IAM user credentials. However, there are a few differences, which are covered in the [AWS Identity and Access Management documentation](https://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_temp_use-resources.html).

</Accordion>

## Set up Identity Center

Follow the steps below if **you have never set up AWS profiles before**. 
<YoutubeEmbed embedId="LhRa_kZmmVY" />

If you already have a profile, attach the [`AmplifyBackendDeployFullAccess`](https://docs.aws.amazon.com/aws-managed-policy/latest/reference/AmplifyBackendDeployFullAccess.html) managed policy to your [IAM user](https://docs.aws.amazon.com/IAM/latest/UserGuide/id_users_change-permissions.html#users_change_permissions-add-console).


### 1. Create user with Amplify permissions

Sign in to the AWS Console to access [IAM Identity Center page](https://console.aws.amazon.com/singlesignon/home) and choose **Enable**.

![](/images/gen2/account-setup/sso-enable.png)

A dialog will open, prompting you to "Choose how to configure IAM Identity Center in your AWS environment." Select **Enable with AWS Organizations** and choose **Continue**.

![](/images/gen2/account-setup/sso-enable-dialog.png)

Next, we are going to automate a number of steps that simulate the operations of setting up a user in the IAM Identity Center console. To get started open CloudShell, located in the console footer.

<Video src="/images/gen2/account-setup/sso-cloud-shell.mp4" description="Video - Open CloudShell" />

Paste the following command in the CloudShell terminal and enter an email address you would like to associate with this AWS account:

```bash title="CloudShell" showLineNumbers={false}
read -p "Enter email address: " user_email # hit enter
```

```console showLineNumbers={false}
Enter email address: <your-email-address>
```

Now, run the following command

```bash title="CloudShell"
response=$(aws sso-admin list-instances)
ssoId=$(echo $response | jq '.Instances[0].IdentityStoreId' -r)
ssoArn=$(echo $response | jq '.Instances[0].InstanceArn' -r)
email_json=$(jq -n --arg email "$user_email" '{"Type":"Work","Value":$email}')
response=$(aws identitystore create-user --identity-store-id $ssoId --user-name amplify-admin --display-name 'Amplify Admin' --name Formatted=string,FamilyName=Admin,GivenName=Amplify --emails "$email_json")
userId=$(echo $response | jq '.UserId' -r)
response=$(aws sso-admin create-permission-set --name amplify-policy --instance-arn=$ssoArn --session-duration PT12H)
permissionSetArn=$(echo $response | jq '.PermissionSet.PermissionSetArn' -r)
aws sso-admin attach-managed-policy-to-permission-set --instance-arn $ssoArn --permission-set-arn $permissionSetArn --managed-policy-arn arn:aws:iam::aws:policy/service-role/AmplifyBackendDeployFullAccess
accountId=$(aws sts get-caller-identity | jq '.Account' -r)
aws sso-admin create-account-assignment --instance-arn $ssoArn --target-id $accountId --target-type AWS_ACCOUNT --permission-set-arn $permissionSetArn --principal-type USER --principal-id $userId
# Hit enter
```

To validate that this worked, run the following command in the CloudShell. If something failed in this process, please **[report an issue](https://github.com/aws-amplify/amplify-backend/issues)**. Keep this information readily available for [the next step](#2-set-up-local-aws-profile).

```bash title="CloudShell" showLineNumbers={false}
// highlight-next-line
printf "\n\nStart session url: https://$ssoId.awsapps.com/start\nRegion: $AWS_REGION\nUsername: amplify-admin\n\n"

# you should see
Start session url: https://d-XXXXXXXXXX.awsapps.com/start
Region: us-east-1
Username: amplify-admin
```

<Accordion title="Prefer a manual set up?" eyebrow="A step-by-step walkthrough in the console">

- After the AWS Organization is created and IAM Identity Center is enabled, you are presented with a dashboard. In the navigation pane, select **Permission sets**.

  ![AWS IAM Identity Center dashboard indicating "permission sets" in the navigation pane.](/images/gen2/account-setup/sso-dashboard-highlight-permission-sets.png)

- Select **Create permission set**.
- When prompted for the permission set type, choose **Custom permission set**. Then choose **Next**. Expand **AWS Managed Policies (set)** and search for _amplify_. Select **AmplifyBackendDeployFullAccess** and choose **Next**.

  ![AWS IAM Identity Center custom permission set page with the "AmplifyBackendDeployFullAccess" AWS managed policy selected.](/images/gen2/account-setup/sso-permission-set-custom.png)

- Name the permission set _amplify-policy_ and optionally change the session duration. Choose **Next**.

  ![AWS IAM Identity Center custom permission set details page with the name "AmplifySet".](/images/gen2/account-setup/sso-permission-set-custom-details.png)

- Review the permission set and choose **Create**.
- Once the permission set is created, you will return to the IAM Identity Center dashboard. You are now ready to create your first user. Using the navigation pane, select **Users**.
- Enter the user details, then choose **Next**.

  ![AWS IAM Identity Center user creation with the username "amplify-admin".](/images/gen2/account-setup/sso-create-user.png)

- Optionally create and add the user to a group, and choose **Next**.
- Review the user information and select **Add user**. The user will then need to verify their email using the email specified during user creation.
- Once the new user is created, you will return to the IAM Identity Center dashboard. The next step is to grant the user access to an AWS account. For this demo, we will use the AWS account we used to create the Organization, but you can create a new AWS account under your organization for use with Amplify. Select the checkbox next to the management account and choose **Assign users or groups**.

  ![AWS IAM Identity Center "AWS accounts" page with the management account checked.](/images/gen2/account-setup/sso-aws-accounts.png)

- When prompted to assign a user or group, select the **Users** tab, select the user created in step 13, and choose **Next**.

  ![AWS IAM Identity Center "AWS accounts" page assigning "amplify-admin" to the management AWS account](/images/gen2/account-setup/sso-aws-accounts-add-user.png)

- Assign the permission set created in step 9 and choose **Next**.
- Review the assignment information and choose **Submit**.
- Now you are ready to sign in to the access portal. Navigate back to the IAM Identity Center dashboard. Within the **Settings summary** pane, copy the URL for your **AWS access portal URL**.

  ![AWS IAM Identity Center dashboard highlighting the AWS access portal URL.](/images/gen2/account-setup/sso-dashboard-access-portal.png)

- Navigate to the copied URL and sign in as your user, _amplify-admin_. After signing in, you should have access to an AWS account.

  ![AWS IAM Identity Center access portal displaying an AWS account.](/images/gen2/account-setup/sso-access-portal.png)

</Accordion>

### 2. Create password for user

Now create a password for the user that we need for the next step. In the IdC console, navigate to _Users > amplify_admin > Reset password > Send an email to the user with instructions for resetting the password_.

<Video src="/images/gen2/account-setup/sso-reset-password.mp4" description="Video - Reset Password" />

Check your email (make sure you also check your spam folder). Click on the _Reset password_ link and choose a password of your choice. When signing in make sure to use _amplify-admin_ as the _Username_.

![](/images/gen2/account-setup/sso-reset-password.png)

## Finish local setup

Now, set up an AWS profile that is linked to the user you just created on your local machine. There are a few options for [getting IAM Identity Center user credentials](https://docs.aws.amazon.com/singlesignon/latest/userguide/howtogetcredentials.html), but we will use the AWS CLI configuration wizard.

### 3. Install the AWS CLI

Install the [AWS CLI](https://docs.aws.amazon.com/cli/latest/userguide/getting-started-install.html).

<BlockSwitcher>

<Block name="Mac">
In your browser, download the macOS pkg file:

[Install on Mac](https://awscli.amazonaws.com/AWSCLIV2.pkg)

</Block>

<Block name="Windows">
In your browser, Download and run the AWS CLI MSI installer for Windows (64-bit):

[Install on Windows](https://awscli.amazonaws.com/AWSCLIV2.msi)

</Block>
To install the AWS CLI, run the following commands.

<Block name="Linux">

```bash showLineNumbers={false}
curl "https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip" -o "awscliv2.zip"
unzip awscliv2.zip
./aws/install -i /usr/local/aws-cli -b /usr/local/bin
```

</Block>

</BlockSwitcher>

### 4. Set up local AWS profile

Open your terminal, you are ready to configure an AWS profile that uses the SSO user. Use the information from CloudShell to populate the information below.

```console title="Terminal" showLineNumbers={false}
//highlight-next-line
aws configure sso

| SSO session name (Recommended): amplify-admin
| SSO start URL: <START SESSION URL>
| SSO region: <your-region>
| SSO registration scopes [sso:account:access]: <leave blank>
| Attempting to automatically open the SSO authorization page in your default browser.
| If the browser does not open or you wish to use a different device to authorize this request, open the following URL:
|
| https://device.sso.us-east-2.amazonaws.com/
|
| Then enter the code:
|
| SOME-CODE

## browser opens
```

After you provide this information, the browser will automatically open asking you to sign in with the username and password you just created and configure a multi-factor device to authenticate.

Now return to the terminal and enter the following information:

```console title="Terminal" showLineNumbers={false}
The only AWS account available to you is: <your-aws-account-id>
Using the account ID <your-aws-account-id>
The only role available to you is: amplify-policy
Using the role name "amplify-policy"
CLI default client Region [us-east-1]: <your-region>
CLI default output format [None]:
```

**Make sure to set the profile name to `default`**. Alternatively, remember the auto-generated profile name; you will need this later.

```console title="Terminal" showLineNumbers={false}
CLI profile name [amplify-policy-<your-aws-account-id>]: default
To use this profile, specify the profile name using --profile, as shown:

aws s3 ls --profile default
```

If you inspect `~/.aws/config`, you should now see the SSO profile:

```ini title="~/.aws/config"
[profile default]
sso_session = amplify-admin
sso_account_id = <your-aws-account-id>
sso_role_name = AdministratorAccess
region = <your-region>
[sso-session amplify-admin]
sso_start_url = https://xxxxxx.awsapps.com/start#
sso_region = <your-region>
sso_registration_scopes = sso:account:access
```

### 5. Bootstrap your AWS account

Now you are ready to use this AWS profile with AWS Amplify. Open your Amplify project and start the sandbox. If you have multiple local profiles or named your profile something other than `default`, you can specify a profile with `--profile`.

```bash title="Terminal" showLineNumbers={false}
// highlight-next-line
npx ampx sandbox

# OR

// highlight-next-line
npx ampx sandbox --profile <profile-name>

```

Before you can start deploying resources in the cloud sandbox environment, Amplify will need to complete a one-time bootstrap setup for the account and AWS Region before it can start deploying resources.

<Accordion title="What is bootstrapping?" eyebrow="Learn more">

Bootstrapping is the process of provisioning resources for the AWS CDK before you can deploy AWS CDK apps into an AWS environment. These resources include an Amazon S3 bucket for storing files and IAM roles that grant permissions needed to perform deployments. The required resources are defined in an AWS CloudFormation stack, called the bootstrap stack, which is usually named `CDKToolkit`. Like any AWS CloudFormation stack, it appears in the AWS CloudFormation console once it is deployed. You can learn more about this process in the [CDK documentation](https://docs.aws.amazon.com/cdk/v2/guide/bootstrapping.html).

</Accordion>

```bash title="Terminal" showLineNumbers={false}
npx ampx sandbox --profile amplify-admin
The region us-east-1 has not been bootstrapped. Sign in to the AWS console as a Root user or Admin to complete the bootstrap process, then restart the sandbox.
If this is not the region you are expecting to bootstrap, check for any AWS environment variables that may be set in your shell or use --profile <profile-name> to specify a profile with the correct region.
```

During the first-time setup, `npx ampx sandbox` will ask you to sign in to the AWS Management Console. You must sign in as the account **root user** or as a user that has **AdministratorAccess** permissions. Once signed in, you will be redirected to the Amplify console. On the **Create new app** page, choose **Initialize setup now**. It may take a few minutes for the bootstrapping process to complete.

![](/images/gen2/account-setup/profile5.png)

## Success

You have successfully completed the bootstrapping process and you can now return to the terminal to create a new Amplify sandbox environment:

```bash showLineNumbers={false}
npx ampx sandbox --profile <value>
```


Contents of start_connect-to-aws-resources_index.txt:
import { getCustomStaticPath } from '@/utils/getCustomStaticPath';
import { Card } from '@aws-amplify/ui-react';

export const meta = {
  title: 'Connect to AWS resources',
  description: 'You can use Amplify client libraries to connect directly to your AWS resources',
  platforms: [
    'android',
    'angular',
    'flutter',
    'javascript',
    'nextjs',
    'react',
    'react-native',
    'swift',
    'vue'
  ]
};

export async function getStaticPaths() {
  return getCustomStaticPath(meta.platforms);
}

export function getStaticProps(context) {
  return {
    props: {
      platform: context.params.platform,
      meta
    }
  };
}

Amplify client libraries provide you with the flexibility to directly connect your application to AWS resources such as AWS AppSync, Amazon Cognito, Amazon S3, and more.

To get started, client libraries must be _configured_. This is typically done by using the [`amplify_outputs.json` file](/[platform]/reference/amplify_outputs) generated by the Amplify backend tooling, however using the client libraries does not require backend resources to be created by Amplify.

<InlineFilter filters={["angular", "javascript", "nextjs", "react", "react-native", "vue"]}>

For JavaScript-based applications, the client library can be configured by using the generated outputs file:

```ts title="src/main.ts"
import { Amplify } from "aws-amplify"
import outputs from "../amplify_outputs.json"

Amplify.configure(outputs)
```

Or by configuring the library directly by passing a [`ResourcesConfig`](https://aws-amplify.github.io/amplify-js/api/interfaces/aws_amplify.index.ResourcesConfig.html) object. For example, to configure the client library for use with Amazon Cognito, specify the `Auth` configuration:

```ts title="src/main.ts"
import { Amplify } from "aws-amplify"

Amplify.configure({
  Auth: {
    Cognito: {
      userPoolId: "<your-cognito-user-pool-id>",
      userPoolClientId: "<your-cognito-user-pool-client-id>",
      identityPoolId: "<your-cognito-identity-pool-id>",
      loginWith: {
        email: true,
      },
      signUpVerificationMethod: "code",
      userAttributes: {
        email: {
          required: true,
        },
      },
      allowGuestAccess: true,
      passwordFormat: {
        minLength: 8,
        requireLowercase: true,
        requireUppercase: true,
        requireNumbers: true,
        requireSpecialCharacters: true,
      },
    },
  },
})
```

By configuring the client library, Amplify automates the communication with the underlying AWS resources, and provides a friendly API to author your business logic. In the snippet below, the `signIn` function does not require passing information from your Cognito resource to initiate the sign-in flow.

```ts title="src/main.ts"
import { signIn } from "aws-amplify/auth"

await signIn({
  username: "john.doe@example.com",
  password: "hunter2",
})
```

</InlineFilter>
<InlineFilter filters={["android", "flutter", "swift"]}>

For mobile platforms, the client library can be configured by creating an `amplify_outputs.json` file in your project's directory. To get started, create the file and specify your resource configuration:

```json title="amplify_outputs.json"
{
  "$schema": "https://raw.githubusercontent.com/aws-amplify/amplify-backend/main/packages/client-config/src/client-config-schema/schema_v1.json",
  "version": "1",
  "auth": {
    "user_pool_id": "<your-cognito-user-pool-id>",
    "aws_region": "<your-aws-region>",
    "user_pool_client_id": "<your-cognito-user-pool-client-id>",
    "identity_pool_id": "<your-cognito-identity-pool-id>",
    "mfa_methods": [],
    "standard_required_attributes": [
      "email"
    ],
    "username_attributes": [
      "email"
    ],
    "user_verification_types": [
      "email"
    ],
    "mfa_configuration": "NONE",
    "password_policy": {
      "min_length": 8,
      "require_lowercase": true,
      "require_numbers": true,
      "require_symbols": true,
      "require_uppercase": true
    },
    "unauthenticated_identities_enabled": true
  }
}
```

</InlineFilter>

For more information about how to use the Amplify client libraries with existing AWS resources, visit the guides:

<Columns columns={2}>
<Card variation="outlined">
[Connect to Cognito](/[platform]/build-a-backend/auth/use-existing-cognito-resources/)

Connect to Cognito resources using Amplify Auth's client library
</Card>
</Columns>


Contents of start_index.txt:
import { getChildPageNodes } from '@/utils/getChildPageNodes';
import { getCustomStaticPath } from '@/utils/getCustomStaticPath';

export const meta = {
  title: 'Get started',
  description: 'Learn how to get started with AWS Amplify Gen 2.',
  route: '/[platform]/start',
  platforms: [
    'android',
    'angular',
    'flutter',
    'javascript',
    'nextjs',
    'react',
    'react-native',
    'swift',
    'vue'
  ]
};

export const getStaticPaths = async () => {
  return getCustomStaticPath(meta.platforms);
};

export function getStaticProps(context) {
  const childPageNodes = getChildPageNodes(meta.route);
  return {
    props: {
      meta,
      childPageNodes
    }
  };
}

AWS Amplify is a collection of cloud services and libraries for fullstack application development. Amplify provides frontend libraries, UI components, backend building, and frontend hosting for building fullstack cloud apps. This tutorial will teach you how to use Amplify's new code-first developer experience to build a fullstack application with data, authentication, and frontend hosting which are all deployed to AWS. If you're completely new to AWS Amplify, you may want to read more about [how it works and the concepts behind the second generation of AWS Amplify](/[platform]/how-amplify-works/concepts/), which this tutorial will use.

<Overview childPageNodes={props.childPageNodes} />


Contents of start_kotlin-coroutines_index.txt:
import { getCustomStaticPath } from '@/utils/getCustomStaticPath';
                  
export const meta = {
  title: 'Kotlin Coroutines support',
  description: 'Amplify Android includes first-class support for Kotlin Coroutines and Flows.',
  platforms: ['android']
};

export const getStaticPaths = async () => {
  return getCustomStaticPath(meta.platforms);
};

export function getStaticProps(context) {
  return {
    props: {
      platform: context.params.platform,
      meta
    }
  };
}
          


import android0 from '/src/fragments/lib/project-setup/android/coroutines/coroutines.mdx';

Amplify provides an optional and separate API surface which is entirely focused on using Kotlin's [coroutines](https://developer.android.com/kotlin/coroutines) and [flows](https://developer.android.com/kotlin/flow).

To use it, import **`Amplify`** facade from `core-kotlin` instead of from `core`. See the Installation notes below for more details.

With the Coroutines APIs, most Amplify functions are expressed as `suspend` functions. Suspending functions can be launched using one of the [lifecycle-aware coroutine scopes](https://developer.android.com/topic/libraries/architecture/coroutines#lifecyclescope) in the Android Architecture components:

```kotlin
import com.amplifyframework.kotlin.core.Amplify
// ...

val post = Post.builder()
    .title("My First Post")
    .build()

lifecycleScope.launch {
    try {
        Amplify.DataStore.save(post) // This is suspending function!
        Log.i("AmplifyKotlinDemo", "Saved a post")
    } catch (failure: DataStoreException) {
        Log.e("AmplifyKotlinDemo", "Save failed", failure)
    }
}
```

Coroutines can greatly improve the readability of dependent, asynchronous calls. Moreover, you can use scopes, dispatchers, and other Kotlin coroutine primitives to get more control over your execution context.

Let's consider what happens when you have three dependent operations. You want to save a `Post`, then an `Editor`, and finally a `PostEditor`. With Amplify's coroutines interface, you can write these operations sequentially:

```kotlin
lifecycleScope.launch {
    try {
        listOf(post, editor, postEditor)
            .forEach { Amplify.DataStore.save(it) }
        Log.i("AmplifyKotlinDemo", "Post, Editor, and PostEditor saved")
    } catch (failure: DataStoreException) {
        Log.e("AmplifyKotlinDemo", "An item failed to save", failure)
    }
}
```

In Amplify's vanilla APIs, this would have created a large block of code with three nested callbacks.

## Installation

Amplify's coroutine support is included in an optional module, `core-kotlin`.

1.  Under **Gradle Scripts**, open **build.gradle.kts (Module :app)**, and add the following line in `dependencies`:

    ```kotlin title="app/build.gradle.kts"
    dependencies {
        // Add the below line in `dependencies`
        implementation("com.amplifyframework:core-kotlin:ANDROID_VERSION")
    }
    ```

2. Wherever you use the **`Amplify`** facade, import `com.amplifyframework.kotlin.core.Amplify` instead of `com.amplifyframework.core.Amplify`:

    ```kotlin
    import com.amplifyframework.kotlin.core.Amplify
    ```

## Usage

Amplify tries to map the behavior of your callback-based APIs to Kotlin primitives in an intuitive way. Functions whose callbacks emit a single value (or error) are now expressed as suspending functions, returning the value instead. Functions whose callbacks emit a stream of values will now return Kotlin `Flow`s, instead.

## Special cases

Some APIs return an operation which can be cancelled. Examples include realtime subscriptions to an API, and uploading/downloading objects from Storage.

### API subscriptions

The API category's `subscribe()` function uses both a suspend function _and_ a Flow. The function suspends until the API subscription is established. Then, it starts emitting values over the Flow.

```kotlin
lifecycleScope.async {
    try {
        Amplify.API.subscribe(request) // Suspends until subscription established
            .catch { Log.e("AmplifyKotlinDemo", "Error on subscription", it) }
            .collect { Log.i("AmplifyKotlinDemo", "Data on subscription = $it") }
    } catch (error: ApiException) {
        Log.e("AmplifyKotlinDemo", "Failed to establish subscription", error)
    }
}
```

### Storage upload & download operations

The Storage category's `downloadFile()` and `uploadFile()` functions are bit more complex. These APIs allow you to observe transfer progress, and also to obtain a result. Progress results are delivered over a Flow, returned from the `progress()` function. Completion events are delivered by a suspending `result()` function.

```kotlin
// Download
val download = Amplify.Storage.downloadFile(StoragePath.fromString("public/example.txt"), localFile)

lifecycleScope.async {
    download
        .progress()
        .collect { Log.i("AmplifyKotlinDemo", "Download progress = $it") }
}

lifecycleScope.async {
    try {
        val result = download.result()
        Log.i("AmplifyKotlinDemo", "Download finished! ${result.file.path}")
    } catch (failure: StorageException) {
        Log.e("AmplifyKotlinDemo", "Download failed", failure)
    }
}

// Upload
val upload = Amplify.Storage.uploadFile(StoragePath.fromString("public/example.txt"), localFile)

lifecycleScope.async {
    upload
        .progress()
        .collect { Log.i("AmplifyKotlinDemo", "Upload progress = $it") }
}
lifecycleScope.async {
    try {
        val result = upload.result()
        Log.i("AmplifyKotlinDemo", "Upload finished! ${result.path}")
    } catch (failure: StorageException) {
        Log.e("AmplifyKotlinDemo", "Upload failed", failure)
    }
}
```



Contents of start_manual-installation_index.txt:
import { getCustomStaticPath } from '@/utils/getCustomStaticPath';

export const meta = {
  title: 'Manual installation',
  description: 'Learn how to get started with AWS Amplify Gen 2 by manually installing.',
  platforms: [
    'android',
    'angular',
    'flutter',
    'javascript',
    'nextjs',
    'react',
    'react-native',
    'swift',
    'vue'
  ]
};

export const getStaticPaths = async () => {
  return getCustomStaticPath(meta.platforms);
};

export function getStaticProps(context) {
  return {
    props: {
      platform: context.params.platform,
      meta
    }
  };
}

To get started with AWS Amplify we recommend that you use our [quickstart](/[platform]/start/quickstart) starter template. However, for some use cases, it may be preferable to start from scratch, either with a brand new directory or an existing frontend app. In that case we recommend to use [npm](https://npmjs.com) with [`create-amplify`](https://www.npmjs.com/package/create-amplify). 

```bash title="Terminal" showLineNumbers={false}
npm create amplify@latest
```

```console title="Terminal" showLineNumbers={false}
? Where should we create your project? (.) # press enter
```

Running this command will scaffold a lightweight Amplify project in your current project with the following files:

```text
├── amplify/
│   ├── auth/
│   │   └── resource.ts
│   ├── data/
│   │   └── resource.ts
│   ├── backend.ts
│   ├── tsconfig.json
│   └── package.json
├── node_modules/
├── .gitignore
├── package-lock.json
├── package.json
└── tsconfig.json
``` 

 If needed, you can manually install AWS Amplify without using `create-amplify` or the starter template. This guide will walk you through how to initialize your project, install dependencies, and author your first backend.

## Manual setup

First, if your frontend framework of choice doesn't have it already, create your project's `package.json` with `npm init -y`. Then, install the Amplify dependencies for building a backend:

```bash title="Terminal" showLineNumbers={false}
npm add --save-dev @aws-amplify/backend@latest @aws-amplify/backend-cli@latest typescript
```

<Callout info>

**Note**: TypeScript is not a requirement but is recommended for an optimal experience.

</Callout>

Next, create the entry point for your backend, `amplify/backend.ts`, with the following code:

```ts
import { defineBackend } from '@aws-amplify/backend';

defineBackend({});
```

Now you can run `npx ampx sandbox` to create your first backend!

<Callout warning>

Amplify Gen 2 requires your backend to be configured for use with [ECMAScript modules (ESM)](https://nodejs.org/api/esm.html). If you encounter the following error during `ampx sandbox`, consider modifying your `package.json` with `"type": "module"`:

```text
The current file is a CommonJS module whose imports will produce 'require' calls; however, the referenced file is an ECMAScript module and cannot be imported with 'require'. Consider writing a dynamic 'import("@aws-amplify/backend")' call instead.
```

Or, you can create a local file in the Amplify backend directory, `amplify/package.json`:

```json
{
  "type": "module"
}
```

</Callout>

You can use `define*` functions to _define_ your resources. For example, you can define authentication:

```ts title="amplify/auth/resource.ts"
import { defineAuth } from '@aws-amplify/backend';

export const auth = defineAuth({
  loginWith: {
    email: true
  }
});
```

Or define your data resource:

```ts title="amplify/data/resource.ts"
import { a, defineData, type ClientSchema } from '@aws-amplify/backend';

const schema = a.schema({
  Todo: a.model({
      content: a.string(),
      isDone: a.boolean()
    })
    .authorization(allow => [allow.publicApiKey()])
});

export type Schema = ClientSchema<typeof schema>;
export const data = defineData({
  schema
});
```

Each of these newly defined resources are then imported and set in the backend definition:

```ts title="amplify/backend.ts"
import { defineBackend } from '@aws-amplify/backend';
import { auth } from './auth/resource';
import { data } from './data/resource';

defineBackend({
  auth,
  data
});
```

## Upgrade existing projects

You can also update an existing frontend app. To upgrade existing Amplify code-first DX (Gen 2) apps, use your Node.js package manager (for example, `npm`) to update relevant backend packages:

```bash title="Terminal" showLineNumbers={false}
npm update @aws-amplify/backend @aws-amplify/backend-cli
```

## Next steps

We recommend the following next steps:

- [Learn more about defining authentication](/[platform]/build-a-backend/auth)
- [Learn more about defining data](/[platform]/build-a-backend/data)
- [Get started with cloud sandbox](/[platform]/deploy-and-host/sandbox-environments)
- [Deploy and host your first app](/[platform]/deploy-and-host/fullstack-branching)


Contents of start_migrate-to-gen2_index.txt:
import { getCustomStaticPath } from '@/utils/getCustomStaticPath';

export const meta = {
  title: 'Gen 2 for Gen 1 customers',
  description: 'Learn how to set up your AWS account and configure it locally for use with Amplify.',
  platforms: [
    'android',
    'angular',
    'flutter',
    'javascript',
    'nextjs',
    'react',
    'react-native',
    'swift',
    'vue'
  ]
};

export const getStaticPaths = async () => {
  return getCustomStaticPath(meta.platforms);
};

export function getStaticProps(context) {
  return {
    props: {
      platform: context.params.platform,
      meta
    }
  };
}

## Migrating from Gen 1 to Gen 2

We are actively developing migration tooling to aid in transitioning your project from Gen 1 to Gen 2. Until then, we recommend you continue working with your Gen 1 Amplify project.  We remain committed to supporting both Gen 1 and Gen 2 for the foreseeable future. For new projects, we recommend adopting Gen 2 to take advantage of its [enhanced capabilities](/[platform]/how-amplify-works/concepts/). Meanwhile, customers on Gen 1 will continue to receive support for high-priority bugs and essential security updates.


## Gen 1 vs. Gen 2 feature matrix

The tables below present a feature matrix for Gen 1 customers who are considering Gen 2 for their apps. This will help determine the support availability for various features.

### Auth

| Feature | Gen 1 | Gen 2 |
|---|---|---|
| Configure username | Yes | Yes with CDK |
| Configure email | Yes | Yes |
| Configure phone number | Yes | Yes |
| Facebook | Yes | Yes |
| Google | Yes | Yes |
| Amazon | Yes | Yes |
| Sign-in with Apple | Yes | Yes |
| Add user pool groups | Yes | Yes |
| User pool group preference | Yes | Yes |
| Email verification link redirect | Yes | Yes |
| Sign-up attributes | Yes | Yes |
| Auth trigger support | Yes | Yes |
| Auth trigger templates: Add Google reCaptcha Challenge | Yes | Yes |
| Auth trigger templates: Add user to Group | Yes | Yes |
| Auth trigger templates: Email Domain Filtering (denylist) | Yes | Yes |
| Auth trigger templates: Email Domain Filtering (allowlist) | Yes | Yes |
| Auth trigger templates: Override ID Token Claims | Yes | Yes |
| Auth trigger templates: Custom Auth Challenge Flow| Yes | No |
| Configure default password policy | Yes | Yes with CDK |
| Configure read/write capabilities for attributes | Yes | Yes with CDK |
| Oauth flow: Configure authorization v implicit grant | Yes | Yes with CDK |
| Admin queries | Yes | Yes with CDK |
| MFA login (on/off/optional) | Yes | Yes |
| MFA: SMS | Yes | Yes |
| MFA: TOTP | Yes | Yes |
| Zero-config Authenticator support | Yes | Yes |
| User management in console | Yes | Yes |
| Configure Oauth scopes | Yes | Yes |
| Email verification - code | Yes | Yes |
| Email Verification - Link | Yes | Yes |
| Oauth flow: Configure redirect URIs | Yes | Yes |
| Ability to set a friendly name for User Pool | Yes | Yes |
| Unauthenticated logins | Yes | Yes |
| Custom attributes | Yes | Yes with CDK |
| Oauth flow: Configure domain name prefix | Yes | Yes with CDK |
| Auth configuration in console | Yes | No |
| First class OIDC support | No | Yes |
| First class SAML support | No | Yes |
| Import auth | Yes | No |

### Data

| Feature | Gen 1 | Gen2 |
|---|---|---|
| model | Yes | Yes |
| primaryKey | Yes | Yes |
| secondaryKey (name, sortKeyFields, query) | Yes | Yes |
| hasOne | Yes | Yes |
| hasMany | Yes | Yes |
| belongsTo | Yes | Yes |
| manyToMany | Yes | No |
| default | Yes | Yes |
| **auth - model level** |   |   |
| auth - public - apiKey | Yes | Yes |
| auth - public - iam | Yes | Yes |
| auth - owner - userPools | Yes | Yes |
| auth - owner - ownerField - userPools | Yes | Yes |
| auth - owner - ownerField as array - userPools | Yes | Yes |
| auth - owner - oidc | Yes | Yes |
| auth - owner - ownerField - oidc | Yes | Yes |
| auth - owner - ownerField as array - oidc | Yes | Yes |
| auth - private - userPools | Yes | Yes |
| auth - private - oidc | Yes | Yes |
| auth - private - iam | Yes | Yes |
| auth - group - userPools | Yes | Yes |
| auth - group - dynamic - userPools | Yes | Yes |
| auth - group - oidc | Yes | Yes |
| auth - group - dynamic - oidc | Yes | Yes |
| auth - custom - function | Yes | Yes |
| **auth - field level** |   |   |
| auth - public - apiKey | Yes | Yes |
| auth - public - iam | Yes | Yes |
| auth - owner - userPools | Yes | Yes |
| auth - owner - ownerField - userPools | Yes | Yes |
| auth - owner - ownerField as array - userPools | Yes | Yes |
| auth - owner - oidc | Yes | Yes |
| auth - owner - ownerField - oidc | Yes | Yes |
| auth - owner - ownerField as array - oidc | Yes | Yes |
| auth - private - userPools | Yes | Yes |
| auth - private - oidc | Yes | Yes |
| auth - private - iam | Yes | Yes |
| auth - group - userPools | Yes | Yes |
| auth - group - dynamic - userPools | Yes | Yes |
| auth - group - oidc | Yes | Yes |
| auth - group - dynamic - oidc | Yes | Yes |
| auth - custom - function | Yes | Yes |
| **other directives** |   |   |
| searchable | Yes | No but we offer a guide using Zero-ETL DynamoDB-to-OpenSearch |
| predictions | Yes | No but we offer a guide with AI service integrations |
| **Custom Mutations, Queries, Subscriptions** | Yes | Yes |
| VTL handler | Yes | Yes with CDK |
| JavaScript resolver handler | No | Yes |
| function handler | Yes | Yes |
| http handler | Yes | Yes - we support custom data sources including `http` |
| **Other configurations** |  |  |
| DataStore support | Yes | No but we'll offer a migration guide soon |
| Visual configuration | Yes | No - Gen 2 is code-first by design |
| @model queries, mutations, subscriptions, and timestamps modifiers | Yes | No |
| Custom GraphQL Transformer plugins | Yes | No |
| MySQL and PostgreSQL support | No | Yes |
| In-IDE end-to-end type safety | No | Yes |
| @hasOne, @hasMany, and @belongsTo on required fields | Yes | No |
| fields argument on @hasOne, @hasMany, and @belongsTo | Yes | No |

### Storage

| Feature | Gen 1 | Gen 2 |
|---|---|---|
| Ability to provision S3 bucket | Yes | Yes |
| Auth and Guest access | Yes | [Yes](/[platform]/build-a-backend/storage/authorization/#for-gen-1-public-protected-and-private-access-pattern) |
| Auth - Configure CRUD access | Yes | Yes |
| Configure Cognito Group CRUD access | Yes | Yes |
| Guest - Configure CRUD access | Yes | Yes |
| Lambda trigger for S3 bucket | Yes | Yes |
| Import an S3 bucket | Yes | Yes |
| File browser in console | Yes | Yes |
| Ability to override/custom | Yes | Yes |
| S3 Lambda triggers | Yes | Yes |
| Locally test  | Yes | Yes - with sandbox environments |
| Visual configuration | Yes | No - Gen 2 is code-first by design |
| File Browser in console | Yes | Yes |
| Import S3 buckets | Yes | No |


### Functions

| Feature | Gen 1 | Gen 2 |
|---|---|---|
| Function runtime: TypeScript | No | Yes |
| Function resource access permissions: auth | Yes | Yes |
| Function resource access permissions: function | Yes | Yes |
| Function resource access permissions: API | Yes | Yes |
| Function resource access permissions CRUD operations | Yes | Yes |
| Function resource access permissions: custom | No | Yes |
| Environment variables | Yes | Yes |
| Secrets | Yes | Yes |
| Cron jobs | Yes | Yes |
| Configure memory size | Yes | Yes |
| Function build options for Node.js | Yes | Yes |
| Function templates: AWS AppSync - GraphQL API request (with IAM) | Yes | Yes |
| Function templates: CRUD function for DynamoDB (Integration with API Gateway) | Yes | Yes |
| Function templates: GraphQL Lambda Authorizer | Yes | Yes |
| Function templates: Hello World | Yes | Yes |
| Function templates: Lambda trigger | Yes | Yes |
| Function logs in console | Yes | Yes |
| Function resource access permissions: geo | Yes | Yes with CDK |
| Function resource access permissions: analytics | Yes | Yes with CDK |
| Function runtime: .NET 6 | Yes | Yes with CDK |
| Function runtime: Go | Yes | Yes with CDK |
| Function runtime: Java | Yes | Yes with CDK |
| Function runtime: JavaScript | Yes | Yes with CDK |
| Function runtime: Python | Yes | Yes with CDK |
| Lambda layers | Yes | No |


### Other categories

<InlineFilter filters={['android', 'swift']}>

| Feature | Gen 1 | Gen 2 |
|---|---|---|
| REST API| Yes|	No
| Analytics| Yes|	Yes with custom CDK
| Geo| Yes|	Yes with custom CDK
| Predictions | Yes|	No
| Interactions| Yes|	No

</InlineFilter>

<InlineFilter filters={['flutter']}>

| Feature | Gen 1 | Gen 2 |
|---|---|---|
| REST API| Yes|	Yes with custom CDK
| Analytics| Yes|	Yes with custom CDK
| Geo| No|	No
| Predictions | No|	No
| Interactions| No|	No

</InlineFilter>

<InlineFilter filters={['angular','javascript','nextjs','react','react-native','vue']}>

| Feature | Gen 1 | Gen 2 |
|---|---|---|
| REST API| Yes|	Yes with custom CDK
| Analytics| Yes|	Yes with custom CDK
| Geo| Yes|	Yes with custom CDK
| Predictions | Yes|	Yes with custom CDK
| Interactions| Yes|	Yes with custom CDK

</InlineFilter>




Contents of start_platform-setup_index.txt:
import { getCustomStaticPath } from '@/utils/getCustomStaticPath';

export const meta = {
  title: 'Platform setup',
  description: 'Instructions for platform-specific configurations needed for amplify-flutter',
  platforms: [
    'flutter',
  ]
};

export const getStaticPaths = async () => {
  return getCustomStaticPath(meta.platforms);
};

export function getStaticProps(context) {
  return {
    props: {
      platform: context.params.platform,
      meta
    }
  };
}


## iOS

Amplify requires a minimum deployment target of 13.0 and Xcode 15.0 or higher when targeting iOS. Follow the steps below to update the minimum deployment target.

Open `ios/Podfile` and update the target iOS platform to 13.0 or higher.

<Callout info>
If there is no file located at `ios/Podfile`, add `amplify_flutter` to your `pubspec.yaml` and run `pub get`. This will automatically create the file.
</Callout>

```diff title="ios/Podfile"
- # Uncomment this line to define a global platform for your project
- # platform :ios, '12.0'
+ platform :ios, '13.0'
```

Open your project in Xcode and select Runner, Targets -> Runner and then the "General" tab. Under the "Minimum Deployments" section, update the iOS version to 13.0 or higher.

![Setting the iOS version to 13.0 or higher in the minimum deployments section of the Runner general window.](/images/project-setup/flutter/ios/target-min-deployment-version.png)

Select Runner, Project -> Runner and then the "Info" tab. Update "iOS Deployment Target" to 13.0 or higher.

![Setting the iOS version to 13.0 or higher in the deployment targets section of the Runner info window.](/images/project-setup/flutter/ios/project-min-deployment-version.png)

## Android

Amplify Flutter supports API level 24+ (Android 7.0+), and requires Gradle 8+, Kotlin 1.9+, and Java 17+ when targeting Android. Follow the steps below to apply these changes in your app. 

<Callout warning>
The steps below are intended for Flutter apps created with Flutter version 3.16+. If your app was created prior to version 3.16, please follow the guide [here](https://docs.flutter.dev/release/breaking-changes/flutter-gradle-plugin-apply) to migrate to Gradle's declarative plugins block before following the steps below.
</Callout>

1. Open `android/settings.gradle` and update the Android Gradle plugin and kotlin versions:

```diff title="android/settings.gradle"
plugins {
    id "dev.flutter.flutter-plugin-loader" version "1.0.0"
-   id "com.android.application" version "7.3.0" apply false
-   id "org.jetbrains.kotlin.android" version "1.7.10" apply false
+   id "com.android.application" version "8.1.0" apply false
+   id "org.jetbrains.kotlin.android" version "1.9.10" apply false
}
```

2. Open `android/gradle/wrapper/gradle-wrapper.properties` and update the Gradle `distributionUrl`.

```diff title="android/gradle/wrapper/gradle-wrapper.properties"
distributionBase=GRADLE_USER_HOME
distributionPath=wrapper/dists
zipStoreBase=GRADLE_USER_HOME
zipStorePath=wrapper/dists
-distributionUrl=https\://services.gradle.org/distributions/gradle-7.0-all.zip
+distributionUrl=https\://services.gradle.org/distributions/gradle-8.0-all.zip
```

3. Open `android/app/build.gradle` and update the Java version and minimum Android SDK version.

```diff title="android/app/build.gradle"
android {
    namespace = "com.example.myapp"
    compileSdk = flutter.compileSdkVersion
    ndkVersion = flutter.ndkVersion
    compileOptions {
-       sourceCompatibility = JavaVersion.VERSION_1_8
-       targetCompatibility = JavaVersion.VERSION_1_8
+       sourceCompatibility = JavaVersion.VERSION_17
+       targetCompatibility = JavaVersion.VERSION_17
    }

    defaultConfig {
        // TODO: Specify your own unique Application ID (https://developer.android.com/studio/build/application-id.html).
        applicationId = "com.example.myapp"
        // You can update the following values to match your application needs.
        // For more information, see: https://docs.flutter.dev/deployment/android#reviewing-the-gradle-build-configuration.
-       minSdk = flutter.minSdkVersion
+       minSdk = 24
        targetSdk = flutter.targetSdkVersion
        versionCode = flutterVersionCode.toInteger()
        versionName = flutterVersionName
    }
    
    buildTypes {
        release {
            // TODO: Add your own signing config for the release build.
            // Signing with the debug keys for now, so `flutter run --release` works.
            signingConfig = signingConfigs.debug
        }
    }
}
```

<Callout info>
If you would like to use a higher version of Gradle or Android Gradle plugin see the compatibility matrix [here](https://developer.android.com/build/releases/gradle-plugin#updating-gradle).
</Callout>

### Network Permissions for Release Builds

Flutter apps have access to make network requests by default in debug mode. This permission needs to be added when building in release mode. To do this, open `android/app/src/main/AndroidManifest.xml` and make the following addition.

```xml title="android/app/src/main/AndroidManifest.xml"
<manifest xmlns:android="http://schemas.android.com/apk/res/android">
// highlight-start
   <uses-permission android:name="android.permission.INTERNET"/>
// highlight-end
...
</manifest>
```

## Web

There are no Amplify specific requirements or setup instructions when targeting web. You will need to use a browser supported by Flutter. See the following Flutter docs for more info:

- [Supported deployment platforms](https://docs.flutter.dev/reference/supported-platforms)
- [FAQ: Which web browsers are supported by Flutter?](https://docs.flutter.dev/development/platform-integration/web/faq#which-web-browsers-are-supported-by-flutter)

## macOS

Amplify requires a minimum deployment target of 10.15 and Xcode 15.0 or higher when targeting macOS. Additionally, you will need to enable networking, keychain entitlements, and code signing.

### Update Minimum Version

Open `macos/Podfile` and update the target macOS platform to 10.15 or higher.

<Callout info>
If there is no file located at `macos/Podfile`, add `amplify_flutter` to your `pubspec.yaml` and run `pub get`. This will automatically create the file.
</Callout>

```diff title="ios/Podfile"
- platform :osx, '10.14'
+ platform :osx, '10.15'
```

Open your project in Xcode and select Runner, Targets -> Runner and then the "General" tab. Under the "Minimum Deployments" section, update the macOS version to 10.15 or higher.

![Setting the macOS version to 10.15 or higher in the Minimum Deployments tab of the Runner general section.](/images/project-setup/flutter/mac/target-min-deployment-version.png)

Select Runner, Project -> Runner and then the "Info" tab. Update "macOS Deployment Target" to 10.15 or higher.

![Setting the macOS version to 10.15 or higher in the macOS Deployment Target tab of the Runner info section.](/images/project-setup/flutter/mac/project-min-deployment-version.png)

### Enable Network Calls

Open your project in Xcode and select Runner, Targets -> Runner and then the "Signing and Capabilities" tab. Under "App Sandbox" select "Outgoing Connections (Client)".

![Selecting outgoing connections in the app sandbox section of the runner signing and capabilities tab.](/images/project-setup/flutter/mac/xcode-entitlements.png)

For more info on the Networking entitlement, see Apple's documentation on [com.apple.security.network.client](https://developer.apple.com/documentation/bundleresources/entitlements/com_apple_security_network_client).

### Enable Keychain Sharing

<Callout info>

This capability is required because Amplify uses the Data Protection Keychain on macOS as a platform best practice. 
See [TN3137: macOS keychain APIs and implementations](https://developer.apple.com/documentation/technotes/tn3137-on-mac-keychains)
for more information on how Keychain works on macOS and the Keychain Sharing entitlement.

</Callout>

Open your project in Xcode and select Runner, Targets -> Runner and then the "Signing and Capabilities" tab.

1. Click the "+ icon".

![Plus icon circled in the signing and capabilities section of the runner tab.](/images/project-setup/flutter/mac/enable-keychain-access.png)

2. Search for "Keychain Sharing" in the subsequent modal, and add it.

![Keychain Sharing search result after searching keychain.](/images/project-setup/flutter/mac/search-keychain-sharing.png)

3. Scroll down to "Keychain Sharing" in the "Signing and Capabilities" and click the "+" icon. By default, your bundle ID will be used.

![Plus icon highlighted in the keychain sharing section of the signing and capabilities section of runner.](/images/project-setup/flutter/mac/adding-keychain-access-group.png)

4. Finally, add a development team and enable signing.

![Team selector and Enable Development Signing button highlighted in the signing and capabilities section of the runner tab.](/images/project-setup/flutter/mac/enable-signing.png)


## Windows

There are no Amplify specific requirements or setup instructions when targeting Windows. You will need to use a Windows version supported by Flutter. See the following Flutter docs for more info:

- [Supported deployment platforms](https://docs.flutter.dev/reference/supported-platforms)

## Linux

Amplify Flutter depends on the [libsecret](https://wiki.gnome.org/Projects/Libsecret) library when targeting Linux.

### Local Development

To run and debug an app that depends on Amplify Flutter, you must install `libsecret-1-dev`. Run the following commands to install `libsecret-1-dev`. this will also install dependencies of `libsecret-1-dev`, such as `libglib2.0-dev`.

<Callout info>
  The command below is intended for Ubuntu. The command may vary on other Linux distributions.
</Callout>

{/* cSpell:disable */}

```terminal
sudo apt-get update
sudo apt-get install -y libsecret-1-dev
```

{/* cSpell:enable */}

### Packaging Your App

To include the required dependencies when packaging your app with Snapcraft, include them in your `snapcraft.yaml` file. For more info, see [Flutter's documentation on releasing to the Snap Store](https://docs.flutter.dev/deployment/linux).

```yaml
parts:
  my-app:
    plugin: flutter
    source: .
    flutter-target: lib/main.dart
    build-packages:
      - libsecret-1-dev
    stage-packages:
      - libsecret-1-0
```



Contents of start_quickstart_index.txt:
import { getChildPageNodes } from '@/utils/getChildPageNodes';
import { getCustomStaticPath } from '@/utils/getCustomStaticPath';
import { IconGithub } from '@/components/Icons/IconGithub'
import { IconAmplify } from '@/components/Icons/IconAmplify'

export const meta = {
  title: 'Quickstart',
  description: 'Get started with AWS Amplify Gen 2 and React, Next.js, Angular, Vue, Flutter, React Native, Swift, Android, and JavaScript.',
  route: '/[platform]/start/quickstart',
  platforms: [
    'android',
    'angular',
    'flutter',
    'javascript',
    'nextjs',
    'react',
    'react-native',
    'swift',
    'vue'
  ]
};


export const getStaticPaths = async () => {
  return getCustomStaticPath(meta.platforms);
};

export function getStaticProps(context) {
  const childPageNodes = getChildPageNodes(meta.route);
  return {
    props: {
      meta,
      childPageNodes
    }
  };
}

<InlineFilter filters={["javascript"]}>

👋 Welcome to AWS Amplify! In this quickstart guide, you will:

1. Deploy a Vanilla JavaScript app with Vite
2. Build and connect to a database with real-time data updates
3. Configure authentication and authorization rules


## Create project

Create a new Vanilla JavaScript app with vite using the following commands, create the directory (`amplify-js-app`) and files for the app.

```bash
npm create vite@latest
✔ Project name: amplify-js-app
✔ Select a framework: › Vanilla
✔ Select a variant: › TypeScript
```

Initialize npm and install dependencies and dev dependencies.
```bash
cd amplify-js-app
npm install
npm run dev
```

This runs a development server and allows you to see the output generated by the build. You can see the running app by navigating to [http://localhost:5173](http://localhost:5173).

Add the following to the `index.html` file:

```html title="index.html"
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Todo App</title>
</head>
<body>
    <main>
        <h1>My todos</h1>
        <button id="addTodo">+ new</button>
        <ul id="todoList"></ul>
        <div>
            Try creating a new todo.
            <br>
            <a href="https://docs.amplify.aws/javascript/start/quickstart/">
                Review next step of this tutorial.
            </a>
        </div>
    </main>
    <script type="module" src="src/main.ts"></script>
</body>
</html>
```

Add the following to `style.css` file:

{/* cSpell:disable */}

```css title="style.css"
body {
  margin: 0;
  background: linear-gradient(180deg, rgb(117, 81, 194), rgb(255, 255, 255));
  display: flex;
  font-family: Inter, system-ui, Avenir, Helvetica, Arial, sans-serif;
  height: 100vh;
  width: 100vw;
  justify-content: center;
  align-items: center;
}

main {
  display: flex;
  flex-direction: column;
  align-items: stretch;
}

button {
  border-radius: 8px;
  border: 1px solid transparent;
  padding: 0.6em 1.2em;
  font-size: 1em;
  font-weight: 500;
  font-family: inherit;
  background-color: #1a1a1a;
  cursor: pointer;
  transition: border-color 0.25s;
  color: white;
}
button:hover {
  border-color: #646cff;
}
button:focus,
button:focus-visible {
  outline: 4px auto -webkit-focus-ring-color;
}

ul {
  padding-inline-start: 0;
  margin-block-start: 0;
  margin-block-end: 0;
  list-style-type: none;
  display: flex;
  flex-direction: column;
  margin: 8px 0;
  border: 1px solid black;
  gap: 1px;
  background-color: black;
  border-radius: 8px;
  overflow: auto;
}

li {
  background-color: white;
  padding: 8px;
}

li:hover {
  background: #dadbf9;
}

a {
  font-weight: 800;
  text-decoration: none;
}
```
{/* cSpell:enable */}

In `main.js` remove the boilerplate code and leave it empty. Then refresh the browser to see the changes.

## Create Backend

The easiest way to get started with AWS Amplify is through npm with `create-amplify` command. You can run it from your base project directory.

```bash title="Terminal" showLineNumbers={false}
npm create amplify@latest
? Where should we create your project? (.) # press enter
```

Running this command will scaffold Amplify backend files in your current project with the following files added:

```text
├── amplify/
│   ├── auth/
│   │   └── resource.ts
│   ├── data/
│   │   └── resource.ts
│   ├── backend.ts
│   └── package.json
├── node_modules/
├── index.html
├── style.css
├── .gitignore
├── package-lock.json
├── package.json
└── tsconfig.json
```

### Set up local AWS credentials

To make backend updates, we are going to require AWS credentials to deploy backend updates from our local machine.

**Skip ahead to step 8**, if you already have an AWS profile with credentials on your local machine, and your AWS profile has the `AmplifyBackendDeployFullAccess` permission policy.

Otherwise, **[set up local AWS credentials](/[platform]/start/account-setup/)** that grant Amplify permissions to deploy backend updates from your local machine.

### Deploy cloud sandbox

To deploy your backend use Amplify's per-developer cloud sandbox. This feature provides a separate backend environment for every developer on a team, ideal for local development and testing. To run your application with a sandbox environment, you can run the following command:

```bash title="Terminal" showLineNumbers={false}
npx ampx sandbox
```

Once the sandbox environment is deployed, it will create a GraphQL API, database, and auth service. All the deployed resources will be available in the `amplify_outputs.json`.

## Connect frontend to backend

The initial scaffolding already has a pre-configured data backend defined in the `amplify/data/resource.ts` file. The default example will create a Todo model with `content` field. Update your main.js file to create new to-do items.

```typescript title="src/main.ts"
import { generateClient } from "aws-amplify/data";
import type { Schema } from "../amplify/data/resource";
import './style.css';
import { Amplify } from 'aws-amplify';
import outputs from '../amplify_outputs.json';

Amplify.configure(outputs);


const client = generateClient<Schema>();

document.addEventListener("DOMContentLoaded", function () {
    const todos: Array<Schema["Todo"]["type"]> = [];
    const todoList = document.getElementById("todoList") as HTMLUListElement;
    const addTodoButton = document.getElementById("addTodo") as HTMLButtonElement;

    addTodoButton.addEventListener("click", createTodo);

    function updateUI() {
        todoList.innerHTML = '';
        todos.forEach(todo => {
            const li = document.createElement('li');
            li.textContent = todo.content ?? '';
            todoList.appendChild(li);
        });
    }

    function createTodo() {
      console.log('createTodo');
      const content = window.prompt("Todo content");
      if (content) {
          client.models.Todo.create({ content }).then(response => {
              if (response.data && !response.errors) {
                  todos.push(response.data);
                  updateUI();
              } else {
                  console.error('Error creating todo:', response.errors);
                  alert('Failed to create todo.');
              }
          }).catch(error => {
              console.error('Network or other error:', error);
              alert('Failed to create todo due to a network or other error.');
          });
      }
  }


    client.models.Todo.observeQuery().subscribe({
        next: (data) => {
            todos.splice(0, todos.length, ...data.items);
            updateUI();
        }
    });
});
```

</InlineFilter>

<InlineFilter filters={["react"]}>

👋 Welcome to AWS Amplify! In this quickstart guide, you will:

1. Deploy a React and Vite app
2. Build and connect to a database with real-time data updates
3. Configure authentication and authorization rules

## Deploy a fullstack app to AWS

We've created a starter "To-do" application to help get started faster. First, you will create a repository in your GitHub account using our starter React template.

### 1. Create the repository

Use our starter template to create a repository in your GitHub account. This template scaffolds `create-vite-app` with Amplify backend capabilities.

<ExternalLinkButton
  size="medium"
  href='https://github.com/new?template_name=amplify-vite-react-template&template_owner=aws-samples&name=amplify-vite-react-template&description=My%20Amplify%20Gen%202%20starter%20application'
>
<IconGithub />
Create repository from template
</ExternalLinkButton>

Use the form in GitHub to finalize your repo's creation.

### 2. Deploy the starter app

Now that the repository has been created, deploy it with Amplify.

<ExternalLinkButton
  size="medium"
  variation="primary"
  href='https://console.aws.amazon.com/amplify/create/repo-branch'
>
<IconAmplify />
Deploy to AWS
</ExternalLinkButton>

Select **GitHub**. After you give Amplify access to your GitHub account via the popup window, pick the repository and `main` branch to deploy. Make no other changes and click through the flow to **Save and deploy**.

<Video src="/images/gen2/getting-started/react/deploy.mp4" description="Video - Deploy the starter app" />

### 3. View deployed app

<Accordion title='Learn about the project structure' headingLevel='4' eyebrow='While you are waiting for your app to deploy (~5 mins)'>

Let's take a tour of the project structure in this starter repository by opening it on GitHub. The starter application has pre-written code for a to-do list app. It gives you a real-time database with a feed of all to-do list items and the ability to add new items.

```text
├── amplify/ # Folder containing your Amplify backend configuration
│   ├── auth/ # Definition for your auth backend
│   │   └── resource.tsx
│   ├── data/ # Definition for your data backend
│   │   └── resource.ts
|   ├── backend.ts
│   └── tsconfig.json
├── src/ # React UI code
│   ├── App.tsx # UI code to sync todos in real-time
│   ├── index.css # Styling for your app
│   └── main.tsx # Entrypoint of the Amplify client library
├── package.json
└── tsconfig.json
```
</Accordion>

 When the build completes, visit the newly deployed branch by selecting "Visit deployed URL". Since the build deployed an API, database, and authentication backend, you will be able to create new to-do items.

<Video src="/images/gen2/getting-started/react/hosted-app.mp4" description="Video - Visit Deployed URL" />

In the Amplify console, click into the deployment branch (in this case **main**) > select **Data** in the left-hand menu > **Data manager** to see the data entered in your database.

<Video src="/images/gen2/getting-started/amplify-console-data-manager.mp4" description="Video - Data Manager" />

## Make frontend updates

Let's learn how to enhance the app functionality by creating a delete flow for to-do list items.

### 4. Set up local environment

Now let's set up our local development environment to add features to the frontend. Click on your deployed branch and you will land on the **Deployments** page which shows you your build history and a list of deployed backend resources.

<Video src="/images/gen2/getting-started/react/branch-details.mp4" description="Video - Deployments" />

At the bottom of the page you will see a tab for **Deployed backend resources**. Click on the tab and then click the **Download amplify_outputs.json file** button.

![](/images/gen2/getting-started/react/amplify-outputs-download.png)

Clone the repository locally.

```bash title="Terminal" showLineNumbers={false}
git clone https://github.com/<github-user>/amplify-vite-react-template.git
cd amplify-vite-react-template && npm install
```

Now move the `amplify_outputs.json` file you downloaded above to the root of your project.

```text
├── amplify
├── src
├── amplify_outputs.json <== backend outputs file
├── package.json
└── tsconfig.json
```

<Accordion title='amplify_outputs.json' headingLevel='4' eyebrow='Learn more'>
The **amplify_outputs.json** file contains backend endpoint information, publicly-viewable API keys, authentication flow information, and more. The Amplify client library uses this outputs file to connect to your Amplify Backend.  You can review how the outputs file is imported within the `main.tsx` file and then passed into the `Amplify.configure(...)` function of the Amplify client library.
</Accordion>



### 5. Implement delete functionality

Go to the **src/App.tsx** file and add in a new `deleteTodo` functionality and pass function into the `<li>` element's `onClick` handler.

```tsx title="src/App.tsx"
function App() {
  // ...
  // highlight-start
  function deleteTodo(id: string) {
    client.models.Todo.delete({ id })
  }
  // highlight-end

  return (
    <main>
      <h1>My todos</h1>
      <button onClick={createTodo}>+ new</button>
      <ul>
        {todos.map(todo => <li
          // highlight-next-line
          onClick={() => deleteTodo(todo.id)}
          key={todo.id}>
          {todo.content}
        </li>)}
      </ul>
      <div>
        🥳 App successfully hosted. Try creating a new todo.
        <br />
        <a href="https://docs.amplify.aws/react/start/quickstart/">Review next step of this tutorial.</a>
      </div>
    </main>
  )
}
```

Try out the deletion functionality now by starting the local dev server:

```bash title="Terminal" showLineNumbers={false}
npm run dev
```

This should start a local dev server at http://localhost:5173.

<Video src="/images/gen2/getting-started/react/demo-delete.mp4" description="Video - Demo" />

### 6. Implement login UI

The starter application already has a pre-configured auth backend defined in the **amplify/auth/resource.ts** file. We've configured it to support email and password login but you can extend it to support a variety of login mechanisms, including Google, Amazon, Sign In With Apple, and Facebook.

The fastest way to get your login experience up and running is to use our Authenticator UI component. In your **src/main.tsx** file, import the Authenticator UI component and wrap your `<App>` component.

```tsx title="src/main.tsx"
import React from 'react';
import ReactDOM from 'react-dom/client';
// highlight-next-line
import { Authenticator } from '@aws-amplify/ui-react';
import { Amplify } from 'aws-amplify';
import App from './App.tsx';
import outputs from '../amplify_outputs.json';
import './index.css';
// highlight-next-line
import '@aws-amplify/ui-react/styles.css';

Amplify.configure(outputs);

ReactDOM.createRoot(document.getElementById('root')!).render(
  // highlight-start
  <React.StrictMode>
    <Authenticator>
      <App />
    </Authenticator>
  </React.StrictMode>
  // highlight-end
);
```

The Authenticator component auto-detects your auth backend settings and renders the correct UI state based on the auth backend's authentication flow.

In your `src/App.tsx` file, add a button to enable users to sign out of the application. Import the [`useAuthenticator`](https://ui.docs.amplify.aws/react/connected-components/authenticator/advanced#access-auth-state) hook from the Amplify UI library to hook into the state of the Authenticator.

```tsx title="src/App.tsx"
import type { Schema } from '../amplify/data/resource';
// highlight-next-line
import { useAuthenticator } from '@aws-amplify/ui-react';
import { useEffect, useState } from 'react';
import { generateClient } from 'aws-amplify/data';

const client = generateClient<Schema>();

function App() {
  // highlight-next-line
  const { signOut } = useAuthenticator();

  // ...

  return (
    <main>
      {/* ... */}
      // highlight-next-line
      <button onClick={signOut}>Sign out</button>
    </main>
  );
}

export default App;
```

Try out your application in your localhost environment again. You should be presented with a login experience now.

<Video src="/images/gen2/getting-started/react/demo-auth.mp4" description="Video - Authentication Demo" />

To get these changes to the cloud, commit them to git and push the changes upstream.

```bash title="Terminal" showLineNumbers={false}
git commit -am "added authenticator"
git push
```

Amplify automatically deploys the latest version of your app based on your git commits. In just a few minutes, when the application rebuilds, the hosted app will be updated to support the deletion functionality.

## Make backend updates

Let's update our backend to implement per-user authorization rules, allowing each user to only access their own to-dos.

### 7. Set up local AWS credentials

To make backend updates, we are going to require AWS credentials to deploy backend updates from our local machine.

**Skip ahead to step 8**, if you already have an AWS profile with credentials on your local machine, and your AWS profile has the `AmplifyBackendDeployFullAccess` permission policy.

Otherwise, **[set up local AWS credentials](/[platform]/start/account-setup/)** that grant Amplify permissions to deploy backend updates from your local machine.


### 8. Deploy cloud sandbox

To update your backend without affecting the production branch, use Amplify's cloud sandbox. This feature provides a separate backend environment for each developer on a team, ideal for local development and testing.

To start your cloud sandbox, run the following command in a **new Terminal window**:

```bash title="Terminal" showLineNumbers={false}
npx ampx sandbox
```

Once the cloud sandbox has been fully deployed (~5 min), you'll see the `amplify_outputs.json` file updated with connection information to a new isolated authentication and data backend.

<Callout info>

The `npx ampx sandbox` command should run concurrently to your `npm run dev`. You can think of the cloud sandbox as the "localhost-equivalent for your app backend".

</Callout>

### 9. Implement per-user authorization

The to-do items in the starter are currently shared across all users, but, in most cases, you want data to be isolated on a per-user basis.

To isolate the data on a per-user basis, you can use an "owner-based authorization rule". Let's apply the owner-based authorization rule to your to-do items:

```ts title="amplify/data/resource.ts"
import { type ClientSchema, a, defineData } from '@aws-amplify/backend';

const schema = a.schema({
  Todo: a.model({
    content: a.string(),
    // highlight-next-line
  }).authorization(allow => [allow.owner()]),
});

export type Schema = ClientSchema<typeof schema>;

export const data = defineData({
  schema,
  authorizationModes: {
    // This tells the data client in your app (generateClient())
    // to sign API requests with the user authentication token.
    // highlight-next-line
    defaultAuthorizationMode: 'userPool',
  },
});
```

In the application client code, let's also render the username to distinguish different users once they're logged in. Go to your **src/App.tsx** file and render the `user` property from the `useAuthenticator` hook.

```tsx title="src/App.tsx"
// ... imports

function App() {
  // highlight-next-line
  const { user, signOut } = useAuthenticator();

  // ...

  return (
    <main>
      // highlight-next-line
      <h1>{user?.signInDetails?.loginId}'s todos</h1>
      {/* ... */}
    </main>
  )
}
```

Now, let's go back to your local application and test out the user isolation of the to-do items.

You will need to sign up new users again because now you're working with the cloud sandbox instead of your production backend.

<Video src="/images/gen2/getting-started/react/demo-auth.mp4" description="Video - Authentication Demo" />

To get these changes to the cloud, commit them to git and push the changes upstream.

```bash title="Terminal" showLineNumbers={false}
git commit -am "added per-user data isolation"
git push
```

Once your build completes in the Amplify Console, the `main` backend will update to support the changes made within the cloud sandbox. The data in the cloud sandbox is fully isolated and won't pollute your production database.

</InlineFilter>





<InlineFilter filters={["nextjs"]}>

👋 Welcome to AWS Amplify! In this quickstart guide, you will:

1. Deploy a Next.js app
2. Build and connect to a database with real-time data updates
3. Configure authentication and authorization rules

We have two Quickstart guides you can follow:

<Overview childPageNodes={props.childPageNodes} />

</InlineFilter>



<InlineFilter filters={["vue"]}>

👋 Welcome to AWS Amplify! In this quickstart guide, you will:

1. Deploy a Vue.js app
2. Build and connect to a database with real-time data updates
3. Configure authentication and authorization rules

## Deploy a fullstack app to AWS

We've created a starter "To-do" application to help get started faster. First, you will create a repository in your GitHub account using our starter Vue template.

### 1. Create the repository

Use our starter template to create a repository in your GitHub account. This template scaffolds `create-vite-app` with Amplify backend capabilities.

<ExternalLinkButton
  size="medium"
  href='https://github.com/new?template_name=amplify-vue-template&template_owner=aws-samples&name=amplify-vue-template&description=My%20Amplify%20Gen%202%20starter%20application'
>
<IconGithub />
Create repository from template
</ExternalLinkButton>

Use the form in GitHub to finalize your repo's creation.

### 2. Deploy the starter app

Now that the repository has been created, deploy it with Amplify.

<ExternalLinkButton
  size="medium"
  variation="primary"
  href='https://console.aws.amazon.com/amplify/create/repo-branch'
>
<IconAmplify />
Deploy to AWS
</ExternalLinkButton>

Select **GitHub**. After you give Amplify access to your GitHub account via the popup window, pick the repository and `main` branch to deploy. Make no other changes and click through the flow to **Save and deploy**.

<Video src="/images/gen2/getting-started/react/deploy.mp4" description="Video - Deploy the starter app" />

### 3. View deployed app

<Accordion title='Learn about the project structure' headingLevel='4' eyebrow='While you are waiting for your app to deploy (~5 mins)'>

Let's take a tour of the project structure in this starter repository by opening it on GitHub. The starter application has pre-written code for a to-do list app. It gives you a real-time database with a feed of all to-do list items and the ability to add new items.

```text
├── amplify/ # Folder containing your Amplify backend configuration
│   ├── auth/ # Definition for your auth backend
│   │   └── resource.tsx
│   ├── data/ # Definition for your data backend
│   │   └── resource.ts
|   ├── backend.ts
│   └── tsconfig.json
├── src/ # Vue code
│   ├── assets/ # Styling for your app
│   ├── components/ # UI code to sync todos in real-time
│   ├── App.vue # UI layout
│   └── main.tsx # Entrypoint of the Amplify client library
├── package.json
└── tsconfig.json
```
</Accordion>

 When the build completes, visit the newly deployed branch by selecting "Visit deployed URL". Since the build deployed an API, database, and authentication backend, you will be able to create new to-do items.

<Video src="/images/gen2/getting-started/react/hosted-app.mp4" description="Video - Visit Deployed URL" />

In the Amplify console, click into the deployment branch (in this case **main**) > select **Data** in the left-hand menu > **Data manager** to see the data entered in your database.

<Video src="/images/gen2/getting-started/amplify-console-data-manager.mp4" description="Video - Data Manager" />

## Make frontend updates

Let's learn how to enhance the app functionality by creating a delete flow for to-do list items.

### 4. Set up local environment

Now let's set up our local development environment to add features to the frontend. Click on your deployed branch and you will land on the **Deployments** page which shows you your build history and a list of deployed backend resources.

<Video src="/images/gen2/getting-started/react/branch-details.mp4" description="Video - Deployments" />

At the bottom of the page you will see a tab for **Deployed backend resources**. Click on the tab and then click the **Download amplify_outputs.json file** button.

![](/images/gen2/getting-started/react/amplify-outputs-download.png)

Clone the repository locally.

```bash title="Terminal" showLineNumbers={false}
git clone https://github.com/<github-user>/amplify-vue-template.git
cd amplify-vue-template && npm install
```

Now move the `amplify_outputs.json` file you downloaded above to the root of your project.

```text
├── amplify
├── src
├── amplify_outputs.json <== backend outputs file
├── package.json
└── tsconfig.json
```

<Accordion title='amplify_outputs.json' headingLevel='4' eyebrow='Learn more'>
The **amplify_outputs.json** file contains backend endpoint information, publicly-viewable API keys, authentication flow information, and more. The Amplify client library uses this outputs file to connect to your Amplify Backend.  You can review how the outputs file is imported within the `main.tsx` file and then passed into the `Amplify.configure(...)` function of the Amplify client library.
</Accordion>



### 5. Implement delete functionality

Go to the **components/Todos.vue** file and add in a new `deleteTodo` functionality and pass function into the `<li>` element's `onClick` handler.

```tsx title="components/Todos.vue"
function App() {
  // ...
  // highlight-start
  function deleteTodo(id: string) {
    client.models.Todo.delete({ id })
  }
  // highlight-end

  <template>
  <main>
    <h1>My todos</h1>
    <button @click="createTodo">+ new</button>
    <ul>
      <li
        v-for="todo in todos"
        :key="todo.id"
        // highlight-start
        @click="deleteTodo(todo.id)"
        // highlight-end
      >
        {{ todo.content }}
      </li>
    </ul>
    <div>
      🥳 App successfully hosted. Try creating a new todo.
      <br />
      <a href="https://docs.amplify.aws/vue/start/quickstart/">
        Review next steps of this tutorial.
      </a>
    </div>
  </main>
</template>
}
```

Try out the deletion functionality now by starting the local dev server:

```bash title="Terminal" showLineNumbers={false}
npm run dev
```

This should start a local dev server at http://localhost:5173.

<Video src="/images/gen2/getting-started/react/demo-delete.mp4" description="Video - Demo" />

### 6. Implement login UI

The starter application already has a pre-configured auth backend defined in the **amplify/auth/resource.ts** file. We've configured it to support email and password login but you can extend it to support a variety of login mechanisms, including Google, Amazon, Sign In With Apple, and Facebook.

The fastest way to get your login experience up and running is to use our Authenticator UI component.

```terminal showLineNumbers={false}
npm add @aws-amplify/ui-vue
```
In your **src/App.vue** file, import the Authenticator UI component and wrap your `<main>` template.

```tsx title="src/App.vue"
<script>
// highlight-start
import { Authenticator } from "@aws-amplify/ui-vue";
import "@aws-amplify/ui-vue/styles.css";
// highlight-end
// ... other imports
</script>

<template>
  <main>
    // highlight-start
    <authenticator>
      <template v-slot="{ signOut }">
        <Todos />
        <button @click="signOut">Sign Out</button>
      </template>
    </authenticator>
    // highlight-end
  </main>
</template>
```

The Authenticator component auto-detects your auth backend settings and renders the correct UI state based on the auth backend's authentication flow.

Try out your application in your localhost environment again. You should be presented with a login experience now.

<Video src="/images/gen2/getting-started/react/demo-auth.mp4" description="Video - Authentication Demo" />

To get these changes to the cloud, commit them to git and push the changes upstream.

```bash title="Terminal" showLineNumbers={false}
git commit -am "added authenticator"
git push
```

Amplify automatically deploys the latest version of your app based on your git commits. In just a few minutes, when the application rebuilds, the hosted app will be updated to support the deletion functionality.

## Make backend updates

Let's update our backend to implement per-user authorization rules, allowing each user to only access their own to-dos.

### 7. Set up local AWS credentials

To make backend updates, we are going to require AWS credentials to deploy backend updates from our local machine.

**Skip ahead to step 8**, if you already have an AWS profile with credentials on your local machine, and your AWS profile has the `AmplifyBackendDeployFullAccess` permission policy.

Otherwise, **[set up local AWS credentials](/[platform]/start/account-setup/)** that grant Amplify permissions to deploy backend updates from your local machine.


### 8. Deploy cloud sandbox

To update your backend without affecting the production branch, use Amplify's cloud sandbox. This feature provides a separate backend environment for each developer on a team, ideal for local development and testing.

To start your cloud sandbox, run the following command in a **new Terminal window**:

```bash title="Terminal" showLineNumbers={false}
npx ampx sandbox
```

Once the cloud sandbox has been fully deployed (~5 min), you'll see the `amplify_outputs.json` file updated with connection information to a new isolated authentication and data backend.

<Callout info>

The `npx ampx sandbox` command should run concurrently to your `npm run dev`. You can think of the cloud sandbox as the "localhost-equivalent for your app backend".

</Callout>

### 9. Implement per-user authorization

The to-do items in the starter are currently shared across all users, but, in most cases, you want data to be isolated on a per-user basis.

To isolate the data on a per-user basis, you can use an "owner-based authorization rule". Let's apply the owner-based authorization rule to your to-do items:

```ts title="amplify/data/resource.ts"
import { type ClientSchema, a, defineData } from '@aws-amplify/backend';

const schema = a.schema({
  Todo: a.model({
    content: a.string(),
    // highlight-next-line
  }).authorization(allow => [allow.owner()]),
});

export type Schema = ClientSchema<typeof schema>;

export const data = defineData({
  schema,
  authorizationModes: {
    // This tells the data client in your app (generateClient())
    // to sign API requests with the user authentication token.
    // highlight-next-line
    defaultAuthorizationMode: 'userPool',
  },
});
```

In the application client code, let's also render the username to distinguish different users once they're logged in.

```tsx title="src/App.vue"
<script>
// highlight-start
import { Authenticator } from "@aws-amplify/ui-vue";
import "@aws-amplify/ui-vue/styles.css";
// highlight-end
// ... other imports
</script>

<template>
  <main>
    <authenticator>
    // highlight-start
      <template v-slot="{ user, signOut }">
        <h1>Hello {{user?.signInDetails?.loginId}}'s todos</h1>
    // highlight-end
        <Todos />
        <button @click="signOut">Sign Out</button>
      </template>
    </authenticator>
  </main>
</template>
```

Now, let's go back to your local application and test out the user isolation of the to-do items.

You will need to sign up new users again because now you're working with the cloud sandbox instead of your production backend.

<Video src="/images/gen2/getting-started/react/demo-auth.mp4" description="Video - Authentication Demo" />

To get these changes to the cloud, commit them to git and push the changes upstream.

```bash title="Terminal" showLineNumbers={false}
git commit -am "added per-user data isolation"
git push
```

Once your build completes in the Amplify Console, the `main` backend will update to support the changes made within the cloud sandbox. The data in the cloud sandbox is fully isolated and won't pollute your production database.

</InlineFilter>







<InlineFilter filters={["angular"]}>

👋 Welcome to AWS Amplify! In this quickstart guide, you will:

1. Deploy an Angular app
2. Build and connect to a database with real-time data updates
3. Configure authentication and authorization rules

## Deploy a fullstack app to AWS

We've created a starter "To-do" application to help get started faster. First, you will create a repository in your GitHub account using our starter Angular template.

### 1. Create the repository

Use our starter template to create a repository in your GitHub account. This template scaffolds a starter Angular application with Amplify backend capabilities.

<ExternalLinkButton
  size="medium"
  href='https://github.com/new?template_name=amplify-angular-template&template_owner=aws-samples&name=amplify-angular-template&description=My%20Amplify%20Gen%202%20starter%20application'
>
<IconGithub />
Create repository from template
</ExternalLinkButton>

Use the form in GitHub to finalize your repo's creation.

### 2. Deploy the starter app

Now that the repository has been created, deploy it with Amplify.

<ExternalLinkButton
  size="medium"
  variation="primary"
  href='https://console.aws.amazon.com/amplify/create/repo-branch'
>
<IconAmplify />
Deploy to AWS
</ExternalLinkButton>

Select **GitHub**. After you give Amplify access to your GitHub account via the popup window, pick the repository and `main` branch to deploy. Make no other changes and click through the flow to **Save and deploy**.

<Video src="/images/gen2/getting-started/react/deploy.mp4" description="Video - Deploy the starter app" />

### 3. View deployed app

<Accordion title='Learn about the project structure' headingLevel='4' eyebrow='While you are waiting for your app to deploy (~5 mins)'>

Let's take a tour of the project structure in this starter repository by opening it on GitHub. The starter application has pre-written code for a to-do list app. It gives you a real-time database with a feed of all to-do list items and the ability to add new items.

```text
├── amplify/ # Folder containing your Amplify backend configuration
│   ├── auth/ # Definition for your auth backend
│   │   └── resource.tsx
│   ├── data/ # Definition for your data backend
│   │   └── resource.ts
|   ├── backend.ts
│   └── tsconfig.json
├── src/app/ # Angular UI code
│   ├── todos/ # UI code to sync todos in real-time
│   ├── app.component.css # Styling for your app
│   └── app.component.ts # Entrypoint of the Amplify client library
├── package.json
└── tsconfig.json
```
</Accordion>

 When the build completes, visit the newly deployed branch by selecting "Visit deployed URL". Since the build deployed an API, database, and authentication backend, you will be able to create new to-do items.

<Video src="/images/gen2/getting-started/react/hosted-app.mp4" description="Video - Visit Deployed URL" />

In the Amplify console, click into the deployment branch (in this case **main**) > select **Data** in the left-hand menu > **Data manager** to see the data entered in your database.

<Video src="/images/gen2/getting-started/amplify-console-data-manager.mp4" description="Video - Data Manager"/>

## Make frontend updates

Let's learn how to enhance the app functionality by creating a delete flow for to-do list items.

### 4. Set up local environment

Now let's set up our local development environment to add features to the frontend. Click on your deployed branch and you will land on the **Deployments** page which shows you your build history and a list of deployed backend resources.

<Video src="/images/gen2/getting-started/react/branch-details.mp4" description="Video - Deployments" />

At the bottom of the page you will see a tab for **Deployed backend resources**. Click on the tab and then click the **Download amplify_outputs.json file** button.

![](/images/gen2/getting-started/react/amplify-outputs-download.png)

Clone the repository locally.

```bash title="Terminal" showLineNumbers={false}
git clone https://github.com/<github-user>/amplify-angular-template.git
cd amplify-angular-template && npm install
```

Now move the `amplify_outputs.json` file you downloaded above to the root of your project.

```text
├── amplify
├── src
├── amplify_outputs.json <== backend outputs file
├── package.json
└── tsconfig.json
```

<Accordion title='amplify_outputs.json' headingLevel='4' eyebrow='Learn more'>
The **amplify_outputs.json** file contains backend endpoint information, publicly-viewable API keys, authentication flow information, and more. The Amplify client library uses this outputs file to connect to your Amplify Backend.  You can review how the outputs file is imported within the `app.component.ts` file and then passed into the `Amplify.configure(...)` function of the Amplify client library.
</Accordion>


### 5. Implement delete functionality

Go to the **src/app/todos/todos.component.ts** file and add a new `deleteTodo` function.

```tsx title="src/todos/todos.component.ts"
export class TodosComponent implements OnInit {
  // ...
  // highlight-start
  deleteTodo(id: string) {
    client.models.Todo.delete({ id })
  }
  // highlight-end
}
```

Call the `deleteTodo` function from the UI.

```html title="src/app/todos/todos.component.html"
...
  <ul>
    <li *ngFor="let todo of todos;" (click)="deleteTodo(todo.id)">
        {{ todo.content }}
    </li>
  </ul>
...
```

Try out the deletion functionality now by starting the local dev server:

```bash title="Terminal" showLineNumbers={false}
npm run start
```

This should start a local dev server at http://localhost:4200.

<Video src="/images/gen2/getting-started/react/demo-delete.mp4" description="Video - Demo" />

### 6. Implement login UI

The starter application already has a pre-configured auth backend defined in the **amplify/auth/resource.ts** file. We've configured it to support email and password login but you can extend it to support a variety of login mechanisms, including Google, Amazon, Sign In With Apple, and Facebook.

The fastest way to get your login experience up and running is to use our Authenticator UI component.

```terminal showLineNumbers={false}
npm add @aws-amplify/ui-angular
```

In your **src/app/app.component.ts** file, import the `AmplifyAuthenticatorModule`.

```ts title="src/app/app.component.ts"
import { Component } from '@angular/core';
import { RouterOutlet } from '@angular/router';
import { TodosComponent } from './todos/todos.component';
import { Amplify } from 'aws-amplify';
import outputs from '../../amplify_outputs.json';
// highlight-next-line
import { AmplifyAuthenticatorModule, AuthenticatorService } from '@aws-amplify/ui-angular';

Amplify.configure(outputs);

@Component({
  selector: 'app-root',
  standalone: true,
  templateUrl: './app.component.html',
  styleUrl: './app.component.css',
  // highlight-next-line
  imports: [RouterOutlet, TodosComponent, AmplifyAuthenticatorModule],
})
export class AppComponent {
  title = 'amplify-angular-template';
  // highlight-start
  constructor(public authenticator: AuthenticatorService) {
    Amplify.configure(outputs);
  }
  // highlight-end
}
```
Update the application UI and include styles.

```html title="src/app/app.component.html"
<amplify-authenticator>
  <ng-template
    amplifySlot="authenticated"
    let-user="user"
    let-signOut="signOut"
  >
    <app-todos></app-todos>
    <button (click)="signOut()">Sign Out</button>
  </ng-template>
</amplify-authenticator>
```

```json title="angular.json"
...
    "styles": [
      "node_modules/@aws-amplify/ui-angular/theme.css",
      "src/styles.css"
    ],
...
```
The Authenticator component auto-detects your auth backend settings and renders the correct UI state based on the auth backend's authentication flow.

Try out your application in your localhost environment again. You should be presented with a login experience now.

<Video src="/images/gen2/getting-started/react/demo-auth.mp4" description="Video - Authentication Demo" />

To get these changes to the cloud, commit them to git and push the changes upstream.

```bash title="Terminal" showLineNumbers={false}
git commit -am "added authenticator"
git push
```

Amplify automatically deploys the latest version of your app based on your git commits. In just a few minutes, when the application rebuilds, the hosted app will be updated to support the deletion functionality.

## Make backend updates

Let's update our backend to implement per-user authorization rules, allowing each user to only access their own to-dos.

### 7. Set up local AWS credentials

To make backend updates, we are going to require AWS credentials to deploy backend updates from our local machine.

**Skip ahead to step 8**, if you already have an AWS profile with credentials on your local machine, and your AWS profile has the `AmplifyBackendDeployFullAccess` permission policy.

Otherwise, **[set up local AWS credentials](/[platform]/start/account-setup/)** that grant Amplify permissions to deploy backend updates from your local machine.


### 8. Deploy cloud sandbox

To update your backend without affecting the production branch, use Amplify's cloud sandbox. This feature provides a separate backend environment for each developer on a team, ideal for local development and testing.

To start your cloud sandbox, run the following command in a **new Terminal window**:

```bash title="Terminal" showLineNumbers={false}
npx ampx sandbox
```

Once the cloud sandbox has been fully deployed (~5 min), you'll see the `amplify_outputs.json` file updated with connection information to a new isolated authentication and data backend.

<Callout info>

The `npx ampx sandbox` command should run concurrently to your `npm run dev`. You can think of the cloud sandbox as the "localhost-equivalent for your app backend".

</Callout>

### 9. Implement per-user authorization

The to-do items in the starter are currently shared across all users, but, in most cases, you want data to be isolated on a per-user basis.

To isolate the data on a per-user basis, you can use an "owner-based authorization rule". Let's apply the owner-based authorization rule to your to-do items:

```ts title="amplify/data/resource.ts"
import { type ClientSchema, a, defineData } from '@aws-amplify/backend';

const schema = a.schema({
  Todo: a.model({
    content: a.string(),
  })
  // highlight-next-line
  .authorization(allow => [allow.owner()]),
});

export type Schema = ClientSchema<typeof schema>;

export const data = defineData({
  schema,
  authorizationModes: {
    // This tells the data client in your app (generateClient())
    // to sign API requests with the user authentication token.
    // highlight-next-line
    defaultAuthorizationMode: 'userPool',
  },
});
```

In the application client code, let's also render the username to distinguish different users once they're logged in.

```html title="src/app/app.component.html"
<amplify-authenticator>
  <ng-template
    amplifySlot="authenticated"
    let-user="user"
    let-signOut="signOut"
  >
  <h1>Hello {{user?.signInDetails?.loginId}}'s todos</h1>
    <app-todos></app-todos>
    <button (click)="signOut()">Sign Out</button>
  </ng-template>
</amplify-authenticator>
```

Now, let's go back to your local application and test out the user isolation of the to-do items.

You will need to sign up new users again because now you're working with the cloud sandbox instead of your production backend.

<Video src="/images/gen2/getting-started/react/demo-auth.mp4" description="Video - Authentication Demo" />

To get these changes to the cloud, commit them to git and push the changes upstream.

```bash title="Terminal" showLineNumbers={false}
git commit -am "added per-user data isolation"
git push
```

Once your build completes in the Amplify Console, the `main` backend will update to support the changes made within the cloud sandbox. The data in the cloud sandbox is fully isolated and won't pollute your production database.


</InlineFilter>






<InlineFilter filters={["flutter"]}>

## Prerequisites

Before you get started, make sure you have the following installed:

- [Node.js](https://nodejs.org/) v18.17 or later
- [npm](https://www.npmjs.com/) v9 or later
- [git](https://git-scm.com/) v2.14.1 or later
- You will also need to [create an AWS Account](https://portal.aws.amazon.com/billing/signup). Note that AWS Amplify is part of the [AWS Free Tier](https://aws.amazon.com/amplify/pricing/).
- Configure your AWS account to use with Amplify [instructions](/[platform]/start/account-setup/).
- A stable version of [Flutter](https://docs.flutter.dev/get-started/install).

<Callout info>
You can follow the [official documentation](https://flutter.dev/docs/get-started/install) to install Flutter on your machine and check the [editor documentation](https://docs.flutter.dev/get-started/editor) for setting up your editor.
</Callout>

Once you have installed Flutter, you can create a new Flutter project using the following command:

<Callout info>
In this Quickstart guide, you will build the application for web. However, if you want to run the application on other platforms, be sure to follow the required setup [guide here](/[platform]/start/platform-setup/).
</Callout>

```bash title="Terminal" showLineNumbers={false}
flutter create my_amplify_app
```

## Create Backend

The easiest way to get started with AWS Amplify is through npm with `create-amplify` command. You can run it from your base project directory. First, go to the base project directory with the following command:

```bash title="Terminal" showLineNumbers={false}
cd my_amplify_app
```

After that, run the following to create an Amplify project:

```bash title="Terminal" showLineNumbers={false}
npm create amplify@latest -y
```

Running this command will scaffold Amplify backend files in your current project with the following files added:

```text
├── amplify/
│   ├── auth/
│   │   └── resource.ts
│   ├── data/
│   │   └── resource.ts
│   ├── backend.ts
│   └── package.json
├── node_modules/
├── .gitignore
├── package-lock.json
├── package.json
└── tsconfig.json
```

To deploy your backend use Amplify's per-developer cloud sandbox. This feature provides a separate backend environment for every developer on a team, ideal for local development and testing. To run your application with a sandbox environment, you can run the following command:


<InlineFilter filters={["android", "javascript", "react-native", "angular", "nextjs", "react", "react-native", "vue", "swift"]}>
```bash title="Terminal" showLineNumbers={false}
npx ampx sandbox

```
</InlineFilter>
<InlineFilter filters={["flutter"]}>
```bash title="Terminal" showLineNumbers={false}
npx ampx sandbox --outputs-format dart --outputs-out-dir lib
```

</InlineFilter>

## Adding Authentication

The initial scaffolding already has a pre-configured auth backend defined in the `amplify/auth/resource.ts` file. We've configured it to support email and password login but you can extend it to support a variety of login mechanisms, including Google, Amazon, Sign In With Apple, and Facebook.

The fastest way to get your login experience up and running is to use our Authenticator UI component available in the Amplify UI library.

To use the Authenticator, you need to add the following dependencies to your project:

```yaml title="pubspec.yaml"
dependencies:
  amplify_flutter: ^2.0.0
  amplify_auth_cognito: ^2.0.0
  amplify_authenticator: ^2.0.0
```

You will add:

- `amplify_flutter` to connect your application with the Amplify resources.
- `amplify_auth_cognito` to connect your application with the Amplify Cognito resources.
- `amplify_authenticator` to use the Amplify UI components.

After adding the dependencies, you need to run the following command to install the dependencies:

```bash title="Terminal" showLineNumbers={false}
flutter pub get
```

Lastly update your main.dart file to use the Amplify UI components:

```dart title="main.dart"
import 'package:amplify_auth_cognito/amplify_auth_cognito.dart';
import 'package:amplify_authenticator/amplify_authenticator.dart';
import 'package:amplify_flutter/amplify_flutter.dart';
import 'package:flutter/material.dart';

import 'amplify_outputs.dart';

Future<void> main() async {
  try {
    WidgetsFlutterBinding.ensureInitialized();
    await _configureAmplify();
    runApp(const MyApp());
  } on AmplifyException catch (e) {
    runApp(Text("Error configuring Amplify: ${e.message}"));
  }
}

Future<void> _configureAmplify() async {
  try {
    await Amplify.addPlugin(AmplifyAuthCognito());
    await Amplify.configure(amplifyConfig);
    safePrint('Successfully configured');
  } on Exception catch (e) {
    safePrint('Error configuring Amplify: $e');
  }
}

class MyApp extends StatelessWidget {
  const MyApp({super.key});
  @override
  Widget build(BuildContext context) {
    return Authenticator(
      child: MaterialApp(
        builder: Authenticator.builder(),
        home: const Scaffold(
          body: Center(
            child: Column(
              mainAxisAlignment: MainAxisAlignment.center,
              children: [
                SignOutButton(),
                Text('TODO Application'),
              ],
            ),
          ),
        ),
      ),
    );
  }
}
```

The Authenticator component auto-detects your auth backend settings and renders the correct UI state based on the auth backend's authentication flow.

Run your application in your local environment again. You should be presented with a login experience now.


<Video src="/images/gen2/getting-started/flutter/flutter-getting-started-1.mp4" description="Video - Flutter Getting Started" />

## Adding Data

The initial scaffolding already has a pre-configured data backend defined in the `amplify/data/resource.ts` file. The default example will create a Todo model with `content` field.

Let's modify this to add the following:
- A boolean `isDone` field.
- An authorization rules specifying owners, authenticated via your Auth resource can "create", "read", "update", and "delete" their own records.
- Update the `defaultAuthorizationMode` to sign API requests with the user authentication token.

```typescript
import { type ClientSchema, a, defineData } from "@aws-amplify/backend";

const schema = a.schema({
  Todo: a
    .model({
      content: a.string(),
      isDone: a.boolean(),
    })
    .authorization(allow => [allow.owner()]),
});

export type Schema = ClientSchema<typeof schema>;

export const data = defineData({
  schema,
  authorizationModes: {
    defaultAuthorizationMode: "userPool",
  },
});
```
Next, let's implement UI to create, list, and delete the to-do items.

Amplify can automatically generate code for interacting with the backend API. Run the command in the terminal to generate dart model classes from the Data schema under `lib/models`:

```bash title="Terminal" showLineNumbers={false}
npx ampx generate graphql-client-code --format modelgen --model-target dart --out lib/models
```


Once you are done, add the API dependencies to your project. You will add `amplify_api` to connect your application with the Amplify API.

```yaml title="pubspec.yaml"
dependencies:
  amplify_api: ^2.0.0
```


After adding the dependencies, update the `_configureAmplify` method in your `main.dart` file to use the Amplify API:

```dart title="main.dart"
Future<void> _configureAmplify() async {
  try {
    await Amplify.addPlugins(
      [
        AmplifyAuthCognito(),
        AmplifyAPI(
          options: APIPluginOptions(
            modelProvider: ModelProvider.instance,
          ),
        ),
      ],
    );
    await Amplify.configure(amplifyConfig);
    safePrint('Successfully configured');
  } on Exception catch (e) {
    safePrint('Error configuring Amplify: $e');
  }
}
```

Next create a new widget called `TodoScreen` and add the following code to the end of the **main.dart** file:

```dart title="main.dart"

class TodoScreen extends StatefulWidget {
  const TodoScreen({super.key});

  @override
  State<TodoScreen> createState() => _TodoScreenState();
}

class _TodoScreenState extends State<TodoScreen> {
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      floatingActionButton: FloatingActionButton.extended(
        label: const Text('Add Random Todo'),
        onPressed: () async {
          final newTodo = Todo(
            id: uuid(),
            content: "Random Todo ${DateTime.now().toIso8601String()}",
            isDone: false,
          );
          final request = ModelMutations.create(newTodo);
          final response = await Amplify.API.mutate(request: request).response;
          if (response.hasErrors) {
            safePrint('Creating Todo failed.');
          } else {
            safePrint('Creating Todo successful.');
          }
        },
      ),
      body: const Placeholder(),
    );
  }
}
```

This will create a random Todo every time a user clicks on the floating action button. You can see the `ModelMutations.create` method is used to create a new Todo.

And update the `MyApp` widget in your **main.dart** file like the following:

```dart title="main.dart"
class MyApp extends StatelessWidget {
  const MyApp({super.key});
  @override
  Widget build(BuildContext context) {
    return Authenticator(
      child: MaterialApp(
        builder: Authenticator.builder(),
        home: const SafeArea(
          child: Scaffold(
            body: Column(
              children: [
                SignOutButton(),
                Expanded(child: TodoScreen()),
              ],
            ),
          ),
        ),
      ),
    );
  }
}
```

Next add a `_todos` list in `_TodoScreenState` to add the results from the API and call the refresh function:

```dart title="main.dart"
List<Todo> _todos = [];

@override
void initState() {
  super.initState();
  _refreshTodos();
}
```


and create a new function called `_refreshTodos`:

```dart title="main.dart"
Future<void> _refreshTodos() async {
  try {
    final request = ModelQueries.list(Todo.classType);
    final response = await Amplify.API.query(request: request).response;

    final todos = response.data?.items;
    if (response.hasErrors) {
      safePrint('errors: ${response.errors}');
      return;
    }
    setState(() {
      _todos = todos!.whereType<Todo>().toList();
    });
  } on ApiException catch (e) {
    safePrint('Query failed: $e');
  }
}
```

and update the `build` function like the following:

```dart title="main.dart"
@override
Widget build(BuildContext context) {
  return Scaffold(
    floatingActionButton: FloatingActionButton.extended(
      label: const Text('Add Random Todo'),
      onPressed: () async {
        final newTodo = Todo(
          id: uuid(),
          content: "Random Todo ${DateTime.now().toIso8601String()}",
          isDone: false,
        );
        final request = ModelMutations.create(newTodo);
        final response = await Amplify.API.mutate(request: request).response;
        if (response.hasErrors) {
          safePrint('Creating Todo failed.');
        } else {
          safePrint('Creating Todo successful.');
        }
        _refreshTodos();
      },
    ),
    body: _todos.isEmpty == true
        ? const Center(
            child: Text(
              "The list is empty.\nAdd some items by clicking the floating action button.",
              textAlign: TextAlign.center,
            ),
          )
        : ListView.builder(
            itemCount: _todos.length,
            itemBuilder: (context, index) {
              final todo = _todos[index];
              return Dismissible(
                key: UniqueKey(),
                confirmDismiss: (direction) async {
                  return false;
                },
                child: CheckboxListTile.adaptive(
                  value: todo.isDone,
                  title: Text(todo.content!),
                  onChanged: (isChecked) async {},
                ),
              );
            },
          ),
  );
}
```

Now let's add the update and delete functionality.

For update, add the following code to the `onChanged` method of the `CheckboxListTile.adaptive` widget:

```dart title="main.dart"
final request = ModelMutations.update(
  todo.copyWith(isDone: isChecked!),
);
final response =
    await Amplify.API.mutate(request: request).response;
if (response.hasErrors) {
  safePrint('Updating Todo failed. ${response.errors}');
} else {
  safePrint('Updating Todo successful.');
  await _refreshTodos();
}
```

This will call the `ModelMutations.update` method to update the Todo with a copied/updated version of the todo item. So now the checkbox will get an update as well.

For delete functionality, add the following code to the `confirmDismiss` method of the `Dismissible` widget:

```dart title="main.dart"
if (direction == DismissDirection.endToStart) {
  final request = ModelMutations.delete(todo);
  final response =
      await Amplify.API.mutate(request: request).response;
  if (response.hasErrors) {
    safePrint('Updating Todo failed. ${response.errors}');
  } else {
    safePrint('Updating Todo successful.');
    await _refreshTodos();
    return true;
  }
}
return false;
```

This will delete the Todo item when the user swipes the item from right to left. Now if you run the application you should see the following flow.

<Video src="/images/gen2/getting-started/flutter/flutter-getting-started-2.mp4" description="Video - Flutter Getting Started" />

You can terminate the sandbox environment now to clean up the project.

### Publishing changes to cloud

Publishing changes to the cloud requires a remote git repository. Amplify offers fullstack branch deployments that allow you to automatically deploy infrastructure and application code changes from feature branches. To learn more, visit the [fullstack branch deployments guide](/[platform]/deploy-and-host/fullstack-branching/branch-deployments).

</InlineFilter>










<InlineFilter filters={["swift"]}>

## Prerequisites

Before you get started, make sure you have the following installed:

- [Node.js](https://nodejs.org/) v18.17 or later
- [npm](https://www.npmjs.com/) v9 or later
- [git](https://git-scm.com/) v2.14.1 or later
- You will also need to [create an AWS Account](https://portal.aws.amazon.com/billing/signup). Note that AWS Amplify is part of the [AWS Free Tier](https://aws.amazon.com/amplify/pricing/).
- Configure your AWS account to use with Amplify [instructions](/[platform]/start/account-setup/).
- You need to have [Xcode and Developer Tooling](https://developer.apple.com/xcode/) installed on your machine.

<Accordion title='Create an XCode project' headingLevel='4' eyebrow='Starting fresh?'>
Open Xcode and select **Create New Project...**

![Shows the Xcode starter video to start project](/images/lib/getting-started/ios/set-up-swift-1.png)

In the next step select the **App** template under **iOS**. Click on next.

![Shows the template of apps for iOS](/images/lib/getting-started/ios/set-up-swift-2.png)

Next steps are:

- Adding a _Product Name_ (e.g. MyAmplifyApp)
- Select a _Team_ (e.g. None)
- Select a _Organization Identifier_ (e.g. com.example)
- Select **SwiftUI** an _Interface_.
- Press **Next**

![Shows the project details dialog](/images/lib/getting-started/ios/set-up-swift-3.png)

Now you should have your project created.

![Shows the base project for SwiftUI](/images/lib/getting-started/ios/set-up-swift-4.png)
</Accordion>

## Create Backend

The easiest way to get started with AWS Amplify is through npm with `create-amplify` command. You can run it from your base project directory.

```bash title="Terminal" showLineNumbers={false}
cd my_amplify_app
npm create amplify@latest
? Where should we create your project? (.) # press enter
```

Running this command will scaffold Amplify backend files in your current project with the following files added:

```text
├── amplify/
│   ├── auth/
│   │   └── resource.ts
│   ├── data/
│   │   └── resource.ts
│   ├── backend.ts
│   └── package.json
├── node_modules/
├── .gitignore
├── package-lock.json
├── package.json
└── tsconfig.json
```

To deploy your backend use Amplify's per-developer cloud sandbox. This feature provides a separate backend environment for every developer on a team, ideal for local development and testing. To run your application with a sandbox environment, you can run the following command:


```bash title="Terminal" showLineNumbers={false}
npx ampx sandbox
```

Once the sandbox environment is deployed, it will create an `amplify_outputs.json`. However, Xcode won't be able to recognize them. For recognizing the files, you need to drag and drop the generated files to your project.

<Video src="/images/gen2/getting-started/ios/ios-getting-started-2.mp4" description="Video - XCode Demo" />

## Adding Authentication

The initial scaffolding already has a pre-configured auth backend defined in the `amplify/auth/resource`.ts file. We've configured it to support email and password login but you can extend it to support a variety of login mechanisms, including Google, Amazon, Sign In With Apple, and Facebook.

The fastest way to get your login experience up and running is to use our Authenticator UI component available in the Amplify UI library.

To use the Authenticator, open your project in Xcode and select **File > Add Packages...** and add the following dependencies:

![Shows the Amplify library for Swift](/images/lib/getting-started/ios/set-up-swift-5.png)

- Amplify Library for Swift: Enter its GitHub URL (https://github.com/aws-amplify/amplify-swift), select **Up to Next Major Version** and click **Add Package Dependencies...** and select the following libraries:

  - Amplify
  - AWSCognitoAuthPlugin

![Shows the Amplify library for Swift](/images/lib/getting-started/ios/set-up-swift-6.png)

- Amplify UI Swift - Authenticator: Enter its GitHub URL (https://github.com/aws-amplify/amplify-ui-swift-authenticator), select **Up to Next Major Version** and click **Add Package Dependencies...** and select the following libraries:
  - Authenticator

![Shows the Amplify library for Swift](/images/lib/getting-started/ios/set-up-swift-7.png)

Now update the `MyAmplifyAppApp` class with the following code:

```swift
import Amplify
import Authenticator
import AWSCognitoAuthPlugin
import SwiftUI

@main
struct MyApp: App {
    init() {
        do {
            try Amplify.add(plugin: AWSCognitoAuthPlugin())
            try Amplify.configure(with: .amplifyOutputs)
        } catch {
            print("Unable to configure Amplify \(error)")
        }
    }

    var body: some Scene {
        WindowGroup {
            ContentView()
        }
    }
}
```

Update `ContentView` with the following code:
```swift
import Amplify
import Authenticator

struct ContentView: View {
    var body: some View {
        Authenticator { state in
            VStack {
                Button("Sign out") {
                    Task {
                        await state.signOut()
                    }
                }
            }
        }
    }
}
```

The Authenticator component auto-detects your auth backend settings and renders the correct UI state based on the auth backend's authentication flow.

Run your application in your local environment again. You should be presented with a login experience now.

<Video with="40%" src="/images/gen2/getting-started/ios/ios-getting-started-1.mp4" description="Video - Authentication Demo" />

## Adding Data

The initial scaffolding already has a pre-configured data backend defined in the `amplify/data/resource.ts` file. The default example will create a Todo model with `content` field.

Let's modify this to add the following:
- A boolean `isDone` field.
- An authorization rules specifying owners, authenticated via your Auth resource can "create", "read", "update", and "delete" their own records.
- Update the `defaultAuthorizationMode` to sign API requests with the user authentication token.

```typescript
import { type ClientSchema, a, defineData } from '@aws-amplify/backend';

const schema = a.schema({
  Todo: a
    .model({
      content: a.string(),
      isDone: a.boolean().required()
    })
    .authorization((allow) => [allow.owner()])
});

export type Schema = ClientSchema<typeof schema>;

export const data = defineData({
  schema,
  authorizationModes: {
    defaultAuthorizationMode: 'userPool'
  }
});
```
Next, let's implement UI to create, list, and delete the to-do items.

Amplify can automatically generate code for interacting with the backend API. The command below generates model classes from the Data schema:

```bash title="Terminal" showLineNumbers={false}
npx ampx generate graphql-client-code --format modelgen --model-target swift
```

Move the generated files to your project. You can do this by dragging and dropping the files to your project.

![Shows the drag and drop phase](/images/lib/getting-started/ios/set-up-swift-8.png)

Once you are done, add the API dependencies to your project. Select **File > Add Package Dependencies...** and add the `AWSAPIPlugin`.

![Shows the Amplify API library for Swift selected](/images/lib/getting-started/ios/set-up-swift-9.png)

After adding the dependencies, update the `import` part of your `MyAmplifyAppApp.swift` file with the following code:

```swift title="MyAmplifyAppApp.swift"
import Amplify
import AWSCognitoAuthPlugin
import AWSAPIPlugin
```

Then, update the `init()` part of your `MyAmplifyAppApp.swift` file with the following code:

```swift title="MyAmplifyAppApp.swift"
init() {
    do {
        try Amplify.add(plugin: AWSCognitoAuthPlugin())
        try Amplify.add(plugin: AWSAPIPlugin(modelRegistration: AmplifyModels()))
        try Amplify.configure(with: .amplifyOutputs)
    } catch {
        print("Unable to configure Amplify \(error)")
    }
}
```

Create a new file called `TodoViewModel.swift` and the `createTodo` function with the following code:

```swift title="TodoViewModel.swift"
import Amplify
import SwiftUI

@MainActor
class TodoViewModel: ObservableObject {
    func createTodo() async {
        let creationTime = Temporal.DateTime.now()
        let todo = Todo(
            content: "Random Todo \(creationTime.iso8601String)",
            isDone: false,
            createdAt: creationTime,
            updatedAt: creationTime
        )
        do {
            let result = try await Amplify.API.mutate(request: .create(todo))
            switch result {
            case .success(let todo):
                print("Successfully created todo: \(todo)")
                todos.append(todo)
            case .failure(let error):
                print("Got failed result with \(error.errorDescription)")
            }
        } catch let error as APIError {
            print("Failed to create todo: ", error)
        } catch {
            print("Unexpected error: \(error)")
        }
    }
}

```

The code above will create a random todo with the current time.

Next, update the `listTodos` function in the `TodoViewModel.swift` for listing to-do items:

```swift title="TodoViewModel.swift"
@MainActor
class TodoViewModel: ObservableObject {
    @Published var todos: [Todo] = []

    func createTodo() {
        /// ...
    }

    func listTodos() async {
        let request = GraphQLRequest<Todo>.list(Todo.self)
        do {
            let result = try await Amplify.API.query(request: request)
            switch result {
            case .success(let todos):
                print("Successfully retrieved list of todos: \(todos)")
                self.todos = todos.elements
            case .failure(let error):
                print("Got failed result with \(error.errorDescription)")
            }
        } catch let error as APIError {
            print("Failed to query list of todos: ", error)
        } catch {
            print("Unexpected error: \(error)")
        }
    }
}
```

This will assign the value of the fetched todos into a Published object.

Now let's update the UI code to observe the todos. Update the `VStack` in the `ContentView.swift` file with the following code:

```swift title="ContentView.swift"
struct ContentView: View {

    // Create an observable object instance.
    @StateObject var vm = TodoViewModel()

    var body: some View {
        Authenticator { state in
            VStack {
                Button("Sign out") {
                    Task {
                        await state.signOut()
                    }
                }
                Button(action: {
                    Task { await vm.createTodo() }
                }) {
                    HStack {
                        Text("Add a New Todo")
                        Image(systemName: "plus")
                    }
                }
                .accessibilityLabel("New Todo")
            }
        }
    }
}
```

<Callout info>
  Throughout the Swift implementation, the async/await pattern has been used and
  for using it easily, we take advantage of the Task structure. For more
  information about the Task structure, you can check the
  [documentation](https://developer.apple.com/documentation/swift/task).
</Callout>

The code will create a todo and update the todo list each time a todo is created.

Next step is to update and delete the todos. For that, create `updateTodo` and `deleteTodo` functions in the `TodoViewModel.swift` file with the following code:

```swift title="TodoViewModel.swift"
@MainActor
class TodoViewModel: ObservableObject {
    @Published var todos: [Todo] = []

    func createTodo() {
        // ...
    }

    func listTodos() {
        // ...
    }

    func deleteTodos(indexSet: IndexSet) async {
        for index in indexSet {
            do {
                let todo = todos[index]
                let result = try await Amplify.API.mutate(request: .delete(todo))
                switch result {
                case .success(let todo):
                    print("Successfully deleted todo: \(todo)")
                    todos.remove(at: index)
                case .failure(let error):
                    print("Got failed result with \(error.errorDescription)")
                }
            } catch let error as APIError {
                print("Failed to deleted todo: ", error)
            } catch {
                print("Unexpected error: \(error)")
            }
        }
    }

    func updateTodo(todo: Todo) async {
        do {
            let result = try await Amplify.API.mutate(request: .update(todo))
            switch result {
            case .success(let todo):
                print("Successfully updated todo: \(todo)")
            case .failure(let error):
                print("Got failed result with \(error.errorDescription)")
            }
        } catch let error as APIError {
            print("Failed to updated todo: ", error)
        } catch {
            print("Unexpected error: \(error)")
        }
    }
}

```

Update the `List` in the `ContentView.swift` file with code to fetch the todos when the View is displayed and to call `deleteTodos(indexSet:)` when the user left-swipe a todo.

```swift title="ContentView.swift"
struct ContentView: View {
    @StateObject var vm = TodoViewModel()

    var body: some View {
        Authenticator { state in
            VStack {
                // ... Sign out Button
                List {
                    ForEach($vm.todos, id: \.id) { todo in
                        TodoRow(vm: vm, todo: todo)
                    }
                    .onDelete { indexSet in
                        Task { await vm.deleteTodos(indexSet: indexSet) }
                    }
                }
                .task {
                    await vm.listTodos()
                }
                // ... Add new Todo button
            }
        }
    }
}
```

Lastly, create a new file called `TodoRow.swift` with the following code:

```swift title="TodoRow.swift"
import SwiftUI

struct TodoRow: View {
    @ObservedObject var vm: TodoViewModel
    @Binding var todo: Todo

    var body: some View {
        Toggle(isOn: $todo.isDone) {
            Text(todo.content ?? "")
        }
        .toggleStyle(.switch)
        .onChange(of: todo.isDone) { _, newValue in
            var updatedTodo = todo
            updatedTodo.isDone = newValue
            Task { await vm.updateTodo(todo: updatedTodo) }
        }
    }
}

#Preview {
    @State var todo = Todo(content: "Hello Todo World 20240706T15:23:42.256Z", isDone: false)
    return TodoRow(vm: TodoViewModel(), todo: $todo)
}
```

This will update the UI to show a toggle to update the todo `isDone` and a swipe to delete the todo. Now if you run the application you should see the following flow.

<Video width="40%" src="/images/gen2/getting-started/ios/ios-getting-started-3.mp4" description="Video - Delete Demo" />

You can terminate the sandbox environment now to clean up the project.

## Publishing changes to cloud

Publishing changes to the cloud requires a remote git repository. Amplify offers fullstack branch deployments that allow you to automatically deploy infrastructure and application code changes from feature branches. To learn more, visit the [fullstack branch deployments guide](/[platform]/deploy-and-host/fullstack-branching/branch-deployments).

</InlineFilter>




<InlineFilter filters={["android"]}>

👋 Welcome to AWS Amplify! In this quickstart guide, you will:
1. deploy an Amplify backend database and authentication
2. connect to the backend from an Android app
3. make backend updates

## Deploy Amplify backend to AWS

To get started faster, we've created a starter "To-do" Amplify backend. First, create a repository in your GitHub account using our starter template.

### 1. Create repository

Use our starter template to create a repository in your GitHub account. This template scaffolds an Amplify Backend with Auth and Data capabilities.
<ExternalLinkButton
  size="medium"
  href='https://github.com/new?template_name=amplify-backend-template&template_owner=aws-samples&name=amplify-backend-template&description=My%20Amplify%20Gen%202%20starter%20application'
>
<IconGithub />
Create repository from template
</ExternalLinkButton>

### 2. Deploy starter

Now that the repository has been created, deploy this to Amplify's CI/CD pipeline.

<ExternalLinkButton
  size="medium"
  variation="primary"
  href='https://us-east-1.console.aws.amazon.com/amplify/create/repo-branch'
>
<IconAmplify />
Deploy to AWS
</ExternalLinkButton>

Select **GitHub**, pick the starter repository, and hit "Save and Deploy".

<Video src="/images/gen2/getting-started/react/deploy.mp4" description="Video - Deploy the starter app" />

### 3: View deployed backend

<Accordion title='Learn about the project structure' headingLevel='4' eyebrow='While you are waiting for your app to deploy (~5 mins)'>

Let's take a tour of the project structure in this starter repository. The starter application already has pre-written code to give you a real-time database with a feed of all to-do items and the ability to add new items.

```text
├── amplify/ # Folder containing your Amplify backend configuration
│   ├── auth/ # Definition for your auth backend
│   │   └── resource.ts
│   ├── data/ # Definition for your data backend
│   │   └── resource.ts
|   ├── backend.ts
│   └── package.json
```
</Accordion>

 When the build completes, visit the newly deployed branch by selecting the branch name and then looking at the **Deployed backend resources** section under deployments.

<Video src="/images/gen2/getting-started/react/branch-details.mp4" description="Video - Deployments" />

## Make app updates

Let's learn how to enhance the app functionality by creating a delete flow for to-do list items.

### 4. Set up local environment

<Accordion title='Setup Android project' headingLevel='4' eyebrow='If you do not have an existing Android app.'>

**Open Android Studio.** Select **+ Create New Project.**

![Shows the Android studio welcome window](/images/lib/getting-started/android/set-up-android-studio-welcome.png)

In **Select a Project Template**, select **Empty Activity** or **Empty Compose Activity**. Press **Next**.

![Shows Android studio new project window](/images/lib/getting-started/android/set-up-android-studio-select-project-template.png)

- Enter _MyAmplifyApp_ in the **Name** field
- Select either _Java_ or _Kotlin_ from the **Language** dropdown menu
- Select _API 24: Android 7.0 (Nougat)_ from the **Minimum SDK** dropdown menu
- Press **Finish**

![Shows Android studio configure project window](/images/lib/getting-started/android/set-up-android-studio-configure-your-project.png)

</Accordion>

On the **Deployed backend resources**, choose **Download outputs file** to download the `amplify_outputs.json` file that contains identifiers for all the deployed backend resources.

![](/images/gen2/getting-started/react/amplify-outputs-download.png)


Now move the `amplify_outputs.json` file you downloaded above to `app/src/main/res/raw` in your Android project. You will now be able to connect to this backend.

<Accordion title='amplify_outputs.json' headingLevel='4' eyebrow='Learn more'>
The **amplify_outputs.json** file contains backend endpoint information, publicly-viewable API keys, authentication flow information, and more. The Amplify client library uses this outputs file to connect to your Amplify Backend.
</Accordion>

### 5. Install dependencies

Amplify uses some modern Java APIs that require desugaring to be added for earlier versions of Android. In your app/build.gradle.kts add the following lines:
```kotlin title="app/build.gradle.kts"
android {
    compileOptions {
        // Support for Java 8 features
        isCoreLibraryDesugaringEnabled = true
        sourceCompatibility = JavaVersion.VERSION_1_8
        targetCompatibility = JavaVersion.VERSION_1_8
    }
}

dependencies {
    coreLibraryDesugaring("com.android.tools:desugar_jdk_libs:2.0.3")
}
```

### 6. Implement login UI

The deployed backend application already has a pre-configured auth backend defined in the `amplify/auth/resource.ts` file.

The fastest way to get your login experience up and running is to use our Authenticator UI component. To use the Authenticator UI component, you need to add the following dependencies to your app/build.gradle.kts file:

<Callout warning>Be sure to have compileSdk version as 34 or higher.</Callout>

```kotlin title="app/build.gradle.kts"
dependencies {
    implementation("com.amplifyframework.ui:authenticator:ANDROID_AUTHENTICATOR_VERSION")
    coreLibraryDesugaring("com.android.tools:desugar_jdk_libs:2.0.3")
}
```

Afterwards create a `MyAmplifyApp` class that extends `Application` and add the following code:


```kotlin title="MyAmplifyApp.kt"
import android.app.Application
import android.util.Log
import com.amplifyframework.AmplifyException
import com.amplifyframework.auth.cognito.AWSCognitoAuthPlugin
import com.amplifyframework.core.Amplify
import com.amplifyframework.core.configuration.AmplifyOutputs

class MyAmplifyApp: Application() {
    override fun onCreate() {
        super.onCreate()

        try {
            Amplify.addPlugin(AWSCognitoAuthPlugin())
            Amplify.configure(AmplifyOutputs(R.raw.amplify_outputs), applicationContext)
            Log.i("MyAmplifyApp", "Initialized Amplify")
        } catch (error: AmplifyException) {
            Log.e("MyAmplifyApp", "Could not initialize Amplify", error)
        }
    }
}
```

Next call this class in your `AndroidManifest.xml` file:

```xml title="AndroidManifest.xml"
<application
    android:name=".MyAmplifyApp"
    ...
</application>
```

Update `MainActivity.kt` to use the Android Authenticator component.

```kotlin title="MainActivity.kt"
import android.os.Bundle
..
//highlight-start
import com.amplifyframework.ui.authenticator.ui.Authenticator
import androidx.compose.foundation.layout.Column
import androidx.compose.material3.Button
import com.amplifyframework.core.Amplify
//highlight-end

class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            MyAmplifyAppTheme {
                // A surface container using the 'background' color from the theme
                Surface(
                    modifier = Modifier.fillMaxSize(),
                    color = MaterialTheme.colorScheme.background
                )
                //highlight-start
                {
                    Authenticator { state ->
                        Column {
                            Text(
                                text = "Hello ${state.user.username}!",
                            )
                            Button(onClick = {
                                Amplify.Auth.signOut {  }
                            }) {
                                Text(text = "Sign Out")
                            }
                        }
                    }
                }
                //highlight-end
            }
        }
    }
}
```

Now if you run the application on the Android emulator, you should see the authentication flow working.

<Video width="40%" src="/images/gen2/getting-started/android/android-getting-started-1.mp4" description="Video - Authentication Demo" />

### 7. Read and write data

The initial scaffolding already has a pre-configured data backend defined in the `amplify/data/resource.ts` file. The default example will create a Todo model with `content` field.

Amplify can automatically generate code for interacting with the backend API. The command below generates model classes from the Data schema:


<Accordion title='Looking for your App ID?' headingLevel='4' eyebrow='Find your App ID in the Amplify Console'>
In the command below, replace the APP-ID with your Amplify app ID. Find this in the Amplify Console.
![image](images/gen2/getting-started/appid.png)
</Accordion>


```bash title="Terminal" showLineNumbers={false}
cd my-android-app
npx @aws-amplify/backend-cli generate graphql-client-code --format modelgen --model-target java --out app/src/main/java --app-id <your-amplify-app-id> --branch main
```

Once you are done, add the following dependencies to your project:

```kotlin title="build.gradle.kts"
dependencies {
    // Amplify API dependencies
    // highlight-start
    implementation("com.amplifyframework:aws-api:ANDROID_VERSION")
    // highlight-end
    // ... other dependencies
}
```

After adding the dependencies, open the `MyAmplifyApp` class and add the following line before the `configure` call:

```kotlin title="MyAmplifyApp.kt"

// highlight-next-line
import com.amplifyframework.api.aws.AWSApiPlugin

..
// highlight-next-line
Amplify.addPlugin(AWSApiPlugin())
```

Update the `MainActivity` class with the following code to create new to-do items. The `onClick` function will create a new Todo item.

```kt title="MainActivity"

class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            MyAmplifyAppTheme {
                // A surface container using the 'background' color from the theme
                Surface(
                    modifier = Modifier.fillMaxSize(),
                    color = MaterialTheme.colorScheme.background
                ) {
                    Authenticator { state ->
                        Column {
                            Text(
                                text = "Hello ${state.user.username}!",
                            )
                            // highlight-start
                            Button(onClick = {
                                val todo = Todo.builder()
                                    .content("My first todo")
                                    .build()

                                Amplify.API.mutate(
                                    ModelMutation.create(todo),
                                    { Log.i("MyAmplifyApp", "Added Todo with id: ${it.data.id}")},
                                    { Log.e("MyAmplifyApp", "Create failed", it)},
                                )
                            }) {
                                Text(text = "Create Todo")
                            }
                            // highlight-end
                            Button(onClick = {
                                Amplify.Auth.signOut {  }
                            }) {
                                Text(text = "Sign Out")
                            }
                        }
                    }
                }
            }
        }
    }
}
```

Now it is time to add a logic to view the added items.

```kt title="MainActivity.kt"
@Composable
fun TodoList() {
    var todoList by remember { mutableStateOf(emptyList<Todo>()) }

    LaunchedEffect(Unit) {
        // API request to list all Todos
        Amplify.API.query(
            ModelQuery.list(Todo::class.java),
            { todoList = it.data.items.toList() },
            { Log.e("MyAmplifyApp", "Failed to query.", it) }
        )
    }

    LazyColumn {
        items(todoList) { todo ->
            Row {
                // Render your activity item here
                Text(text = todo.content)
            }
        }
    }
}
```

Now call `TodoList()` from the `onCreate()` function:

```kt title="MainActivity.kt"
setContent {
    MyAmplifyAppTheme {
        // A surface container using the 'background' color from the theme
        Surface(
            modifier = Modifier.fillMaxSize(),
            color = MaterialTheme.colorScheme.background
        ) {
            Authenticator { state ->
                Column {
                    Text(
                        text = "Hello ${state.user.username}!",
                    )
                    ....
                    //highlight-next-line
                    TodoList()
```

### 8. Enable real-time data

If you build and rerun the application, you should see the todo that was created in the previous build. But notice how when you click on the "create Todo" button, it doesn't add any new todos to the list below until the next time your app relaunches. To solve this, let's add real-time updates to the todo list.

To add real-time updates, you can use the subscription feature of Amplify Data. It allows to subscribe to `onCreate`, `onUpdate`, and `onDelete` events of the application. In our example, let's append the list every time a new todo is added.

```kt title="MainActivity.kt"
@Composable
fun TodoList() {
    var todoList by remember { mutableStateOf(emptyList<Todo>()) }

    LaunchedEffect(Unit) {
        Amplify.API.query(
            ModelQuery.list(Todo::class.java),
            { todoList = it.data.items.toList() },
            { Log.e("MyAmplifyApp", "Failed to query.", it) }
        )
        // highlight-start
        Amplify.API.subscribe(
            ModelSubscription.onCreate(Todo::class.java),
            { Log.i("ApiQuickStart", "Subscription established") },
            {
                Log.i("ApiQuickStart", "Todo create subscription received: ${it.data}")
                todoList = todoList + it.data
            },
            { Log.e("ApiQuickStart", "Subscription failed", it) },
            { Log.i("ApiQuickStart", "Subscription completed") }
        )
        // highlight-end
    }

    LazyColumn {
        items(todoList) { todo ->
            Row {
                // Render your activity item here
                Text(text = todo.content)
            }
        }
    }
}
```


## Make backend updates

Let's update our backend to implement per-user authorization rules, allowing each user to only access their own to-dos.

### 9. Implement per-user authorization

First, clone the deployed repository.

```bash title="Terminal" showLineNumbers={false}
git clone https://github.com/<github-user>/amplify-backend-template.git
cd amplify-backend-template
npm install
```
The backend to-do model is configured to share data across all users, but, in most cases, you want data to be isolated on a per-user basis.

To isolate the data on a per-user basis, you can use an "owner-based authorization rule". Let's apply the owner-based authorization rule to your to-do items:

```ts title="amplify/data/resource.ts"
import { type ClientSchema, a, defineData } from '@aws-amplify/backend';

const schema = a.schema({
  Todo: a.model({
    content: a.string(),
    // highlight-next-line
  }).authorization(allow => [allow.owner()]),
});

export type Schema = ClientSchema<typeof schema>;

export const data = defineData({
  schema,
  authorizationModes: {
    // This tells the data client in your app (generateClient())
    // to sign API requests with the user authentication token.
    // highlight-next-line
    defaultAuthorizationMode: 'userPool',
  },
});
```
Commit this change to your git repository. Amplify's CI/CD system will automatically pick up the changes and build and deploy the updates.


```bash title="Terminal" showLineNumbers={false}
git commit -am "added per-user data isolation"
git push
```
### 10. Test in app

Now, let's go back to your Android application and test out the user isolation of the to-do items. Fetch the latest `amplify_outputs.json` and model files by re-running the following command in your Android Studio terminal.

<Accordion title='Looking for your App ID?' headingLevel='4' eyebrow='Find your App ID in the Amplify Console'>
In the command below, replace the APP-ID with your Amplify app ID. Find this in the Amplify Console.

![image](images/gen2/getting-started/appid.png)
</Accordion>

```bash showLineNumbers={false}
npx @aws-amplify/backend-cli generate graphql-client-code --format modelgen --model-target java --out app/src/main/java --app-id <your-amplify-app-id> --branch main
```

Also update your `amplify_outputs` file with the latest outputs information.

```bash showLineNumbers={false}
npx @aws-amplify/backend-cli generate outputs --out-dir app/src/main/res/raw --app-id <your-amplify-app-id> --branch main
```


</InlineFilter>









<InlineFilter filters={['react-native']}>
## Prerequisites

Before you get started, make sure you have the following installed:

- [Node.js](https://nodejs.org/) v18.17 or later
- [npm](https://www.npmjs.com/) v9 or later
- [git](https://git-scm.com/) v2.14.1 or later
- You will also need to [create an AWS Account](https://portal.aws.amazon.com/billing/signup). Note that AWS Amplify is part of the [AWS Free Tier](https://aws.amazon.com/amplify/pricing/).
- Configure your AWS account to use with Amplify [instructions](/[platform]/start/account-setup/).


This Quickstart guide will walk you through how to build a Todo application for Android or iOS using [Expo](https://expo.dev/)'s TypeScript template.

<Callout warning>

**Warning:** React Native for Web is not officially supported yet, but we are working towards official support. We are tracking the progress in [issue #13918 on GitHub](https://github.com/aws-amplify/amplify-js/issues/13918)

</Callout>

<Callout>

Amplify now requires native modules not available through the Expo SDK. As a result, Expo Go is no longer supported but you should still be able to use Expo. [Learn more about dropping support for Expo Go in Amplify v6](/gen1/react-native/build-a-backend/troubleshooting/migrate-from-javascript-v5-to-v6/).

</Callout>

```bash title="Terminal" showLineNumbers={false}
npx create-expo-app my_amplify_app -t expo-template-blank-typescript
cd my_amplify_app
```

<Callout warning>
For calling native libraries and platform dependencies, you need to have run the prebuild command for generating the folders for depending platforms.

```bash title="Terminal" showLineNumbers={false}
npx expo prebuild
```
</Callout>

## Create Backend

The easiest way to get started with AWS Amplify is through npm with `create-amplify` command. You can run it from your base project directory.

```bash title="Terminal" showLineNumbers={false}
cd my_amplify_app
npm create amplify@latest
? Where should we create your project? (.) # press enter
```

Running this command will scaffold Amplify backend files in your current project with the following files added:

```text
├── amplify/
│   ├── auth/
│   │   └── resource.ts
│   ├── data/
│   │   └── resource.ts
│   ├── backend.ts
│   └── package.json
├── node_modules/
├── .gitignore
├── package-lock.json
├── package.json
└── tsconfig.json
```

To deploy your backend use Amplify's per-developer cloud sandbox. This feature provides a separate backend environment for every developer on a team, ideal for local development and testing. To run your application with a sandbox environment, you can run the following command:

```bash title="Terminal" showLineNumbers={false}
npx ampx sandbox
```

### Adding Authentication

The initial scaffolding already has a pre-configured auth backend defined in the `amplify/auth/resource`.ts file. We've configured it to support email and password login but you can extend it to support a variety of login mechanisms, including Google, Amazon, Sign In With Apple, and Facebook.

The fastest way to get your login experience up and running is to use our Authenticator UI component available in the Amplify UI library.

To use the Authenticator, you need to add the following dependencies to your project:

```bash title="Terminal" showLineNumbers={false}
npm add \
  @aws-amplify/ui-react-native \
  @aws-amplify/react-native \
  aws-amplify \
  @react-native-community/netinfo \
  @react-native-async-storage/async-storage \
  react-native-safe-area-context@^4.2.5 \
  react-native-get-random-values \
  react-native-url-polyfill
```

Then install the iOS cocoapods for targeting iOS by running:

```bash title="Terminal" showLineNumbers={false}
npx pod-install
```

Next, update the `App.tsx` file with the following:

```typescript
import React from "react";
import { Button, View, StyleSheet } from "react-native";

import { Amplify } from "aws-amplify";
import { Authenticator, useAuthenticator } from "@aws-amplify/ui-react-native";

import outputs from "./amplify_outputs.json";

Amplify.configure(outputs);

const SignOutButton = () => {
  const { signOut } = useAuthenticator();

  return (
    <View style={styles.signOutButton}>
      <Button title="Sign Out" onPress={signOut} />
    </View>
  );
};

const App = () => {
  return (
    <Authenticator.Provider>
      <Authenticator>
        <SignOutButton />
      </Authenticator>
    </Authenticator.Provider>
  );
};

const styles = StyleSheet.create({
  signOutButton: {
    alignSelf: "flex-end",
  },
});

export default App;
```

The Authenticator component auto-detects your auth backend settings and renders the correct UI state based on the auth backend's authentication flow.


Run your application in your local environment again. You should be presented with a login experience now.

<Video src="/images/gen2/getting-started/reactnative/reactnative-getting-started-1.mp4" description="Video - Authentication Demo" />

## Adding Data

The initial scaffolding already has a pre-configured data backend defined in the `amplify/data/resource.ts` file. The default example will create a Todo model with `content` field.

Let's modify this to add the following:
- A boolean `isDone` field.
- An authorization rules specifying owners, authenticated via your Auth resource can "create", "read", "update", and "delete" their own records.
- Update the `defaultAuthorizationMode` to sign API requests with the user authentication token.

```typescript
import { type ClientSchema, a, defineData } from '@aws-amplify/backend';

const schema = a.schema({
  Todo: a
    .model({
      content: a.string(),
      isDone: a.boolean()
    })
    .authorization(allow => [allow.owner()])
});

export type Schema = ClientSchema<typeof schema>;

export const data = defineData({
  schema,
  authorizationModes: {
    defaultAuthorizationMode: 'userPool'
  }
});
```

Next, let's implement UI to create, list, and delete the to-do items. Create a `src` folder, and within the folder, create a new file called `TodoList.tsx`. This page will contain information about creating, reading, updating, and deleting Todo items.

Copy and paste the following code into the file:

```typescript
import { useState, useEffect } from "react";
import { View, Button, Text, StyleSheet, FlatList } from "react-native";

import { generateClient } from "aws-amplify/data";
import type { Schema } from "../amplify/data/resource";
import { GraphQLError } from "graphql";
const client = generateClient<Schema>();

const TodoList = () => {
  const dateTimeNow = new Date();
  const [todos, setTodos] = useState<Schema["Todo"]["type"][]>([]);
  const [errors, setErrors] = useState<GraphQLError>();

  useEffect(() => {
    const sub = client.models.Todo.observeQuery().subscribe({
      next: ({ items }) => {
        setTodos([...items]);
      },
    });

    return () => sub.unsubscribe();
  }, []);

  const createTodo = async () => {
    try {
      await client.models.Todo.create({
        content: `${dateTimeNow.getUTCMilliseconds()}`,
      });
    } catch (error: unknown) {
      if (error instanceof GraphQLError) {
        setErrors(error);
      } else {
        throw error;
      }
    }
  };

  if (errors) {
    return <Text>{errors.message}</Text>;
  }

  const renderItem = ({ item }: { item: Schema["Todo"]["type"] }) => (
    <TodoItem {...item} />
  );
  return (
    <View style={{ flex: 1 }}>
      <FlatList
        data={todos}
        renderItem={renderItem}
        keyExtractor={(item) => item.id}
        ItemSeparatorComponent={() => (
          <View style={styles.listItemSeparator} />
        )}
        ListEmptyComponent={() => <Text>The todo list is empty.</Text>}
        style={styles.listContainer}
      ></FlatList>
      <Button onPress={createTodo} title="Create Todo" />
    </View>
  );
};

const TodoItem = (todo: Schema["Todo"]["type"]) => (
  <View style={styles.todoItemContainer} key={todo.id}>
    <Text
      style={{
        ...styles.todoItemText,
        textDecorationLine: todo.isDone ? "line-through" : "none",
        textDecorationColor: todo.isDone ? "red" : "black",
      }}
    >
      {todo.content}
    </Text>
    <Button
      onPress={async () => {
        await client.models.Todo.delete(todo);
      }}
      title="Delete"
    />
    <Button
      onPress={() => {
        client.models.Todo.update({
          id: todo.id,
          isDone: !todo.isDone,
        });
      }}
      title={todo.isDone ? "Undo" : "Done"}
    />
  </View>
);

const styles = StyleSheet.create({
  todoItemContainer: { flexDirection: "row", alignItems: "center", padding: 8 },
  todoItemText: { flex: 1, textAlign: "center" },
  listContainer: { flex: 1, alignSelf: "stretch", padding:8 },
  listItemSeparator: { backgroundColor: "lightgrey", height: 2 },
});

export default TodoList;
```

With the code above, you can create a random todo item and display todo items in a list. You can mark them as done, update the list, or revert that operation. You can also delete the items. Each change in the list is listened to with the subscription and immediately shown on the screen.

If we take a closer look at the code:
- `generateClient` generates the necessary files and folders for models.
- `TodoList` component includes the subscription, creation operations, and a list to hold created items.
- `TodoItem` holds the information about each todo item.

Lastly, update the `App` component in `App.tsx` as follows:

```typescript
const App = () => {
  return (
    <Authenticator.Provider>
      <Authenticator>
        <SafeAreaView style={styles.container}>
          <SignOutButton />
          <TodoList />
        </SafeAreaView>
      </Authenticator>
    </Authenticator.Provider>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    padding: 8,
  },
  signOutButton: {
    alignSelf: "flex-end",
  },
});
```

If you run the application now, you should see the following behavior:

<Video src="/images/gen2/getting-started/reactnative/reactnative-getting-started-2.mp4" description="Video - Delete Demo" />

You can terminate the sandbox environment now to clean up the project.

### Publishing changes to cloud

Publishing changes to the cloud requires a remote git repository. Amplify offers fullstack branch deployments that allow you to automatically deploy infrastructure and application code changes from feature branches. To learn more, visit the [fullstack branch deployments guide](/[platform]/deploy-and-host/fullstack-branching/branch-deployments).

</InlineFilter>

<InlineFilter filters={["javascript", "react-native", "angular", "react", "vue", "android", "swift", "flutter"]}>

## 🥳 Success

That's it! You have successfully built a fullstack app on AWS Amplify. If you want to learn more about how to work with Amplify, here's the conceptual guide for [how Amplify works](/[platform]/how-amplify-works/concepts/).

</InlineFilter>


Contents of start_quickstart_nextjs-app-router-client-components_index.txt:
import { getCustomStaticPath } from '@/utils/getCustomStaticPath';
import { IconGithub } from '@/components/Icons/IconGithub'
import { IconAmplify } from '@/components/Icons/IconAmplify'

export const meta = {
  title: 'Next.js App Router',
  description: 'Get started with AWS Amplify Gen 2 using the Next.js App Router.',
  platforms: [
    'nextjs'
  ]
};

export const getStaticPaths = async () => {
  return getCustomStaticPath(meta.platforms);
};

export function getStaticProps(context) {
  return {
    props: {
      platform: context.params.platform,
      meta
    }
  };
}

## Pre-requisites

This Quickstart guide will walk you through how to build a task list application with TypeScript, Next.js **App Router with Client Components**, and React. Before you begin, make sure you have the following installed:

- [Node.js](https://nodejs.org/) v14.x or later
- [npm](https://www.npmjs.com/) v6.14.4 or later
- [git](https://git-scm.com/) v2.14.1 or later
- If you are new to these technologies, we recommend you go through the official [React](https://react.dev/learn/tutorial-tic-tac-toe), [Next.js](https://nextjs.org/docs/app/getting-started), and [TypeScript](https://www.typescriptlang.org/docs/handbook/typescript-from-scratch.html) tutorials first.

## Deploy a fullstack app to AWS

We've created a starter "To-do" application to help get started faster. First, you will create a repository in your GitHub account using our starter Next template.

### 1. Create the repository

Use our starter template to create a repository in your GitHub account. This template scaffolds `create-next-app` with Amplify backend capabilities.

<ExternalLinkButton
  size="medium"
  href='https://github.com/new?template_name=amplify-next-template&template_owner=aws-samples&name=amplify-next-template&description=My%20Amplify%20Gen%202%20starter%20application'
>
<IconGithub />
Create repository from template
</ExternalLinkButton>

Use the form in GitHub to finalize your repo's creation.

### 2. Deploy the starter app

Now that the repository has been created, deploy it with Amplify.

<ExternalLinkButton
  size="medium"
  variation="primary"
  href='https://console.aws.amazon.com/amplify/create/repo-branch'
>
<IconAmplify />
Deploy to AWS
</ExternalLinkButton>

Select **Start with an existing app** > **GitHub**. After you give Amplify access to your GitHub account via the popup window, pick the repository and `main` branch to deploy. Make no other changes and click through the flow to **Save and deploy**.

<Video src="/images/gen2/getting-started/react/deploy.mp4" description="Video - Connect GitHub" />

### 3. View deployed app

<Accordion title='Learn about the project structure' headingLevel='4' eyebrow='While you are waiting for your app to deploy (~5 mins)'>

Let's take a tour of the project structure in this starter repository by opening it on GitHub. The starter application has pre-written code for a to-do list app. It gives you a real-time database with a feed of all to-do list items and the ability to add new items. 

```text
├── amplify/ # Folder containing your Amplify backend configuration
│   ├── auth/ # Definition for your auth backend
│   │   └── resource.tsx
│   ├── data/ # Definition for your data backend
│   │   └── resource.ts
|   ├── backend.ts
│   └── tsconfig.json
├── src/ # React UI code
│   ├── App.tsx # UI code to sync todos in real-time
│   ├── index.css # Styling for your app
│   └── main.tsx # Entrypoint of the Amplify client library
├── package.json
└── tsconfig.json
```
</Accordion>

 When the build completes, visit the newly deployed branch by selecting "View deployed URL". Since the build deployed an API, database, and authentication backend, you will be able to create new to-do items.

<Video src="/images/gen2/getting-started/react/hosted-app.mp4" description="Video - View Deployed URL" />

In the Amplify console, click into the deployment branch (in this case **main**) > select **Data** in the left-hand menu > **Data manager** to see the data entered in your database.

<Video src="/images/gen2/getting-started/amplify-console-data-manager.mp4" description="Video - Data Manager" />

## Make frontend updates

Let's learn how to enhance the app functionality by creating a delete flow for to-do list items. 

### 4. Set up local environment

Now let's set up our local development environment to add features to the frontend. Click on your deployed branch and you will land on the **Deployments** page which shows you your build history and a list of deployed backend resources.

<Video src="/images/gen2/getting-started/react/branch-details.mp4" description="Video - Deployments" />

At the bottom of the page you will see a tab for **Deployed backend resources**. Click on the tab and then click the **Download amplify_outputs.json file** button. 

![](/images/gen2/getting-started/react/amplify-outputs-download.png)

Clone the repository locally.

```bash title="Terminal" showLineNumbers={false}
git clone https://github.com/<github-user>/amplify-next-template.git
cd amplify-next-template && npm install
```

Now move the `amplify_outputs.json` file you downloaded above to the root of your project.

```text
├── amplify
├── src
├── amplify_outputs.json <== backend outputs file
├── package.json
└── tsconfig.json
```

<Accordion title='amplify_outputs.json' headingLevel='4' eyebrow='Learn more'>
The **amplify_outputs.json** file contains backend endpoint information, publicly-viewable API keys, authentication flow information, and more. The Amplify client library uses this outputs file to connect to your Amplify Backend.  You can review how the outputs file is imported within the `main.tsx` file and then passed into the `Amplify.configure(...)` function of the Amplify client library. 
</Accordion>

### 5. Implement delete functionality

Go to the **app/page.tsx** file and add in a new `deleteTodo` functionality and pass function into the `<li>` element's `onClick` handler.

```tsx title="app/page.tsx"
function App() {
  // ...
  // highlight-start
  function deleteTodo(id: string) {
    client.models.Todo.delete({ id })
  }
  // highlight-end

  return (
    <main>
      <h1>My todos</h1>
      <button onClick={createTodo}>+ new</button>
      <ul>
        {todos.map(todo => <li
          // highlight-next-line
          onClick={() => deleteTodo(todo.id)}
          key={todo.id}>
          {todo.content}
        </li>)}
      </ul> 
      <div>
        🥳 App successfully hosted. Try creating a new todo.
        <br />
        <a href="https://docs.amplify.aws/nextjs/start/quickstart/nextjs-app-router-client-components/">Review next step of this tutorial.</a>
      </div>
    </main>
  )
}
```
<Accordion title="See the complete amplify/data/resources.ts">

Open the `amplify/data/resource.ts` file in your text editor, and you will see a default data model generated for you.

```ts showLineNumbers title="amplify/data/resource.ts"
import { type ClientSchema, a, defineData } from '@aws-amplify/backend';

const schema = a.schema({
  Todo: a
    .model({
      content: a.string()
    })
    .authorization(allow => [allow.owner(), allow.publicApiKey().to(['read'])])
});

export type Schema = ClientSchema<typeof schema>;

export const data = defineData({
  schema,
  authorizationModes: {
    defaultAuthorizationMode: 'apiKey',
    // API Key is used for allow.publicApiKey() rules
    apiKeyAuthorizationMode: {
      expiresInDays: 30
    }
  }
});
```

  The schema generated by Amplify is for a to-do app. A schema is a blueprint
  for how our app's data will be organized. Within the schema, we will define
  models that will correspond to a database table—`Todo` in the above code.
  Finally, we will define fields, which are attributes that each data instance
  will have—in the generated code, the field is `content`. Each
  field will have a type attached to it—in the above examples, we are stating
  that the `content` field is a string.
</Accordion>

Try out the deletion functionality now by starting the local dev server:

```bash title="Terminal" showLineNumbers={false}
npm run dev
```

This should start a local dev server at http://localhost:3000.

<Video src="/images/gen2/getting-started/react/demo-delete.mp4" description="Video - Demo" />

### 6. Implement login UI

The starter application already has a pre-configured auth backend defined in the **amplify/auth/resource.ts** file. We've configured it to support email and password login but you can extend it to support a variety of login mechanisms, including Google, Amazon, Sign In With Apple, and Facebook.

The fastest way to get your login experience up and running is to use our Authenticator UI component. In your **app/layout.tsx** file, import the Authenticator UI component and wrap the children or pages components.


```tsx title="app/layout.tsx"
"use client"

import React from "react";
import { Amplify } from "aws-amplify";
import "./app.css";
// highlight-start
import { Authenticator } from "@aws-amplify/ui-react";
import "@aws-amplify/ui-react/styles.css";
// highlight-end
import outputs from "@/amplify_outputs.json";

Amplify.configure(outputs);

export default function RootLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  return (
    // highlight-start
    <html lang="en">
      <body>      
        <Authenticator>
          {children}
        </Authenticator>
      </body>
    </html>
    // highlight-end
  );
}
```

The Authenticator component auto-detects your auth backend settings and renders the correct UI state based on the auth backend's authentication flow.

In your **app/page.tsx** file, add a button to enable users to sign out of the application. Import the [`useAuthenticator`](https://ui.docs.amplify.aws/react/connected-components/authenticator/advanced#access-auth-state) hook from the Amplify UI library to hook into the state of the Authenticator.

```tsx title="app/page.tsx"
import type { Schema } from "@/amplify/data/resource";
// highlight-next-line
import { useAuthenticator } from "@aws-amplify/ui-react";
import { useState, useEffect } from "react";
import { generateClient } from "aws-amplify/data";

const client = generateClient<Schema>();

export default function HomePage() {

  // highlight-start
  const { signOut } = useAuthenticator();
  // highlight-end

  // ...

  return (
    <main>
      {/* ... */}
      // highlight-next-line
      <button onClick={signOut}>Sign out</button>
    </main>
  );
}
```

Try out your application in your localhost environment again. You should be presented with a login experience now.

<Video src="/images/gen2/getting-started/react/demo-auth.mp4" description="Video - Authentication Demo" />

To get these changes to the cloud, commit them to git and push the changes upstream.

```bash title="Terminal" showLineNumbers={false}
git commit -am "added authenticator"
git push
```

Amplify automatically deploys the latest version of your app based on your git commits. In just a few minutes, when the application rebuilds, the hosted app will be updated to support the deletion functionality.

## Make backend updates

Let's update our backend to implement per-user authorization rules, allowing each user to only access their own to-dos.

### 7. Set up local AWS credentials

To make backend updates, we are going to require AWS credentials to deploy backend updates from our local machine. 

**Skip ahead to step 8**, if you already have an AWS profile with credentials on your local machine, and your AWS profile has the `AmplifyBackendDeployFullAccess` permission policy.

Otherwise, **[set up local AWS credentials](/[platform]/start/account-setup/)** that grant Amplify permissions to deploy backend updates from your local machine.


### 8. Deploy cloud sandbox

To update your backend without affecting the production branch, use Amplify's cloud sandbox. This feature provides a separate backend environment for each developer on a team, ideal for local development and testing.

To start your cloud sandbox, run the following command in a **new Terminal window**:

```bash title="Terminal" showLineNumbers={false}
npx ampx sandbox
```

Once the cloud sandbox has been fully deployed (~5 min), you'll see the `amplify_outputs.json` file updated with connection information to a new isolated authentication and data backend.

<Callout info>

The `npx ampx sandbox` command should run concurrently to your `npm run dev`. You can think of the cloud sandbox as the "localhost-equivalent for your app backend".

</Callout>

### 9. Implement per-user authorization

The to-do items in the starter are currently shared across all users, but, in most cases, you want data to be isolated on a per-user basis. 

To isolate the data on a per-user basis, you can use an "owner-based authorization rule". Let's apply the owner-based authorization rule to your to-do items:

```ts title="amplify/data/resource.ts"
import { type ClientSchema, a, defineData } from '@aws-amplify/backend';

const schema = a.schema({
  Todo: a.model({
    content: a.string(),
    // highlight-next-line
  }).authorization(allow => [allow.owner()]),
});

export type Schema = ClientSchema<typeof schema>;

export const data = defineData({
  schema,
  authorizationModes: {
    // This tells the data client in your app (generateClient())
    // to sign API requests with the user authentication token. 
    // highlight-next-line
    defaultAuthorizationMode: 'userPool',
  },
});
```

In the application client code, let's also render the username to distinguish different users once they're logged in. Go to your **app/page.tsx** file and render the `user` property from the `useAuthenticator` hook.

```tsx title="app/page.tsx"
// ... imports

function HomePage() {
  // highlight-next-line
  const { user, signOut } = useAuthenticator();
  
  // ...
  
  return (
    <main>
      // highlight-next-line
      <h1>{user?.signInDetails?.loginId}'s todos</h1>
      {/* ... */}
    </main>
  )
}
```

Now, let's go back to your local application and test out the user isolation of the to-do items. 

You will need to sign up new users again because now you're working with the cloud sandbox instead of your production backend.

<Video src="/images/gen2/getting-started/react/demo-auth.mp4" description="Video - Authentication Demo" />

To get these changes to the cloud, commit them to git and push the changes upstream.

```bash title="Terminal" showLineNumbers={false}
git commit -am "added per-user data isolation"
git push
```

Once your build completes in the Amplify Console, the `main` backend will update to support the changes made within the cloud sandbox. The data in the cloud sandbox is fully isolated and won't pollute your production database.

## 🥳 Success

That's it! You have successfully built a fullstack app on AWS Amplify. If you want to learn more about how to work with Amplify, here's the conceptual guide for [how Amplify works](/[platform]/how-amplify-works/concepts/).


Contents of start_quickstart_nextjs-pages-router_index.txt:
import { getCustomStaticPath } from '@/utils/getCustomStaticPath';
import { IconGithub } from '@/components/Icons/IconGithub'
import { IconAmplify } from '@/components/Icons/IconAmplify'

export const meta = {
  title: 'Next.js Pages Router',
  description: 'Get started with AWS Amplify Gen 2 using the Next.js Pages Router.',
  platforms: [
    'nextjs'
  ]
};

export const getStaticPaths = async () => {
  return getCustomStaticPath(meta.platforms);
};

export function getStaticProps(context) {
  return {
    props: {
      platform: context.params.platform,
      meta
    }
  };
}


## Pre-requisites

This Quickstart guide will walk you through how to build a task list application with TypeScript, Next.js **Pages Router with Client Components**, and React. Before you begin, make sure you have the following installed:

- [Node.js](https://nodejs.org/) v14.x or later
- [npm](https://www.npmjs.com/) v6.14.4 or later
- [git](https://git-scm.com/) v2.14.1 or later
- If you are new to these technologies, we recommend you go through the official [React](https://react.dev/learn/tutorial-tic-tac-toe), [Next.js](https://nextjs.org/docs/pages/getting-started), and [TypeScript](https://www.typescriptlang.org/docs/handbook/typescript-from-scratch.html) tutorials first.

## Deploy a fullstack app to AWS

We've created a starter "To-do" application to help get started faster. First, you will create a repository in your GitHub account using our starter Next (Pages) template.

### 1. Create the repository

Use our starter template to create a repository in your GitHub account. This template scaffolds `create-next-app` with Amplify backend capabilities.

<ExternalLinkButton
  size="medium"
  href='https://github.com/new?template_name=amplify-next-pages-template&template_owner=aws-samples&name=amplify-next-pages-template&description=My%20Amplify%20Gen%202%20starter%20application'
>
<IconGithub />
Create repository from template
</ExternalLinkButton>

Use the form in GitHub to finalize your repo's creation.

### 2. Deploy the starter app

Now that the repository has been created, deploy it with Amplify.

<ExternalLinkButton
  size="medium"
  variation="primary"
  href='https://console.aws.amazon.com/amplify/create/repo-branch'
>
<IconAmplify />
Deploy to AWS
</ExternalLinkButton>

Select **Start with an existing app** > **GitHub**. After you give Amplify access to your GitHub account via the popup window, pick the repository and `main` branch to deploy. Make no other changes and click through the flow to **Save and deploy**.

<Video src="/images/gen2/getting-started/react/deploy.mp4" description="Video - Save and Deploy" />

### 3. View deployed app

<Accordion title='Learn about the project structure' headingLevel='4' eyebrow='While you are waiting for your app to deploy (~5 mins)'>

Let's take a tour of the project structure in this starter repository by opening it on GitHub. The starter application has pre-written code for a to-do list app. It gives you a real-time database with a feed of all to-do list items and the ability to add new items. 

```text
├── amplify/ # Folder containing your Amplify backend configuration
│   ├── auth/ # Definition for your auth backend
│   │   └── resource.tsx
│   ├── data/ # Definition for your data backend
│   │   └── resource.ts
|   ├── backend.ts
│   └── tsconfig.json
├── src/ # React UI code
│   ├── App.tsx # UI code to sync todos in real-time
│   ├── index.css # Styling for your app
│   └── main.tsx # Entrypoint of the Amplify client library
├── package.json
└── tsconfig.json
```
</Accordion>

 When the build completes, visit the newly deployed branch by selecting "View deployed URL". Since the build deployed an API, database, and authentication backend, you will be able to create new to-do items.

<Video src="/images/gen2/getting-started/react/hosted-app.mp4" description="Video - View Deployed URL" />

In the Amplify console, click into the deployment branch (in this case **main**) > select **Data** in the left-hand menu > **Data manager** to see the data entered in your database.

<Video src="/images/gen2/getting-started/amplify-console-data-manager.mp4" description="Video - Data Manager" />


## Make frontend updates

Let's learn how to enhance the app functionality by creating a delete flow for to-do list items. 

### 4. Set up local environment

Now let's set up our local development environment to add features to the frontend. Click on your deployed branch and you will land on the **Deployments** page which shows you your build history and a list of deployed backend resources.

<Video src="/images/gen2/getting-started/react/branch-details.mp4" description="Video - Deployments" />

At the bottom of the page you will see a tab for **Deployed backend resources**. Click on the tab and then click the **Download amplify_outputs.json file** button. 

![](/images/gen2/getting-started/react/amplify-outputs-download.png)

Clone the repository locally.

```bash title="Terminal" showLineNumbers={false}
git clone https://github.com/<github-user>/amplify-next-template.git
cd amplify-next-template && npm install
```

Now move the `amplify_outputs.json` file you downloaded above to the root of your project.

```text
├── amplify
├── src
├── amplify_outputs.json <== backend outputs file
├── package.json
└── tsconfig.json
```

<Accordion title='amplify_outputs.json' headingLevel='4' eyebrow='Learn more'>
The **amplify_outputs.json** file contains backend endpoint information, publicly-viewable API keys, authentication flow information, and more. The Amplify client library uses this outputs file to connect to your Amplify Backend.  You can review how the outputs file is imported within the `main.tsx` file and then passed into the `Amplify.configure(...)` function of the Amplify client library. 
</Accordion>

### 5. Implement delete functionality

Go to the **pages/index.tsx** file and add in a new `deleteTodo` functionality and pass function into the `<li>` element's `onClick` handler.

```tsx title="pages/index.tsx"
function App() {
  // ...
  // highlight-start
  function deleteTodo(id: string) {
    client.models.Todo.delete({ id })
  }
  // highlight-end

  return (
    <main>
      <h1>My todos</h1>
      <button onClick={createTodo}>+ new</button>
      <ul>
        {todos.map(todo => <li
          // highlight-next-line
          onClick={() => deleteTodo(todo.id)}
          key={todo.id}>
          {todo.content}
        </li>)}
      </ul> 
      <div>
        🥳 App successfully hosted. Try creating a new todo.
        <br />
        <a href="https://docs.amplify.aws/nextjs/start/quickstart/nextjs-pages-router/">Review next step of this tutorial.</a>
      </div>
    </main>
  )
}
```
<Accordion title="See the complete amplify/data/resources.ts">

Open the `amplify/data/resource.ts` file in your text editor, and you will see a default data model generated for you.

```ts showLineNumbers title="amplify/data/resource.ts"
import { type ClientSchema, a, defineData } from '@aws-amplify/backend';

const schema = a.schema({
  Todo: a
    .model({
      content: a.string()
    })
    .authorization(allow => [allow.owner(), allow.publicApiKey().to(['read'])])
});

export type Schema = ClientSchema<typeof schema>;

export const data = defineData({
  schema,
  authorizationModes: {
    defaultAuthorizationMode: 'apiKey',
    // API Key is used for allow.publicApiKey() rules
    apiKeyAuthorizationMode: {
      expiresInDays: 30
    }
  }
});
```

  The schema generated by Amplify is for a to-do app. A schema is a blueprint
  for how our app's data will be organized. Within the schema, we will define
  models that will correspond to a database table—`Todo` in the above code.
  Finally, we will define fields, which are attributes that each data instance
  will have—in the generated code, the field is `content`. Each
  field will have a type attached to it—in the above examples, we are stating
  that the `content` field is a string.
</Accordion>

Try out the deletion functionality now by starting the local dev server:

```bash title="Terminal" showLineNumbers={false}
npm run dev
```

This should start a local dev server at http://localhost:3000.

<Video src="/images/gen2/getting-started/react/demo-delete.mp4" description="Video - Demo" />

### 6. Implement login UI

The starter application already has a pre-configured auth backend defined in the **amplify/auth/resource.ts** file. We've configured it to support email and password login but you can extend it to support a variety of login mechanisms, including Google, Amazon, Sign In With Apple, and Facebook.

The fastest way to get your login experience up and running is to use our Authenticator UI component. In your **pages/_app.tsx** file, import the Authenticator UI component and wrap your `<App>` component.

```tsx title="pages/_app.tsx"
import type { AppProps } from "next/app";
// highlight-start
import { Authenticator } from '@aws-amplify/ui-react'
import '@aws-amplify/ui-react/styles.css'
// highlight-end
import "@/styles/app.css";
import { Amplify } from "aws-amplify";
import outputs from "@/amplify_outputs.json";

Amplify.configure(outputs);

export default function App({ Component, pageProps }: AppProps) {
  return(
    // highlight-start
    <Authenticator>
      <Component {...pageProps} />;
    </Authenticator>
    // highlight-end
  ) 
}
```
<Accordion title="See the complete amplify/auth/resources.ts">

```ts title="amplify/auth/resource.ts"
import { defineAuth } from '@aws-amplify/backend';

/**
 * Define and configure your auth resource
 * When used alongside data, it is automatically configured as an auth provider for data
 * @see https://docs.amplify.aws/gen2/build-a-backend/auth
 */
export const auth = defineAuth({
  loginWith: {
    email: true,
    // add social providers
    externalProviders: {
      /**
       * first, create your secrets using `ampx sandbox secret`
       * then, import `secret` from `@aws-amplify/backend`
       * @see https://docs.amplify.aws/gen2/deploy-and-host/sandbox-environments/features/#setting-secrets
       */
      // loginWithAmazon: {
      //   clientId: secret('LOGINWITHAMAZON_CLIENT_ID'),
      //   clientSecret: secret('LOGINWITHAMAZON_CLIENT_SECRET'),
      // }
    }
  },
  /**
   * enable multifactor authentication
   * @see https://docs.amplify.aws/gen2/build-a-backend/auth/manage-mfa
   */
  // multifactor: {
  //   mode: 'OPTIONAL',
  //   sms: {
  //     smsMessage: (code) => `Your verification code is ${code}`,
  //   },
  // },
  userAttributes: {
    /** request additional attributes for your app's users */
    // profilePicture: {
    //   mutable: true,
    //   required: false,
    // },
  }
});
```
</Accordion>

The Authenticator component auto-detects your auth backend settings and renders the correct UI state based on the auth backend's authentication flow.

In your **pages/index.tsx** file, add a button to enable users to sign out of the application. Import the [`useAuthenticator`](https://ui.docs.amplify.aws/react/connected-components/authenticator/advanced#access-auth-state) hook from the Amplify UI library to hook into the state of the Authenticator.

```tsx title="pages/index.tsx"
import type { Schema } from "@/amplify/data/resource";
// highlight-next-line
import { useAuthenticator } from "@aws-amplify/ui-react";
import { useState, useEffect } from "react";
import { generateClient } from "aws-amplify/data";

const client = generateClient<Schema>();

export default function HomePage() {

  // highlight-start
  const { signOut } = useAuthenticator();
  // highlight-end

  // ...

  return (
    <main>
      {/* ... */}
      // highlight-next-line
      <button onClick={signOut}>Sign out</button>
    </main>
  );
}
```

Try out your application in your localhost environment again. You should be presented with a login experience now.

<Video src="/images/gen2/getting-started/react/demo-auth.mp4" description="Video - Authentication Demo" />

To get these changes to the cloud, commit them to git and push the changes upstream.

```bash title="Terminal" showLineNumbers={false}
git commit -am "added authenticator"
git push
```

Amplify automatically deploys the latest version of your app based on your git commits. In just a few minutes, when the application rebuilds, the hosted app will be updated to support the deletion functionality.

## Make backend updates

Let's update our backend to implement per-user authorization rules, allowing each user to only access their own to-dos.

### 7. Set up local AWS credentials

To make backend updates, we are going to require AWS credentials to deploy backend updates from our local machine. 

**Skip ahead to step 8**, if you already have an AWS profile with credentials on your local machine, and your AWS profile has the `AmplifyBackendDeployFullAccess` permission policy.

Otherwise, **[set up local AWS credentials](/[platform]/start/account-setup/)** that grant Amplify permissions to deploy backend updates from your local machine.


### 8. Deploy cloud sandbox

To update your backend without affecting the production branch, use Amplify's cloud sandbox. This feature provides a separate backend environment for each developer on a team, ideal for local development and testing.

To start your cloud sandbox, run the following command in a **new Terminal window**:

```bash title="Terminal" showLineNumbers={false}
npx ampx sandbox
```

Once the cloud sandbox has been fully deployed (~5 min), you'll see the `amplify_outputs.json` file updated with connection information to a new isolated authentication and data backend.

<Callout info>

The `npx ampx sandbox` command should run concurrently to your `npm run dev`. You can think of the cloud sandbox as the "localhost-equivalent for your app backend".

</Callout>

### 9. Implement per-user authorization

The to-do items in the starter are currently shared across all users, but, in most cases, you want data to be isolated on a per-user basis. 

To isolate the data on a per-user basis, you can use an "owner-based authorization rule". Let's apply the owner-based authorization rule to your to-do items:

```ts title="amplify/data/resource.ts"
import { type ClientSchema, a, defineData } from '@aws-amplify/backend';

const schema = a.schema({
  Todo: a.model({
    content: a.string(),
    // highlight-next-line
  }).authorization(allow => [allow.owner()]),
});

export type Schema = ClientSchema<typeof schema>;

export const data = defineData({
  schema,
  authorizationModes: {
    // This tells the data client in your app (generateClient())
    // to sign API requests with the user authentication token. 
    // highlight-next-line
    defaultAuthorizationMode: 'userPool',
  },
});
```

In the application client code, let's also render the username to distinguish different users once they're logged in. Go to your **pages/index.tsx** file and render the `user` property from the `useAuthenticator` hook.

```tsx title="pages/index.tsx"
// ... imports

function HomePage() {
  // highlight-next-line
  const { user, signOut } = useAuthenticator();

  // ...

  return (
    <main>
      // highlight-next-line
      <h1>{user?.signInDetails?.loginId}'s todos</h1>
      {/* ... */}
    </main>
  )
}
```

Now, let's go back to your local application and test out the user isolation of the to-do items. 

You will need to sign up new users again because now you're working with the cloud sandbox instead of your production backend.

<Video src="/images/gen2/getting-started/react/demo-auth.mp4" description="Video - Authentication Demo" />

To get these changes to the cloud, commit them to git and push the changes upstream.

```bash title="Terminal" showLineNumbers={false}
git commit -am "added per-user data isolation"
git push
```

Once your build completes in the Amplify Console, the `main` backend will update to support the changes made within the cloud sandbox. The data in the cloud sandbox is fully isolated and won't pollute your production database.

## 🥳 Success

That's it! You have successfully built a fullstack app on AWS Amplify. If you want to learn more about how to work with Amplify, here's the conceptual guide for [how Amplify works](/[platform]/how-amplify-works/concepts/).



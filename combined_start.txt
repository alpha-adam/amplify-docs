To configure AWS for local development with Amplify, you need to set up temporary credentials with IAM Identity Center and AWS Organizations. This will enable you to define single-sign-on (SSO), users, groups, permission sets, and more for your team.

If you already have an AWS account and profile configured locally, you don't need to follow this guide. Just add the AmplifyBackendDeployFullAccess IAM role to your configured AWS profile.

To set up Identity Center, follow these steps:

1. Create a user with Amplify permissions: Sign in to the AWS Console, enable IAM Identity Center, and create a user with the necessary permissions.
2. Create a password for the user: Reset the password for the user and choose a password.
3. Install the AWS CLI: Download and install the AWS CLI on your local machine.
4. Set up a local AWS profile: Configure an AWS profile that uses the SSO user.
5. Bootstrap your AWS account: Use the AWS profile with AWS Amplify and complete the bootstrapping process.

The bootstrapping process provisions resources for the AWS CDK, including an Amazon S3 bucket and IAM roles. This is a one-time setup that allows you to deploy AWS CDK apps into an AWS environment.

To complete the bootstrapping process, sign in to the AWS Management Console as the account root user or a user with AdministratorAccess permissions. Then, return to the terminal and create a new Amplify sandbox environment using the configured AWS profile.

Here's an example of how to create a user with Amplify permissions using the AWS CLI:
```bash
aws sso-admin create-user --identity-store-id <identity-store-id> --user-name amplify-admin --display-name 'Amplify Admin' --name Formatted=string,FamilyName=Admin,GivenName=Amplify --emails '{"Type":"Work","Value":"<email-address>"}'
```
And here's an example of how to configure an AWS profile that uses the SSO user:
```console
aws configure sso
SSO session name (Recommended): amplify-admin
SSO start URL: <START SESSION URL>
SSO region: <your-region>
SSO registration scopes [sso:account:access]: 
```
Note that you need to replace `<identity-store-id>`, `<email-address>`, `<START SESSION URL>`, and `<your-region>` with the actual values for your AWS account.

To connect your application to AWS resources such as AWS AppSync, Amazon Cognito, Amazon S3, and more, you can use Amplify client libraries. These libraries provide a flexible way to directly connect your application to AWS resources.

To get started, you need to configure the client libraries. This can be done by using the amplify_outputs.json file generated by the Amplify backend tooling. However, using the client libraries does not require backend resources to be created by Amplify.

For JavaScript-based applications, such as React, you can configure the client library by using the generated outputs file or by configuring the library directly by passing a configuration object. For example, to configure the client library for use with Amazon Cognito, you can specify the Auth configuration:

```javascript
import { Amplify } from "aws-amplify"

Amplify.configure({
  Auth: {
    Cognito: {
      userPoolId: "<your-cognito-user-pool-id>",
      userPoolClientId: "<your-cognito-user-pool-client-id>",
      identityPoolId: "<your-cognito-identity-pool-id>",
      loginWith: {
        email: true,
      },
      signUpVerificationMethod: "code",
      userAttributes: {
        email: {
          required: true,
        },
      },
      allowGuestAccess: true,
      passwordFormat: {
        minLength: 8,
        requireLowercase: true,
        requireUppercase: true,
        requireNumbers: true,
        requireSpecialCharacters: true,
      },
    },
  },
})
```

By configuring the client library, Amplify automates the communication with the underlying AWS resources, and provides a friendly API to author your business logic. For example, you can use the signIn function to initiate the sign-in flow without passing information from your Cognito resource:

```javascript
import { signIn } from "aws-amplify/auth"

await signIn({
  username: "john.doe@example.com",
  password: "hunter2",
})
```

For more information about how to use the Amplify client libraries with existing AWS resources, you can visit the guides, such as the one on connecting to Cognito resources using Amplify Auth's client library.

To get started with AWS Amplify, it is recommended to use the quickstart starter template. However, for some use cases, it may be preferable to start from scratch. 

You can create a new project with `npm create amplify@latest` and follow the prompts to set up the project. This will create a lightweight Amplify project in your current directory.

If you prefer a manual setup, you can create your project's `package.json` with `npm init -y` and then install the Amplify dependencies with `npm add --save-dev @aws-amplify/backend@latest @aws-amplify/backend-cli@latest typescript`. TypeScript is not required but is recommended for an optimal experience.

Next, create the entry point for your backend, `amplify/backend.ts`, with the following code:
```
import { defineBackend } from '@aws-amplify/backend';

defineBackend({});
```
You can then run `npx ampx sandbox` to create your first backend. 

It's worth noting that Amplify Gen 2 requires your backend to be configured for use with ECMAScript modules (ESM). If you encounter an error during `ampx sandbox`, you can modify your `package.json` with `"type": "module"` or create a local file in the Amplify backend directory, `amplify/package.json`, with the following content:
```
{
  "type": "module"
}
```
To define your resources, you can use the `define*` functions. For example, to define authentication, you can use the following code:
```javascript
import { defineAuth } from '@aws-amplify/backend';

export const auth = defineAuth({
  loginWith: {
    email: true
  }
});
```
To define your data resource, you can use the following code:
```javascript
import { a, defineData, type ClientSchema } from '@aws-amplify/backend';

const schema = a.schema({
  Todo: a.model({
      content: a.string(),
      isDone: a.boolean()
    })
   .authorization(allow => [allow.publicApiKey()])
});

export type Schema = ClientSchema<typeof schema>;
export const data = defineData({
  schema
});
```
Each of these newly defined resources are then imported and set in the backend definition:
```javascript
import { defineBackend } from '@aws-amplify/backend';
import { auth } from './auth/resource';
import { data } from './data/resource';

defineBackend({
  auth,
  data
});
```
If you have an existing project, you can update it by running `npm update @aws-amplify/backend @aws-amplify/backend-cli`. 

The recommended next steps are to learn more about defining authentication, defining data, get started with cloud sandbox, and deploy and host your first app.

Migrating from Gen 1 to Gen 2

AWS is actively developing migration tooling to aid in transitioning projects from Gen 1 to Gen 2. Until then, it is recommended to continue working with Gen 1 Amplify projects. Both Gen 1 and Gen 2 will be supported for the foreseeable future. For new projects, adopting Gen 2 is recommended to take advantage of its enhanced capabilities. 

Gen 1 vs Gen 2 Feature Matrix

The following tables present a feature matrix for Gen 1 customers who are considering Gen 2 for their apps. This will help determine the support availability for various features.

### Auth

Features like configuring username, email, and phone number are available in both Gen 1 and Gen 2, with some features requiring CDK in Gen 2. Social media sign-in options like Facebook, Google, and Amazon are available in both versions. Features like user pool groups, email verification, sign-up attributes, and auth trigger support are also available in both Gen 1 and Gen 2. 

However, some features like custom auth challenge flow are only available in Gen 1. First-class OIDC and SAML support are available in Gen 2, but not in Gen 1.

### Data

Features like model, primary key, secondary key, hasOne, hasMany, and belongsTo are available in both Gen 1 and Gen 2. However, manyToMany is only available in Gen 1. Auth configurations at the model and field levels are available in both versions, with some features requiring CDK in Gen 2.

Some features like searchable, predictions, and custom GraphQL transformer plugins are only available in Gen 1. However, MySQL and PostgreSQL support, as well as in-IDE end-to-end type safety, are only available in Gen 2.

### Storage

Features like provisioning S3 buckets, auth and guest access, and configuring CRUD access are available in both Gen 1 and Gen 2. Lambda triggers for S3 buckets and file browsers in the console are also available in both versions. However, visual configuration is only available in Gen 1.

### Functions

Features like function runtime, environment variables, and secrets are available in both Gen 1 and Gen 2. Function templates like AWS AppSync GraphQL API request and CRUD function for DynamoDB are also available in both versions. However, some features like function build options for Node.js and function logs in the console are only available in Gen 1.

Some features like custom function handlers and function resource access permissions are available in both Gen 1 and Gen 2, with some features requiring CDK in Gen 2.

### Other Categories

REST API, analytics, geo, predictions, and interactions features are available in both Gen 1 and Gen 2, with some variations depending on the platform. However, some features are only available in Gen 1 or Gen 2, or require custom CDK configurations. 

For example, in Android and Swift, REST API is not available in Gen 2, while in Flutter, it is available with custom CDK. In Angular, JavaScript, Next.js, React, React Native, and Vue, REST API is available with custom CDK in Gen 2. 

Similarly, analytics and geo features are available with custom CDK in Gen 2 for most platforms, while predictions and interactions are not available in Gen 2 for some platforms. 

In general, Gen 2 offers more features and capabilities than Gen 1, especially when it comes to authentication, data modeling, and storage. However, some features are only available in Gen 1 or require custom CDK configurations in Gen 2.

To set up your platform for Amplify, follow these steps for each operating system:

For iOS, make sure you have a minimum deployment target of 13.0 and Xcode 15.0 or higher. To do this, update the target iOS platform in your `ios/Podfile` to 13.0 or higher. Then, open your project in Xcode, select the Runner target, and update the "Minimum Deployments" section to 13.0 or higher. Also, update the "iOS Deployment Target" to 13.0 or higher.

For Android, Amplify supports API level 24+ (Android 7.0+), and requires Gradle 8+, Kotlin 1.9+, and Java 17+. To set this up, update the Android Gradle plugin and kotlin versions in your `android/settings.gradle` file. Then, update the Gradle `distributionUrl` in your `android/gradle/wrapper/gradle-wrapper.properties` file. Next, update the Java version and minimum Android SDK version in your `android/app/build.gradle` file. Additionally, you need to add the internet permission to your `android/app/src/main/AndroidManifest.xml` file to make network requests in release mode.

For web, there are no Amplify specific requirements or setup instructions. You just need to use a browser supported by Flutter.

For macOS, Amplify requires a minimum deployment target of 10.15 and Xcode 15.0 or higher. Update the target macOS platform in your `macos/Podfile` to 10.15 or higher. Then, open your project in Xcode, select the Runner target, and update the "Minimum Deployments" section to 10.15 or higher. Also, update the "macOS Deployment Target" to 10.15 or higher. You also need to enable networking and keychain entitlements in the "Signing and Capabilities" tab.

For Windows, there are no Amplify specific requirements or setup instructions. You just need to use a Windows version supported by Flutter.

For Linux, Amplify depends on the `libsecret` library. To run and debug an app, you need to install `libsecret-1-dev`. You can do this by running the command `sudo apt-get install -y libsecret-1-dev`. When packaging your app with Snapcraft, include the required dependencies in your `snapcraft.yaml` file.

Here is an example of how you might implement the networking permission in Android:
```java
<uses-permission android:name="android.permission.INTERNET"/>
```
And here is an example of how you might implement the minimum deployment target in iOS using React Native:
```jsx
import { Platform } from 'react-native';

if (Platform.OS === 'ios') {
  // update the minimum deployment target to 13.0 or higher
}
```
Note that the above code is just an example and may need to be adapted to your specific use case.

Welcome to AWS Amplify. This quickstart guide will walk you through how to build a Todo application using various frameworks, including Vanilla JavaScript, React, Next.js, Angular, Vue, Flutter, React Native, and Swift. 

To get started, you will need to deploy an Amplify backend database and authentication, then connect to the backend from your application, and finally make backend updates.

You can choose your preferred framework to follow the quickstart guide, including:

* Vanilla JavaScript
* React
* Next.js
* Angular
* Vue
* Flutter
* React Native
* Swift
* Android

Each framework has its own set of instructions, but the overall process involves the following steps:

1. Deploy an Amplify backend to AWS.
2. Add authentication to the application.
3. Add data to the application.
4. Make backend updates.

To deploy an Amplify backend, you will need to create a repository in your GitHub account using the Amplify Backend template, then deploy the repository to Amplify's CI/CD pipeline.

To add authentication, you will need to install the necessary dependencies and import the Authenticator component. The Authenticator component auto-detects your auth backend settings and renders the correct UI state based on the auth backend's authentication flow.

To add data, you will need to install the necessary dependencies, update the data schema, and implement the UI to create, list, and delete the to-do items.

To make backend updates, you will need to update the data schema, commit the changes to your git repository, and let Amplify's CI/CD system automatically pick up the changes and build and deploy the updates.

Once you have completed these steps, you will have a fully functional Todo application with authentication and data storage. You can then terminate the sandbox environment to clean up the project.

For more information on how to work with Amplify, you can refer to the conceptual guide on [how Amplify works](https://docs.amplify.aws/cli/sdk/quickstart/).

Here is an example of how to create a Todo application using React Native:
```typescript
import React, { useState, useEffect } from 'react';
import { View, Button, Text, StyleSheet } from 'react-native';

import { generateClient } from "aws-amplify/data";
import type { Schema } from "../amplify/data/resource";
import { GraphQLError } from "graphql";
const client = generateClient<Schema>();

const TodoList = () => {
  const dateTimeNow = new Date();
  const [todos, setTodos] = useState<Schema["Todo"]["type"][]>([]);
  const [errors, setErrors] = useState<GraphQLError>();

  useEffect(() => {
    const sub = client.models.Todo.observeQuery().subscribe({
      next: ({ items }) => {
        setTodos([...items]);
      },
    });

    return () => sub.unsubscribe();
  }, []);

  const createTodo = async () => {
    try {
      await client.models.Todo.create({
        content: `${dateTimeNow.getUTCMilliseconds()}`,
      });
    } catch (error: unknown) {
      if (error instanceof GraphQLError) {
        setErrors(error);
      } else {
        throw error;
      }
    }
  };

  if (errors) {
    return <Text>{errors.message}</Text>;
  }

  const renderItem = ({ item }: { item: Schema["Todo"]["type"] }) => (
    <TodoItem {...item} />
  );
  return (
    <View style={{ flex: 1 }}>
      <FlatList
        data={todos}
        renderItem={renderItem}
        keyExtractor={(item) => item.id}
        ItemSeparatorComponent={() => (
          <View style={styles.listItemSeparator} />
        )}
        ListEmptyComponent={() => <Text>The todo list is empty.</Text>}
        style={styles.listContainer}
      ></FlatList>
      <Button onPress={createTodo} title="Create Todo" />
    </View>
  );
};

const TodoItem = (todo: Schema["Todo"]["type"]) => (
  <View style={styles.todoItemContainer} key={todo.id}>
    <Text
      style={{
       ...styles.todoItemText,
        textDecorationLine: todo.isDone? "line-through" : "none",
        textDecorationColor: todo.isDone? "red" : "black",
      }}
    >
      {todo.content}
    </Text>
    <Button
      onPress={async () => {
        await client.models.Todo.delete(todo);
      }}
      title="Delete"
    />
    <Button
      onPress={() => {
        client.models.Todo.update({
          id: todo.id,
          isDone:!todo.isDone,
        });
      }}
      title={todo.isDone? "Undo" : "Done"}
    />
  </View>
);

const styles = StyleSheet.create({
  todoItemContainer: { flexDirection: "row", alignItems: "center", padding: 8 },
  todoItemText: { flex: 1, textAlign: "center" },
  listContainer: { flex: 1, alignSelf: "stretch", padding:8 },
  listItemSeparator: { backgroundColor: "lightgrey", height: 2 },
});
```

To get started with AWS Amplify Gen 2 using the Next.js App Router, you need to have Node.js version 14.x or later, npm version 6.14.4 or later, and git version 2.14.1 or later installed. If you are new to these technologies, it is recommended that you go through the official React, Next.js, and TypeScript tutorials first.

To deploy a full-stack app to AWS, you will create a repository in your GitHub account using the Amplify Next template. This template scaffolds a create-next-app with Amplify backend capabilities. After creating the repository, you will deploy it with Amplify by selecting "Start with an existing app" and then "GitHub". You will then give Amplify access to your GitHub account and pick the repository and main branch to deploy.

While waiting for your app to deploy, you can take a tour of the project structure in the starter repository. The starter application has pre-written code for a to-do list app and gives you a real-time database with a feed of all to-do list items and the ability to add new items.

Once the build completes, you can visit the newly deployed branch by selecting "View deployed URL". You will be able to create new to-do items, and since the build deployed an API, database, and authentication backend, you will be able to view the data entered in your database in the Amplify console.

To make frontend updates, you will set up a local development environment by cloning the repository locally, installing dependencies, and moving the amplify_outputs.json file to the root of your project. You will then implement a delete functionality by adding a new deleteTodo function and passing it into the onClick handler of the li element.

To implement login UI, you will use the Authenticator UI component from the Amplify UI library. You will import the Authenticator component, wrap the children or pages components with it, and add a button to enable users to sign out of the application.

To make backend updates, you will update the backend to implement per-user authorization rules. You will set up local AWS credentials, deploy a cloud sandbox, and implement per-user authorization by applying an owner-based authorization rule to your to-do items.

Finally, you will commit and push the changes to get them to the cloud, and once the build completes in the Amplify Console, the main backend will update to support the changes made within the cloud sandbox.

To build a task list application with TypeScript, Next.js, and React using AWS Amplify Gen 2, follow these steps:

First, ensure you have the necessary prerequisites installed, including Node.js, npm, and git. If you're new to these technologies, consider going through the official React, Next.js, and TypeScript tutorials.

To deploy a full-stack app to AWS, start by creating a repository in your GitHub account using the provided Next.js template. This template scaffolds a create-next-app with Amplify backend capabilities. Once the repository is created, deploy it to AWS using the Amplify console.

After deployment, view your deployed app by selecting the "View deployed URL" option. You can then interact with your app, creating new to-do items and viewing them in real-time.

To make frontend updates, set up your local development environment by cloning the repository and installing the necessary dependencies. Download the amplify_outputs.json file from the Amplify console and move it to the root of your project. This file contains backend endpoint information and is used by the Amplify client library to connect to your Amplify backend.

Implement the delete functionality by adding a new function to your pages/index.tsx file and passing it to the onClick handler of the li element. Try out the deletion functionality by starting the local dev server.

Next, implement the login UI by importing the Authenticator UI component and wrapping your app component with it. Add a button to enable users to sign out of the application using the useAuthenticator hook.

To make backend updates, set up local AWS credentials and deploy a cloud sandbox using the ampx sandbox command. This provides a separate backend environment for local development and testing. Implement per-user authorization by applying an owner-based authorization rule to your to-do items and rendering the username to distinguish different users.

Finally, commit and push your changes to get them to the cloud. Once your build completes in the Amplify Console, the main backend will update to support the changes made within the cloud sandbox.

Here is some example code to illustrate these steps:

To implement the delete functionality, add the following code to your pages/index.tsx file:
```tsx
function deleteTodo(id: string) {
  client.models.Todo.delete({ id })
}

return (
  <main>
    <h1>My todos</h1>
    <button onClick={createTodo}>+ new</button>
    <ul>
      {todos.map(todo => <li
        onClick={() => deleteTodo(todo.id)}
        key={todo.id}>
        {todo.content}
      </li>)}
    </ul> 
  </main>
)
```

To implement the login UI, add the following code to your pages/_app.tsx file:
```tsx
import { Authenticator } from '@aws-amplify/ui-react'
import '@aws-amplify/ui-react/styles.css'

export default function App({ Component, pageProps }: AppProps) {
  return(
    <Authenticator>
      <Component {...pageProps} />;
    </Authenticator>
  ) 
}
```

To implement per-user authorization, update your amplify/data/resource.ts file with the following code:
```ts
const schema = a.schema({
  Todo: a.model({
    content: a.string(),
  }).authorization(allow => [allow.owner()]),
});
```

And update your pages/index.tsx file with the following code:
```tsx
const { user, signOut } = useAuthenticator();

return (
  <main>
    <h1>{user?.signInDetails?.loginId}'s todos</h1>
    {/*... */}
  </main>
)
```